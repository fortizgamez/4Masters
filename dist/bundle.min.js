!function(A){var B={};function Q(F){if(B[F])return B[F].exports;var U=B[F]={i:F,l:!1,exports:{}};return A[F].call(U.exports,U,U.exports,Q),U.l=!0,U.exports}Q.m=A,Q.c=B,Q.d=function(A,B,F){Q.o(A,B)||Object.defineProperty(A,B,{enumerable:!0,get:F})},Q.r=function(A){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(A,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(A,"__esModule",{value:!0})},Q.t=function(A,B){if(1&B&&(A=Q(A)),8&B)return A;if(4&B&&"object"==typeof A&&A&&A.__esModule)return A;var F=Object.create(null);if(Q.r(F),Object.defineProperty(F,"default",{enumerable:!0,value:A}),2&B&&"string"!=typeof A)for(var U in A)Q.d(F,U,function(B){return A[B]}.bind(null,U));return F},Q.n=function(A){var B=A&&A.__esModule?function(){return A.default}:function(){return A};return Q.d(B,"a",B),B},Q.o=function(A,B){return Object.prototype.hasOwnProperty.call(A,B)},Q.p="",Q(Q.s=7)}([function(module,exports,__webpack_require__){eval("var api = __webpack_require__(1);\n            var content = __webpack_require__(2);\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.i, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\nvar exported = content.locals ? content.locals : {};\n\n\n\nmodule.exports = exported;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY3NzL21haW4uc2Nzcz9lOWRjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLFVBQVUsbUJBQU8sQ0FBQyxDQUEyRTtBQUM3RiwwQkFBMEIsbUJBQU8sQ0FBQyxDQUFvRzs7QUFFdEk7O0FBRUE7QUFDQSwwQkFBMEIsUUFBUztBQUNuQzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOzs7O0FBSUEiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBhcGkgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKTtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbWFpbi5zY3NzXCIpO1xuXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICB9XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gXCJoZWFkXCI7XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG52YXIgZXhwb3J0ZWQgPSBjb250ZW50LmxvY2FscyA/IGNvbnRlbnQubG9jYWxzIDoge307XG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydGVkOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar isOldIE = function isOldIE() {\n  var memo;\n  return function memorize() {\n    if (typeof memo === 'undefined') {\n      // Test for IE <= 9 as proposed by Browserhacks\n      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n      // Tests for existence of standard globals is to allow style-loader\n      // to operate correctly into non-standard environments\n      // @see https://github.com/webpack-contrib/style-loader/issues/177\n      memo = Boolean(window && document && document.all && !window.atob);\n    }\n\n    return memo;\n  };\n}();\n\nvar getTarget = function getTarget() {\n  var memo = {};\n  return function memorize(target) {\n    if (typeof memo[target] === 'undefined') {\n      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n        try {\n          // This will throw an exception if access to iframe is blocked\n          // due to cross-origin restrictions\n          styleTarget = styleTarget.contentDocument.head;\n        } catch (e) {\n          // istanbul ignore next\n          styleTarget = null;\n        }\n      }\n\n      memo[target] = styleTarget;\n    }\n\n    return memo[target];\n  };\n}();\n\nvar stylesInDom = [];\n\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n\n  for (var i = 0; i < stylesInDom.length; i++) {\n    if (stylesInDom[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var index = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3]\n    };\n\n    if (index !== -1) {\n      stylesInDom[index].references++;\n      stylesInDom[index].updater(obj);\n    } else {\n      stylesInDom.push({\n        identifier: identifier,\n        updater: addStyle(obj, options),\n        references: 1\n      });\n    }\n\n    identifiers.push(identifier);\n  }\n\n  return identifiers;\n}\n\nfunction insertStyleElement(options) {\n  var style = document.createElement('style');\n  var attributes = options.attributes || {};\n\n  if (typeof attributes.nonce === 'undefined') {\n    var nonce =  true ? __webpack_require__.nc : undefined;\n\n    if (nonce) {\n      attributes.nonce = nonce;\n    }\n  }\n\n  Object.keys(attributes).forEach(function (key) {\n    style.setAttribute(key, attributes[key]);\n  });\n\n  if (typeof options.insert === 'function') {\n    options.insert(style);\n  } else {\n    var target = getTarget(options.insert || 'head');\n\n    if (!target) {\n      throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n    }\n\n    target.appendChild(style);\n  }\n\n  return style;\n}\n\nfunction removeStyleElement(style) {\n  // istanbul ignore if\n  if (style.parentNode === null) {\n    return false;\n  }\n\n  style.parentNode.removeChild(style);\n}\n/* istanbul ignore next  */\n\n\nvar replaceText = function replaceText() {\n  var textStore = [];\n  return function replace(index, replacement) {\n    textStore[index] = replacement;\n    return textStore.filter(Boolean).join('\\n');\n  };\n}();\n\nfunction applyToSingletonTag(style, index, remove, obj) {\n  var css = remove ? '' : obj.media ? \"@media \".concat(obj.media, \" {\").concat(obj.css, \"}\") : obj.css; // For old IE\n\n  /* istanbul ignore if  */\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = replaceText(index, css);\n  } else {\n    var cssNode = document.createTextNode(css);\n    var childNodes = style.childNodes;\n\n    if (childNodes[index]) {\n      style.removeChild(childNodes[index]);\n    }\n\n    if (childNodes.length) {\n      style.insertBefore(cssNode, childNodes[index]);\n    } else {\n      style.appendChild(cssNode);\n    }\n  }\n}\n\nfunction applyToTag(style, options, obj) {\n  var css = obj.css;\n  var media = obj.media;\n  var sourceMap = obj.sourceMap;\n\n  if (media) {\n    style.setAttribute('media', media);\n  } else {\n    style.removeAttribute('media');\n  }\n\n  if (sourceMap && btoa) {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    while (style.firstChild) {\n      style.removeChild(style.firstChild);\n    }\n\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar singleton = null;\nvar singletonCounter = 0;\n\nfunction addStyle(obj, options) {\n  var style;\n  var update;\n  var remove;\n\n  if (options.singleton) {\n    var styleIndex = singletonCounter++;\n    style = singleton || (singleton = insertStyleElement(options));\n    update = applyToSingletonTag.bind(null, style, styleIndex, false);\n    remove = applyToSingletonTag.bind(null, style, styleIndex, true);\n  } else {\n    style = insertStyleElement(options);\n    update = applyToTag.bind(null, style, options);\n\n    remove = function remove() {\n      removeStyleElement(style);\n    };\n  }\n\n  update(obj);\n  return function updateStyle(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\n        return;\n      }\n\n      update(obj = newObj);\n    } else {\n      remove();\n    }\n  };\n}\n\nmodule.exports = function (list, options) {\n  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n  // tags it will allow on a page\n\n  if (!options.singleton && typeof options.singleton !== 'boolean') {\n    options.singleton = isOldIE();\n  }\n\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n\n    if (Object.prototype.toString.call(newList) !== '[object Array]') {\n      return;\n    }\n\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDom[index].references--;\n    }\n\n    var newLastIdentifiers = modulesToDom(newList, options);\n\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n\n      var _index = getIndexByIdentifier(_identifier);\n\n      if (stylesInDom[_index].references === 0) {\n        stylesInDom[_index].updater();\n\n        stylesInDom.splice(_index, 1);\n      }\n    }\n\n    lastIdentifiers = newLastIdentifiers;\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanM/MmRiYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsd0JBQXdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLEtBQXdDLEdBQUcsc0JBQWlCLEdBQUcsU0FBSTs7QUFFbkY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0EscUVBQXFFLHFCQUFxQixhQUFhOztBQUV2Rzs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0EseURBQXlEO0FBQ3pELEdBQUc7O0FBRUg7OztBQUdBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9CQUFvQiw2QkFBNkI7QUFDakQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwiZmlsZSI6IjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIGlzT2xkSUUgPSBmdW5jdGlvbiBpc09sZElFKCkge1xuICB2YXIgbWVtbztcbiAgcmV0dXJuIGZ1bmN0aW9uIG1lbW9yaXplKCkge1xuICAgIGlmICh0eXBlb2YgbWVtbyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG4gICAgICAvLyBAc2VlIGh0dHA6Ly9icm93c2VyaGFja3MuY29tLyNoYWNrLWU3MWQ4NjkyZjY1MzM0MTczZmVlNzE1YzIyMmNiODA1XG4gICAgICAvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG4gICAgICAvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcbiAgICAgIC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xuICAgICAgbWVtbyA9IEJvb2xlYW4od2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2IpO1xuICAgIH1cblxuICAgIHJldHVybiBtZW1vO1xuICB9O1xufSgpO1xuXG52YXIgZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gZ2V0VGFyZ2V0KCkge1xuICB2YXIgbWVtbyA9IHt9O1xuICByZXR1cm4gZnVuY3Rpb24gbWVtb3JpemUodGFyZ2V0KSB7XG4gICAgaWYgKHR5cGVvZiBtZW1vW3RhcmdldF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB2YXIgc3R5bGVUYXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7IC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5cbiAgICAgIGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuICAgICAgICAgIC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG4gICAgICAgICAgc3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgc3R5bGVUYXJnZXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuICAgIH1cblxuICAgIHJldHVybiBtZW1vW3RhcmdldF07XG4gIH07XG59KCk7XG5cbnZhciBzdHlsZXNJbkRvbSA9IFtdO1xuXG5mdW5jdGlvbiBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKSB7XG4gIHZhciByZXN1bHQgPSAtMTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlc0luRG9tLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHN0eWxlc0luRG9tW2ldLmlkZW50aWZpZXIgPT09IGlkZW50aWZpZXIpIHtcbiAgICAgIHJlc3VsdCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucykge1xuICB2YXIgaWRDb3VudE1hcCA9IHt9O1xuICB2YXIgaWRlbnRpZmllcnMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV07XG4gICAgdmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG4gICAgdmFyIGNvdW50ID0gaWRDb3VudE1hcFtpZF0gfHwgMDtcbiAgICB2YXIgaWRlbnRpZmllciA9IFwiXCIuY29uY2F0KGlkLCBcIiBcIikuY29uY2F0KGNvdW50KTtcbiAgICBpZENvdW50TWFwW2lkXSA9IGNvdW50ICsgMTtcbiAgICB2YXIgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICB2YXIgb2JqID0ge1xuICAgICAgY3NzOiBpdGVtWzFdLFxuICAgICAgbWVkaWE6IGl0ZW1bMl0sXG4gICAgICBzb3VyY2VNYXA6IGl0ZW1bM11cbiAgICB9O1xuXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMrKztcbiAgICAgIHN0eWxlc0luRG9tW2luZGV4XS51cGRhdGVyKG9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlc0luRG9tLnB1c2goe1xuICAgICAgICBpZGVudGlmaWVyOiBpZGVudGlmaWVyLFxuICAgICAgICB1cGRhdGVyOiBhZGRTdHlsZShvYmosIG9wdGlvbnMpLFxuICAgICAgICByZWZlcmVuY2VzOiAxXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZGVudGlmaWVycy5wdXNoKGlkZW50aWZpZXIpO1xuICB9XG5cbiAgcmV0dXJuIGlkZW50aWZpZXJzO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykge1xuICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICB2YXIgYXR0cmlidXRlcyA9IG9wdGlvbnMuYXR0cmlidXRlcyB8fCB7fTtcblxuICBpZiAodHlwZW9mIGF0dHJpYnV0ZXMubm9uY2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIG5vbmNlID0gdHlwZW9mIF9fd2VicGFja19ub25jZV9fICE9PSAndW5kZWZpbmVkJyA/IF9fd2VicGFja19ub25jZV9fIDogbnVsbDtcblxuICAgIGlmIChub25jZSkge1xuICAgICAgYXR0cmlidXRlcy5ub25jZSA9IG5vbmNlO1xuICAgIH1cbiAgfVxuXG4gIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHN0eWxlLnNldEF0dHJpYnV0ZShrZXksIGF0dHJpYnV0ZXNba2V5XSk7XG4gIH0pO1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvcHRpb25zLmluc2VydChzdHlsZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRhcmdldCA9IGdldFRhcmdldChvcHRpb25zLmluc2VydCB8fCAnaGVhZCcpO1xuXG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0JyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG4gICAgfVxuXG4gICAgdGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgfVxuXG4gIHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKSB7XG4gIC8vIGlzdGFuYnVsIGlnbm9yZSBpZlxuICBpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xufVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5cblxudmFyIHJlcGxhY2VUZXh0ID0gZnVuY3Rpb24gcmVwbGFjZVRleHQoKSB7XG4gIHZhciB0ZXh0U3RvcmUgPSBbXTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHJlcGxhY2UoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG4gICAgdGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xuICAgIHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuICB9O1xufSgpO1xuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcbiAgdmFyIGNzcyA9IHJlbW92ZSA/ICcnIDogb2JqLm1lZGlhID8gXCJAbWVkaWEgXCIuY29uY2F0KG9iai5tZWRpYSwgXCIge1wiKS5jb25jYXQob2JqLmNzcywgXCJ9XCIpIDogb2JqLmNzczsgLy8gRm9yIG9sZCBJRVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cblxuICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcbiAgICB2YXIgY2hpbGROb2RlcyA9IHN0eWxlLmNoaWxkTm9kZXM7XG5cbiAgICBpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHtcbiAgICAgIHN0eWxlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICB9XG5cbiAgICBpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgIHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnKHN0eWxlLCBvcHRpb25zLCBvYmopIHtcbiAgdmFyIGNzcyA9IG9iai5jc3M7XG4gIHZhciBtZWRpYSA9IG9iai5tZWRpYTtcbiAgdmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cbiAgaWYgKG1lZGlhKSB7XG4gICAgc3R5bGUuc2V0QXR0cmlidXRlKCdtZWRpYScsIG1lZGlhKTtcbiAgfSBlbHNlIHtcbiAgICBzdHlsZS5yZW1vdmVBdHRyaWJ1dGUoJ21lZGlhJyk7XG4gIH1cblxuICBpZiAoc291cmNlTWFwICYmIGJ0b2EpIHtcbiAgICBjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiLmNvbmNhdChidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpLCBcIiAqL1wiKTtcbiAgfSAvLyBGb3Igb2xkIElFXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqL1xuXG5cbiAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHN0eWxlLmZpcnN0Q2hpbGQpIHtcbiAgICAgIHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuICB9XG59XG5cbnZhciBzaW5nbGV0b24gPSBudWxsO1xudmFyIHNpbmdsZXRvbkNvdW50ZXIgPSAwO1xuXG5mdW5jdGlvbiBhZGRTdHlsZShvYmosIG9wdGlvbnMpIHtcbiAgdmFyIHN0eWxlO1xuICB2YXIgdXBkYXRlO1xuICB2YXIgcmVtb3ZlO1xuXG4gIGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xuICAgIHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xuICAgIHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuICAgIHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgZmFsc2UpO1xuICAgIHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgc3R5bGUgPSBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG4gICAgdXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcblxuICAgIHJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG4gICAgfTtcbiAgfVxuXG4gIHVwZGF0ZShvYmopO1xuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUobmV3T2JqKSB7XG4gICAgaWYgKG5ld09iaikge1xuICAgICAgaWYgKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZShvYmogPSBuZXdPYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmUoKTtcbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGxpc3QsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307IC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuICAvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5cbiAgaWYgKCFvcHRpb25zLnNpbmdsZXRvbiAmJiB0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gIT09ICdib29sZWFuJykge1xuICAgIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuICB9XG5cbiAgbGlzdCA9IGxpc3QgfHwgW107XG4gIHZhciBsYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucyk7XG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xuICAgIG5ld0xpc3QgPSBuZXdMaXN0IHx8IFtdO1xuXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXdMaXN0KSAhPT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tpXTtcbiAgICAgIHZhciBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMtLTtcbiAgICB9XG5cbiAgICB2YXIgbmV3TGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKG5ld0xpc3QsIG9wdGlvbnMpO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tfaV07XG5cbiAgICAgIHZhciBfaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihfaWRlbnRpZmllcik7XG5cbiAgICAgIGlmIChzdHlsZXNJbkRvbVtfaW5kZXhdLnJlZmVyZW5jZXMgPT09IDApIHtcbiAgICAgICAgc3R5bGVzSW5Eb21bX2luZGV4XS51cGRhdGVyKCk7XG5cbiAgICAgICAgc3R5bGVzSW5Eb20uc3BsaWNlKF9pbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGFzdElkZW50aWZpZXJzID0gbmV3TGFzdElkZW50aWZpZXJzO1xuICB9O1xufTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n")},function(module,exports,__webpack_require__){eval('// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(3);\nvar ___CSS_LOADER_GET_URL_IMPORT___ = __webpack_require__(4);\nvar ___CSS_LOADER_URL_IMPORT_0___ = __webpack_require__(5);\nvar ___CSS_LOADER_URL_IMPORT_1___ = __webpack_require__(6);\nexports = ___CSS_LOADER_API_IMPORT___(false);\nvar ___CSS_LOADER_URL_REPLACEMENT_0___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_0___);\nvar ___CSS_LOADER_URL_REPLACEMENT_1___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_1___);\n// Module\nexports.push([module.i, ".fade-in{animation-name:fade-in;animation-duration:1s;animation-delay:0.3s;animation-fill-mode:both}.fade-in-slow{animation-name:fade-in;animation-duration:2.5s;animation-delay:0.5s;animation-fill-mode:both}.fade-out{animation-name:fade-out;animation-duration:1s;animation-delay:0.3s;animation-fill-mode:both}@keyframes fade-in{from{opacity:0;z-index:0}35%{opacity:1}to{opacity:1;z-index:inherit}}@keyframes fade-out{from{opacity:1;z-index:inherit}35%{opacity:0}to{opacity:0;z-index:-10}}html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td,article,aside,canvas,details,embed,figure,figcaption,footer,header,hgroup,menu,nav,output,ruby,section,summary,time,mark,audio,video{margin:0;padding:0;border:0;font-size:100%;line-height:150%;font:inherit;vertical-align:baseline}:focus{outline:0}article,aside,details,figcaption,figure,footer,header,hgroup,menu,nav,section{display:block}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:\'\';content:none}table{border-collapse:collapse;border-spacing:0}input[type=search]::-webkit-search-cancel-button,input[type=search]::-webkit-search-decoration,input[type=search]::-webkit-search-results-button,input[type=search]::-webkit-search-results-decoration{-webkit-appearance:none;-moz-appearance:none}input[type=search]{-webkit-appearance:none;-moz-appearance:none;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box}textarea{overflow:auto;vertical-align:top;resize:vertical}audio,canvas,video{display:inline-block;*display:inline;*zoom:1;max-width:100%}audio:not([controls]){display:none;height:0}[hidden]{display:none}html{font-size:100%;-webkit-text-size-adjust:100%;-ms-text-size-adjust:100%}a:focus{outline:thin dotted}a:active,a:hover{outline:0}img{border:0;-ms-interpolation-mode:bicubic}figure{margin:0}form{margin:0}fieldset{border:1px solid #c0c0c0;margin:0 2px;padding:0.35em 0.625em 0.75em}legend{border:0;padding:0;white-space:normal;*margin-left:-7px}button,input,select,textarea{font-size:100%;margin:0;vertical-align:baseline;*vertical-align:middle}button,input{line-height:normal}button,select{text-transform:none}button,html input[type=\\"button\\"],input[type=\\"reset\\"],input[type=\\"submit\\"]{-webkit-appearance:button;cursor:pointer;*overflow:visible}button[disabled],html input[disabled]{cursor:default}input[type=\\"checkbox\\"],input[type=\\"radio\\"]{box-sizing:border-box;padding:0;*height:13px;*width:13px}input[type=\\"search\\"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}input[type=\\"search\\"]::-webkit-search-cancel-button,input[type=\\"search\\"]::-webkit-search-decoration{-webkit-appearance:none}button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}textarea{overflow:auto;vertical-align:top}table{border-collapse:collapse;border-spacing:0}html,button,input,select,textarea{color:#222}::-moz-selection{background:#b3d4fc;text-shadow:none}::selection{background:#b3d4fc;text-shadow:none}img{vertical-align:middle}fieldset{border:0;margin:0;padding:0}textarea{resize:vertical}.chromeframe{margin:0.2em 0;background:#ccc;color:#000;padding:0.2em 0}body{font-family:\'Open Sans\'}div{box-sizing:border-box}h1,h2,h3,h4,h5,h6{font-family:\'Archivo\'}h1{font-size:6rem}h2{font-size:3.75rem}h3{font-size:3rem}h4{font-size:2.125rem}h5{font-size:1.5rem}h6{font-size:1.25rem}a{color:#F1F3F5}a:focus{outline:none}p{font-size:1rem;line-height:1.8rem}@font-face{font-family:\'Open Sans\';font-style:normal;font-weight:normal;src:url(" + ___CSS_LOADER_URL_REPLACEMENT_0___ + ") format(\\"truetype\\")}@font-face{font-family:\'Archivo\';font-style:normal;font-weight:normal;src:url(" + ___CSS_LOADER_URL_REPLACEMENT_1___ + ") format(\\"truetype\\")}.display-flex{display:flex}.flex-direction-row{flex-direction:row}.flex-direction-column{flex-direction:column}.justify-end{justify-items:flex-end}#loading{position:fixed;width:100vw;height:100vh;background:#F8F9FA;z-index:20}#loading .loading__progress{position:relative;height:100%;display:flex;align-items:center;justify-content:right;background:#212529}#loading .loading__progress h1{position:absolute;right:-210px;color:#212529}#loading.loading-label-animation h1{animation:loading-label-animation;animation-duration:1s;animation-fill-mode:both}@keyframes loading-label-animation{from{color:#212529}to{transform:translateX(-240px);color:#F8F9FA}}#nav__hamburguer-menu{position:fixed;z-index:15;right:.25rem;top:.5rem;margin:.25rem;width:2.5rem}#nav__hamburguer-menu:hover{cursor:pointer}#nav__hamburguer-menu line{stroke:#FCFCFC;stroke-width:.25rem}#nav__menu{opacity:0;position:fixed;display:flex;justify-content:center;align-items:center;width:100%;height:100%;z-index:1;visibility:hidden;background:#212529}@media screen and (min-width: 640px){#nav__menu{width:18.75rem;height:37.5rem;right:0}}#nav__menu .menu-list{display:flex;flex-direction:column;align-items:center}#nav__menu .menu-list a{font-size:1.4rem;font-weight:bold;font-family:\'Archivo\';line-height:1.75rem;padding:.25rem .25rem}::-webkit-scrollbar-track{background:#E9ECEF}::-webkit-scrollbar{width:10px;background:#E9ECEF}::-webkit-scrollbar-thumb{background:#212529}.artist-section img{position:absolute;left:50%;top:50%;width:100%;height:100%;transform:translate(-50%, -50%);object-fit:cover}.artist-section__wrapper{position:relative;height:100vh;background:#212529}.artist-section__welcome{position:absolute;background-position:center;width:100%;height:100%;z-index:10}#velazquez .artist-section__welcome{background-image:url(\\"/src/img/velazquez_black.min.svg\\")}#goya .artist-section__welcome{background-image:url(\\"/src/img/goya_black.min.svg\\")}#picasso .artist-section__welcome{background-image:url(\\"/src/img/picasso_black.min.svg\\")}#dali .artist-section__welcome{background-image:url(\\"/src/img/dali_black.min.svg\\")}.artist-section__info{position:absolute;bottom:0;right:0;margin:.5rem;padding:1rem;background-color:#212529;color:#FCFCFC}.artist-section__info p:not(:first-of-type){display:none}@media screen and (min-width: 640px){.artist-section__info{width:50%;margin:1rem;padding:1.5rem}}.artist-section__info-link{float:right;position:relative;width:20px;height:20px;margin-left:1rem}.artist-section__info-link line{stroke:#FCFCFC;stroke-width:2px}body{scroll-behavior:smooth}main{overflow:hidden}body.loaded{overflow:initial}#home{display:flex;justify-content:center;align-items:center;height:100vh;background-color:#212529;color:#F8F9FA}#contact{display:flex;flex-direction:column;min-height:100vh;background-color:#212529;color:#F8F9FA}@media screen and (min-width: 1024px){#contact{align-items:center;justify-content:center}}#contact>div{display:flex;flex-direction:column}@media screen and (min-width: 1024px){#contact>div{flex-direction:row;align-items:flex-start}}#contact__bibliography{display:flex;flex-direction:column;width:100%;padding:2rem;font-size:0.8rem}#contact__bibliography ul{margin:1.5rem 0 0 1.5rem;list-style-type:circle}#contact__form{display:flex;flex-direction:column;width:100%;padding:2rem}\\n", ""]);\n// Exports\nmodule.exports = exports;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY3NzL21haW4uc2Nzcz85ZmQ0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0Esa0NBQWtDLG1CQUFPLENBQUMsQ0FBbUQ7QUFDN0Ysc0NBQXNDLG1CQUFPLENBQUMsQ0FBc0Q7QUFDcEcsb0NBQW9DLG1CQUFPLENBQUMsQ0FBK0I7QUFDM0Usb0NBQW9DLG1CQUFPLENBQUMsQ0FBMkI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVMsWUFBWSx1QkFBdUIsc0JBQXNCLHFCQUFxQix5QkFBeUIsY0FBYyx1QkFBdUIsd0JBQXdCLHFCQUFxQix5QkFBeUIsVUFBVSx3QkFBd0Isc0JBQXNCLHFCQUFxQix5QkFBeUIsbUJBQW1CLEtBQUssVUFBVSxVQUFVLElBQUksVUFBVSxHQUFHLFVBQVUsaUJBQWlCLG9CQUFvQixLQUFLLFVBQVUsZ0JBQWdCLElBQUksVUFBVSxHQUFHLFVBQVUsYUFBYSwyWkFBMlosU0FBUyxVQUFVLFNBQVMsZUFBZSxpQkFBaUIsYUFBYSx3QkFBd0IsT0FBTyxVQUFVLDhFQUE4RSxjQUFjLE1BQU0sZ0JBQWdCLGFBQWEsWUFBWSxvREFBb0QsV0FBVyxhQUFhLE1BQU0seUJBQXlCLGlCQUFpQix1TUFBdU0sd0JBQXdCLHFCQUFxQixtQkFBbUIsd0JBQXdCLHFCQUFxQiwrQkFBK0IsNEJBQTRCLHVCQUF1QixTQUFTLGNBQWMsbUJBQW1CLGdCQUFnQixtQkFBbUIscUJBQXFCLGdCQUFnQixRQUFRLGVBQWUsc0JBQXNCLGFBQWEsU0FBUyxTQUFTLGFBQWEsS0FBSyxlQUFlLDhCQUE4QiwwQkFBMEIsUUFBUSxvQkFBb0IsaUJBQWlCLFVBQVUsSUFBSSxTQUFTLCtCQUErQixPQUFPLFNBQVMsS0FBSyxTQUFTLFNBQVMseUJBQXlCLGFBQWEsOEJBQThCLE9BQU8sU0FBUyxVQUFVLG1CQUFtQixrQkFBa0IsNkJBQTZCLGVBQWUsU0FBUyx3QkFBd0IsdUJBQXVCLGFBQWEsbUJBQW1CLGNBQWMsb0JBQW9CLGdGQUFnRiwwQkFBMEIsZUFBZSxrQkFBa0Isc0NBQXNDLGVBQWUsK0NBQStDLHNCQUFzQixVQUFVLGFBQWEsWUFBWSx1QkFBdUIsNkJBQTZCLDRCQUE0QiwrQkFBK0IsdUJBQXVCLHVHQUF1Ryx3QkFBd0IsaURBQWlELFNBQVMsVUFBVSxTQUFTLGNBQWMsbUJBQW1CLE1BQU0seUJBQXlCLGlCQUFpQixrQ0FBa0MsV0FBVyxpQkFBaUIsbUJBQW1CLGlCQUFpQixZQUFZLG1CQUFtQixpQkFBaUIsSUFBSSxzQkFBc0IsU0FBUyxTQUFTLFNBQVMsVUFBVSxTQUFTLGdCQUFnQixhQUFhLGVBQWUsZ0JBQWdCLFdBQVcsZ0JBQWdCLEtBQUssd0JBQXdCLElBQUksc0JBQXNCLGtCQUFrQixzQkFBc0IsR0FBRyxlQUFlLEdBQUcsa0JBQWtCLEdBQUcsZUFBZSxHQUFHLG1CQUFtQixHQUFHLGlCQUFpQixHQUFHLGtCQUFrQixFQUFFLGNBQWMsUUFBUSxhQUFhLEVBQUUsZUFBZSxtQkFBbUIsV0FBVyx3QkFBd0Isa0JBQWtCLG1CQUFtQix5RUFBeUUsV0FBVyxzQkFBc0Isa0JBQWtCLG1CQUFtQix5RUFBeUUsY0FBYyxhQUFhLG9CQUFvQixtQkFBbUIsdUJBQXVCLHNCQUFzQixhQUFhLHVCQUF1QixTQUFTLGVBQWUsWUFBWSxhQUFhLG1CQUFtQixXQUFXLDRCQUE0QixrQkFBa0IsWUFBWSxhQUFhLG1CQUFtQixzQkFBc0IsbUJBQW1CLCtCQUErQixrQkFBa0IsYUFBYSxjQUFjLG9DQUFvQyxrQ0FBa0Msc0JBQXNCLHlCQUF5QixtQ0FBbUMsS0FBSyxjQUFjLEdBQUcsNkJBQTZCLGVBQWUsc0JBQXNCLGVBQWUsV0FBVyxhQUFhLFVBQVUsY0FBYyxhQUFhLDRCQUE0QixlQUFlLDJCQUEyQixlQUFlLG9CQUFvQixXQUFXLFVBQVUsZUFBZSxhQUFhLHVCQUF1QixtQkFBbUIsV0FBVyxZQUFZLFVBQVUsa0JBQWtCLG1CQUFtQixxQ0FBcUMsV0FBVyxlQUFlLGVBQWUsU0FBUyxzQkFBc0IsYUFBYSxzQkFBc0IsbUJBQW1CLHdCQUF3QixpQkFBaUIsaUJBQWlCLHNCQUFzQixvQkFBb0Isc0JBQXNCLDBCQUEwQixtQkFBbUIsb0JBQW9CLFdBQVcsbUJBQW1CLDBCQUEwQixtQkFBbUIsb0JBQW9CLGtCQUFrQixTQUFTLFFBQVEsV0FBVyxZQUFZLGdDQUFnQyxpQkFBaUIseUJBQXlCLGtCQUFrQixhQUFhLG1CQUFtQix5QkFBeUIsa0JBQWtCLDJCQUEyQixXQUFXLFlBQVksV0FBVyxvQ0FBb0MsMkRBQTJELCtCQUErQixzREFBc0Qsa0NBQWtDLHlEQUF5RCwrQkFBK0Isc0RBQXNELHNCQUFzQixrQkFBa0IsU0FBUyxRQUFRLGFBQWEsYUFBYSx5QkFBeUIsY0FBYyw0Q0FBNEMsYUFBYSxxQ0FBcUMsc0JBQXNCLFVBQVUsWUFBWSxnQkFBZ0IsMkJBQTJCLFlBQVksa0JBQWtCLFdBQVcsWUFBWSxpQkFBaUIsZ0NBQWdDLGVBQWUsaUJBQWlCLEtBQUssdUJBQXVCLEtBQUssZ0JBQWdCLFlBQVksaUJBQWlCLE1BQU0sYUFBYSx1QkFBdUIsbUJBQW1CLGFBQWEseUJBQXlCLGNBQWMsU0FBUyxhQUFhLHNCQUFzQixpQkFBaUIseUJBQXlCLGNBQWMsc0NBQXNDLFNBQVMsbUJBQW1CLHdCQUF3QixhQUFhLGFBQWEsc0JBQXNCLHNDQUFzQyxhQUFhLG1CQUFtQix3QkFBd0IsdUJBQXVCLGFBQWEsc0JBQXNCLFdBQVcsYUFBYSxpQkFBaUIsMEJBQTBCLHlCQUF5Qix1QkFBdUIsZUFBZSxhQUFhLHNCQUFzQixXQUFXLGFBQWE7QUFDL29PO0FBQ0EiLCJmaWxlIjoiMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiKTtcbnZhciBfX19DU1NfTE9BREVSX0dFVF9VUkxfSU1QT1JUX19fID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9nZXRVcmwuanNcIik7XG52YXIgX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzBfX18gPSByZXF1aXJlKFwiLi4vZm9udHMvT3BlblNhbnMtUmVndWxhci50dGZcIik7XG52YXIgX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzFfX18gPSByZXF1aXJlKFwiLi4vZm9udHMvQXJjaGl2by1Cb2xkLnR0ZlwiKTtcbmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oZmFsc2UpO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzBfX18gPSBfX19DU1NfTE9BREVSX0dFVF9VUkxfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF8wX19fKTtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF8xX19fID0gX19fQ1NTX0xPQURFUl9HRVRfVVJMX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfMV9fXyk7XG4vLyBNb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5mYWRlLWlue2FuaW1hdGlvbi1uYW1lOmZhZGUtaW47YW5pbWF0aW9uLWR1cmF0aW9uOjFzO2FuaW1hdGlvbi1kZWxheTowLjNzO2FuaW1hdGlvbi1maWxsLW1vZGU6Ym90aH0uZmFkZS1pbi1zbG93e2FuaW1hdGlvbi1uYW1lOmZhZGUtaW47YW5pbWF0aW9uLWR1cmF0aW9uOjIuNXM7YW5pbWF0aW9uLWRlbGF5OjAuNXM7YW5pbWF0aW9uLWZpbGwtbW9kZTpib3RofS5mYWRlLW91dHthbmltYXRpb24tbmFtZTpmYWRlLW91dDthbmltYXRpb24tZHVyYXRpb246MXM7YW5pbWF0aW9uLWRlbGF5OjAuM3M7YW5pbWF0aW9uLWZpbGwtbW9kZTpib3RofUBrZXlmcmFtZXMgZmFkZS1pbntmcm9te29wYWNpdHk6MDt6LWluZGV4OjB9MzUle29wYWNpdHk6MX10b3tvcGFjaXR5OjE7ei1pbmRleDppbmhlcml0fX1Aa2V5ZnJhbWVzIGZhZGUtb3V0e2Zyb217b3BhY2l0eToxO3otaW5kZXg6aW5oZXJpdH0zNSV7b3BhY2l0eTowfXRve29wYWNpdHk6MDt6LWluZGV4Oi0xMH19aHRtbCxib2R5LGRpdixzcGFuLGFwcGxldCxvYmplY3QsaWZyYW1lLGgxLGgyLGgzLGg0LGg1LGg2LHAsYmxvY2txdW90ZSxwcmUsYSxhYmJyLGFjcm9ueW0sYWRkcmVzcyxiaWcsY2l0ZSxjb2RlLGRlbCxkZm4sZW0saW1nLGlucyxrYmQscSxzLHNhbXAsc21hbGwsc3RyaWtlLHN0cm9uZyxzdWIsc3VwLHR0LHZhcixiLHUsaSxjZW50ZXIsZGwsZHQsZGQsb2wsdWwsbGksZmllbGRzZXQsZm9ybSxsYWJlbCxsZWdlbmQsdGFibGUsY2FwdGlvbix0Ym9keSx0Zm9vdCx0aGVhZCx0cix0aCx0ZCxhcnRpY2xlLGFzaWRlLGNhbnZhcyxkZXRhaWxzLGVtYmVkLGZpZ3VyZSxmaWdjYXB0aW9uLGZvb3RlcixoZWFkZXIsaGdyb3VwLG1lbnUsbmF2LG91dHB1dCxydWJ5LHNlY3Rpb24sc3VtbWFyeSx0aW1lLG1hcmssYXVkaW8sdmlkZW97bWFyZ2luOjA7cGFkZGluZzowO2JvcmRlcjowO2ZvbnQtc2l6ZToxMDAlO2xpbmUtaGVpZ2h0OjE1MCU7Zm9udDppbmhlcml0O3ZlcnRpY2FsLWFsaWduOmJhc2VsaW5lfTpmb2N1c3tvdXRsaW5lOjB9YXJ0aWNsZSxhc2lkZSxkZXRhaWxzLGZpZ2NhcHRpb24sZmlndXJlLGZvb3RlcixoZWFkZXIsaGdyb3VwLG1lbnUsbmF2LHNlY3Rpb257ZGlzcGxheTpibG9ja31vbCx1bHtsaXN0LXN0eWxlOm5vbmV9YmxvY2txdW90ZSxxe3F1b3Rlczpub25lfWJsb2NrcXVvdGU6YmVmb3JlLGJsb2NrcXVvdGU6YWZ0ZXIscTpiZWZvcmUscTphZnRlcntjb250ZW50OicnO2NvbnRlbnQ6bm9uZX10YWJsZXtib3JkZXItY29sbGFwc2U6Y29sbGFwc2U7Ym9yZGVyLXNwYWNpbmc6MH1pbnB1dFt0eXBlPXNlYXJjaF06Oi13ZWJraXQtc2VhcmNoLWNhbmNlbC1idXR0b24saW5wdXRbdHlwZT1zZWFyY2hdOjotd2Via2l0LXNlYXJjaC1kZWNvcmF0aW9uLGlucHV0W3R5cGU9c2VhcmNoXTo6LXdlYmtpdC1zZWFyY2gtcmVzdWx0cy1idXR0b24saW5wdXRbdHlwZT1zZWFyY2hdOjotd2Via2l0LXNlYXJjaC1yZXN1bHRzLWRlY29yYXRpb257LXdlYmtpdC1hcHBlYXJhbmNlOm5vbmU7LW1vei1hcHBlYXJhbmNlOm5vbmV9aW5wdXRbdHlwZT1zZWFyY2hdey13ZWJraXQtYXBwZWFyYW5jZTpub25lOy1tb3otYXBwZWFyYW5jZTpub25lOy13ZWJraXQtYm94LXNpemluZzpjb250ZW50LWJveDstbW96LWJveC1zaXppbmc6Y29udGVudC1ib3g7Ym94LXNpemluZzpjb250ZW50LWJveH10ZXh0YXJlYXtvdmVyZmxvdzphdXRvO3ZlcnRpY2FsLWFsaWduOnRvcDtyZXNpemU6dmVydGljYWx9YXVkaW8sY2FudmFzLHZpZGVve2Rpc3BsYXk6aW5saW5lLWJsb2NrOypkaXNwbGF5OmlubGluZTsqem9vbToxO21heC13aWR0aDoxMDAlfWF1ZGlvOm5vdChbY29udHJvbHNdKXtkaXNwbGF5Om5vbmU7aGVpZ2h0OjB9W2hpZGRlbl17ZGlzcGxheTpub25lfWh0bWx7Zm9udC1zaXplOjEwMCU7LXdlYmtpdC10ZXh0LXNpemUtYWRqdXN0OjEwMCU7LW1zLXRleHQtc2l6ZS1hZGp1c3Q6MTAwJX1hOmZvY3Vze291dGxpbmU6dGhpbiBkb3R0ZWR9YTphY3RpdmUsYTpob3ZlcntvdXRsaW5lOjB9aW1ne2JvcmRlcjowOy1tcy1pbnRlcnBvbGF0aW9uLW1vZGU6YmljdWJpY31maWd1cmV7bWFyZ2luOjB9Zm9ybXttYXJnaW46MH1maWVsZHNldHtib3JkZXI6MXB4IHNvbGlkICNjMGMwYzA7bWFyZ2luOjAgMnB4O3BhZGRpbmc6MC4zNWVtIDAuNjI1ZW0gMC43NWVtfWxlZ2VuZHtib3JkZXI6MDtwYWRkaW5nOjA7d2hpdGUtc3BhY2U6bm9ybWFsOyptYXJnaW4tbGVmdDotN3B4fWJ1dHRvbixpbnB1dCxzZWxlY3QsdGV4dGFyZWF7Zm9udC1zaXplOjEwMCU7bWFyZ2luOjA7dmVydGljYWwtYWxpZ246YmFzZWxpbmU7KnZlcnRpY2FsLWFsaWduOm1pZGRsZX1idXR0b24saW5wdXR7bGluZS1oZWlnaHQ6bm9ybWFsfWJ1dHRvbixzZWxlY3R7dGV4dC10cmFuc2Zvcm06bm9uZX1idXR0b24saHRtbCBpbnB1dFt0eXBlPVxcXCJidXR0b25cXFwiXSxpbnB1dFt0eXBlPVxcXCJyZXNldFxcXCJdLGlucHV0W3R5cGU9XFxcInN1Ym1pdFxcXCJdey13ZWJraXQtYXBwZWFyYW5jZTpidXR0b247Y3Vyc29yOnBvaW50ZXI7Km92ZXJmbG93OnZpc2libGV9YnV0dG9uW2Rpc2FibGVkXSxodG1sIGlucHV0W2Rpc2FibGVkXXtjdXJzb3I6ZGVmYXVsdH1pbnB1dFt0eXBlPVxcXCJjaGVja2JveFxcXCJdLGlucHV0W3R5cGU9XFxcInJhZGlvXFxcIl17Ym94LXNpemluZzpib3JkZXItYm94O3BhZGRpbmc6MDsqaGVpZ2h0OjEzcHg7KndpZHRoOjEzcHh9aW5wdXRbdHlwZT1cXFwic2VhcmNoXFxcIl17LXdlYmtpdC1hcHBlYXJhbmNlOnRleHRmaWVsZDstbW96LWJveC1zaXppbmc6Y29udGVudC1ib3g7LXdlYmtpdC1ib3gtc2l6aW5nOmNvbnRlbnQtYm94O2JveC1zaXppbmc6Y29udGVudC1ib3h9aW5wdXRbdHlwZT1cXFwic2VhcmNoXFxcIl06Oi13ZWJraXQtc2VhcmNoLWNhbmNlbC1idXR0b24saW5wdXRbdHlwZT1cXFwic2VhcmNoXFxcIl06Oi13ZWJraXQtc2VhcmNoLWRlY29yYXRpb257LXdlYmtpdC1hcHBlYXJhbmNlOm5vbmV9YnV0dG9uOjotbW96LWZvY3VzLWlubmVyLGlucHV0OjotbW96LWZvY3VzLWlubmVye2JvcmRlcjowO3BhZGRpbmc6MH10ZXh0YXJlYXtvdmVyZmxvdzphdXRvO3ZlcnRpY2FsLWFsaWduOnRvcH10YWJsZXtib3JkZXItY29sbGFwc2U6Y29sbGFwc2U7Ym9yZGVyLXNwYWNpbmc6MH1odG1sLGJ1dHRvbixpbnB1dCxzZWxlY3QsdGV4dGFyZWF7Y29sb3I6IzIyMn06Oi1tb3otc2VsZWN0aW9ue2JhY2tncm91bmQ6I2IzZDRmYzt0ZXh0LXNoYWRvdzpub25lfTo6c2VsZWN0aW9ue2JhY2tncm91bmQ6I2IzZDRmYzt0ZXh0LXNoYWRvdzpub25lfWltZ3t2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9ZmllbGRzZXR7Ym9yZGVyOjA7bWFyZ2luOjA7cGFkZGluZzowfXRleHRhcmVhe3Jlc2l6ZTp2ZXJ0aWNhbH0uY2hyb21lZnJhbWV7bWFyZ2luOjAuMmVtIDA7YmFja2dyb3VuZDojY2NjO2NvbG9yOiMwMDA7cGFkZGluZzowLjJlbSAwfWJvZHl7Zm9udC1mYW1pbHk6J09wZW4gU2Fucyd9ZGl2e2JveC1zaXppbmc6Ym9yZGVyLWJveH1oMSxoMixoMyxoNCxoNSxoNntmb250LWZhbWlseTonQXJjaGl2byd9aDF7Zm9udC1zaXplOjZyZW19aDJ7Zm9udC1zaXplOjMuNzVyZW19aDN7Zm9udC1zaXplOjNyZW19aDR7Zm9udC1zaXplOjIuMTI1cmVtfWg1e2ZvbnQtc2l6ZToxLjVyZW19aDZ7Zm9udC1zaXplOjEuMjVyZW19YXtjb2xvcjojRjFGM0Y1fWE6Zm9jdXN7b3V0bGluZTpub25lfXB7Zm9udC1zaXplOjFyZW07bGluZS1oZWlnaHQ6MS44cmVtfUBmb250LWZhY2V7Zm9udC1mYW1pbHk6J09wZW4gU2Fucyc7Zm9udC1zdHlsZTpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO3NyYzp1cmwoXCIgKyBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF8wX19fICsgXCIpIGZvcm1hdChcXFwidHJ1ZXR5cGVcXFwiKX1AZm9udC1mYWNle2ZvbnQtZmFtaWx5OidBcmNoaXZvJztmb250LXN0eWxlOm5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7c3JjOnVybChcIiArIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzFfX18gKyBcIikgZm9ybWF0KFxcXCJ0cnVldHlwZVxcXCIpfS5kaXNwbGF5LWZsZXh7ZGlzcGxheTpmbGV4fS5mbGV4LWRpcmVjdGlvbi1yb3d7ZmxleC1kaXJlY3Rpb246cm93fS5mbGV4LWRpcmVjdGlvbi1jb2x1bW57ZmxleC1kaXJlY3Rpb246Y29sdW1ufS5qdXN0aWZ5LWVuZHtqdXN0aWZ5LWl0ZW1zOmZsZXgtZW5kfSNsb2FkaW5ne3Bvc2l0aW9uOmZpeGVkO3dpZHRoOjEwMHZ3O2hlaWdodDoxMDB2aDtiYWNrZ3JvdW5kOiNGOEY5RkE7ei1pbmRleDoyMH0jbG9hZGluZyAubG9hZGluZ19fcHJvZ3Jlc3N7cG9zaXRpb246cmVsYXRpdmU7aGVpZ2h0OjEwMCU7ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6cmlnaHQ7YmFja2dyb3VuZDojMjEyNTI5fSNsb2FkaW5nIC5sb2FkaW5nX19wcm9ncmVzcyBoMXtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDotMjEwcHg7Y29sb3I6IzIxMjUyOX0jbG9hZGluZy5sb2FkaW5nLWxhYmVsLWFuaW1hdGlvbiBoMXthbmltYXRpb246bG9hZGluZy1sYWJlbC1hbmltYXRpb247YW5pbWF0aW9uLWR1cmF0aW9uOjFzO2FuaW1hdGlvbi1maWxsLW1vZGU6Ym90aH1Aa2V5ZnJhbWVzIGxvYWRpbmctbGFiZWwtYW5pbWF0aW9ue2Zyb217Y29sb3I6IzIxMjUyOX10b3t0cmFuc2Zvcm06dHJhbnNsYXRlWCgtMjQwcHgpO2NvbG9yOiNGOEY5RkF9fSNuYXZfX2hhbWJ1cmd1ZXItbWVudXtwb3NpdGlvbjpmaXhlZDt6LWluZGV4OjE1O3JpZ2h0Oi4yNXJlbTt0b3A6LjVyZW07bWFyZ2luOi4yNXJlbTt3aWR0aDoyLjVyZW19I25hdl9faGFtYnVyZ3Vlci1tZW51OmhvdmVye2N1cnNvcjpwb2ludGVyfSNuYXZfX2hhbWJ1cmd1ZXItbWVudSBsaW5le3N0cm9rZTojRkNGQ0ZDO3N0cm9rZS13aWR0aDouMjVyZW19I25hdl9fbWVudXtvcGFjaXR5OjA7cG9zaXRpb246Zml4ZWQ7ZGlzcGxheTpmbGV4O2p1c3RpZnktY29udGVudDpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyO3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7ei1pbmRleDoxO3Zpc2liaWxpdHk6aGlkZGVuO2JhY2tncm91bmQ6IzIxMjUyOX1AbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOiA2NDBweCl7I25hdl9fbWVudXt3aWR0aDoxOC43NXJlbTtoZWlnaHQ6MzcuNXJlbTtyaWdodDowfX0jbmF2X19tZW51IC5tZW51LWxpc3R7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjthbGlnbi1pdGVtczpjZW50ZXJ9I25hdl9fbWVudSAubWVudS1saXN0IGF7Zm9udC1zaXplOjEuNHJlbTtmb250LXdlaWdodDpib2xkO2ZvbnQtZmFtaWx5OidBcmNoaXZvJztsaW5lLWhlaWdodDoxLjc1cmVtO3BhZGRpbmc6LjI1cmVtIC4yNXJlbX06Oi13ZWJraXQtc2Nyb2xsYmFyLXRyYWNre2JhY2tncm91bmQ6I0U5RUNFRn06Oi13ZWJraXQtc2Nyb2xsYmFye3dpZHRoOjEwcHg7YmFja2dyb3VuZDojRTlFQ0VGfTo6LXdlYmtpdC1zY3JvbGxiYXItdGh1bWJ7YmFja2dyb3VuZDojMjEyNTI5fS5hcnRpc3Qtc2VjdGlvbiBpbWd7cG9zaXRpb246YWJzb2x1dGU7bGVmdDo1MCU7dG9wOjUwJTt3aWR0aDoxMDAlO2hlaWdodDoxMDAlO3RyYW5zZm9ybTp0cmFuc2xhdGUoLTUwJSwgLTUwJSk7b2JqZWN0LWZpdDpjb3Zlcn0uYXJ0aXN0LXNlY3Rpb25fX3dyYXBwZXJ7cG9zaXRpb246cmVsYXRpdmU7aGVpZ2h0OjEwMHZoO2JhY2tncm91bmQ6IzIxMjUyOX0uYXJ0aXN0LXNlY3Rpb25fX3dlbGNvbWV7cG9zaXRpb246YWJzb2x1dGU7YmFja2dyb3VuZC1wb3NpdGlvbjpjZW50ZXI7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTt6LWluZGV4OjEwfSN2ZWxhenF1ZXogLmFydGlzdC1zZWN0aW9uX193ZWxjb21le2JhY2tncm91bmQtaW1hZ2U6dXJsKFxcXCIvc3JjL2ltZy92ZWxhenF1ZXpfYmxhY2subWluLnN2Z1xcXCIpfSNnb3lhIC5hcnRpc3Qtc2VjdGlvbl9fd2VsY29tZXtiYWNrZ3JvdW5kLWltYWdlOnVybChcXFwiL3NyYy9pbWcvZ295YV9ibGFjay5taW4uc3ZnXFxcIil9I3BpY2Fzc28gLmFydGlzdC1zZWN0aW9uX193ZWxjb21le2JhY2tncm91bmQtaW1hZ2U6dXJsKFxcXCIvc3JjL2ltZy9waWNhc3NvX2JsYWNrLm1pbi5zdmdcXFwiKX0jZGFsaSAuYXJ0aXN0LXNlY3Rpb25fX3dlbGNvbWV7YmFja2dyb3VuZC1pbWFnZTp1cmwoXFxcIi9zcmMvaW1nL2RhbGlfYmxhY2subWluLnN2Z1xcXCIpfS5hcnRpc3Qtc2VjdGlvbl9faW5mb3twb3NpdGlvbjphYnNvbHV0ZTtib3R0b206MDtyaWdodDowO21hcmdpbjouNXJlbTtwYWRkaW5nOjFyZW07YmFja2dyb3VuZC1jb2xvcjojMjEyNTI5O2NvbG9yOiNGQ0ZDRkN9LmFydGlzdC1zZWN0aW9uX19pbmZvIHA6bm90KDpmaXJzdC1vZi10eXBlKXtkaXNwbGF5Om5vbmV9QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDogNjQwcHgpey5hcnRpc3Qtc2VjdGlvbl9faW5mb3t3aWR0aDo1MCU7bWFyZ2luOjFyZW07cGFkZGluZzoxLjVyZW19fS5hcnRpc3Qtc2VjdGlvbl9faW5mby1saW5re2Zsb2F0OnJpZ2h0O3Bvc2l0aW9uOnJlbGF0aXZlO3dpZHRoOjIwcHg7aGVpZ2h0OjIwcHg7bWFyZ2luLWxlZnQ6MXJlbX0uYXJ0aXN0LXNlY3Rpb25fX2luZm8tbGluayBsaW5le3N0cm9rZTojRkNGQ0ZDO3N0cm9rZS13aWR0aDoycHh9Ym9keXtzY3JvbGwtYmVoYXZpb3I6c21vb3RofW1haW57b3ZlcmZsb3c6aGlkZGVufWJvZHkubG9hZGVke292ZXJmbG93OmluaXRpYWx9I2hvbWV7ZGlzcGxheTpmbGV4O2p1c3RpZnktY29udGVudDpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyO2hlaWdodDoxMDB2aDtiYWNrZ3JvdW5kLWNvbG9yOiMyMTI1Mjk7Y29sb3I6I0Y4RjlGQX0jY29udGFjdHtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246Y29sdW1uO21pbi1oZWlnaHQ6MTAwdmg7YmFja2dyb3VuZC1jb2xvcjojMjEyNTI5O2NvbG9yOiNGOEY5RkF9QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDogMTAyNHB4KXsjY29udGFjdHthbGlnbi1pdGVtczpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcn19I2NvbnRhY3Q+ZGl2e2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW59QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDogMTAyNHB4KXsjY29udGFjdD5kaXZ7ZmxleC1kaXJlY3Rpb246cm93O2FsaWduLWl0ZW1zOmZsZXgtc3RhcnR9fSNjb250YWN0X19iaWJsaW9ncmFwaHl7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjt3aWR0aDoxMDAlO3BhZGRpbmc6MnJlbTtmb250LXNpemU6MC44cmVtfSNjb250YWN0X19iaWJsaW9ncmFwaHkgdWx7bWFyZ2luOjEuNXJlbSAwIDAgMS41cmVtO2xpc3Qtc3R5bGUtdHlwZTpjaXJjbGV9I2NvbnRhY3RfX2Zvcm17ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjt3aWR0aDoxMDAlO3BhZGRpbmc6MnJlbX1cXG5cIiwgXCJcIl0pO1xuLy8gRXhwb3J0c1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\n// eslint-disable-next-line func-names\nmodule.exports = function (useSourceMap) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item, useSourceMap);\n\n      if (item[2]) {\n        return "@media ".concat(item[2], " {").concat(content, "}");\n      }\n\n      return content;\n    }).join(\'\');\n  }; // import a list of modules into the list\n  // eslint-disable-next-line func-names\n\n\n  list.i = function (modules, mediaQuery, dedupe) {\n    if (typeof modules === \'string\') {\n      // eslint-disable-next-line no-param-reassign\n      modules = [[null, modules, \'\']];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var i = 0; i < this.length; i++) {\n        // eslint-disable-next-line prefer-destructuring\n        var id = this[i][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _i = 0; _i < modules.length; _i++) {\n      var item = [].concat(modules[_i]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      if (mediaQuery) {\n        if (!item[2]) {\n          item[2] = mediaQuery;\n        } else {\n          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n  var content = item[1] || \'\'; // eslint-disable-next-line prefer-destructuring\n\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (useSourceMap && typeof btoa === \'function\') {\n    var sourceMapping = toComment(cssMapping);\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return "/*# sourceURL=".concat(cssMapping.sourceRoot || \'\').concat(source, " */");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join(\'\\n\');\n  }\n\n  return [content].join(\'\\n\');\n} // Adapted from convert-source-map (MIT)\n\n\nfunction toComment(sourceMap) {\n  // eslint-disable-next-line no-undef\n  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);\n  return "/*# ".concat(data, " */");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzPzI0ZmIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QyxxQkFBcUI7QUFDakU7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLHFCQUFxQjtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCOztBQUU5Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxjQUFjO0FBQ25FO0FBQ0EiLCJmaWxlIjoiMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh1c2VTb3VyY2VNYXApIHtcbiAgdmFyIGxpc3QgPSBbXTsgLy8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXG4gIGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBjb250ZW50ID0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApO1xuXG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICByZXR1cm4gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwiIHtcIikuY29uY2F0KGNvbnRlbnQsIFwifVwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfSkuam9pbignJyk7XG4gIH07IC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5cblxuICBsaXN0LmkgPSBmdW5jdGlvbiAobW9kdWxlcywgbWVkaWFRdWVyeSwgZGVkdXBlKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGVzID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICBtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCAnJ11dO1xuICAgIH1cblxuICAgIHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cbiAgICBpZiAoZGVkdXBlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgICAgIHZhciBpZCA9IHRoaXNbaV1bMF07XG5cbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbW9kdWxlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBpdGVtID0gW10uY29uY2F0KG1vZHVsZXNbX2ldKTtcblxuICAgICAgaWYgKGRlZHVwZSAmJiBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1lZGlhUXVlcnkpIHtcbiAgICAgICAgaWYgKCFpdGVtWzJdKSB7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhUXVlcnk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsyXSA9IFwiXCIuY29uY2F0KG1lZGlhUXVlcnksIFwiIGFuZCBcIikuY29uY2F0KGl0ZW1bMl0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGxpc3Q7XG59O1xuXG5mdW5jdGlvbiBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCkge1xuICB2YXIgY29udGVudCA9IGl0ZW1bMV0gfHwgJyc7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuXG4gIHZhciBjc3NNYXBwaW5nID0gaXRlbVszXTtcblxuICBpZiAoIWNzc01hcHBpbmcpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuXG4gIGlmICh1c2VTb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcbiAgICB2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgcmV0dXJuIFwiLyojIHNvdXJjZVVSTD1cIi5jb25jYXQoY3NzTWFwcGluZy5zb3VyY2VSb290IHx8ICcnKS5jb25jYXQoc291cmNlLCBcIiAqL1wiKTtcbiAgICB9KTtcbiAgICByZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcbiAgfVxuXG4gIHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59IC8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcblxuXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICB2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcbiAgdmFyIGRhdGEgPSBcInNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LFwiLmNvbmNhdChiYXNlNjQpO1xuICByZXR1cm4gXCIvKiMgXCIuY29uY2F0KGRhdGEsIFwiICovXCIpO1xufSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\nmodule.exports = function (url, options) {\n  if (!options) {\n    // eslint-disable-next-line no-param-reassign\n    options = {};\n  } // eslint-disable-next-line no-underscore-dangle, no-param-reassign\n\n\n  url = url && url.__esModule ? url.default : url;\n\n  if (typeof url !== \'string\') {\n    return url;\n  } // If url is already wrapped in quotes, remove them\n\n\n  if (/^[\'"].*[\'"]$/.test(url)) {\n    // eslint-disable-next-line no-param-reassign\n    url = url.slice(1, -1);\n  }\n\n  if (options.hash) {\n    // eslint-disable-next-line no-param-reassign\n    url += options.hash;\n  } // Should url be wrapped?\n  // See https://drafts.csswg.org/css-values-3/#urls\n\n\n  if (/["\'() \\t\\n]/.test(url) || options.needQuotes) {\n    return "\\"".concat(url.replace(/"/g, \'\\\\"\').replace(/\\n/g, \'\\\\n\'), "\\"");\n  }\n\n  return url;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvZ2V0VXJsLmpzPzFkZTUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsImZpbGUiOiI0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICBvcHRpb25zID0ge307XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVyc2NvcmUtZGFuZ2xlLCBuby1wYXJhbS1yZWFzc2lnblxuXG5cbiAgdXJsID0gdXJsICYmIHVybC5fX2VzTW9kdWxlID8gdXJsLmRlZmF1bHQgOiB1cmw7XG5cbiAgaWYgKHR5cGVvZiB1cmwgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfSAvLyBJZiB1cmwgaXMgYWxyZWFkeSB3cmFwcGVkIGluIHF1b3RlcywgcmVtb3ZlIHRoZW1cblxuXG4gIGlmICgvXlsnXCJdLipbJ1wiXSQvLnRlc3QodXJsKSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIHVybCA9IHVybC5zbGljZSgxLCAtMSk7XG4gIH1cblxuICBpZiAob3B0aW9ucy5oYXNoKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgdXJsICs9IG9wdGlvbnMuaGFzaDtcbiAgfSAvLyBTaG91bGQgdXJsIGJlIHdyYXBwZWQ/XG4gIC8vIFNlZSBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3NzLXZhbHVlcy0zLyN1cmxzXG5cblxuICBpZiAoL1tcIicoKSBcXHRcXG5dLy50ZXN0KHVybCkgfHwgb3B0aW9ucy5uZWVkUXVvdGVzKSB7XG4gICAgcmV0dXJuIFwiXFxcIlwiLmNvbmNhdCh1cmwucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpLnJlcGxhY2UoL1xcbi9nLCAnXFxcXG4nKSwgXCJcXFwiXCIpO1xuICB9XG5cbiAgcmV0dXJuIHVybDtcbn07Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__["default"] = ("data:font/ttf;base64,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KzUAAgCw/hQEdQYUABYAIgA+QB8gBhsUEBARBhEkIxIAERsMFgkDCR5GWQkWAxdGWQMQAD8rABg/KxESADk5GD8/ERIBOTkRMxEzMxEzMTABNjYzMhIREAIjIicjFxYVESMRMxEUByUiBgcVFBYzIBE0JgFYQqpq1/Dx1t56DAQIpqYGAUiomAKaqgEvlAO0WU/+1P71/vT+06EiTT/+NQgA/i40Whu4ySnnxwGw19H//wAC/hQEBgXTAiYAXAAAAQYAarUAAAq0AgErESYAKzU1//8AAAAABRAGtAImACQAAAEHAU0APwFSAAizAhIFJgArNf//AF7/7APNBWICJgBEAAABBgFN9QAACLMCKBEmACs1//8AAAAABRAHNwImACQAAAEHAU4AKwFSAAizAg8FJgArNf//AF7/7APNBeUCJgBEAAABBgFO5AAACLMCJREmACs1//8AAP5CBREFvAImACQAAAAHAVEDoAAA//8AXv5CBAAEWgImAEQAAAAHAVECjwAA//8Aff/sBM8HcwImACYAAAEHAHYBCAFSAAizASAFJgArNf//AHP/7AOLBiECJgBGAAABBgB2RAAACLMBIBEmACs1//8Aff/sBM8HcwImACYAAAEHAUsArAFSAAizASUFJgArNf//AHP/7AOLBiECJgBGAAABBgFL1AAACLMBJREmACs1//8Aff/sBM8HMQImACYAAAEHAU8CGwFSAAizASAFJgArNf//AHP/7AOLBd8CJgBGAAABBwFPAVAAAAAIswEgESYAKzX//wB9/+wEzwdzAiYAJgAAAQcBTADBAVIACLMBIgUmACs1//8Ac//sA6EGIQImAEYAAAEGAUzzAAAIswEiESYAKzX//wDJAAAFWAdzAiYAJwAAAQcBTABYAVIACLMCHQUmACs1//8Ac//sBYEGFAImAEcAAAEHAjgDDAAAAAeyAiMAAD81AP//AC8AAAVIBbYCBgCSAAAAAgBz/+wE0wYUABoAJwBkQDclBhIOAB4eFRkWGRAGBCgpGhUYEBEQR1kVDxEfES8RAwkDEREJEwABDAMJCSJGWQkQAxtGWQMWAD8rABg/KxESADk5GD8SOS9fXl0zKxEAMxg/ERIBFzkRMzMRMzMzETMxMCUjBiMiAhEQEjMyFzMmNTUhNSE1MxUzFSMRIyUyNjU1NCYjIgYVFBYDmglz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AAizAhkRJgArNf//AH3/7AW+B3MCJgAyAAABBwFTARQBUgAKtAMCKwUmACs1Nf//AHP/7ARiBiECJgBSAAABBgFTWgAACrQDAiwRJgArNTUAAgB9/+wG5wXNABQAHwBTQC4YBg8TEx0ADREdBgUgIQ8SSVkPDwALCw5JWQsDCRVJWQkEAxtJWQMSABNJWQASAD8rABg/KwAYPysAGD8rERIAORgvKxESARc5ETMRMxEzMTAhIQYjIAAREAAhMhchFSERIRUhESEBIgAREAAzMjcRJgbn/QBmXP65/p8BXAFAZloDDv2zAif92QJN/ET5/v8BAfdwV1cUAYkBagFoAYYXl/4plv3mBJ3+z/7Z/tf+zSEEdR4AAwBx/+wHHwRaAB4AKgAxAFVALR8IDgIWFiUvFRUcJQgEMjMrKAsoRlkuFkZZAgUOCy4uBRELEBgiBSJGWQAFFgA/MysRADMYPzMSOS8SORI5KysRADMREgEXOREzETMSOTkRMzEwBSAnBgYjIgAREAAzMhYXNjYzMhIVFSESITI2NxUGBgEUFjMyNjU0JiMiBiUiBgchNCYFlv7bfT7Rid/+9AEG64PNPjrAfsnu/ScIAUpeoVdYmPshmKejmZulppUER3+RDAIghBTrdHcBMQEIAQkBLHdycHn+9+Jp/ncjJ5QnIAI509vV0d3V2Niknp6k//8AyQAABM8HcwImADUAAAEHAHYAeQFSAAizAh8FJgArNf//ALAAAAMnBiECJgBVAAABBgB23AAACLMBGhEmACs1//8Ayf47BM8FtgImADUAAAAGAjl9AP//AGD+OwMnBFwCJgBVAAAABwI5/u8AAP//AMkAAATPB3MCJgA1AAABBwFMABsBUgAIswIhBSYAKzX//wCCAAADJwYhAiYAVQAAAQcBTP92AAAACLMBHBEmACs1//8Aav/sBAIHcwImADYAAAEHAHYAUAFSAAizAS4FJgArNf//AGr/7ANzBiECJgBWAAABBgB26gAACLMBLhEmACs1//8Aav/sBAIHcwImADYAAAEHAUv/6gFSAAizATMFJgArNf//AGr/7ANzBiECJgBWAAABBgFLlwAACLMBMxEmACs1//8Aav4UBAIFywImADYAAAAHAHoBJwAA//8Aav4UA3MEXAImAFYAAAAHAHoA1QAA//8Aav/sBAIHcwImADYAAAEH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WONZAlkhWUBZdVm3WfxaTVpuWtNbJ1snWydbJ1snWydbJ1snWydbJ1snWydbJ1snXHFczFzdXOVdbF2nXgteHF4tXjleRV5XXoxew17TXuNfQF+XX+BgMWA6YENgTGB6YJlgqmC7YMtg22FOYZlh7WI7Ypti/mM/Y4Bj1mQsZI9k9GVpZeBmjGcwZzhnQGedZ/ZoL2hnaHloi2kBaQ1pgGnzap1rO2vRbDpsfWy/bQNtM21gbYZtrG6QbxtvgW/fcDFwgnDXcUNxe3G0cgZyVXKocvtzB3MTc1BzjHPNdBB0WHSsdOZ1HnVddaJ13XYddnN2xndCd7l3xXfReAJ4NHg8eG94rXjxeTB5cXmueex6MHpzer97C3tDe3p76HxLfMF9LX01fUZ9V32sffx+RH6Hfsx/FX9Vf5Z/2oAegG+AvYDFgNaA5oD4gQmBEYEZgSqBOoGLgdqB7IH9gg+CIYIzgkSCkILaguuC+4MNgx6DMINBg0mDUYNjg3SDhoOXg6iDuIPKg9uD7YP+hBCEIYRMhHeEiYSbhKeEsoS+hMqFEIVWhZSFnIX2hmSGyYcnh4GH1IgriHmIxIkTiWaJsInvii2KioqSip6Kqoq2isKK04rkivaLCIsaiyyLPotQi2KLdIuJi52Lr4vBi9OL5Yv3jAmMG4wtjEKMVoxijG6Mf4yQjKGMsYzDjNWM54z5jQuNHY0vjUGNVo1qjXuNjI2YjaSNsI28jc2N3o3wjgKOFI4mjjiOSo5cjm6Og46XjqiOuI7JjtmO6o77jwyPHI8ojzSPQI9Mj12Pbo9/j4+PoI+wj8GP0o/jj/OP/5ALkBeQI5A0kEWQVpBmkHKQppDhkR2RapHCkfqSMpJ7ks2S9ZMYkzuTRJODk62T7pROlJOU3pTmlQmVEZVulXqV9pYClg6WcZaBlpGWopaylseW2JbplvqXDJcdly6XP5dKl1uXZ5d5l4GXk5ebl62XtZe9l86X2gAAAAEAAAABGdsfPbV9Xw889QAJCAAAAAAAyTUxiwAAAADVK8zV+5r91QmiCGIAAAAJAAIAAAAAAAAEzQDBAAAAAAQUAAACFAAAAiMAmAM1AIUFKwAzBJMAgwaWAGgF1wBxAcUAhQJeAFICXgA9BGoAVgSTAGgB9gA/ApMAVAIhAJgC8AAUBJMAZgSTALwEkwBkBJMAXgSTACsEkwCFBJMAdQSTAF4EkwBoBJMAagIhAJgCIQA/BJMAaASTAHcEkwBoA28AGwcxAHkFEAAABS8AyQUMAH0F1QDJBHMAyQQhAMkF0wB9BecAyQKqAFQCI/9gBOkAyQQnAMkHOQDJBggAyQY7AH0E0QDJBjsAfQTyAMkEZABqBG0AEgXTALoEwwAAB2gAGwSeAAgEewAABJEAUgKiAKYC8AAXAqIAMwRWADEDlv/8BJ4BiQRzAF4E5wCwA88AcwTnAHMEfQBzArYAHQRiACcE6QCwAgYAogIG/5EEMwCwAgYAsAdxALAE6QCwBNUAcwTnALAE5wBzA0QAsAPRAGoC0wAfBOkApAQCAAAGOQAXBDEAJwQIAAIDvgBSAwgAPQRoAe4DCABIBJMAaAIUAAACIwCYBJMAvgSTAD8EkwB7BJMAHwRoAe4EIQB7BJ4BNQaoAGQC1QBGA/oAUgSTAGgCkwBUBqgAZAQA//oDbQB/BJMAaALHADECxwAhBJ4BiQT0ALAFPQBxAiEAmAHRACUCxwBMAwAAQgP6AFAGPQBLBj0ALgY9ABoDbwAzBRAAAAUQAAAFEAAABRAAAAUQAAAFEAAABvz//gUMAH0EcwDJBHMAyQRzAMkEcwDJAqoAPAKqAFQCqv//AqoAPAXHAC8GCADJBjsAfQY7AH0GOwB9BjsAfQY7AH0EkwCFBjsAfQXTALoF0wC6BdMAugXTALoEewAABOMAyQT6ALAEcwBeBHMAXgRzAF4EcwBeBHMAXgRzAF4G3QBeA88AcwR9AHMEfQBzBH0AcwR9AHMCBv/aAgYAqQIG/7MCBv/sBMUAcQTpALAE1QBzBNUAcwTVAHME1QBzBNUAcwSTAGgE1QBzBOkApATpAKQE6QCkBOkApAQIAAIE5wCwBAgAAgUQAAAEcwBeBRAAAARzAF4FEAAABHMAXgUMAH0DzwBzBQwAfQPPAHMFDAB9A88AcwUMAH0DzwBzBdUAyQTnAHMFxwAvBOcAcwRzAMkEfQBzBHMAyQR9AHMEcwDJBH0AcwRzAMkEfQBzBHMAyQR9AHMF0wB9BGIAJwXTAH0EYgAnBdMAfQRiACcF0wB9BGIAJwXnAMkE6QCwBecAAATpABQCqv/iAgb/kAKqACoCBv/aAqoAHgIG/8wCqgBUAgYANQKqAFQCBgCwBM0AVAQMAKICI/9gAgb/kQTpAMkEMwCwBCUAsAQnAMkCBgCjBCcAyQIGAFkEJwDJAgYAsAQnAMkCgwCwBC8AHQIX//wGCADJBOkAsAYIAMkE6QCwBggAyQTpALAFcwABBggAyQTpALAGOwB9BNUAcwY7AH0E1QBzBjsAfQTVAHMHYgB9B4kAcQTyAMkDRACwBPIAyQNEAGAE8gDJA0QAggRkAGoD0QBqBGQAagPRAGoEZABqA9EAagRkAGoD0QBqBG0AEgLTAB8EbQASAtMAHwRtABIC0wAfBdMAugTpAKQF0wC6BOkApAXTALoE6QCkBdMAugTpAKQF0wC6BOkApAXTALoE6QCkB2gAGwY5ABcEewAABAgAAgR7AAAEkQBSA74AUgSRAFIDvgBSBJEAUgO+AFICjwCwBJ4AwwUUAAAEcwBeBvz//gbdAF4GOwB9BNUAcwRkAGoD0QBqBLwBDAS8AQwEsgEtBLwBJQIGAKIEngFvAZMAJQS8AQgEngDnBJ4B/ASeARsFEAAAAiEAmATy/9QGff/UA5j/5AaB/+QFhf/UBoH/5AK2/+kFEAAABS8AyQQpAMkEkwAnBHMAyQSRAFIF5wDJBjsAfQKqAFQE6QDJBNMAAAc5AMkGCADJBG0ASAY7AH0F1QDJBNEAyQSJAEoEbQASBHsAAAZiAGoEngAIBl4AbQZCAFACqgA8BHsAAATjAHMDzQBaBOkAsAK2AKgE3wCkBOMAcwUGALAEGQAKBKQAcQPNAFoD3QBzBOkAsAS8AHMCtgCoBCUAsARG//IE9ACwBFYAAAPNAHEE1QBzBTMAGQTVAKYD2wBzBOcAcwPJABIE3wCkBb4AcwRe/+wGBgCkBi8AcwK2AAkE3wCkBNUAcwTfAKQGLwBzBHMAyQXfABIEKQDJBR0AfQRkAGoCqgBUAqoAPAIj/2AHbwAAB6AAyQXfABIE5QDJBPgAGwXVAMkFEAAABOcAyQUvAMkEKQDJBXcADgRzAMkGwQACBKYASgYZAMsGGQDLBOUAyQWiAAAHOQDJBecAyQY7AH0F1QDJBNEAyQUMAH0EbQASBPgAGwZiAGoEngAIBeUAyQWPAKoIQgDJCEQAyQWBABIG0wDJBSUAyQUKAD0IZgDJBRcAMwRzAF4ExQB3BI0AsANtALAEkwApBH0AcwXjAAQD3QBEBRIAsAUSALAEJwCwBJEAEAXhALAFEgCwBNUAcwT4ALAE5wCw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AAsAOAHsAAMAAQQJAAwAXAIkAAMAAQQJAA0AXAKAAAMAAQQJAA4AVALcAEQAaQBnAGkAdABpAHoAZQBkACAAZABhAHQAYQAgAGMAbwBwAHkAcgBpAGcAaAB0ACAAqQAgADIAMAAxADAALQAyADAAMQAxACwAIABHAG8AbwBnAGwAZQAgAEMAbwByAHAAbwByAGEAdABpAG8AbgAuAE8AcABlAG4AIABTAGEAbgBzAFIAZQBnAHUAbABhAHIAMQAuADEAMAA7ADEAQQBTAEMAOwBPAHAAZQBuAFMAYQBuAHMALQBSAGUAZwB1AGwAYQByAE8AcABlAG4AIABTAGEAbgBzACAAUgBlAGcAdQBsAGEAcgBWAGUAcgBzAGkAbwBuACAAMQAuADEAMABPAHAAZQBuAFMAYQBuAHMALQBSAGUAZwB1AGwAYQByAE8AcABlAG4AIABTAGEAbgBzACAAaQBzACAAYQAgAHQAcgBhAGQAZQBtAGEAcgBrACAAbwBmACAARwBvAG8AZwBsAGUAIABhAG4AZAAgAG0AYQB5ACAAYgBlACAAcgBlAGcAaQBzAHQAZQByAGUAZAAgAGkAbgAgAGMAZQByAHQAYQBpAG4AIABqAHUAcgBpAHMAZABpAGMAdABpAG8AbgBzAC4AQQBzAGMAZQBuAGQAZQByACAAQwBvAHIAcABvAHIAYQB0AGkAbwBuAGgAdAB0AHAAOgAvAC8AdwB3AHcALgBhAHMAYwBlAG4AZABlAHIAYwBvAHIAcAAuAGMAbwBtAC8AaAB0AHQAcAA6AC8ALwB3AHcAdwAuAGEAcwBjAGUAbgBkAGUAcgBjAG8AcgBwAC4AYwBvAG0ALwB0AHkAcABlAGQAZQBzAGkAZwBuAGUAcgBzAC4AaAB0AG0AbABMAGkAYwBlAG4AcwBlAGQAIAB1AG4AZABlAHIAIAB0AGgAZQAgAEEAcABhAGMAaABlACAATABpAGMAZQBuAHMAZQAsACAAVgBlAHIAcwBpAG8AbgAgADIALgAwAGgAdAB0AHAAOgAvAC8AdwB3AHcALgBhAHAAYQBjAGgAZQAuAG8AcgBnAC8AbABpAGMAZQBuAHMAZQBzAC8ATABJAEMARQBOAFMARQAtADIALgAwAAAAAgAAAAAAAP9mAGYAAAAAAAAAAAAAAAAAAAAAAAAAAAOqAAABAgACAAMABAAFAAYABwAIAAkACgALAAwADQAOAA8AEAARABIAEwAUABUAFgAXABgAGQAaABsAHAAdAB4AHwAgACEAIgAjACQAJQAmACcAKAApACoAKwEDAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAOgA7ADwAPQA+AD8AQABBAEIAQwBEAEUARgBHAEgASQBKAEsATABNAE4ATwBQAFEAUgBTAFQAVQBWAFcAWABZAFoAWwBcAF0AXgBfAGAAYQCsAKMAhACFAL0AlgDoAIYAjgCLAJ0AqQCkAQQAigEFAIMAkwDyAPMAjQCXAIgAwwDeAPEAngCqAPUA9AD2AKIArQDJAMcArgBiAGMAkABkAMsAZQDIAMoBBgEHAQgBCQDpAGYA0wDQANEArwBnAPAAkQDWANQA1QBoAOsA7QCJAGoAaQBrAG0AbABuAKAAbwBxAHAAcgBzAHUAdAB2AHcA6gB4AHoAeQB7AH0AfAC4AKEAfwB+AIAAgQDsAO4AugEKAQsBDAENAQ4BDwD9AP4BEAERARIBEwD/AQABFAEVARYBAQEXARgBGQEaARsBHAEdAR4BHwEgASEBIgD4APkBIwEkASUBJgEnASgBKQEqASsBLAEtAS4BLwEwATEBMgEzANcBNAE1ATYBNwE4ATkBOgE7ATwBPQE+AT8BQAFBAUIA4gDjAUMBRAFFAUYBRwFIAUkBSgFLAUwBTQFOAU8BUAFRALAAsQFSAVMBVAFVAVYBVwFYAVkBWgFbAPsA/ADkAOUBXAFdAV4BXwFgAWEBYgFjAWQBZQFmAWcBaAFpAWoBawFsAW0BbgFvAXABcQC7AXIBcwF0AXUA5gDnAXYApgF3AXgBeQF6AXsBfAF9AX4A2ADhANoA2wDcAN0A4ADZAN8BfwGAAYEBggGDAYQBhQGGAYcBiAGJAYoBiwGMAY0BjgGPAZABkQGSAZMBlAGVAZYBlwGYAZkBmgGbAZwBnQGeAZ8BoAGhAaIBowGkAaUBpgGnAagBqQGqAasBrAGtAa4BrwGwAbEBsgGzAbQBtQG2AbcAmwG4AbkBugG7AbwBvQG+Ab8BwAHBAcIBwwHEAcUBxgHHAcgByQHKAcsBzAHNAc4BzwHQAdEB0gHTAdQB1QHWAdcB2AHZAdoB2wHcAd0B3gHfAeAB4QHiAeMB5AHlAeYB5wHoAekB6gHrAewB7QHuAe8B8AHxAfIB8wH0AfUB9gH3AfgB+QH6AfsB/AH9Af4B/wIAAgECAgIDAgQCBQIGAgcCCAIJAgoCCwIMAg0CDgIPAhACEQISAhMCFAIVAhYCFwIYAhkCGgIbAhwCHQIeAh8CIAIhAiICIwIkAiUCJgInAigCKQIqAisAsgCzAiwCLQC2ALcAxAIuALQAtQDFAIIAwgCHAKsAxgIvAjAAvgC/AjEAvAIyAPcCMwI0AjUCNgI3AjgAjACfAjkCOgI7AjwCPQCYAKgAmgCZAO8ApQCSAJwApwCPAJQAlQC5Aj4CPwJAAkECQgJDAkQCRQJGAkcCSAJJAkoCSwJMAk0CTgJPAlACUQJSAlMCVAJVAlYCVwJYAlkCWgJbAlwCXQJeAl8CYAJhAmICYwJkAmUCZgJnAmgCaQJqAmsCbAJtAm4CbwJwAnECcgJzAnQCdQJ2AncCeAJ5AnoCewJ8An0CfgJ/AoACgQKCAoMChAKFAoYChwKIAokCigKLAowCjQKOAo8CkAKRApICkwKUApUClgKXApgCmQKaApsCnAKdAp4CnwKgAqECogKjAqQCpQKmAqcCqAKpAqoCqwKsAq0CrgKvArACsQKyArMCtAK1ArYCtwK4ArkCugK7ArwCvQK+Ar8CwALBAsICwwLEAsUCxgLHAsgCyQLKAssCzALNAs4CzwLQAtEC0gLTAtQC1QLWAtcC2ALZAtoC2wLcAt0C3gLfAuAC4QLiAuMC5ALlAuYC5wLoAukC6gLrAuwC7QLuAu8C8ALxAvIC8wL0AvUC9gL3AvgC+QL6AvsC/AL9Av4C/wMAAwEDAgMDAwQDBQMGAwcDCAMJAwoDCwMMAw0DDgMPAxADEQMSAxMDFAMVAxYDFwMYAxkDGgMbAxwDHQMeAx8DIAMhAyIDIwMkAyUDJgMnAygDKQMqAysDLAMtAy4DLwMwAzEDMgMzAzQDNQM2AzcDOAM5AzoDOwM8Az0DPgM/A0ADQQNCA0MDRANFA0YDRwNIA0kDSgNLA0wDTQNOA08DUANRA1IDUwNUA1UDVgNXA1gDWQNaA1sDXANdA14DXwNgA2EDYgNjA2QDZQNmA2cDaANpA2oDawNsA20DbgNvA3ADcQNyA3MDdAN1A3YDdwN4A3kDegN7A3wDfQN+A38DgAOBA4IDgwOEA4UDhgOHA4gDiQOKA4sDjAONA44DjwOQA5EDkgOTA5QDlQOWA5cDmAOZA5oDmwOcA50DngOfACwAzwDMAM0AzgOgA6EDogOjAPoDpAOlA6YDpwOoA6kDqgOrA6wDrQRudWxsBUkuYWx0B3VuaTAwQUQJb3ZlcnNjb3JlCklncmF2ZS5hbHQKSWFjdXRlLmFsdA9JY2lyY3VtZmxleC5hbHQNSWRpZXJlc2lzLmFsdAdBbWFjcm9uB2FtYWNyb24GQWJyZXZlBmFicmV2ZQdBb2dvbmVrB2FvZ29uZWsLQ2NpcmN1bWZsZXgLY2NpcmN1bWZsZXgEQ2RvdARjZG90BkRjYXJvbgZkY2Fyb24GRGNyb2F0B0VtYWNyb24HZW1hY3JvbgZFYnJldmUGZWJyZXZlCkVkb3RhY2NlbnQKZWRvdGFjY2VudAdFb2dvbmVrB2VvZ29uZWsGRWNhcm9uBmVjYXJvbgtHY2lyY3VtZmxleAtnY2lyY3VtZmxleARHZG90BGdkb3QMR2NvbW1hYWNjZW50DGdjb21tYWFjY2VudAtIY2lyY3VtZmxleAtoY2lyY3VtZmxleARIYmFyBGhiYXIKSXRpbGRlLmFsdAZpdGlsZGULSW1hY3Jvbi5hbHQHaW1hY3JvbgpJYnJldmUuYWx0BmlicmV2ZQtJb2dvbmVrLmFsdAdpb2dvbmVrDklkb3RhY2NlbnQuYWx0BklKLmFsdAJpagtKY2lyY3VtZmxleAtqY2lyY3VtZmxleAxLY29tbWFhY2NlbnQMa2NvbW1hYWNjZW50DGtncmVlbmxhbmRpYwZMYWN1dGUGbGFjdXRlDExjb21tYWFjY2VudAxsY29tbWFhY2NlbnQGTGNhcm9uBmxjYXJvbgRMZG90BGxkb3QGTmFjdXRlBm5hY3V0ZQxOY29tbWFhY2NlbnQMbmNvbW1hYWNjZW50Bk5jYXJvbgZuY2Fyb24LbmFwb3N0cm9waGUDRW5nA2VuZwdPbWFjcm9uB29tYWNyb24GT2JyZXZlBm9icmV2ZQ1PaHVuZ2FydW1sYXV0DW9odW5nYXJ1bWxhdXQGUmFjdXRlBnJhY3V0ZQxSY29tbWFhY2NlbnQMcmNvbW1hYWNjZW50BlJjYXJvbgZyY2Fyb24GU2FjdXRlBnNhY3V0ZQtTY2lyY3VtZmxleAtzY2lyY3VtZmxleAxUY29tbWFhY2NlbnQMdGNvbW1hYWNjZW50BlRjYXJvbgZ0Y2Fyb24EVGJhcgR0YmFyBlV0aWxkZQZ1dGlsZGUHVW1hY3Jvbgd1bWFjcm9uBlVicmV2ZQZ1YnJldmUFVXJpbmcFdXJpbmcNVWh1bmdhcnVtbGF1dA11aHVuZ2FydW1sYXV0B1VvZ29uZWsHdW9nb25lawtXY2lyY3VtZmxleAt3Y2lyY3VtZmxleAtZY2lyY3VtZmxleAt5Y2lyY3VtZmxleAZaYWN1dGUGemFjdXRlClpkb3RhY2NlbnQKemRvdGFjY2VudAVsb25ncwpBcmluZ2FjdXRlCmFyaW5nYWN1dGUHQUVhY3V0ZQdhZWFjdXRlC09zbGFzaGFjdXRlC29zbGFzaGFjdXRlDFNjb21tYWFjY2VudAxzY29tbWFhY2NlbnQFdG9ub3MNZGllcmVzaXN0b25vcwpBbHBoYXRvbm9zCWFub3RlbGVpYQxFcHNpbG9udG9ub3MIRXRhdG9ub3MNSW90YXRvbm9zLmFsdAxPbWljcm9udG9ub3MMVXBzaWxvbnRvbm9zCk9tZWdhdG9ub3MRaW90YWRpZXJlc2lzdG9ub3MFQWxwaGEEQmV0YQVHYW1tYQd1bmkwMzk0B0Vwc2lsb24EWmV0YQNFdGEFVGhldGEISW90YS5hbHQFS2FwcGEGTGFtYmRhAk11Ak51AlhpB09taWNyb24CUGkDUmhvBVNpZ21hA1RhdQdVcHNpbG9uA1BoaQNDaGkDUHNpB3VuaTAzQTkQSW90YWRpZXJlc2lzLmFsdA9VcHNpbG9uZGllcmVzaXMKYWxwaGF0b25vcwxlcHNpbG9udG9ub3MIZXRhdG9ub3MJaW90YXRvbm9zFHVwc2lsb25kaWVyZXNpc3Rvbm9zBWFscGhhBGJldGEFZ2FtbWEFZGVsdGEHZXBzaWxvbgR6ZXRhA2V0YQV0aGV0YQRpb3RhBWthcHBhBmxhbWJkYQd1bmkwM0JDAm51AnhpB29taWNyb24DcmhvBnNpZ21hMQVzaWdtYQN0YXUHdXBzaWxvbgNwaGkDY2hpA3BzaQVvbWVnYQxpb3RhZGllcmVzaXMPdXBzaWxvbmRpZXJlc2lzDG9taWNyb250b25vcwx1cHNpbG9udG9ub3MKb21lZ2F0b25vcwlhZmlpMTAwMjMJYWZpaTEwMDUxCWFmaWkxMDA1MglhZmlpMTAwNTMJYWZpaTEwMDU0DWFmaWkxMDA1NS5hbHQNYWZpaTEwMDU2LmFsdAlhZmlpMTAwNTcJYWZpaTEwMDU4CWFmaWkxMDA1OQlhZmlpMTAwNjAJYWZpaTEwMDYxCWFmaWkxMDA2MglhZmlpMTAxNDUJYWZpaTEwMDE3CWFmaWkxMDAxOAlhZmlpMTAwMTkJYWZpaTEwMDIwCWFmaWkxMDAyMQlhZmlpMTAwMjIJYWZpaTEwMDI0CWFmaWkxMDAyNQlhZmlpMTAwMjYJYWZpaTEwMDI3CWFmaWkxMDAyOAlhZmlpMTAwMjkJYWZpaTEwMDMwCWFmaWkxMDAzMQlhZmlpMTAwMzIJYWZpaTEwMDMzCWFmaWkxMDAzNAlhZmlpMTAwMzUJYWZpaTEwMDM2CWFmaWkxMDAzNwlhZmlpMTAwMzgJYWZpaTEwMDM5CWFmaWkxMDA0MAlhZmlpMTAwNDEJYWZpaTEwMDQyCWFmaWkxMDA0MwlhZmlpMTAwNDQJYWZpaTEwMDQ1CWFmaWkxMDA0NglhZmlpMTAwNDcJYWZpaTEwMDQ4CWFmaWkxMDA0OQlhZmlpMTAwNjUJYWZpaTEwMDY2CWFmaWkxMDA2NwlhZmlpMTAwNjgJYWZpaTEwMDY5CWFmaWkxMDA3MAlhZmlpMTAwNzIJYWZpaTEwMDczCWFmaWkxMDA3NAlhZmlpMTAwNzUJYWZpaTEwMDc2CWFmaWkxMDA3NwlhZmlpMTAwNzgJYWZpaTEwMDc5CWFmaWkxMDA4MAlhZmlpMTAwODEJYWZpaTEwMDgyCWFmaWkxMDA4MwlhZmlpMTAwODQJYWZpaTEwMDg1CWFmaWkxMDA4NglhZmlpMTAwODcJYWZpaTEwMDg4CWFmaWkxMDA4OQlhZmlpMTAwOTAJYWZpaTEwMDkxCWFmaWkxMDA5MglhZmlpMTAwOTMJYWZpaTEwMDk0CWFmaWkxMDA5NQlhZmlpMTAwOTYJYWZpaTEwMDk3CWFmaWkxMDA3MQlhZmlpMTAwOTkJYWZpaTEwMTAwCWFmaWkxMDEwMQlhZmlpMTAxMDIJYWZpaTEwMTAzCWFmaWkxMDEwNAlhZmlpMTAxMDUJYWZpaTEwMTA2CWFmaWkxMDEwNwlhZmlpMTAxMDgJYWZpaTEwMTA5CWFmaWkxMDExMAlhZmlpMTAxOTMJYWZpaTEwMDUwCWFmaWkxMDA5OAZXZ3JhdmUGd2dyYXZlBldhY3V0ZQZ3YWN1dGUJV2RpZXJlc2lzCXdkaWVyZXNpcwZZZ3JhdmUGeWdyYXZlCWFmaWkwMDIwOA11bmRlcnNjb3JlZGJsDXF1b3RlcmV2ZXJzZWQGbWludXRlBnNlY29uZAlleGNsYW1kYmwJbnN1cGVyaW9yCWFmaWkwODk0MQZwZXNldGEERXVybwlhZmlpNjEyNDgJYWZpaTYxMjg5CWFmaWk2MTM1Mgllc3RpbWF0ZWQJb25lZWlnaHRoDHRocmVlZWlnaHRocwtmaXZlZWlnaHRocwxzZXZlbmVpZ2h0aHMHdW5pRkIwMQd1bmlGQjAyDWN5cmlsbGljYnJldmUIZG90bGVzc2oQY2Fyb25jb21tYWFjY2VudAtjb21tYWFjY2VudBFjb21tYWFjY2VudHJvdGF0ZQx6ZXJvc3VwZXJpb3IMZm91cnN1cGVyaW9yDGZpdmVzdXBlcmlvcgtzaXhzdXBlcmlvcg1zZXZlbnN1cGVyaW9yDWVpZ2h0c3VwZXJpb3IMbmluZXN1cGVyaW9yB3VuaTIwMDAHdW5pMjAwMQd1bmkyMDAyB3VuaTIwMDMHdW5pMjAwNAd1bmkyMDA1B3VuaTIwMDYHdW5pMjAwNwd1bmkyMDA4B3VuaTIwMDkHdW5pMjAwQQd1bmkyMDBCB3VuaUZFRkYHdW5pRkZGQwd1bmlGRkZEB3VuaTAxRjAHdW5pMDJCQwd1bmkwM0QxB3VuaTAzRDIHdW5pMDNENgd1bmkxRTNFB3VuaTFFM0YHdW5pMUUwMAd1bmkxRTAxB3VuaTFGNEQHdW5pMDJGMwlkYXNpYW94aWEHdW5pRkIwMwd1bmlGQjA0BU9ob3JuBW9ob3JuBVVob3JuBXVob3JuB3VuaTAzMDAHdW5pMDMwMQd1bmkwMzAzBGhvb2sIZG90YmVsb3cHdW5pMDQwMAd1bmkwNDBEB3VuaTA0NTAHdW5pMDQ1RAd1bmkwNDYwB3VuaTA0NjEHdW5pMDQ2Mgd1bmkwNDYzB3VuaTA0NjQHdW5pMDQ2NQd1bmkwNDY2B3VuaTA0NjcHdW5pMDQ2OAd1bmkwNDY5B3VuaTA0NkEHdW5pMDQ2Qgd1bmkwNDZDB3VuaTA0NkQHdW5pMDQ2RQd1bmkwNDZGB3VuaTA0NzAHdW5pMDQ3MQd1bmkwNDcyB3VuaTA0NzMHdW5pMDQ3NAd1bmkwNDc1B3VuaTA0NzYHdW5pMDQ3Nwd1bmkwNDc4B3VuaTA0NzkHdW5pMDQ3QQd1bmkwNDdCB3VuaTA0N0MHdW5pMDQ3RAd1bmkwNDdFB3VuaTA0N0YHdW5pMDQ4MAd1bmkwNDgxB3VuaTA0ODIHdW5pMDQ4Mwd1bmkwNDg0B3VuaTA0ODUHdW5pMDQ4Ngd1bmkwNDg4B3VuaTA0ODkHdW5pMDQ4QQd1bmkwNDhCB3VuaTA0OEMHdW5pMDQ4RAd1bmkwNDhFB3VuaTA0OEYHdW5pMDQ5Mgd1bmkwNDkzB3VuaTA0OTQHdW5pMDQ5NQd1bmkwNDk2B3VuaTA0OTcHdW5pMDQ5OAd1bmkwNDk5B3VuaTA0OUEHdW5pMDQ5Qgd1bmkwNDlDB3VuaTA0OUQHdW5pMDQ5RQd1bmkwNDlGB3VuaTA0QTAHdW5pMDRBMQd1bmkwNEEyB3VuaTA0QTMHdW5pMDRBNAd1bmkwNEE1B3VuaTA0QTYHdW5pMDRBNwd1bmkwNEE4B3VuaTA0QTkHdW5pMDRBQQd1bmkwNEFCB3VuaTA0QUMHdW5pMDRBRAd1bmkwNEFFB3VuaTA0QUYHdW5pMDRCMAd1bmkwNEIxB3VuaTA0QjIHdW5pMDRCMwd1bmkwNEI0B3VuaTA0QjUHdW5pMDRCNgd1bmkwNEI3B3VuaTA0QjgHdW5pMDRCOQd1bmkwNEJBB3VuaTA0QkIHdW5pMDRCQwd1bmkwNEJEB3VuaTA0QkUHdW5pMDRCRgt1bmkwNEMwLmFsdAd1bmkwNEMxB3VuaTA0QzIHdW5pMDRDMwd1bmkwNEM0B3VuaTA0QzUHdW5pMDRDNgd1bmkwNEM3B3VuaTA0QzgHdW5pMDRDOQd1bmkwNENBB3VuaTA0Q0IHdW5pMDRDQwd1bmkwNENEB3VuaTA0Q0ULdW5pMDRDRi5hbHQHdW5pMDREMAd1bmkwNEQxB3VuaTA0RDIHdW5pMDREMwd1bmkwNEQ0B3VuaTA0RDUHdW5pMDRENgd1bmkwNEQ3B3VuaTA0RDgHdW5pMDREOQd1bmkwNERBB3VuaTA0REIHdW5pMDREQwd1bmkwNEREB3VuaTA0REUHdW5pMDRERgd1bmkwNEUwB3VuaTA0RTEHdW5pMDRFMgd1bmkwNEUzB3VuaTA0RTQHdW5pMDRFNQd1bmkwNEU2B3VuaTA0RTcHdW5pMDRFOAd1bmkwNEU5B3VuaTA0RUEHdW5pMDRFQgd1bmkwNEVDB3VuaTA0RUQHdW5pMDRFRQd1bmkwNEVGB3VuaTA0RjAHdW5pMDRGMQd1bmkwNEYyB3VuaTA0RjMHdW5pMDRGNAd1bmkwNEY1B3VuaTA0RjYHdW5pMDRGNwd1bmkwNEY4B3VuaTA0RjkHdW5pMDRGQQd1bmkwNEZCB3VuaTA0RkMHdW5pMDRGRAd1bmkwNEZFB3VuaTA0RkYHdW5pMDUwMAd1bmkwNTAxB3VuaTA1MDIHdW5pMDUwMwd1bmkwNTA0B3VuaTA1MDUHdW5pMDUwNgd1bmkwNTA3B3VuaTA1MDgHdW5pMDUwOQd1bmkwNTBBB3VuaTA1MEIHdW5pMDUwQwd1bmkwNTBEB3VuaTA1MEUHdW5pMDUwRgd1bmkwNTEwB3VuaTA1MTEHdW5pMDUxMgd1bmkwNTEzB3VuaTFFQTAHdW5pMUVBMQd1bmkxRUEyB3VuaTFFQTMHdW5pMUVBNAd1bmkxRUE1B3VuaTFFQTYHdW5pMUVBNwd1bmkxRUE4B3VuaTFFQTkHdW5pMUVBQQd1bmkxRUFCB3VuaTFFQUMHdW5pMUVBRAd1bmkxRUFFB3VuaTFFQUYHdW5pMUVCMAd1bmkxRUIxB3VuaTFFQjIHdW5pMUVCMwd1bmkxRUI0B3VuaTFFQjUHdW5pMUVCNgd1bmkxRUI3B3VuaTFFQjgHdW5pMUVCOQd1bmkxRUJBB3VuaTFFQkIHdW5pMUVCQwd1bmkxRUJEB3VuaTFFQkUHdW5pMUVCRgd1bmkxRUMwB3VuaTFFQzEHdW5pMUVDMgd1bmkxRUMzB3VuaTFFQzQHdW5pMUVDNQd1bmkxRUM2B3VuaTFFQzcLdW5pMUVDOC5hbHQHdW5pMUVDOQt1bmkxRUNBLmFsdAd1bmkxRUNCB3VuaTFFQ0MHdW5pMUVDRAd1bmkxRUNFB3VuaTFFQ0YHdW5pMUVEMAd1bmkxRUQxB3VuaTFFRDIHdW5pMUVEMwd1bmkxRUQ0B3VuaTFFRDUHdW5pMUVENgd1bmkxRUQ3B3VuaTFFRDgHdW5pMUVEOQd1bmkxRURBB3VuaTFFREIHdW5pMUVEQwd1bmkxRUREB3VuaTFFREUHdW5pMUVERgd1bmkxRUUwB3VuaTFFRTEHdW5pMUVFMgd1bmkxRUUzB3VuaTFFRTQHdW5pMUVFNQd1bmkxRUU2B3VuaTFFRTcHdW5pMUVFOAd1bmkxRUU5B3VuaTFFRUEHdW5pMUVFQgd1bmkxRUVDB3VuaTFFRUQHdW5pMUVFRQd1bmkxRUVGB3VuaTFFRjAHdW5pMUVGMQd1bmkxRUY0B3VuaTFFRjUHdW5pMUVGNgd1bmkxRUY3B3VuaTFFRjgHdW5pMUVGOQd1bmkyMEFCB3VuaTAzMEYTY2lyY3VtZmxleGFjdXRlY29tYhNjaXJjdW1mbGV4Z3JhdmVjb21iEmNpcmN1bWZsZXhob29rY29tYhNjaXJjdW1mbGV4dGlsZGVjb21iDmJyZXZlYWN1dGVjb21iDmJyZXZlZ3JhdmVjb21iDWJyZXZlaG9va2NvbWIOYnJldmV0aWxkZWNvbWIQY3lyaWxsaWNob29rbGVmdBFjeXJpbGxpY2JpZ2hvb2tVQxFjeXJpbGxpY2JpZ2hvb2tMQwhvbmUucG51bQd6ZXJvLm9zBm9uZS5vcwZ0d28ub3MIdGhyZWUub3MHZm91ci5vcwdmaXZlLm9zBnNpeC5vcwhzZXZlbi5vcwhlaWdodC5vcwduaW5lLm9zAmZmB3VuaTIxMjAIVGNlZGlsbGEIdGNlZGlsbGEFZy5hbHQPZ2NpcmN1bWZsZXguYWx0CmdicmV2ZS5hbHQIZ2RvdC5hbHQQZ2NvbW1hYWNjZW50LmFsdAZJdGlsZGUHSW1hY3JvbgZJYnJldmUHSW9nb25lawJJSglJb3RhdG9ub3MESW90YQxJb3RhZGllcmVzaXMJYWZpaTEwMDU1CWFmaWkxMDA1Ngd1bmkwNEMwB3VuaTA0Q0YHdW5pMUVDOAd1bmkxRUNBAAABAAMACAAKAA0AB///AA8AAQAAAAwAAAAAAAAAAgAFAAACNQABAjcCNwABAjsCWwABAl0DdgABA4IDqQABAAAAAQAAAAoADAAOAAAAAAAAAAEAAAAKAG4BWgABbGF0bgAIABAAAk1PTCAAKFJPTSAAQgAA//8ACQADAAgACwAAAA4AEQAUABcAGgAA//8ACgAEAAYACQAMAAEADwASABUAGAAbAAD//wAKAAUABwAKAA0AAgAQABMAFgAZABwAHWxpZ2EAsGxpZ2EAsGxpZ2EAsGxudW0AtmxudW0AtmxudW0AtmxvY2wAvGxvY2wAvG9udW0Awm9udW0Awm9udW0AwnBudW0AynBudW0AynBudW0AynNhbHQA0HNhbHQA0HNhbHQA0HNzMDEA0HNzMDEA0HNzMDEA0HNzMDIA2HNzMDIA2HNzMDIA2HNzMDMA3nNzMDMA3nNzMDMA3nRudW0A5HRudW0A5HRudW0A5AAAAAEACQAAAAEABwAAAAEACAAAAAIAAgADAAAAAQAEAAAAAgAAAAEAAAABAAAAAAABAAEAAAACAAUABgAKABYAPAB8AJQAzADgAO4BAgEuAVAAAQAAAAEACAACABAABQORA5IDkwOUA5UAAQAFAEoA3wDhAOMA5QABAAAAAQAIAAIALgAUACwAjgCPAJAAkQDqAOwA7gDwAPIA9AFaAWcBdwGhAaICyQLYA0UDRwACAAEDlgOpAAAAAQAAAAEACAABAAYDcAACAAEAEwAcAAAAAQAAAAEACAACABoACgODA4UDhgOHA4gDiQOKA4sDjAOEAAIAAwATABMAAAAVABwAAQOCA4IACQABAAAAAQAIAAEABgNuAAEAAQAUAAEAAAABAAgAAQA8/JAAAQAAAAEACAABAAb8kgABAAEDggABAAAAAQAIAAIAGgAKABMDggAVABYAFwAYABkAGgAbABwAAgABA4MDjAAAAAEAAAABAAgAAgAOAAQDjwOQASABIQABAAQBJAElAUkBSgAEAAAAAQAIAAEANgABAAgABQAMABQAHAAiACgCXgADAEkATwJdAAMASQBMA40AAgBJAjUAAgBPAjQAAgBMAAEAAQBJAAA=");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZm9udHMvT3BlblNhbnMtUmVndWxhci50dGY/MDg1YSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFlLDhFQUFlLG91OEgiLCJmaWxlIjoiNS5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiZGF0YTpmb250L3R0ZjtiYXNlNjQsQUFFQUFBQVJBUUFBQkFBUVIwUkZSZ3Q4RE5RQUFYZDBBQUFBTGtkUVQxTUFHUUFNQUFGM3BBQUFBQkJIVTFWQzQ3TXB1QUFCZDdRQUFBTHVUMU12TXFFMm5za0FBVWRBQUFBQVlHTnRZWEN1dS9YN0FBRkhvQUFBQTRoamRuUWdEMDBZcEFBQlUrZ0FBQUNpWm5CbmJYNWh0aEVBQVVzb0FBQUh0R2RoYzNBQUZRQWpBQUYzWkFBQUFCQm5iSGxtZERpWlN3QUFBUndBQVMrMGFHVmhaQUs2WTNBQUFUaElBQUFBTm1ob1pXRU56QWx6QUFGSEhBQUFBQ1JvYlhSNDZEVTgzUUFCT0lBQUFBNmFiRzlqWVNrVTNQRUFBVER3QUFBSFZtMWhlSEFGUXdJS0FBRXcwQUFBQUNCdVlXMWxXNUtBSHdBQlZJd0FBQVBTY0c5emRIKzRDVzhBQVZoZ0FBQWZBM0J5WlhCRHQ1YWtBQUZTM0FBQUFRa0FBZ0RCQUFBRUNnVzJBQU1BQndBVnR3UURCUUlFQXdjQUFDOHlMek1CTHpNdk16RXdFeUVSSVRjaEVTSEJBMG44dDJnQ2VmMkhCYmI2U21nRTVnQUNBSmovNHdHSkJiWUFBd0FPQUN0QUZBTUpDUUlFQkE4UUFRRU1BZ3dHVDFrTUZnSURBRDgvS3hFU0FEa1lMeEVTQVRrUk16TVJNekV3QVNNRE13TTBNeklXRlJRR0l5SW1BVVpwTTgvaGVEby9RRGswUkFHVEJDUDZ0SWhHUWtCSFB3QUFBZ0NGQTZZQ3NBVzJBQU1BQndBZlFBMEFBd2NFQXdRSUNRWUNCd01EQUQ4enpUSVJFZ0U1T1JFekVUTXhNQUVESXdNaEF5TURBVDhvYVNrQ0t5bG9LUVcyL2ZBQ0VQM3dBaEFBQUFJQU13QUFCUFlGdGdBYkFCOEFtVUJWQ0I4Y0ZRUVVDUkVNREFrU0R3NExCQW9URXhRV0hSNEhCQVlYQkFFQUdRUVlCUVVHRkFZS0lRTWFGd01ZQ2hnZ0lRZ0VEQTBNVGxrY0FRMGZBQkFSRUU1WkdSVVJUdzBCVHhFQkRSRU5FUVVYRXdNS0JRQXZNejh6RWprNUx5OWRYUkV6TXlzUkFETXpFVE16S3hFQU16TVJFZ0U1T1JFWE14RVNPVGtSTXhFU0Z6a1JFaGM1RVRNUkVoYzVNaklSTXhFU0Z6a3hNQUVESVJVaEF5TVRJUU1qRXlFMUlSTWhOU0VUTXdNaEV6TURJUlVCSVJNaEE5VkNBUnYrelZTSlZQN1JVb2hRL3ZvQkgwVCs2d0VyVW90U0FURlVobFFCQ1B6bEFTOUMvdEVEZy82c2dmNVNBYTcrVWdHdWdRRlVmd0cwL2t3QnRQNU1mLzZzQVZRQUF3Q0QvNGtFREFZU0FDQUFKZ0F0QUdaQU5TY1JKUjBYQkFRcUZBMEZJUUFBR1FVUkNRVXVMeVVOQmcxTldRTUdKQTRxRGt4WkhTb3JIQlFjVFZrWEtoUUdGQVlVQlJZRkFDOHZFams1THk4U09USXJFUUF6RVRNckVRQXpFVE1yRVFBekVSSUJGemtSTXhFek16TXpFVE16TXhFek1UQUJGQVlIRlNNMUlpWW5OUllXTXhFbUpqVTBOamMxTXhVV0Z3Y21KeEVlQWdjMEppY1JOZ0VVRmhjUkJnWUVETXkzZ1hEU1ExUFpXYzJseTZlQnVLczBsWnFkbkVxcVdZRFovZDFhYjJObUFjR0lzUmZvM3lNZm5DVXZBYmhCcklpRHFCSzJ0QVZGZ3pzTC9rNHlYM3RsU0Zrcy9uc2VBd2RNWENrQmd4QmRBQUFGQUdqLzdBWXRCY3NBQ1FBVkFDRUFMUUF4QUVWQUpBQVFCUW9XS0J3aUlpNG9DakFRQmpJekF3MGZLdzByRFNzd01RWXdHQmtsR1FjVEJ3QS9Nejh6UHo4U09Ua3ZMeEV6RVRNUkVnRVhPUkV6RVRNUk14RXpNVEFURkJZek1oRVFJeUlHQlJRR0l5SW1OVFEyTXpJV0FSUVdNekkyTlRRbUl5SUdCUlFHSXlJbU5UUTJNeklXQVFFakFmSktVNlNrVTBvQnlwbVVqSnVWa3BHY0FhWktWRlJRVUZSVVNnSExtWlNPbVpXU2pwLysvdnpWa3dNckJBS3FxZ0ZVQVZLb3F1VHA3dC9qNXU3ODI2dXBwNjJycGFXcjQrbnUzdVBtNndNZytrb0Z0Z0FBQXdCeC8rd0Ywd1hOQUFzQUZRQTFBRkZBTUJNV0FCMEdJeW9yTGlzdEl3NG1HUjBXQ1RZM013eEpXVE1URHljdERqQUZMd01aSmdNcUtpQXZFaUFKU2xrZ0JBQS9Ld0FZUHhJNUx4YzVFaGM1UHlzUkVnRVhPUkV6RVRNUk14RXpNVEFCRkJZWE5qWTFOQ1lqSWdZVE1qY0JEZ0lWRkJZbE5EWTNMZ0kxTkRZek1oWVZGQVlIQVRZMk56TUNCd0VqSndZR0l5SW1BWjVJVjRGbFoxWlpiNXZ4bi81TGIxd3NtLzY1aTdSVlBTVEVyNks2aUowQmx6aERGNmhFaVFFcjVibDI5SmJYN1FTVFJYMVlTMzlUVFdGZys1MmFBYWhFV1daQmRZbjZnc2htWDJKcU9aYW9wNVZydFYzK2VUNm5ZLzdpbFA3ZHNtcGMxQUFBQVFDRkE2WUJQd1cyQUFNQUZMY0FBd01FQlFJREF3QS96UkVTQVRrUk16RXdBUU1qQXdFL0tHa3BCYmI5OEFJUUFBQUJBRkwrdkFJaEJiWUFEUUFjUUF3SEFBb0VBQVFPRHdzbkF3TUFQejhSRWdFNU9SRXpFVE14TUJNUUVqY3pCZ0lWRkJJWEl5WUNVcHVTb3BDUmxJdWdrNW9DTVFFSkFjNnV3ZjR5OVBEK05yMnFBY1lBQUFFQVBmNjhBZ3dGdGdBTkFCeEFEQVFLQndBS0FBNFBDZ01FSndBL1B4RVNBVGs1RVRNUk16RXdBUkFDQnlNMkVqVTBBaWN6RmhJQ0RKdVNvSXVVa1pDaWs1b0NNZjc1L2pxb3ZBSEw4UFFCenNHdi9qRUFBUUJXQW44RURnWVVBQTRBTUVBYkF3VUVBUWNOQ2drTENROFFCQW9CRFFJTURBMEtCd1FHQ0E0QUFEL0VNaGM1RVRNUk14RXpFUklCRnpreE1BRURKUmNGRXdjREF5Y1RKVGNGQXdLUkt3R09HdjZEK0t5d29MRHkvb2NkQVljckJoVCtkVysySC82NlhnRnEvcFplQVVZZnRtOEJpd0FBQVFCb0FPTUVLUVREQUFzQUtFQVRBQVFFQ1FVRkRBMERCd2dIVUZrQUR3Z0JDQUF2WFRNckVRQXpFUklCT1JFek14RXpNVEFCSVJVaEVTTVJJVFVoRVRNQ2pRR2MvbVNML21ZQm1vc0RGNHIrVmdHcWlnR3NBQUVBUC83NEFXMEE3Z0FJQUJHMUJRQUpDZ1VBQUMvTkVSSUJPVGt4TUNVWEJnSUhJellTTndGZUR4cGlOWDBiUVEzdUYyVCs5M0pvQVRKY0FBRUFWQUhaQWo4Q2NRQURBQkcxQWdBRkJBQUJBQzh6RVJJQk9Ua3hNQk0xSVJWVUFlc0IyWmlZQUFFQW1QL2pBWWtBOGdBTEFCaEFDd1lBQUF3TkNRTlBXUWtXQUQ4ckVSSUJPUkV6TVRBM05EWXpNaFlWRkFZaklpYVlQVGs2UVVJNU0wTnFRMFZGUTBGR1B3QUFBUUFVQUFBQzJ3VzJBQU1BRTdjQ0FBUUZBd01DRWdBL1B4RVNBVGs1TVRBQkFTTUJBdHY5MzZZQ0lRVzIra29GdGdBQ0FHYi83QVF0QmMwQUN3QVhBQ2hBRkJJQURBWUFCaGtZQ1JWTFdRa0hBdzlMV1FNWkFEOHJBQmcvS3hFU0FUazVFVE1STXpFd0FSQUNJeUlDRVJBU016SVNBUkFTTXpJU0VSQUNJeUlDQkMzdjl1ejI3dlR1OS96aGxxU21sWldtcEpZQzNmNkYvb29CZndGeUFYNEJjdjUrL3BMK3dmN2RBU2NCT3dFN0FTWCszd0FCQUx3QUFBTExCYllBQ2dBa1FCQUpBQUVJQVFzTUJBa0hCd0VKQmdFWUFEOC9Famt2RWprUkVnRTVPUkV6TXpFd0lTTVJORGNHQmdjbkFUTUN5NklJRlRUVVdBR0RqQVFTZ25RVkxxeHlBU3NBQVFCa0FBQUVKUVhMQUJrQUswQVhHQUVIRXdBVERnRUVHaHNRQ2t0WkVBY0JHRXhaQVJnQVB5c0FHRDhyRVJJQkZ6a1JNeEV6TVRBaElUVUJQZ0kxTkNZaklnWUhKell6TWhZVkZBSUhBUlVoQkNYOFB3R0JzSEE0am41Ym8yUll5dTdPNnB6Vy9zQUM4SThCZzdLWWtGTjFpVHhQY2FqVHNvdis4TkQreHdnQUFBRUFYdi9zQkJzRnl3QW5BRU5BSkJzQUV3Y0hBQU1XSWcwR0tDa0RGeFlYRmt0WkZ4Y0tKU1VlUzFrbEJ3b1JTMWtLR1FBL0t3QVlQeXNSRWdBNUdDOHJFUklBT1JFU0FSYzVFVE1STXpFd0FSUUdCeFVXRmhVVUJDRWlKaWMxRmhZeklCRVFJU00xTXpJMk5UUW1JeUlHQnljMk5qTXlGZ1B1blpDd3F2N2UvdlYwd1Z0ZjEyQUJlLzVla0pLcnlKTitZS3B0VkZycmd0WHNCRjZNc2g0SUZyU1MwZUVqTEo0dk1RRXBBUXFQbDRacmVqUkdjRWRSd3dBQUFnQXJBQUFFYWdXK0FBb0FFZ0E4UUI0U0JRa0NBZ3NIQXdBREJRTVRGQUVGRWdWTVdRa1BCeElTQXdjR0F4Z0FQejhTT1M4U09UTXJFUUF6RVJJQkZ6a1JNek16RVRNUk16RXdBU01SSXhFaE5RRXpFVE1oRVRRM0l3WUhBUVJxMlovOU9RSzJzTm4raUFvSU1DcitOd0ZRL3JBQlVKRUQzZndwQWVhUHRHQS8vWFlBQVFDRi8rd0VIUVcyQUJvQU9rQWZEd01aRkFnVUZ3TUVIQnNBRVV0WkFBQUdGUlVZVEZrVkJnWU1TMWtHR1FBL0t3QVlQeXNSRWdBNUdDOHJFUklCRnprUk14RXpNVEFCTWdRVkZBQWpJaWMxRmhZek1qWTFFQ0VpQnljVElSVWhBellDTGVjQkNmN2YvdmVDUnRCbHNNUCtpVitmVmpjQzEvMjNKWE1EZmVYSDQvNytUNkF0TTZhZEFUSWROd0tzbWY1SkZ3QUFBZ0IxLyt3RUx3WExBQllBSkFCRVFDTWFFUXNoSVFBQUJoRURKaVVNQ3c0ZFRWa0xEZzRVQXhRWFMxa1VHUU1JVFZrREJ3QS9Ld0FZUHlzUkVnQTVHQzg1S3hFQU14RVNBUmM1RVRNUk14RXpNVEFURUFBaE1oY1ZKaU1pQWdNek5qTXlGaFVVQWlNaUFBVXlOalUwSmlNaUJnWVZGQllXZFFGUEFVaHhRVTFqNi9nTURHN3V4ZVA1MU9QKzlnSHJqcDJTa1ZxV1dWQ1RBbkVCcndHckU0OFovdHYreHF6dXpPVCsrd0ZWeUxPcGthWktna1puc21nQUFRQmVBQUFFS3dXMkFBWUFIMEFRQVFVRkFBSURCd2dEQWt4WkF3WUFHQUEvUHlzUkVnRVhPUkV6TVRBaEFTRTFJUlVCQVIwQ1h2empBODM5cWdVZG1ZWDZ6d0FEQUdqLzdBUXBCY3NBRmdBaUFDNEFUVUFwRnc4bUZDd0RIUWtKQXdZUkZBOEdMekFHRVNrZ0tTQkxXU2twREFBTUdrMVpEQmtBSTAxWkFBY0FQeXNBR0Q4ckVSSUFPUmd2S3hFU0FEazVFUklCRnprUk14RXpFVE1STXpFd0FUSVdGUlFHQnhZV0ZSUUdJeUltTlRRbEppWTFORFlERkJZek1qWTFOQ1luQmdZQklnWVZGQllYTmpZMU5DWUNTTWpxaHBPeWx2N2Q2dndCTW9wNDYzZW5sNVdtbk1LVmhnRTZmWTUybjQ5M2tRWEx1cVJzc2tsVnUzdTIyYzI4KzR4T3RYQ2Z2ZnVtZUlhTWVtR1hSMENiQTJkNFpGeUVRanlLWEdWM0FBQUNBR3IvN0FRbEJjc0FGd0FsQUVGQUloc1JJZ29LQUFBRUVRTW1KdzRlVFZrTEZBNE9BaFFVR0V0WkZBY0NCMDFaQWhrQVB5c0FHRDhyRVJJQU9SZ3ZFamtyRVJJQkZ6a1JNeEV6RVRNeE1BRVFJU0luTlJZek1oSVRJd1lHSXlJbU5UUVNNeklXRWdFaUJoVVVGak15TmpZMU5DWW1CQ1g5YUhSRVVHYnc5UXNNTjdaeXd1VC8wSlhmZVA0VWo1eVFrMXVaV0ZLVEEwYjhwaFNQR2dFcEFUTlRWK2pRNUFFSW1mN2JBVEM0cEpDbFNvQkdhYkptQUFBQ0FKai80d0dKQkdRQUN3QVZBQ2hBRkJBR0Jnd0FBQllYRGhOUFdRNFFDUU5QV1FrV0FEOHJBQmcvS3hFU0FUa1JNek1STXpFd056UTJNeklXRlJRR0l5SW1FVFF6TWhVVUJpTWlKcGc5T1RwQlFqa3pRM1o3UWprelEycERSVVZEUVVZL0E3dUhoMEZHUHdBQ0FELysrQUdGQkdRQUNBQVNBQ0pBRUFFTkRRVUpDUlFUQ3hCUFdRc1FCUUFBTDgwL0t4RVNBVGtSTXpNUk16RXdKUmNHQWdjak5oSTNBelF6TWhVVUJpTWlKZ0ZlRHhwaU5YMGJRUTBWZDN0Q09Ubzk3aGRrL3ZkeWFBRXlYQUx2aDRkQlJrWUFBQUVBYUFEeUJDa0UyUUFHQUJWQUNRUUFCUUVFQndnREFBQXZMeEVTQVJjNU1UQWxBVFVCRlFFQkJDbjhQd1BCL1BJRER2SUJwbUlCMzVYK2pmNjRBQUFDQUhjQndRUVpBK01BQXdBSEFDcEFGUWNDQkFBQ0FBa0lCQVZRV1FRQkFGQlpEd0VCQVFBdlhTc0FHQzhyRVJJQk9Ua1JNeEV6TVRBVE5TRVZBVFVoRlhjRG92eGVBNklEV29tSi9tZUppUUFBQVFCb0FQSUVLUVRaQUFZQUZVQUpCUUVDQUFRSENBWURBQzh2RVJJQkZ6a3hNQk1CQVRVQkZRRm9Bdy84OFFQQi9EOEJpUUZHQVhXVi9pRmkvbG9BQUFJQUcvL2pBemtGeXdBYkFDWUFPVUFkSVJ3YkFBY1RFd0FjRGdRbktBQUFKQkFrSGs5WkpCWVFDa2xaRUFRQVB5c0FHRDhyRVJJQU9SZ3ZFUklCRnprUk14RXpFVE14TUFFMU5EWTNOalkxTkNZaklnWUhKell6TWhZVkZBWUdCd1lHRlJVRE5ETXlGaFVVQmlNaUpnRWhTR0tJUjRON1Q1WmhPNzNPdjlRblRINWxRYko0T2o5QU9UUkVBWk0yZFpkVWMzUlNabThsTVlkanZLdEpiMk51Vm5KZklmN1hpRVpDUUVjL0FBSUFlZjlHQnJnRnRBQTFBRDhBUlVBaUl5NDJEanNIRkJzQUFDa1VEaTRGUUVFWU9EZ0VQUWdSQ3hFTEVTc2ZNZ01tS3dBdk16OHpFams1THk4U09USXpNeEV6RVJJQkZ6a1JNeEV6TXhFekVUTXhNQUVVQmdZaklpWW5Jd1lHSXlJbU5UUTJNeklXRndNVkZETXlOalUwQWlRaklnUUNGUkFBSVRJM0ZRWWpJQUFSRUJJa0lUSUVFZ0VVTXpJVEV5WWpJZ1lHdUZpZ2FGWjJDd2dvbFdhV3FlekFSS3hGR1lWYmNwVCs3N0hmL3JhdUFVSUJMOUxpd1BUK2xmNXYxZ0dNQVFEWEFVKzMrL2JEenhJT1NGV0Nrd0xaanV5Q2FGRlhZczJ3elA4WkZ2NHFGckxYckxVQkVKTzUvcW5oL3MvK3VGYUZWQUdQQVdZQkJBR1czN1grcy82ay9nRTVBUVVVdEFBQ0FBQUFBQVVRQmJ3QUJ3QU9BRGxBSGdJT0N3Z0JCUUFEQUFjREJBY0VFQThPQWtsWkN3VU9EZ1FGQXdBRUVnQS9NejhTT1M4U09Tc1JFZ0U1T1JFekVUTVJFaGM1TVRBaEF5RURJd0V6QVFFREppY0dCd01FWUxiOXRyU3NBa0tQQWovK1phb2hJeFlwckFIUi9pOEZ2UHBFQW1vQnhWWjlZSFArT3dBREFNa0FBQVMrQmJZQURnQVhBQ0FBU1VBbUV3UWRDZzhaR1E0S0JBY09CQ0VpQ0E4WUR4aEtXUThQRGdBT0dVcFpEaElBRjBwWkFBTUFQeXNBR0Q4ckVSSUFPUmd2S3hFU0FEa1JFZ0VYT1JFekVUTVJNeEV6TVRBVElTQUVGUlFHQnhVRUVSUUVJeUVUSVRJMk5UUW1JeU1SRVNFeU5qVTBKaVBKQVowQkl3RUVrWXNCVGY3Mzd2NENxZ0VZdEo2d3dQb0JNYkd6dDdzRnRxNjhncWtaQ2puKzI4VGNBMFJ4aG50dC9aSDkzWW1TaUlBQUFBRUFmZi9zQk04Rnl3QVdBQ1pBRkFNT0ZBa09BeGNZRWdCSldSSUVDd1pKV1FzVEFEOHJBQmcvS3hFU0FSYzVFVE14TUFFaUFCRVFBRE15TnhVR0l5QUFFVFFTSkRNeUZ3Y21BenZ4L3VrQkRmbVp4SmpmL3IzK29ha0JQOWptckVpbUJUUCt2LzdwL3VIK3h6ZVZPUUdJQVduaUFWUzRWSkpPQUFBQ0FNa0FBQVZZQmJZQUNBQVJBQ2hBRkE0RUNRQUVBQklUQlExS1dRVURCQTVLV1FRU0FEOHJBQmcvS3hFU0FUazVFVE1STXpFd0FSQUFJU0VSSVNBQUF4QUFJU01STXlBQUJWaitkLzZQL21zQndBRlZBWHEwL3VIKzVmZlBBVEFCTWdMcC9wYitnUVcyL29iK3B3RWVBU0w3Y0FFckFBQUJBTWtBQUFQNEJiWUFDd0E2UUI4R0Nnb0JCQUFJQVFRTURRWUpTVmtHQmdFQ0FnVkpXUUlEQVFwSldRRVNBRDhyQUJnL0t4RVNBRGtZTHlzUkVnRVhPUkV6RVRNeE1DRWhFU0VWSVJFaEZTRVJJUVA0L05FREwvMTdBbDc5b2dLRkJiYVgvaW1XL2VZQUFRREpBQUFEK0FXMkFBa0FNa0FhQmdBQUFRTUlBUU1LQ3dZSlNWa0dCZ0VDQWdWSldRSURBUklBUHo4ckVSSUFPUmd2S3hFU0FSYzVFVE1STXpFd0lTTVJJUlVoRVNFVklRRnpxZ012L1hzQ1h2MmlCYmFYL2VtWEFBQUJBSDMvN0FVOUJjc0FHd0E2UUI4VUNCa0NBZzRiQ0FRY0hRQWJTVmtBQUFVTURCRkpXUXdFQlJkSldRVVRBRDhyQUJnL0t4RVNBRGtZTHlzUkVnRVhPUkV6RVRNeE1BRWhFUVlHSXlBQUVUUVNKRE15RndjbUl5QUFFUkFBSVRJM0VTRURUQUh4ZFBDZS9yVCtqcmNCV09mcXlrTEd0LzcxL3RRQklRRVltSkgrdVFMKy9Ua2xKZ0dMQVdUa0FWZTFWcFpVL3NMKzV2N1kvczRqQWNJQUFRREpBQUFGSHdXMkFBc0FNMEFaQ1FFQkFBZ0VCQVVBQlEwTUNBTkpXUWdJQlFvR0F3RUZFZ0EvTXo4ekVqa3ZLeEVTQVRrNUVUTVJNeEV6RVRNeE1DRWpFU0VSSXhFekVTRVJNd1VmcXZ6K3Fxb0RBcW9Dc1AxUUJiYjlrZ0p1QUFBQkFGUUFBQUpXQmJZQUN3QTNRQndGQVFvRENBQUFBd0VEREEwSkJBWUVTbGtHQXdvREFRTktXUUVTQUQ4ckVRQXpHRDhyRVFBekVSSUJGemtSTXhFekVUTXhNQ0VoTlRjUkp6VWhGUWNSRndKVy9mNnNyQUlDckt4aUl3U3FKV0ppSmZ0V0l3QUIvMkQrZndGb0JiWUFEUUFkUUEwTENBZ09Ed2tEQUFWSldRQWlBRDhyQUJnL0VSSUJPUkV6TVRBRElpYzFGak15TmpVUk14RVVCZ3hlTmtkTlkyZXF3UDUvRzVFVWVIRUZ0dnBZdnRFQUFBRUF5UUFBQk9rRnRnQUxBQ3BBRlFnRUJBVUZBZ3NLQUFVTkRBSUlCUWtHQXdFRkVnQS9Nejh6RWprNUVSSUJGemtSTXhFek1UQWhJd0VIRVNNUk14RUJNd0VFNmNqOTY1bXFxZ0tYeWYyMEFzV0kvY01GdHYwckF0WDloUUFCQU1rQUFBUDRCYllBQlFBZlFBNERBQUFFQmdjQkF3QURTVmtBRWdBL0t3QVlQeEVTQVRrNUVUTXhNRE1STXhFaEZjbXFBb1VGdHZya21nQUJBTWtBQUFaeEJiWUFFd0F5UUJnSUJRVUdDdzRPRFFZTkZCVUJDaEVEQmdzSEF3NEFCaElBUHpNelB6TVNGemtSRWdFNU9SRXpFVE1STXhFek1UQWhBU01XRlJFakVTRUJNd0V6RVNNUk5EY2pBUU5RL2hBSURwMEJBQUhQQ0FIVC9xb09DUDRNQlJDYTFQeGVCYmI3U2dTMitrb0RycUsrK3ZJQUFRREpBQUFGUHdXMkFCQUFMa0FWQ1FZR0J3RVBEd0FIQUJFU0N3TUhEd2dEQVFjU0FEOHpQek1TT1RrUkVnRTVPUkV6RVRNUk14RXpNVEFoSXdFakZoVVJJeEV6QVRNbUFqY1JNd1Uvd3Z6aENCQ2R3QU1kQ0FJT0FwOEV5OWkwL01FRnR2czZHd0VsUHdOSEFBQUNBSDMvN0FXK0JjMEFDd0FYQUNoQUZCSUFEQVlBQmhrWUNSVkpXUWtFQXc5SldRTVRBRDhyQUJnL0t4RVNBVGs1RVRNUk16RXdBUkFBSVNBQUVSQUFJU0FBQVJBU016SVNFUkFDSXlJQ0JiNytuZjdFL3IzK29RRmdBVVFCT3dGaSszUDk4ZlA0OS9Mei9RTGQvcUgrYmdHTEFXZ0JaUUdKL25EK29QN1gvczBCTWdFcUFTY0JNZjdOQUFJQXlRQUFCR2dGdGdBSkFCSUFORUFhQ2dVRkJnNEFCZ0FURkFvRVNsa0tDZ1lIQnhKS1dRY0RCaElBUHo4ckVSSUFPUmd2S3hFU0FUazVFVE1STXhFek1UQUJGQVFoSXhFakVTRWdBVE15TmpVMEppTWpCR2orMGY3bXJLb0Jld0lrL1F1WjRzcSt5YjRFRE43di9jRUZ0djBia3FHUmpnQUFBZ0I5L3FRRnZnWE5BQThBR3dBMFFCc1FDaFlBQUFRRENnUWNIUU1OQncwWlNWa05CQWNUU1ZrRkJ4TUFQOFlyQUJnL0t4RVNBRGtSRWdFWE9SRXpFVE14TUFFUUFnY0JJd0VISUFBUkVBQWhJQUFCRUJJek1oSVJFQUlqSWdJRnZ1TE9BVnozL3VNMy9yMytvUUZnQVVRQk93RmkrM1A5OGZQNDkvTHovUUxkL3VmK2pFTCtsZ0ZLQWdHTEFXZ0JaUUdKL25EK29QN1gvczBCTWdFcUFTY0JNZjdOQUFJQXlRQUFCTThGdGdBTUFCVUFTRUFsRFFFQkFnd0pFUWNMQ2dvSENRSUVGaGNKRFFBTkFFcFpEUTBDQXdNVlNWa0RBd3NDRWdBL016OHJFUklBT1Jndkt4RVNBRGtSRWdFWE9SRXpFVE1STXhFekVUTXhNQUVSSXhFaElBUVZFQVVCSXdFbE16STJOVFFtSXlNQmM2b0JrUUVOQVFIKzJnR055ZjZlL3MvcHRLaXJ2ZDBDWVAyZ0JiYk96LzdlWnYxdkFtQ1NqNCtSZ0FBQkFHci83QVFDQmNzQUpBQTBRQnNlRXd3QUFCZ1RCUVFsSmd3ZUF4WVdHMGxaRmdRRENVbFpBeE1BUHlzQUdEOHJFUklBT1RrUkVnRVhPUkV6RVRNeE1BRVVCQ01nSnpVV0ZqTXlOalUwSmlZbkppWTFORFl6TWhjSEppTWlCaFVVRmhZWEZoWUVBdjdvOFA3OGpGclVhS3FzUFkrU3pLLyswZHEzTmJXcmg1ZzRoWW5tclFHRndkaERwQ1lzZ1hOTVlWSTBTY2locWNoUWxFeDBaMHhoVVRGU3ZBQUFBUUFTQUFBRVdnVzJBQWNBSkVBU0FBRUZBUU1EQ0FrSEF3UURTVmtFQXdFU0FEOC9LeEVBTXhFU0FSYzVFVE14TUNFakVTRTFJUlVoQW91cS9qRUVTUDR4QlIrWGx3QUFBUUM2Lyt3RkdRVzJBQkVBSlVBUkVBRUtCd0VIRXhJUkNBTUVEVWxaQkJNQVB5c0FHRDh6RVJJQk9Ua1JNeEV6TVRBQkVSUUFJU0FBTlJFekVSUVdNekkyTlJFRkdmN1MvdmorK1A3ZnFzakN1Y2dGdHZ4Tyt2N2lBU0Q4QTY3OFJyZkV4YmdEdUFBQkFBQUFBQVREQmJZQUNnQWFRQXNCQkF3TENBTUFCQU1ERWdBL1B6TVNPUkVTQVRrNU1UQUJNd0VqQVRNQkZoYzJOd1FNdC8zeHFQMzB0QUZRT2lJa09nVzIra29GdHZ4T281cWlvUUFCQUJzQUFBZE1CYllBR1FBa1FCQVpDaHNhRlE0T0JRa1lFUW9EQVFrU0FEOHpQek16RWprNUVUTVJFZ0U1T1RFd0lTTUJKaVluQmdjQkl3RXpFeFlYTmpjQk13RVdGelkzRXpNRnhhaisyUlUwQVJZdy91S28vbnUwNXpBV0d6VUJCclFCRXpBaEV6WG10QVBUUWNZVWhKMzhNd1cyL0htK21yZXZBM244ZjV2RGpzd0RoUUFBQVFBSUFBQUVsZ1cyQUFzQUkwQVNCQVlGQ3dvQUJnME1BZ2dFQ1FZREFRUVNBRDh6UHpNU09Ua1JFZ0VYT1RFd0lTTUJBU01CQVRNQkFUTUJCSmJCL25mK2NMUUI1djQ3dkFGckFXNjEvanNDZy8xOUF2d0N1djI5QWtQOVRBQUFBUUFBQUFBRWV3VzJBQWdBSUVBUEJBVUNCUWNEQ1FvQUJRRUhBd1VTQUQ4L014STVFUklCRnprUk16RXdBUUV6QVJFakVRRXpBajBCaHJqK0dLeitHYm9DMndMYi9JSDl5UUl2QTRjQUFRQlNBQUFFUHdXMkFBa0FLMEFYQ0FFREJ3QUhCQUVFQ2dzRkJFbFpCUU1CQ0VsWkFSSUFQeXNBR0Q4ckVSSUJGemtSTXhFek1UQWhJVFVCSVRVaEZRRWhCRC84RXdNSS9SQUR2L3o0QXg2RkJKaVpoZnRwQUFFQXB2NjhBbThGdGdBSEFDQkFEZ1lCQkFBQkFBZ0pCUUlEQmdFbkFEOHpQek1SRWdFNU9SRXpFVE14TUFFaEVTRVZJUkVoQW0vK053SEovdDhCSWY2OEJ2cU4raUVBQUFFQUZ3QUFBdDBGdGdBREFCTzNBd0VFQlFNREFoSUFQejhSRWdFNU9URXdFd0VqQWJvQ0k2Yjk0QVcyK2tvRnRnQUFBUUF6L3J3Qi9BVzJBQWNBSUVBT0F3QUJCZ0FHQ0FrQUJ5Y0RCQU1BUHpNL014RVNBVGs1RVRNUk16RXdGeUVSSVRVaEVTRXpBU0grM3dISi9qZTJCZCtOK1FZQUFBRUFNUUluQkNNRndRQUdBQmhBQ1FBREJ3Z0ZBZ0FFQWdBdkx6TVNPUkVTQVRrNU1UQVRBVE1CSXdFQk1RR3lZd0hkbVA2TS9ySUNKd09hL0dZQzZmMFhBQUgvL1A3RkE1ci9TQUFEQUJHMUFBVUJCQUVDQUM4ekVRRXpFVE14TUFFaE5TRURtdnhpQTU3K3hZTUFBUUdKQk5rREVnWWhBQWtBRTdZQUJBc0tCb0FCQUM4YXpSRVNBVGs1TVRBQkl5WW1KelV6RmhZWEF4SnVRYklveXlCeUxBVFpOTUEvRlVXMU5RQUNBRjcvN0FQTkJGb0FHUUFrQUVkQUpTSUlDeDRlR1JrU0NBTWxKZ0VDQ3g1SFdRSUxDd0FWRlE5R1dSVVFCUnBHV1FVV0FCVUFQejhyQUJnL0t4RVNBRGtZTHprckVRQXpFUklCRnprUk14RXpFVE14TUNFbkl3WUdJeUltTlJBbE56VTBKaU1pQnljMk5qTXlGaFVSSlRJMk5UVUhCZ1lWRkJZRFVpRUlVcU42bzdrQ0U3cHZlb210TTFIQlljUzkvZzZic2FiR3IyMmNaMG1vbXdGTUVBWkVnWHRVZnl3eXJzRDlGSFdxbVdNSEIyMXpXbDRBQWdDdy8rd0VkUVlVQUJNQUh3QkVRQ0lLRnhjUER3d2RBd3dESUNFTkFBd1ZFaEVLRVFZQUJocEdXUVlXQUJSR1dRQVFBRDhyQUJnL0t4RVNBRGs1RVRNWVB6OFJFZ0U1T1JFekVUTVJNeEV6TVRBQk1oSVJFQUlqSWlZbkl3Y2pFVE1SRkFjek5oY2lCaFVVRmpNeU5qVTBKZ0t1Mk8veDFtdXhQQXdqZDZZSUNIVE1xcGFhcXBtV2xnUmEvdG4rOHY3eS90VlBVbzBHRlA2R2YyV2tpOFBuNThmZjBkYlNBQUFCQUhQLzdBT0xCRndBRmdBbVFCUVBBd01WQ1FNWUZ3WU5SbGtHRUFBU1Jsa0FGZ0EvS3dBWVB5c1JFZ0VYT1JFek1UQUZJZ0FSRUFBek1oWVhCeVltSXlBUkZCWXpNamNWQmdKbTd2NzdBUW4xVDU0dE16ZUNNdjZ5bzZDSmtHNFVBU1VCREFFVEFTd2lGNDBXSGY1V3l0ZzdremtBQWdCei8rd0VOd1lVQUJJQUh3QkNRQ0VkQmhjQURnNFJCaEVnSVJJVkR3QUFBUUVNQXdrSkdrWlpDUkFERTBaWkF4WUFQeXNBR0Q4ckVSSUFPVGtSTXhnL1B4RVNBVGs1RVRNUk16TVJNekV3SlNNR0l5SUNFUkFTTXpJWE15Y25FVE1SSXlVeU5qVTFOQ1lqSWdZVkZCWURtZ2x6NWRmdjhOYmZkdzBIQkthSC9wNnFtWnVxa3B1YWs2Y0JKZ0VQQVE4QkxLSlBUUUcrK2V4M3VjNGo2Y2ZqejlMV0FBSUFjLy9zQkJJRVhBQVRBQm9BTzBBZkdBb1hDd01ERVFvREhCc1hDMFpaRnhjQUJnWVVSbGtHRUFBT1Jsa0FGZ0EvS3dBWVB5c1JFZ0E1R0M4ckVSSUJGemtSTXpNUk16RXdCU0lBRVJBQU16SVNGUlVoRmhZek1qY1ZCZ1lESWdZSElUUW1Bbi96L3VjQkJkek84UDBOQmJtb3NhMVluWnlFblE0Q1BZd1VBU2dCQndFSkFUais4ZDVwd2NoS2xDWWhBK1dzbUoybkFBQUJBQjBBQUFNT0JoOEFGQUE1UUIwVURBd1RBZ0lIQXdVREZSWUtEMFpaQ2dBQkJRY0ZSbGtUQnc4REZRQS9Qek1yRVFBekdEOHJFUklCT1RrUk16TVJNek1TT1RFd0FTRVJJeEVqTlRjMUVDRXlGd2NtSXlJR0ZSVWhBcDcrNmFiRXhBRmhWM1VyWUVSZVdnRVhBOGY4T1FQSFN6dzlBWlFqaFI5OWlrY0FBQU1BSi80VUJERUVYQUFxQURjQVFRQnVRRDRyR1RnbERCODlCVEVUQVJNRkFpb2lIQjhsR1FwQ1F4d1BOUTgxUmxrSU8wZFpDaUlJS2c4SUR3Z1dLaW9DUjFrcUR5Zy9SMWtvRUJZdVIxa1dHd0EvS3dBWVB5c0FHRDhyRVJJQU9Ua1lMeThSRWprNUt5c1JFZ0E1RVJJQkZ6a1JNeEV6RVRNUk14RXpNVEFCRlFjV0ZoVVVCaU1pSndZVkZCWXpNeklXRlJRRUlTSW1OVFEyTnlZbU5UUTJOeVltTlRRMk16SVhBUlFXTXpJMk5UUW1JeU1pQmhNVUZqTXlOVFFqSWdZRU1jc2NMTnpBTVN0cVNsckNzci8rM1A3bzErbUFkQ281UUVWVmE5akdWa1grRVphTTBjbHVtTWR4ZmxxQ2RQUDJkWDRFU0drWUkzRkhvY0FJT0ZVdEs1YVB0citna21TU0doTlFOVHhhS2lPb2JMVERGUHNBV1Z4OWExbEZiQU04YzNiczkzNEFBUUN3QUFBRVJBWVVBQllBTTBBWkRnd0lDQWtBRmdrV0Z4Z09DUklTQkVaWkVoQUtBQUFKRlFBL016OC9LeEVTQURrUkVnRTVPUkV6RVRNUk16TXhNQ0VSTkNZaklnWVZFU01STXhFVUJ6TTJOak15RmhVUkE1NTZncTJmcHFZSUNqRzFkTW5KQXNXR2hMelcvY01HRlA0cFZUaFBXNy9RL1RVQUFBSUFvZ0FBQVdZRjN3QURBQThBSTBBUkNnQUFCQUVCRUJFTkIwaFpEUUlQQVJVQVB6L09LeEVTQVRrUk16TVJNekV3SVNNUk13TTBOak15RmhVVUJpTWlKZ0ZXcHFhME9Db29Pam9vS2pnRVNBRXBPVFUyT0RnM053QUFBditSL2hRQlpnWGZBQXdBR0FBc1FCWVRDd3NOQ0FnWkdoWVFTRmtXUUFrUEFBVkdXUUFiQUQ4ckFCZy9HczRyRVJJQk9SRXpNeEV6TVRBVElpYzFGak15TmpVUk14RVFBelEyTXpJV0ZSUUdJeUltSzE4N1JVTk9TYWEwT0Nvb09qb29LamorRkJtSEZGVlhCUHo3RVA2OEIxMDVOVFk0T0RjM0FBRUFzQUFBQkIwR0ZBQVFBRFpBR3hBT0Nnb0xDd2dHQkFVSUJCRVNEQUFBRUJBSUNBTUhDeFVERHdBL1B6TVNPUzg1RVRNL0VSSUJGemtST1JFekVUTXpNVEFCTmpjQk13RUJJd0VIRVNNUk14RVVCd0ZVSzFnQllzWCtSQUhieWY1OWZhU2tDQUl4UFdNQmQvNHQvWXNDQm16K1pnWVUvTWMzY3dBQkFMQUFBQUZXQmhRQUF3QVdRQWtBQVFFRUJRSUFBUlVBUHo4UkVnRTVFVE14TUNFakVUTUJWcWFtQmhRQUFRQ3dBQUFHeXdSY0FDTUFSa0FqRlJFUkVnZ0pBQ01KRWlNREpDVWNGaFVWRWhrRURSa05SbGtmR1JBVER3a0FFaFVBUHpNelB6OHpLeEVBTXhFU09SZ3ZNek1SRWdFWE9SRXpFVE1STXhFek1UQWhFVFFtSXlJR0ZSRWpFVFFtSXlJR0ZSRWpFVE1YTXpZMk15QVhNelkyTXpJV0ZSRUdKWEIybTVTbWNIZWNrYWFIR3dndnEyb0JBVThJTWJwM3Vya0N5WU9Ec3JuOW5BTEpnNE83MWYzQkJFaVdVRnE2Vm1TLzB2MDFBQUFCQUxBQUFBUkVCRndBRkFBeFFCZ0FGQXdJQ0FrVUNSWVZEQWtRRUFSR1dSQVFDZzhBQ1JVQVB6TS9QeXNSRWdBNUVSSUJPVGtSTXhFekVUTXhNQ0VSTkNZaklnWVZFU01STXhjek5qWXpNaFlWRVFPZWVvS3NvS2FIR3dnenVISEd5QUxGaG9TNjF2M0JCRWlXVVZtLzB2MDFBQUlBYy8vc0JHSUVYQUFNQUJnQUtFQVVFd0FOQndBSEdoa0tGa1paQ2hBREVFWlpBeFlBUHlzQUdEOHJFUklCT1RrUk14RXpNVEFCRUFBaklpWUNOUkFBTXpJQUFSUVdNekkyTlRRbUl5SUdCR0wrOHU2VDVId0JETzdtQVEvOHZhaWpvNm1wcGFPbUFpWCs5UDdUaWdFQ3JRRU1BU3YrenY3NzB0emIwOUhaMWdBQ0FMRCtGQVIxQkZ3QUZBQWhBRDlBSUJrTEJBY0hDQjhTQ0JJaUl3UUxBQThQRlVaWkR4QUpEd2diQUJ4R1dRQVdBRDhyQUJnL1B6OHJFUklBT1RrUkVnRTVPUkV6RVRNUk16TXpNVEFGSWlZbkl4WVZFU01STXhjek5qWXpNaElSRUFJRElnWUhGUlFXTXpJMk5UUW1BcTVyc1R3TURLYUhGd2hBcW03YTdmSHVxSllDbXFxT29hRVVUMUpnVnY0OUJqU1dXbEQrMXY3ei92TCsxUVBqdXNzbDU4Zm15czNiQUFJQWMvNFVCRGNFWEFBTUFCOEFSRUFpQ2hBZEZnTWFHaGtRR1NBaEdoc1hEeDBlSGhZTkV4TUhSbGtURUEwQVJsa05GZ0EvS3dBWVB5c1JFZ0E1T1JFekdEOC9FUklCT1RrUk14RXpNek1STXpFd0pUSTJOelUwSmlNaUJoVVVGaGNpQWhFUUVqTXlGek0zTXhFakVUUTNJd1lDVHFhWUJaeXBrcHVaZmRUdThOYmhlUWtZZzZZTERYTjNzdE1sNXNyano4L1ppd0VxQVFzQkRRRXVxcGI1ekFIVlpFYW5BQUVBc0FBQUF5Y0VYQUFRQUNwQUZBMEpDUW9LQWhFU0N3OE5BQW9WQUFWR1dRQVFBRDhyQUJnL0Vqay9FUklCT1RrUk14RXpNVEFCTWhjSEppTWlCaFVSSXhFekZ6TTJOZ0trU1RvWFJEU0Z2YWFKRXdnOXJBUmNESm9QMktIOXRBUkl5MnQwQUFFQWF2L3NBM01FWEFBa0FEWkFIQjRUREFBQUdBVVRCQ1VtREI0REZoWWJSbGtXRUFZRENVWlpBeFlBUHlzQUdDOC9LeEVTQURrNUVSSUJGemtSTXhFek1UQUJGQVlqSWljMUZoWXpNalkxTkNZbkxnSTFORFl6TWhjSEppTWlCaFVVRmhZWEZoWURjK1RPMm5wUHRWU0NqRytobVlFLzJyNnhxVHVsaG5aNExXU093NGtCSzVtbVJab29MbE5WUUZzK09WVnNTNGFiU0lkRVNrRXNQamcxUjVBQUFRQWYvK3dDcUFWR0FCWUFORUFiRUJRVUNRc0pFZ01FR0JjS0V4QVRSMWtPUUJBUEJ3QkdXUWNXQUQ4ckFCZy9HczByRVFBekVSSUJGemtSTXhFek1UQWxNalkzRlFZR0l5QVJFU00xTnpjekZTRVZJUkVVRmdJU0xGSVlHMmtxL3NLZG5VWmdBVDcrd2w1MURRZC9EUkVCVHdLTVVFWHEvb0g5ZTJOcUFBQUJBS1QvN0FRNUJFZ0FGQUEwUUJrQkV3Y01EQW9UQ2hVV0RBME5FQWdVRHhBRVJsa1FGZ3NWQUQ4L0t3QVlQek1TT1JFekVSSUJPVGtSTXhFekVUTXhNQUVSRkJZek1qWTFFVE1SSXljakJnWWpJaVkxRVFGTWVvS3NuNmFKR0FrenRYVEl4d1JJL1RtR2hMelZBa0Q3dUpOUlZyN1JBczBBQUFFQUFBQUFCQUlFU0FBTEFCaEFDZ0VLREEwRkNRRVBBQlVBUHo4ek9SRVNBVGs1TVRBaEFUTVRGaGN6TmhJVE13RUJvUDVnc3V4UURnZ0xkY3l5L21BRVNQMTI1RVExQVUwQ01QdTRBQUVBRndBQUJpTUVTQUFjQUN4QUZBa2JIUjRYRmc0TkF3UU5CQWdhRWdrUEFBZ1ZBRDh6UHpNekVqazVFVE1STXpNekVSSUJPVGt4TUNFREppY2pCZ2NESXdFekVoSVhNelkyTnhNekV4WVhNelkyRXpNQkJDL0pFelFJS0I3UHdQN1ZybXB2Q0FnTE1STEp0TVE0RkFnRUk3K3MvdEVDZ3p2UnIxLzlmd1JJL21QK1VFczV0VFVDZGYyTHJIVWtsZ0xjKzdnQUFBRUFKd0FBQkFnRVNBQUxBQ0pBRVFjRkJnQUJCUXdOQ1FNQkNBc1ZCQUVQQUQ4elB6TVNPVGtSRWdFWE9URXdBUUV6QVFFekFRRWpBUUVqQWJqK2c3MEJJUUVndS82REFaRzgvczMreXJ3Q01RSVgvbHdCcFAzcC9jOEJ2UDVFQUFFQUF2NFVCQVlFU0FBVkFDUkFFZ2tQQUFNV0Z3UU5BQTBTUmxrTkd3Z0FEd0EvTWo4ckVSSUFPUkVTQVJjNU1UQVRNeE1XRnpNMk5oTXpBUVlHSXlJbk5SWXpNamMzQXJMd1R4TUlEVlBtc3Y0cFJydUlURW8zUkt0SlBRUkkvWS9XWHpQM0FuejdJTG1iRVlVTXdKd0FBQUVBVWdBQUEyMEVTQUFKQUN0QUZ3Z0JBd2NBQndRQkJBb0xCUVJIV1FVUEFRaEhXUUVWQUQ4ckFCZy9LeEVTQVJjNUVUTVJNekV3SVNFMUFTRTFJUlVCSVFOdC9PVUNWdjNQQXVmOXNnSmRjUU5XZ1lIOHVnQUJBRDMrdkFMQkJiWUFIQUFzUUJVWkdob0xGd0FBRHdjVUF3TUhDd01kSGhNREJDY0FQejhSRWdFWE9SRXpFVE16RVRNUk14RXpNVEFsRkJZWEZTWW1OUkUwSmlNMU5qWTFFVFEyTXhVR0ZSRVVCeFVXRlFIYmRYRyswSDU0Z25UWXR1YmYzd3htWEFLTUFxcWFBUzlvV1kwQ1hHQUJNcHVzaXdiQi90blhKd3duMXdBQkFlNytFQUo3QmhRQUF3QVdRQWtDQXdNRUJRTWJBQUFBUHo4UkVnRTVFVE14TUFFekVTTUI3bzJOQmhUMy9BQUJBRWordkFMTEJiWUFIUUFzUUJVVkJRb1NFZ0laQUIwZERnNFpCUU1lSHhVbkJnTUFQejhSRWdFWE9SRXpFVE1STXpNUk14RXpNVEFCSmpVUk5DYzFNaFlWRVJRV0Z4VWlCaFVSRkFZSE5UWTJOUkUwTmpjQ0N0L2p1Tk4yZ25wK3piNXZkRzV4QWo4bjF3RW53UWFMcnBuK3ptRmJBbzFaYVA3Um1hc0NqQUpjWmdFcGNuZ1VBQUFCQUdnQ1VBUXBBMVFBRndBa1FCRUREeGdaRWd4UVdRTVNEd1lHQUZCWkJnQXZLd0FRR01RdnhDc1JFZ0U1T1RFd0FTSUdCelUyTXpJV0Z4WVdNekkyTnhVR0l5SW1KeVltQVZJMWZ6WmtrRVJ4V1VKaUx6YUFObWFPU0g1SVMxb0N5VU0ybDIwY0pod2JRRG1XYmlFZ0lCZ0FBQUlBbVA2TEFZa0VYZ0FEQUE0QUswQVVBZ1FFQXdrSkR4QUFBQU1NREFaUFdRd1FBeUlBUHo4ckVSSUFPUmd2RVJJQk9SRXpNeEV6TVRBVE14TWpFeFFqSWlZMU5EWXpNaGJiYVRQUDRYazhQRDg1TTBZQ3JQdmZCVXlIUjBBL1NFQUFBUUMrLyt3RDJ3WExBQnNBUGtBZUZnZ05Bd01LQkFBUUVBUUlBeHdkR1FVQ0V3b05BZzBDRFFRTEJ3UVpBRDgvRWprNUx5OFJNek1STXpNUkVnRVhPUkV6RVRNekVUTVJNekV3SlFZSEZTTTFKZ0kxRUNVMU14VVdGaGNISmlNaUJoVVVGak15TndQTGFaT0Z5OEVCaklkTGpqRXhoVzJzb3ArbmpZN3dOZ2JJemlBQkVmb0IvRDZzcEFNaEY0d3owOW5VeXpzQUFRQS9BQUFFUkFYSkFCMEFTRUFtR0JNSkRRMGFGaEVDQ3hZVEJSNGZEQmdaR0U1WkNSa1pFd0FURUV4WkV4Z0FCVXRaQUFjQVB5c0FHRDhyRVJJQU9SZ3ZNeXNSQURNUkVnRVhPUkV6TXhFekVUTXhNQUV5RndjbUl5SUdGUkVoRlNFVkZBWUhJUlVoTlRZMU5TTTFNeEUwTmdLcXZxbzltbzk3ZlFHbS9scEJTZ01iKy92TnhzYmdCY2xVaFUxOGpQN1pmOTFraUN5YWpTLzAzMzhCUExMTkFBQUNBSHNCQmdRWEJLQUFHd0FuQUNCQURSd0FJZzRBRGlncEh4VVZKUWNBTHpNekx6TVJFZ0U1T1JFekVUTXhNQk0wTnljM0Z6WXpNaGMzRndjV0ZSUUhGd2NuQmlNaUp3Y25OeVkzRkJZek1qWTFOQ1lqSWdhNFNvZGVoMmlDZjJhSlg0WktTb05jaVdaL2htU0hYSVZLZ1oxMGRKNmdjblNkQXRONmE0eGNoVWxKaFZ5S2NYYURaNGRjaFVkSmhWeUlhM3h3b0o5eGNxS2tBQUFCQUI4QUFBUnhCYllBRmdCV1FDNFNEZ2NMQ3hBTUJRa0NDUU1NRkE0VkJ4Y1lDZzRPQnc4R0VoSURBQk1WRHhNZkV3SVBFdzhUREFFVkJnd1lBRDgvTXhJNU9TOHZYUkVTT1RJeUVUTVJNek1STXhFU0FSYzVFVE1STXpNUk14RXpNVEFCQVRNQklSVWhGU0VWSVJFakVTRTFJVFVoTlNFQk13SklBWHV1L21BQkJ2N0RBVDMrdzZUK3hBRTgvc1FCQVA1bHNnTGZBdGY4L24rcWYvNzBBUXgvcW44REFnQUNBZTcrRUFKN0JoUUFBd0FIQUNSQUVBSUdCZ01IQndnSkJBTUVBd2NiQUFBQVB6ODVPUzh2RVJJQk9SRXpNeEV6TVRBQk14RWpFVE1SSXdIdWpZMk5qUVlVL1BqK0RmejNBQUlBZS8vNEE1WUdIUUF4QUQwQVEwQW1NZ0FUQmlvZU9Ca1pIZ3dHQUNNR1BqOFZBenMySEMwR0lRa2hKMGRaSVJVSkVFZFpDUUFBUHlzQUdEOHJFUklBRnprUkVnRVhPUkV6RVRNUk14RXpNVEFUTkRZM0ppWTFORFl6TWhZWEJ5WW1JeUlHRlJRV0Z4WVdGUlFHQnhZVkZBWWpJaWMxRmhZek1qWTFOQ1ltSnk0Q054UVdGeGMyTlRRbUp3WUdpMVpPU2xUUHhWNmZZVFZpaDB4MGRIdWF1cFpTU3BucTFOcUFUc0pTaG8wd2JIT09oa0tTaEtjeGlaTzVSRlVES1ZhSkpTaHZWWG1MSFNlREp4czdRRHhVTjBTWGExcU5LVkdTakpsQmxDVXRURWN1T2pvck5GcHlZazFwUFJOUWIxTndPUk5rQUFJQk5RVU9BMmdGMHdBTEFCY0FIa0FNQmdBTUVnQVNHQmtQQXhVSkFDOHp6VElSRWdFNU9SRXpFVE14TUFFME5qTXlGaFVVQmlNaUppVTBOak15RmhVVUJpTWlKZ0UxTlNVbU56Y21KVFVCZlRVbEpUYzNKU1UxQlhFMExpNDBNakV4TWpRdUxqUXlNVEVBQUFNQVpQL3NCa1FGeXdBV0FDWUFOZ0JHUUNjbkZ3TVBMeDhmRkFrUEZ3VTNPQVlNQUJJUERCOE1BZ0FTRUJJQ0RCSU1FaHNySXhNekd3UUFQek0vTXhJNU9TOHZYVjBSTXhFekVSSUJGemtSTXhFekVUTXhNQUVpQmhVVUZqTXlOeFVHQmlNaUpqVTBOak15RndjbUFUUVNKRE15QkJJVkZBSUVJeUlrQWpjVUVnUXpNaVFTTlRRQ0pDTWlCQUlEZlgySGY0TldmVEJsUnNMUTNiK0FkanBzL0pmSUFWN0t5QUZleXNMK290RFAvcUxEYWE0QkxheXVBU3F2cnY3WHNLNysxcThFSTY2YXFLSXRmQlFjOGRqUjlqeDJNLzY0eUFGZXlzaitvc3JGL3FiUXp3RmF4cTMrMDYydUFTbXdyZ0VxcjY3KzF3QUFBZ0JHQXhRQ2NRWEhBQllBSHdBM1FCd1hCaHNLQVFFV0ZoQUdBeUFoSEFvS0Voa1dBQU1RQXdJRERSSWZBRDh6MUYzRU14STVMek1SRWdFWE9SRXpFVE16RVRNeE1BRW5CaU1pSmpVME5qYzNOVFFqSWdjbk5qTXlGaFVSSlJRek1qVTFCd1lHQWhRWVhJeGZiNXFsZFpSa2FDdHloWUtKL2xCd3lXSndad01oVkdGalptWnBCZ1FuaFROZ09HbDUvank4WkxReEJBUTVBQUlBVWdCMUE2b0R2Z0FHQUEwQUtVQVRBd1lLRFFJRUN3a0pCQTBHQkE0UERBVUlBUUF2TXk4ekVSSUJGemtSTXhFekVUTVJNekV3RXdFWEFRRUhBU1VCRndFQkJ3RlNBVlozL3Q4QklYZitxZ0dMQVZoMS91RUJIM1grcUFJbkFaZEYvcUwrb1VjQmx4c0JsMFgrb3Y2aFJ3R1hBQUFCQUdnQkNBUXBBeGNBQlFBYlFBd0NBUVFCQmdjRkJGQlpCUUlBTHk4ckVSSUJPVGtSTXpFd0FSRWpFU0UxQkNtSi9NZ0RGLzN4QVlXS0FQLy9BRlFCMlFJL0FuRUNCZ0FRQUFBQUJBQmsvK3dHUkFYTEFBZ0FGZ0FtQURZQVhVQXpKeGNBRVJFU0JBa3ZIeDhOQ1F3U0Z3WTNPQXdRRUFBQURoTU9FZ2dURHhJZkVnSUFFeEFUQWhJVEVoTWJLeU1UTXhzRUFEOHpQek1TT1RrdkwxMWRFVE1STXhFU09TOHpFVE1SRWdFWE9SRXpFVE1STXhFekVUTXhNQUV6TWpZMU5DWWpJd1VVQmdjVEl3TWpFU01SSVRJV0FUUVNKRE15QkJJVkZBSUVJeUlrQWpjVUVnUXpNaVFTTlRRQ0pDTWlCQUlDMDJ4UVlWWmRhZ0d5VlUzdXFNK0hsQUVGcHB2NzM4Z0JYc3JJQVY3S3d2NmkwTS8rb3NOcHJnRXRySzRCS3ErdS90ZXdydjdXcndMNlUwQkxRWWhRZXg3K2RRRmkvcDREZTRMK3hjZ0JYc3JJL3FMS3hmNm0wTThCV3NhdC90T3RyZ0Vwc0s0QktxK3UvdGNBQWYvNkJoUUVCZ2FUQUFNQUViVUFCUUVFQVFJQUx6TVJBVE1STXpFd0FTRTFJUVFHKy9RRURBWVVmd0FDQUg4RFhBTHVCY3NBREFBWUFDRkFEZzBBRXdZQUJoa2FFQXJBRmdNRUFEOHpHc3d5RVJJQk9Ua1JNeEV6TVRBVE5EWXpNaFlWRkFZR0l5SW1OeFFXTXpJMk5UUW1JeUlHZjdXQ2dyWlNrbFNDdFhOMVVWQnpjVkpUY3dTVGdyYTFnMVNQVkxTRFVuSnhVMVJ4Y2dELy93Qm9BQUVFS1FUREFpWUFEZ0FBQUFjQ0t3QUEvWFFBQVFBeEFrb0NqUVhKQUJnQUkwQVJCeE1YQVFFT0V3QUVHaGtLRUI4WEFTQUFQek0vTXhFU0FSYzVFVE1STXpFd0FTRTFOejRDTlRRbUl5SUdCeWMyTXpJV0ZSUUdCd2NoQW8zOXBPeFpVaUZRUHpSaVJVS0RtSVNUV1pPdUFiZ0NTbWptVm1GTU5rUkZKakpZYjRKd1VKZUtwUUFCQUNFQ09RS05CY2tBSXdBNVFDSVBCUVVBQXhJZUNnWWtKUkpkRTIwVEFrd1RBUXNUR3hNQ0V4TUlHaUVmRFFnaEFEOHpQek1TT1M5ZFhWMHpFUklCRnprUk16RXdBUlFHQnhZVkZBWWpJaWMxRmpNeU5UUWpJelV6TWpZMU5DWWpJZ1lISnpZMk16SVdBbk5TUkxDNHFKaDBrM3ZUNTNWM1oyTlFRMEp3T0VVL2pGNkluUVRuVUdjWEw2S0Fqemg3UktLUmEwOUVQVVFySTFvdE5uY0FBUUdKQk5rREVnWWhBQWtBRTdZSkJBb0xCSUFKQUM4YXpSRVNBVGs1TVRBQk5qWTNNeFVHQmdjakFZa3dieURLTEs1QWJ3VHlQckJCRlVHK05BQUJBTEQrRkFSRUJFZ0FGZ0ExUUJvRkNnb0lFQUFURXhRSUZCZ1hCaFVQRkJzTkFrWlpEUllKRlFBL1B5c0FHRDgvTXhFU0FUazVFVE1STXpNUk14RXpNVEFCRURNeU5qVVJNeEVqSnlNR0l5SW5JeFlWRVNNUk13RlcvcXVmcG9nYUNtL2xsbGdLQ3FhbUFYMysrcjNVQWtEN3VKT25YRlNnL3NBR05BQUJBSEgrL0FSZ0JoUUFEd0FuUUJJRUJRRUFBQVVMQXhBUkNBZ0ZBdzhGQVFVQUx6TS9NeEk1THhFU0FSYzVFVE1STXpFd0FTTVJJeEVqRVFZaklpWTFFRFl6SVFSZ2N0VnpQbFRZeTlyb0FpMysvQWF3K1ZBRE14TDYrd0VFL2dBQkFKZ0NUQUdKQTFvQUN3QVhRQW9HQUFBTkRBTUpUMWtEQUM4ckVSSUJPUkV6TVRBVE5EWXpNaFlWRkFZaklpYVlQamc2UVVJNU0wTUMwMEpGUlVKQlJqOEFBQUVBSmY0VUFiUUFBQUFTQUNSQUVCRU9Dd0FBRGdVREV4UU9FUkVJQXhBQUw4d3lPUzh6RVJJQkZ6a1JNeEV6TVRBQkZBWWpJaWMxRmpNeU5qVTBKaWMzTXdjV0FiU1psak10TFR0UFVVOXRXRzQzdFA3ZllXb0phZ2dvTmlzMUViSnpKd0FCQUV3Q1NnSGhCYllBQ2dBZ1FBNENBQU1EQ2d3TENRa0RJQVlBSGdBL01qODVMeEVTQVRrNUVUTXpNVEFCTXhFakVUUTNCZ1lISndGU2o0VUdGamFIUXdXMi9KUUNRMXRhRmkxZllBQUNBRUlERkFLK0JjY0FDd0FYQUNWQUVnd0dFZ0FHQUJnWkR3QURFQU1DQXhVSkh3QS9NOFJkTWhFU0FUazVFVE1STXpFd0FSUUdJeUltTlRRMk16SVdCUlFXTXpJMk5UUW1JeUlHQXI2cmxwS3BxSmVZcGYzK1cyaHBYRnhwWjF3RWI2UzN1cUdqdGJhaWVucDZlbnQyZGdBQ0FGQUFkUU9vQTc0QUJnQU5BQ05BRVFzSkJBSUFBd2NDQ2drR0RnOE1CUWdCQUM4ekx6TVJFZ0VYT1JFekVUTXhNQUVCSndFQk53RUZBU2NCQVRjQkE2aitxSFVCSC83aGRRRlkvblgrcUhVQkgvN2hkUUZZQWd6K2FVY0JYd0ZlUmY1cEcvNXBSd0ZmQVY1Ri9tbi8vd0JMQUFBRjBRVzJBQ2NDRndLREFBQUFKZ0I3L3dBQkJ3SThBeDM5dHdBSnN3TUNFaGdBUHpVMUFQLy9BQzRBQUFYYkJiWUFKd0lYQWo4QUFBQW1BSHZpQUFFSEFIUURUdjIzQUFleUFoQVlBRDgxQVAvL0FCb0FBQVloQmNrQUpnQjErUUFBSndJWEF0OEFBQUVIQWp3RGJmMjNBQW16QXdJckdBQS9OVFVBQUFJQU0vNTNBMVFFWGdBZEFDZ0FRVUFpQ0JRZUl3RWNEeHdqRkFRcEtnQWRBUXdESFIwUkppWWdUMWttRUJFTFNWa1JJd0EvS3dBWVB5c1JFZ0E1R0M5ZlhsMFJFZ0VYT1JFekVUTVJNekV3QVJVVUJnY09BaFVVRmpNeU5qY1hCaU1pSmpVMFBnSTNOalkxTlJNVUl5SW1OVFEyTXpJV0FrNUxZWGs5R1lSNlVKWmlPOFhHdnRnalFGazJaVUcwZVRzK1FqY3pSZ0tzTTNxVVZHcExUVGhrY1NZd2gyQzZxa1pwV1ZJdldIUmRId0VyaDBWQ1FFZEEvLzhBQUFBQUJSQUhjd0ltQUNRQUFBRUhBRVAvd2dGU0FBaXpBaEFGSmdBck5mLy9BQUFBQUFVUUIzTUNKZ0FrQUFBQkJ3QjJBSVVCVWdBSXN3SVlCU1lBS3pYLy93QUFBQUFGRUFkekFpWUFKQUFBQVFjQlN3QWpBVklBQ0xNQ0hRVW1BQ3MxLy84QUFBQUFCUkFITHdJbUFDUUFBQUVIQVZJQUJBRlNBQWl6QWhnRkpnQXJOZi8vQUFBQUFBVVFCeVVDSmdBa0FBQUJCd0JxQURjQlVnQUt0QU1DSkFVbUFDczFOZi8vQUFBQUFBVVFCd1lDSmdBa0FBQUFCd0ZRQURrQWdRQUMvLzRBQUFhQkJiWUFEd0FUQUU1QUxBb09EaEVCQUFnTUFSQUZCUlVGRkFrVEJoTkpXUkFEU1ZrS0RVbFpFQW9RQ2dFR0F3VVNBUTVKV1FFU0FEOHJBQmcvUHhJNU9TOHZLeXNyRVFBekVRRXpFUklYT1JFek14RXpNVEFoSVJFaEF5TUJJUlVoRVNFVklSRWhBU0VSSXdhQi9STDkvdU93QXJvRHlmMjhBaDM5NHdKRSsxUUJ2bllCMGY0dkJiYVgvaW1XL2VZQjBnSzFBUC8vQUgzK0ZBVFBCY3NDSmdBbUFBQUFCd0I2QWdJQUFQLy9BTWtBQUFQNEIzTUNKZ0FvQUFBQkJ3QkQvN2NCVWdBSXN3RU5CU1lBS3pYLy93REpBQUFEK0FkekFpWUFLQUFBQVFjQWRnQS9BVklBQ0xNQkZRVW1BQ3MxLy84QXlRQUFBL2dIY3dJbUFDZ0FBQUVIQVV2Lyt3RlNBQWl6QVJvRkpnQXJOZi8vQU1rQUFBUDRCeVVDSmdBb0FBQUJCd0JxQUJJQlVnQUt0QUlCSVFVbUFDczFOZi8vQUR3QUFBSldCM01DSmdBc0FBQUJCd0JEL3JNQlVnQUlzd0VOQlNZQUt6WC8vd0JVQUFBQ2N3ZHpBaVlBTEFBQUFRY0FkdjloQVZJQUNMTUJGUVVtQUNzMS8vLy8vd0FBQXFFSGN3SW1BQ3dBQUFFSEFVdis4d0ZTQUFpekFSb0ZKZ0FyTmYvL0FEd0FBQUp2QnlVQ0pnQXNBQUFCQndCcS93Y0JVZ0FLdEFJQklRVW1BQ3MxTlFBQ0FDOEFBQVZJQmJZQURBQVhBRmRBTWhFVkZRZ0VEUUFBRXdRR0JCZ1pGQVlIQmtsWkVROEhQd2V2Qjg4SDN3Y0ZDd01IQndRSkNSQktXUWtEQkJWS1dRUVNBRDhyQUJnL0t4RVNBRGtZTDE5ZVhUTXJFUUF6RVJJQkZ6a1JNeEV6TXhFek1UQUJFQUFoSVJFak5UTVJJU0FBQXhBaEl4RWhGU0VSTXlBRlNQNTMvby8rZTVxYUFiSUJVUUY4dGYzSDV3Rjcvb1crQW1JQzZmNlcvb0VDaVpZQ2wvNkovcVFDUVAzOGx2NEsvLzhBeVFBQUJUOEhMd0ltQURFQUFBRUhBVklBa3dGU0FBaXpBUm9GSmdBck5mLy9BSDMvN0FXK0IzTUNKZ0F5QUFBQkJ3QkRBSGtCVWdBSXN3SVpCU1lBS3pYLy93QjkvK3dGdmdkekFpWUFNZ0FBQVFjQWRnRUtBVklBQ0xNQ0lRVW1BQ3MxLy84QWZmL3NCYjRIY3dJbUFESUFBQUVIQVVzQXRBRlNBQWl6QWlZRkpnQXJOZi8vQUgzLzdBVytCeThDSmdBeUFBQUJCd0ZTQUpvQlVnQUlzd0loQlNZQUt6WC8vd0I5Lyt3RnZnY2xBaVlBTWdBQUFRY0FhZ0RWQVZJQUNyUURBaTBGSmdBck5UVUFBUUNGQVJBRURBU1lBQXNBR1VBSkJ3a0RBUWtCREEwSUFCa3ZFUklCT1RrUk14RXpNVEFCRndFQkJ3RUJKd0VCTndFRHJHRCtvQUZlWVA2ZS9xUmxBVjcrb0dRQllRU1lZLzZlL3FCakFWLytvV01CWUFGZ1pmNmRBQUFEQUgzL3d3VytCZllBRXdBYkFDTUFUa0FzRmg4WEhnUWNGQndLRkFBQUVnOEZDQW9HSkNVV0hpRVpEU0ZKV1E4U0NBVUVBeEFOQkFNWlNWa0dBeE1BUDhZckFCZy94aElYT1NzUkVnQTVPUkVTQVJjNUVUTVJNeEVTRnpreE1BRVFBQ0VpSndjbk55WVJFQUFoTWhjM0Z3Y1dBeEFuQVJZek1oSUJFQmNCSmlNaUFnVysvcDMreE91VVpYaHNzZ0ZnQVVUUm5XRjRhc0MwYnYxZ2M3RHorUHduWlFLZGFxanovUUxkL3FIK2JtU05UNXJHQVcwQlpRR0pYb2RRbE1yK2xRRVFtdnhNVWdFeUFTcisrcG9EcjBuK3pRRC8vd0M2Lyt3RkdRZHpBaVlBT0FBQUFRY0FRd0JHQVZJQUNMTUJFd1VtQUNzMS8vOEF1di9zQlJrSGN3SW1BRGdBQUFFSEFIWUF6d0ZTQUFpekFSc0ZKZ0FyTmYvL0FMci83QVVaQjNNQ0pnQTRBQUFCQndGTEFIMEJVZ0FJc3dFZ0JTWUFLelgvL3dDNi8rd0ZHUWNsQWlZQU9BQUFBUWNBYWdDWUFWSUFDclFDQVNjRkpnQXJOVFgvL3dBQUFBQUVld2R6QWlZQVBBQUFBUWNBZGdBeEFWSUFDTE1CRWdVbUFDczFBQUlBeVFBQUJIa0Z0Z0FNQUJVQU5rQWNEUWtGQlFZUkFBWUFGaGNOQkVwWkNSVktXUTBKRFFrR0J3TUdFZ0EvUHhJNU9TOHZLeXNSRWdFNU9SRXpFVE1STXpNeE1BRVVCQ0VqRVNNUk14RXpJQVFCTXpJMk5UUW1JeU1FZWY3Ui91RzRxcXJYQVJrQkZ2ejZxT0xLdnNyTUF4RGo3djdCQmJiL0FNLzk2bytrbFlvQUFBRUFzUC9zQkp3R0h3QXdBRUZBSWlrcUJSMGpBQmNNREFBZEVTb0ZNVElTRWlvdUxpWkdXUzRBS2hVUEZVWlpEeFlBUHlzQUdEOC9LeEVTQURrWUx4RVNBUmM1RVRNUk14RXpFVE14TUFFVUJ3WUdGUlFXRmhjV0ZoVVVCaU1pSnpVV0ZqTXlOVFFtSnlZbU5UUTJOelkyTlRRbUl5QVZFU01STkRZek1oWUVHWTlZT0J0SFRveG13ck84YXorY1NOZFRibjlnUlVkTFFJaC8vdXltM043TzRRVHloM05HUXlFZ0tqa3pYNTFsb0t0Rm1pY3Z0a3RyUmxKN1ZEOXFOVGxhTlZCVjMvdE1CTEt5dTUzLy93QmUvK3dEelFZaEFpWUFSQUFBQVFZQVE0NEFBQWl6QWlZUkpnQXJOZi8vQUY3LzdBUE5CaUVDSmdCRUFBQUJCZ0IyS3dBQUNMTUNMaEVtQUNzMS8vOEFYdi9zQTgwR0lRSW1BRVFBQUFFR0FVdllBQUFJc3dJekVTWUFLelgvL3dCZS8rd0R6UVhkQWlZQVJBQUFBUVlCVXIwQUFBaXpBaTRSSmdBck5mLy9BRjcvN0FQTkJkTUNKZ0JFQUFBQkJnQnE0Z0FBQ3JRREFqb1JKZ0FyTlRYLy93QmUvK3dEelFhRkFpWUFSQUFBQVFZQlVQY0FBQXEwQXdJb0VTWUFLelUxQUFNQVh2L3NCbk1FWEFBcEFEUUFPd0JoUURNcUFDUVJNRGdaR1FRd09SZ1lIekFMQUFVOFBSc3RKeTFHV1JreEJERkhXVGdrSnhFRUJBNGlKeFkxQ0E0SVJsa1VEaEFBUHpNckVRQXpHRDh6RWprdk9SSTVNeXNSQURNckVRQXpFUklCRnprUk14RXpNeEV6RWprNUVUTXhNQk0wTmpjM05UUW1JeUlISnpZMk16SVdGelkyTXpJU0ZSVWhFaUV5TmpjVkJnWWpJQ2NHQmlNaUpqY1VGak15TmpVMUJ3WUdBU0lHQnlFMEpsNzQvcmgwZDVDak5FckhZb0tsS1RXcmJzRG8vVU1JQVRwYm5WUldsV1grMzMxUnhZYWp1YTVyV0pHb25ycWtBNzE1aXdzQ0I0QUJMNkd6Q0FaRWdYdFVmeWsxVjE5WVlQNzEzbXYrZFNNbmxDWWg2WDlxcXBkZldhbWFZd2NJYlFJeXBwNmNxQUQvL3dCei9oUURpd1JjQWlZQVJnQUFBQWNBZWdGR0FBRC8vd0J6Lyt3RUVnWWhBaVlBU0FBQUFRWUFRN1VBQUFpekFod1JKZ0FyTmYvL0FIUC83QVFTQmlFQ0pnQklBQUFCQmdCMlRnQUFDTE1DSkJFbUFDczEvLzhBYy8vc0JCSUdJUUltQUVnQUFBRUdBVXYzQUFBSXN3SXBFU1lBS3pYLy93QnovK3dFRWdYVEFpWUFTQUFBQVFZQWFnb0FBQXEwQXdJd0VTWUFLelUxLy8vLzJnQUFBV01HSVFJbUFQTUFBQUVIQUVQK1VRQUFBQWl6QVFVUkpnQXJOZi8vQUtrQUFBSXlCaUVDSmdEekFBQUJCd0IyL3lBQUFBQUlzd0VORVNZQUt6WC8vLyt6QUFBQ1ZRWWhBaVlBOHdBQUFRY0JTLzZuQUFBQUNMTUJFaEVtQUNzMS8vLy83QUFBQWg4RjB3SW1BUE1BQUFFSEFHcit0d0FBQUFxMEFnRVpFU1lBS3pVMUFBSUFjZi9zQkdJR0lRQWJBQ1lBU2tBcklRWU1IQndBQUJnWkZnNFJFeEFHQ1Njb0NSOUdXUXNERmhFWkRnOEZGQWtKQXhjVUFRTWtSbGtERmdBL0t3QVlQek1TT1M4U0Z6a1NPU3NSRWdFWE9SRXpFVE1STXpFd0FSQUFJeUlBTlRRQU16SVhOeVluQlNjM0ppYzNGaGMzRndjV0VnTTBKaU1nRVJRV016STJCR0wrKy9mZS91a0JCOXppWkFnNXpmN3hTZWxjWGtXY1p1NU16NWlscUxTYy9xK3ZvcStoQWpQKzUvN1NBUTNpNWdFR2VRVFd2NXRzaFQ0eGRVbExpbXQzai81eS91aVRxdjZZcDdmSkFQLy9BTEFBQUFSRUJkMENKZ0JSQUFBQkJnRlNEZ0FBQ0xNQkhoRW1BQ3MxLy84QWMvL3NCR0lHSVFJbUFGSUFBQUVHQUVQVUFBQUlzd0lhRVNZQUt6WC8vd0J6Lyt3RVlnWWhBaVlBVWdBQUFRWUFkbFlBQUFpekFpSVJKZ0FyTmYvL0FIUC83QVJpQmlFQ0pnQlNBQUFCQmdGTERnQUFDTE1DSnhFbUFDczEvLzhBYy8vc0JHSUYzUUltQUZJQUFBRUdBVkx4QUFBSXN3SWlFU1lBS3pYLy93QnovK3dFWWdYVEFpWUFVZ0FBQVFZQWFoc0FBQXEwQXdJdUVTWUFLelUxQUFNQWFBRDhCQ2tFcUFBREFBOEFHd0F6UUJnV0Nnb1FCQUlFQVFNY0hSa1RFd0VIRFEwQkFRQlFXUUVBTHlzUkFETVlMek1STXk4ekVSSUJGemtSTXpNUk16RXdFelVoRlFFME5qTXlGaFVVQmlNaUpoRTBOak15RmhVVUJpTWlKbWdEd2YydU96WTBPanN6TkQwN05qUTZPek0wUFFLTmlvcis2RHc5UHpvNVFEOEM5RHc5UHpvNVFEOEFBd0J6Lzd3RVlnU0hBQk1BR3dBakFFdEFLUmNmSEJRVUNod0FBQklQQlFnS0JpUWxGaDRoR1EwWlJsa1BFZ2dGQkFNUURSQURJVVpaQmdNV0FEL0dLd0FZUDhZU0Z6a3JFUklBT1RrUkVnRVhPUkV6RVRNUkVqazVNVEFCRUFBaklpY0hKemNtRVJBQU16SVhOeGNIRmdVVUZ3RW1JeUlHQlRRbkFSWXpNallFWXY3eTdwcHdWSEplZ1FFTTdwcDBWSFZoZi95OU5RSFJTM0tqcGdLWE0vNHZSM0dqcVFJbC92VCswMFYxVG9PWUFRQUJEQUVyVEhkTWhaajVxMllDaGpYVzFLUmsvWDB6MndELy93Q2svK3dFT1FZaEFpWUFXQUFBQVFZQVE4UUFBQWl6QVJZUkpnQXJOZi8vQUtULzdBUTVCaUVDSmdCWUFBQUJCZ0IyY1FBQUNMTUJIaEVtQUNzMS8vOEFwUC9zQkRrR0lRSW1BRmdBQUFFR0FVc1NBQUFJc3dFakVTWUFLelgvL3dDay8rd0VPUVhUQWlZQVdBQUFBUVlBYWlFQUFBcTBBZ0VxRVNZQUt6VTEvLzhBQXY0VUJBWUdJUUltQUZ3QUFBRUdBSFlTQUFBSXN3RWZFU1lBS3pVQUFnQ3cvaFFFZFFZVUFCWUFJZ0ErUUI4Z0Joc1VFQkFSQmhFa0l4SUFFUnNNRmdrRENSNUdXUWtXQXhkR1dRTVFBRDhyQUJnL0t4RVNBRGs1R0Q4L0VSSUJPVGtSTXhFek14RXpNVEFCTmpZek1oSVJFQUlqSWljakZ4WVZFU01STXhFVUJ5VWlCZ2NWRkJZeklCRTBKZ0ZZUXFwcTEvRHgxdDU2REFRSXBxWUdBVWlvbUFLYXFnRXZsQU8wV1UvKzFQNzEvdlQrMDZFaVRULytOUWdBL2k0MFdodTR5U25ueHdHdzE5SC8vd0FDL2hRRUJnWFRBaVlBWEFBQUFRWUFhclVBQUFxMEFnRXJFU1lBS3pVMS8vOEFBQUFBQlJBR3RBSW1BQ1FBQUFFSEFVMEFQd0ZTQUFpekFoSUZKZ0FyTmYvL0FGNy83QVBOQldJQ0pnQkVBQUFCQmdGTjlRQUFDTE1DS0JFbUFDczEvLzhBQUFBQUJSQUhOd0ltQUNRQUFBRUhBVTRBS3dGU0FBaXpBZzhGSmdBck5mLy9BRjcvN0FQTkJlVUNKZ0JFQUFBQkJnRk81QUFBQ0xNQ0pSRW1BQ3MxLy84QUFQNUNCUkVGdkFJbUFDUUFBQUFIQVZFRG9BQUEvLzhBWHY1Q0JBQUVXZ0ltQUVRQUFBQUhBVkVDandBQS8vOEFmZi9zQk04SGN3SW1BQ1lBQUFFSEFIWUJDQUZTQUFpekFTQUZKZ0FyTmYvL0FIUC83QU9MQmlFQ0pnQkdBQUFCQmdCMlJBQUFDTE1CSUJFbUFDczEvLzhBZmYvc0JNOEhjd0ltQUNZQUFBRUhBVXNBckFGU0FBaXpBU1VGSmdBck5mLy9BSFAvN0FPTEJpRUNKZ0JHQUFBQkJnRkwxQUFBQ0xNQkpSRW1BQ3MxLy84QWZmL3NCTThITVFJbUFDWUFBQUVIQVU4Q0d3RlNBQWl6QVNBRkpnQXJOZi8vQUhQLzdBT0xCZDhDSmdCR0FBQUJCd0ZQQVZBQUFBQUlzd0VnRVNZQUt6WC8vd0I5Lyt3RXp3ZHpBaVlBSmdBQUFRY0JUQURCQVZJQUNMTUJJZ1VtQUNzMS8vOEFjLy9zQTZFR0lRSW1BRVlBQUFFR0FVenpBQUFJc3dFaUVTWUFLelgvL3dESkFBQUZXQWR6QWlZQUp3QUFBUWNCVEFCWUFWSUFDTE1DSFFVbUFDczEvLzhBYy8vc0JZRUdGQUltQUVjQUFBRUhBamdEREFBQUFBZXlBaU1BQUQ4MUFQLy9BQzhBQUFWSUJiWUNCZ0NTQUFBQUFnQnovK3dFMHdZVUFCb0FKd0JrUURjbEJoSU9BQjRlRlJrV0dSQUdCQ2dwR2hVWUVCRVFSMWtWRHhFZkVTOFJBd2tERVJFSkV3QUJEQU1KQ1NKR1dRa1FBeHRHV1FNV0FEOHJBQmcvS3hFU0FEazVHRDhTT1M5ZlhsMHpLeEVBTXhnL0VSSUJGemtSTXpNUk16TXpFVE14TUNVakJpTWlBaEVRRWpNeUZ6TW1OVFVoTlNFMU14VXpGU01SSXlVeU5qVTFOQ1lqSWdZVkZCWURtZ2x6NWRmdjhOYmZkdzBML2tBQndLYWNuSWYrbnFxWm02cVNtNXFUcHdFbUFROEJEd0Vzb2xOSmhZRzR1SUg3SlhlNXppUHB4K1BQMHRiLy93REpBQUFEK0FhMEFpWUFLQUFBQVFjQlRRQVNBVklBQ0xNQkR3VW1BQ3MxLy84QWMvL3NCQklGWWdJbUFFZ0FBQUVHQVUwS0FBQUlzd0llRVNZQUt6WC8vd0RKQUFBRCtBYzNBaVlBS0FBQUFRY0JUZ0FRQVZJQUNMTUJEQVVtQUNzMS8vOEFjLy9zQkJJRjVRSW1BRWdBQUFFR0FVNzdBQUFJc3dJYkVTWUFLelgvL3dESkFBQUQrQWNVQWlZQUtBQUFBUWNCVHdGdkFUVUFDTE1CRlFVbUFDczEvLzhBYy8vc0JCSUYzd0ltQUVnQUFBRUhBVThCVkFBQUFBaXpBaVFSSmdBck5mLy9BTW4rUWdQNEJiWUNKZ0FvQUFBQUJ3RlJBbk1BQVAvL0FIUCtZUVFTQkZ3Q0pnQklBQUFBQndGUkFtWUFILy8vQU1rQUFBUDRCM01DSmdBb0FBQUJCd0ZNQUJBQlVnQUlzd0VYQlNZQUt6WC8vd0J6Lyt3RUVnWWhBaVlBU0FBQUFRWUJUUHNBQUFpekFpWVJKZ0FyTmYvL0FIMy83QVU5QjNNQ0pnQXFBQUFCQndGTEFPa0JVZ0FJc3dFcUJTWUFLelgvL3dBbi9oUUVNUVloQWlZQVNnQUFBUVlCUzhvQUFBaXpBMUFSSmdBck5mLy9BSDMvN0FVOUJ6Y0NKZ0FxQUFBQkJ3Rk9BUUFCVWdBSXN3RWNCU1lBS3pYLy93QW4vaFFFTVFYbEFpWUFTZ0FBQVFZQlRzNEFBQWl6QTBJUkpnQXJOZi8vQUgzLzdBVTlCekVDSmdBcUFBQUJCd0ZQQW1RQlVnQUlzd0VsQlNZQUt6WC8vd0FuL2hRRU1RWGZBaVlBU2dBQUFRY0JUd0VmQUFBQUNMTURTeEVtQUNzMS8vOEFmZjQ3QlQwRnl3SW1BQ29BQUFBSEFqa0JKd0FBLy84QUovNFVCREVHSVFJbUFFb0FBQUVHQWpwRUFBQUlzd05HRVNZQUt6WC8vd0RKQUFBRkh3ZHpBaVlBS3dBQUFRY0JTd0NXQVZJQUNMTUJHZ1VtQUNzMS8vOEFzQUFBQkVRSHFnSW1BRXNBQUFFSEFVc0FId0dKQUFpekFTVUNKZ0FyTlFBQ0FBQUFBQVhuQmJZQUV3QVhBRlJBTEJjRER3OEFFQlFFREF3SEN3Z0xFQklFR0JrWERrbFpGZ29TRXhKS1dRY0RFeGNURnhNQkRCQVNCUUVEQUQ4elB6TVNPVGt2THhFek15c1JBRE16S3hFU0FSYzVFVE16RVRNekVUTXpFVE16TVRBVE5UTVZJVFV6RlRNVkl4RWpFU0VSSXhFak5RRTFJUlhKcWdNQ3FzaklxdnorcXNrRWRmeitCTDc0K1BqNGpmdlBBckQ5VUFReGpmNks2ZWtBQVFBVUFBQUVSQVlVQUI0QVdVQXlGaFFRQ0FnTkNRQWVIaElKQ3dRZklCY1dHZ1JHV1JNTERBdEhXUkFNRHd3ZkRDOE1BeFlhREF3YUZnTUpEZ0FBQ1JVQVB6TS9FaGM1THk4dlhSRXpLeEVBTXlzUkFETVJFZ0VYT1JFekVUTXpFVE16TXpFd0lSRTBKaU1pQmhVUkl4RWpOVE0xTXhVaEZTRVZGQWN6TmpZek1oWVZFUU9lZW9LdW5xYWNuS1lCd2Y0L0NBb3h0WFRKeVFLZWhvUzYxZjNuQk50L3VycC94RlE0VDF1LzB2MWMvLy8vNGdBQUFzb0hMd0ltQUN3QUFBRUhBVkwrMmdGU0FBaXpBUlVGSmdBck5mLy8vNUFBQUFKNEJkMENKZ0R6QUFBQkJ3RlMvb2dBQUFBSXN3RU5FU1lBS3pYLy93QXFBQUFDZ2dhMEFpWUFMQUFBQVFjQlRmNzlBVklBQ0xNQkR3VW1BQ3MxLy8vLzJnQUFBaklGWWdJbUFQTUFBQUVIQVUzK3JRQUFBQWl6QVFjUkpnQXJOZi8vQUI0QUFBS0tCemNDSmdBc0FBQUJCd0ZPL3ZrQlVnQUlzd0VNQlNZQUt6WC8vLy9NQUFBQ09BWGxBaVlBOHdBQUFRY0JUdjZuQUFBQUNMTUJCQkVtQUNzMS8vOEFWUDVDQWxZRnRnSW1BQ3dBQUFBR0FWRm9BUC8vQURYK1FnR0JCZDhDSmdCTUFBQUFCZ0ZSRUFELy93QlVBQUFDVmdjeEFpWUFMQUFBQVFjQlR3QlFBVklBQ0xNQkZRVW1BQ3MxQUFFQXNBQUFBVllFU0FBREFCWkFDUUFCQVFVRUFnOEJGUUEvUHhFU0FUa1JNekV3SVNNUk13RldwcVlFU1AvL0FGVCtmd1FRQmJZQUpnQXNBQUFBQndBdEFxZ0FBUC8vQUtMK0ZBTnNCZDhBSmdCTUFBQUFCd0JOQWdZQUFQLy8vMkQrZndKbEIzTUNKZ0F0QUFBQkJ3RkwvcmNCVWdBSXN3RWNCU1lBS3pYLy8vK1IvaFFDVHdZaEFpWUNOd0FBQVFjQlMvNmhBQUFBQ0xNQkd4RW1BQ3MxLy84QXlmNDdCT2tGdGdJbUFDNEFBQUFIQWprQWlRQUEvLzhBc1A0N0JCMEdGQUltQUU0QUFBQUdBamtyQUFBQkFMQUFBQVFiQkVZQURRQXZRQmtOQ3djSENBTUJBZ1VJQlE0UEFnMEZCZ1FJQUFrUEJBZ1ZBRDh6UHpNU0Z6a1JFZ0VYT1JFekVUTXpNVEFCTXdFQkl3RUhFU01STXhFVUJ3TXZ6LzVpQWJ2Si9wZUhzcklNQkViK0h2MmNBZmh4L25rRVJ2N2xwbkgvL3dESkFBQUQrQWR6QWlZQUx3QUFBUWNBZHY5akFWSUFDTE1CRHdVbUFDczEvLzhBb3dBQUFpd0hyQUltQUU4QUFBRUhBSGIvR2dHTEFBaXpBUTBDSmdBck5mLy9BTW4rT3dQNEJiWUNKZ0F2QUFBQUJnSTVNUUQvL3dCWi9qc0JWd1lVQWlZQVR3QUFBQWNDT2Y3b0FBRC8vd0RKQUFBRCtBVzNBaVlBTHdBQUFRY0NPQUVkLzZNQUI3SUJDUU1BUHpVQS8vOEFzQUFBQXFBR0ZBSW1BRThBQUFFR0FqZ3JBQUFIc2dFSEFBQS9OUUQvL3dESkFBQUQrQVcyQWlZQUx3QUFBQWNCVHdJRS9XZi8vd0N3QUFBQ3FBWVVBQ1lBVHdBQUFBY0JUd0ZDL1RnQUFRQWRBQUFEK0FXMkFBMEFQVUFoQndzTEJBQU1DUUFEQkE4T0NRY0VDZ01CQmdnQ0NBSUlBQVVEQUF0SldRQVNBRDhyQUJnL0VqazVMeThTRnprUkVnRVhPUkV6TXhFek1UQXpFUWNuTnhFekVTVVhCUkVoRmNscFE2eXFBU2xEL3BRQ2hRSDhPM0psQXg3OVJxNTUwLzQ4bWdBQi8vd0FBQUluQmhRQUN3QTNRQndBQkFRSkJRVU1BZzBJREFBQ0NRTUlCZ1lCQndFSEFRVUtBQVVWQUQ4L0VqazVMeThTRnprUkFUTVJNeEk1RVRNekVUTXhNQUUzRndjUkl4RUhKemNSTXdGV2lValJwbTVHdEtZRFlGNXdqZjAvQWxSSWNYY0RJQUQvL3dESkFBQUZQd2R6QWlZQU1RQUFBUWNBZGdFQ0FWSUFDTE1CR2dVbUFDczEvLzhBc0FBQUJFUUdJUUltQUZFQUFBRUdBSFo1QUFBSXN3RWVFU1lBS3pYLy93REovanNGUHdXMkFpWUFNUUFBQUFjQ09RRE5BQUQvL3dDdy9qc0VSQVJjQWlZQVVRQUFBQVlDT1ZZQS8vOEF5UUFBQlQ4SGN3SW1BREVBQUFFSEFVd0FwZ0ZTQUFpekFSd0ZKZ0FyTmYvL0FMQUFBQVJFQmlFQ0pnQlJBQUFCQmdGTUh3QUFDTE1CSUJFbUFDczEvLzhBQVFBQUJNc0Z0Z0FuQUZFQWh3QUFBUVlDQitnQUFBZXlBUndEQUQ4MUFBQUJBTW4rZndVL0JiWUFHUUE0UUJ3UURRME9DQlFVRnhjQ0RnTWFHeElLRGhVUEF3NFNBQVZKV1FBaUFEOHJBQmcvUHpNU09Ua1JFZ0VYT1JFekVUTVJNeEV6TVRBQklpYzFGak15TmpVQkl4SVZFU01STXdFekpqVVJNeEVVQmdQSllqWkhVMmxxL01BSUVKM0FBeDBJRHAvQi9uOGJrUlI2YndUTC92aWUvTnNGdHZ0T2xlQURQZnBZdzh3QUFRQ3cvaFFFUkFSY0FCMEFPRUFlRXc4UEVBY2JHd0lRQXg0ZkZ3dEdXUmNRRXhBUkR4QVZBQVZHV1FBYkFEOHJBQmcvUHhJNVB5c1JFZ0VYT1JFekVUTVJNekV3QVNJbk5SWXpNalVSTkNZaklnWVZFU01STXhjek5qWXpNaFlWRVJRR0F5VldOencrakhxQ3JLQ21oeHNLTkxSdXk4ZU0vaFFaaHhTc0EzbUdoTHJXL2NFRVNKWlNXTC9TL0kyYXF2Ly9BSDMvN0FXK0JyUUNKZ0F5QUFBQkJ3Rk5BTWNCVWdBSXN3SWJCU1lBS3pYLy93QnovK3dFWWdWaUFpWUFVZ0FBQVFZQlRSSUFBQWl6QWh3UkpnQXJOZi8vQUgzLzdBVytCemNDSmdBeUFBQUJCd0ZPQU1FQlVnQUlzd0lZQlNZQUt6WC8vd0J6Lyt3RVlnWGxBaVlBVWdBQUFRWUJUZzRBQUFpekFoa1JKZ0FyTmYvL0FIMy83QVcrQjNNQ0pnQXlBQUFCQndGVEFSUUJVZ0FLdEFNQ0t3VW1BQ3MxTmYvL0FIUC83QVJpQmlFQ0pnQlNBQUFCQmdGVFdnQUFDclFEQWl3UkpnQXJOVFVBQWdCOS8rd0c1d1hOQUJRQUh3QlRRQzRZQmc4VEV4MEFEUkVkQmdVZ0lROFNTVmtQRHdBTEN3NUpXUXNEQ1JWSldRa0VBeHRKV1FNU0FCTkpXUUFTQUQ4ckFCZy9Ld0FZUHlzQUdEOHJFUklBT1Jndkt4RVNBUmM1RVRNUk14RXpNVEFoSVFZaklBQVJFQUFoTWhjaEZTRVJJUlVoRVNFQklnQVJFQUF6TWpjUkpnYm4vUUJtWFA2NS9wOEJYQUZBWmxvRER2MnpBaWY5MlFKTi9FVDUvdjhCQWZkd1YxY1VBWWtCYWdGb0FZWVhsLzRwbHYzbUJKMyt6LzdaL3RmK3pTRUVkUjRBQXdCeC8rd0hId1JhQUI0QUtnQXhBRlZBTFI4SURnSVdGaVV2RlJVY0pRZ0VNak1yS0Fzb1Jsa3VGa1paQWdVT0N5NHVCUkVMRUJnaUJTSkdXUUFGRmdBL015c1JBRE1ZUHpNU09TOFNPUkk1S3lzUkFETVJFZ0VYT1JFekVUTVNPVGtSTXpFd0JTQW5CZ1lqSWdBUkVBQXpNaFlYTmpZek1oSVZGU0VTSVRJMk54VUdCZ0VVRmpNeU5qVTBKaU1pQmlVaUJnY2hOQ1lGbHY3YmZUN1JpZC8rOUFFRzY0UE5QanJBZnNudS9TY0lBVXBlb1ZkWW1Qc2htS2VqbVp1bHBwVUVSMytSREFJZ2hCVHJkSGNCTVFFSUFRa0JMSGR5Y0huKzkrSnAvbmNqSjVRbklBSTUwOXZWMGQzVjJOaWtucDZrLy84QXlRQUFCTThIY3dJbUFEVUFBQUVIQUhZQWVRRlNBQWl6QWg4RkpnQXJOZi8vQUxBQUFBTW5CaUVDSmdCVkFBQUJCZ0IyM0FBQUNMTUJHaEVtQUNzMS8vOEF5ZjQ3Qk04RnRnSW1BRFVBQUFBR0FqbDlBUC8vQUdEK093TW5CRndDSmdCVkFBQUFCd0k1L3U4QUFQLy9BTWtBQUFUUEIzTUNKZ0ExQUFBQkJ3Rk1BQnNCVWdBSXN3SWhCU1lBS3pYLy93Q0NBQUFESndZaEFpWUFWUUFBQVFjQlRQOTJBQUFBQ0xNQkhCRW1BQ3MxLy84QWF2L3NCQUlIY3dJbUFEWUFBQUVIQUhZQVVBRlNBQWl6QVM0RkpnQXJOZi8vQUdyLzdBTnpCaUVDSmdCV0FBQUJCZ0IyNmdBQUNMTUJMaEVtQUNzMS8vOEFhdi9zQkFJSGN3SW1BRFlBQUFFSEFVdi82Z0ZTQUFpekFUTUZKZ0FyTmYvL0FHci83QU56QmlFQ0pnQldBQUFCQmdGTGx3QUFDTE1CTXhFbUFDczEvLzhBYXY0VUJBSUZ5d0ltQURZQUFBQUhBSG9CSndBQS8vOEFhdjRVQTNNRVhBSW1BRllBQUFBSEFIb0ExUUFBLy84QWF2L3NCQUlIY3dJbUFEWUFBQUVIQVV6LzVBRlNBQWl6QVRBRkpnQXJOZi8vQUdyLzdBTnpCaUVDSmdCV0FBQUJCZ0ZNbVFBQUNMTUJNQkVtQUNzMS8vOEFFdjQ3QkZvRnRnSW1BRGNBQUFBR0Fqa1pBUC8vQUIvK093S29CVVlDSmdCWEFBQUFCZ0k1Z2dELy93QVNBQUFFV2dkekFpWUFOd0FBQVFjQlRQL2NBVklBQ0xNQkV3VW1BQ3MxLy84QUgvL3NBdGNHRkFJbUFGY0FBQUVHQWpoaUFBQUhzZ0VhQUFBL05RQUFBUUFTQUFBRVdnVzJBQThBUDBBaEJ3c0xBQXdFQ1F3T0FnVVFFUW9PRHc1S1dRY1BEd01NRWdZQ0F3SkpXUU1EQUQ4ckVRQXpHRDhTT1M4ekt4RUFNeEVTQVJjNUVUTXpFVE14TUFFUklUVWhGU0VSSVJVaEVTTVJJVFVCNGY0eEJFaitNUUUyL3NxcS9zY0RMd0h3bDVmK0VJMzlYZ0tpalFBQkFCLy83QUtvQlVZQUhBQk1RQ2tYRXhzYkRBZ0NGUmtJQ2c0R0hSNE9GaE1XUjFrYUNnc0tSMWtYQ3dzR0VVQVREd1lBUmxrR0ZnQS9Ld0FZUHhyTkVqa3ZNeXNSQURNckVRQXpFUklCRnprUk16TVJNek14TUNVeU54VUdCaU1nRVRVak5UTVJJelUzTnpNVklSVWhFU0VWSVJVVUFoZFZQQ0JxS3Y3SWpZMmRuVVpnQVQ3K3dnRXQvdE4xRkg4T0VBRmMvb0VCQUZCRjZ2NkIvd0NCOU4wQS8vOEF1di9zQlJrSEx3SW1BRGdBQUFFSEFWSUFid0ZTQUFpekFSc0ZKZ0FyTmYvL0FLVC83QVE1QmQwQ0pnQllBQUFCQmdGUzl3QUFDTE1CSGhFbUFDczEvLzhBdXYvc0JSa0d0QUltQURnQUFBRUhBVTBBa1FGU0FBaXpBUlVGSmdBck5mLy9BS1QvN0FRNUJXSUNKZ0JZQUFBQkJnRk5HUUFBQ0xNQkdCRW1BQ3MxLy84QXV2L3NCUmtITndJbUFEZ0FBQUVIQVU0QWl3RlNBQWl6QVJJRkpnQXJOZi8vQUtULzdBUTVCZVVDSmdCWUFBQUJCZ0ZPRWdBQUNMTUJGUkVtQUNzMS8vOEF1di9zQlJrSDF3SW1BRGdBQUFFSEFWQUFuQUZTQUFxMEFnRVZCU1lBS3pVMS8vOEFwUC9zQkRrR2hRSW1BRmdBQUFFR0FWQWpBQUFLdEFJQkdCRW1BQ3MxTmYvL0FMci83QVVaQjNNQ0pnQTRBQUFCQndGVEFPRUJVZ0FLdEFJQkpRVW1BQ3MxTmYvL0FLVC83QVE1QmlFQ0pnQllBQUFCQmdGVGFBQUFDclFDQVNnUkpnQXJOVFgvL3dDNi9rSUZHUVcyQWlZQU9BQUFBQWNCVVFJaEFBRC8vd0NrL2tJRVpRUklBaVlBV0FBQUFBY0JVUUwwQUFELy93QWJBQUFIVEFkekFpWUFPZ0FBQVFjQlN3RlVBVklBQ0xNQktBVW1BQ3MxLy84QUZ3QUFCaU1HSVFJbUFGb0FBQUVIQVVzQXdRQUFBQWl6QVNzUkpnQXJOZi8vQUFBQUFBUjdCM01DSmdBOEFBQUJCd0ZMLytBQlVnQUlzd0VYQlNZQUt6WC8vd0FDL2hRRUJnWWhBaVlBWEFBQUFRWUJTNjBBQUFpekFTUVJKZ0FyTmYvL0FBQUFBQVI3QnlVQ0pnQThBQUFCQndCcS8vRUJVZ0FLdEFJQkhnVW1BQ3MxTmYvL0FGSUFBQVEvQjNNQ0pnQTlBQUFCQndCMkFFSUJVZ0FJc3dFVEJTWUFLelgvL3dCU0FBQURiUVloQWlZQVhRQUFBUVlBZHVnQUFBaXpBUk1SSmdBck5mLy9BRklBQUFRL0J6RUNKZ0E5QUFBQkJ3RlBBVVFCVWdBSXN3RVRCU1lBS3pYLy93QlNBQUFEYlFYZkFpWUFYUUFBQVFjQlR3RGZBQUFBQ0xNQkV4RW1BQ3MxLy84QVVnQUFCRDhIY3dJbUFEMEFBQUVIQVV6LzdRRlNBQWl6QVJVRkpnQXJOZi8vQUZJQUFBTnRCaUVDSmdCZEFBQUJCZ0ZNaGdBQUNMTUJGUkVtQUNzMUFBRUFzQUFBQXRzR0h3QU1BQjFBRGdBQkFRMEdEZ1FKUmxrRUFBRVZBRDgvS3hFQk14STVFVE14TUNFakVSQWhNaGNISmlNaUJoVUJWcVlCWjJCa0sxZEpZVmtFbkFHREpZVWVlM29BQUFFQXcvNFVCQmNGeXdBZ0FFUkFKQm9lSGd3SUVod0lDZ0lGSVNJZENnd0tSbGthREF3UUFCQVdSbGtRQkFBRlJsa0FHd0EvS3dBWVB5c1JFZ0E1R0M4ekt4RUFNeEVTQVJjNUVUTXpFVE14TUFFaUp6VVdNekkyTlJFak5UYzFORFl6TWhjSEJ5WWpJZ1lWRlNFVklSRVVCZ0ZJUlVCR1BWOU4zdDZpdGxWNEZoVm1QR0pRQVJyKzZwNytGQk9MRW1aeEE4MUxQSXZEc2l0QVFTQnBmSldCL0RlNHJ3QUVBQUFBQUFVVUI2b0FFQUFZQUNJQUxnQmhRRFFSQlFRWUJoUUhCQU1IQ0NNQUtRc0lDd2tpRkFJQUhRTUpNQzhtRGl3Q0NSZ0dTVmtKRkE0WUlnNFlHQTRpQXdnY0JBZ1NBRDh6THhJWE9TOHZMeEVTT1RrckVRQXpNeEV6RVJJQkZ6a1JNeEV6RVRNUk14RVNPVGtST1RreE1BRVVCd0VqQXlFREl3RW1OVFEyTXpJV0V3TW1Kd1lHQndNVE5qWTNNeFVHQmdjakV6UW1JeUlHRlJRV016STJBMmhvQWhTdXNQMmVwcTRDRkdwNlkyUjlHN0laTHc0d0NiR1lNV1lYeXlDb1FtL1RRak16UWp3NU5VQUZsb1U0K3ljQmtmNXZCTmMwaUdWeWRmdzJBYkE2a1RDSEdQNVVCSVU3bFNvUUxxRXQvdlU1UER3NU56MDlBQVVBWHYvc0E4MEhxZ0FKQUNRQUx3QTdBRWNBWjBBM0xSSkNOand3S1JVVkN5UWtCakFBTmgwU0IwaEpDUWtFUHpsRk14RUxEQlVwUjFrTUZSVVBJQ0FaUmxrZ0VBOGxSbGtQRmdvVkJBQXZQejhyQUJnL0t4RVNBRGtZTHprckVRQXpHRDh6eERJUk9TOFJFZ0VYT1JFek14RXpFVE1STXhFek1UQUJOVFkyTnlFVkJnWUhBU2NqQmdZaklpWTFFQ1UzTlRRbUl5SUdCeWMyTmpNeUZoVVJKVEkyTlRVSEJnWVZGQllCRkFZaklpWTFORFl6TWhZSE5DWWpJZ1lWRkJZek1qWUIxeTVxRmdFRUZhU0FBUUloQ0ZLamVxTzVBaG0wZDRWZ3AwYzNWTkJsMGNuK0RwdXhwc2F2YlFHcWUyWmxlWGxsWlh4dFFUTXpRanc1TkVBRzJSQXFlQjhNR0dsRStTZWNaMG1vbXdGTUVBWkVnbm8wSUg4ck02N0EvUlIxcXBsakJ3ZHRjMXBlQlQxaWQzUmpZbk4zWGpnOVBUZzRQVDBBLy8vLy9nQUFCb0VIY3dJbUFJZ0FBQUVIQUhZQ1RBRlNBQWl6QWgwRkpnQXJOZi8vQUY3LzdBWnpCaUVDSmdDb0FBQUJCd0IyQVlVQUFBQUlzd05GRVNZQUt6WC8vd0I5LzhNRnZnZHpBaVlBbWdBQUFRY0FkZ0VaQVZJQUNMTURMUVVtQUNzMS8vOEFjLys4QkdJR0lRSW1BTG9BQUFFR0FIWldBQUFJc3dNdEVTWUFLelgvL3dCcS9qc0VBZ1hMQWlZQU5nQUFBQVlDT1FZQS8vOEFhdjQ3QTNNRVhBSW1BRllBQUFBR0FqbTVBQUFCQVF3RTJRT3VCaUVBRGdBWVFBa0hBQkFQQ3dTQURna0FMek1helRJUkVnRTVPVEV3QVRZMk56TVdGaGNWSXlZbkJnY2pBUXgvWmhlbUZtMTlkMWlGaUZOekJQQ0lnQ2txaFlJWE40T0dOQUFBQVFFTUJOa0RyZ1loQUE0QUdFQUpCZ0FRRHdVQmdBTUxBQzh6R3MweUVSSUJPVGt4TUFFekZoYzJOek1WQndZSEl5WW1Kd0VNYzNKcGdsdDNRcEF1cGhkbWZ3WWhTbk9DT3hsRWxGY3Bmb2dBQUFFQkxRVFpBNFVGWWdBREFCRzFBQUVFQlFBREFDOHpFUklCT1RreE1BRWhGU0VCTFFKWS9hZ0ZZb2tBQVFFbEJOa0RrUVhsQUE0QUdFQUpEQU1RRHdzRWdBZ0FBQzh5R3N3eUVSSUJPVGt4TUFFaUppY3pIZ0l6TWpZM013WUdBbGFNbkFsb0JpbEpWV1ZnQ21nS3B3VFppWU14T0JwQVEzNk9BQUFCQUtJRkFnRm1CZDhBQ3dBVHRnWUFBQXdOQXdrQUw4MFJFZ0U1RVRNeE1CTTBOak15RmhVVUJpTWlKcUk0S2lnNk9pZ3FPQVZ4T1RVMk9EZzNOd0FBQWdGdkJOa0RMUWFGQUFzQUZ3QWVRQXdTQmd3QUJnQVlHUThKRlFNQUx6UE1NaEVTQVRrNUVUTVJNekV3QVJRR0l5SW1OVFEyTXpJV0J6UW1JeUlHRlJRV016STJBeTE3Wm1WNGVXUmxmR3hDTXpOQ1BEazBRUVd5WW5kMVltSnpkMTQ0UFQwNE9EMDlBQUVBSmY1Q0FYRUFBQUFQQUJoQUNnQUpCQTBKQXhBUkFnY0FMek1SRWdFWE9SRXpNVEFYRkRNeU54VUdJeUkxTkRZM013WUdzbDRxTjBFOHoxWkllRVJGN2w0TmJSSzhSb2MxUW0wQUFBRUJDQVRaQS9BRjNRQVhBQ1JBRHdrVkdCa1JBQVVNQUF3QURCV0FDUUF2R3N3NU9TOHZFVE1STXhFU0FUazVNVEFCSWk0Q0l5SUdCeU0yTmpNeUhnSXpNalkzTXdZR0F4UXJVazlKSWpJekRtSU5jMXN1Vms1SUlERXdEMk1OY1FUYkpTMGxQRDE1aVNVdEpUcytlWWtBQUFJQTV3VFpBN1lHSVFBSkFCTUFHMEFNRGdVVENRUVVGUTBFZ0JNSkFDOHpHczB5RVJJQkZ6a3hNQk0yTmpjekZRWUdCeU1sTmpZM014VUdCZ2NqNXlSdUg3b2xxenBoQVdVeFpScTZKYXM2WUFUeU1McEZGVC9FTUJsRXNUb1ZQOFF3QUFBQkFmd0UyUU1RQm5NQUNRQVR0Z1FBQ3dvRWdBa0FMeHJORVJJQk9Ua3hNQUUyTmpjekZRWUdCeU1CL0JzMURMZ1NiVEZrQlBaSTQxSVhTdTFNQUFNQkd3VU9BNE1HdEFBSUFCUUFJQUFyUUJRUENSVWJHd01JQ1FRaEloZ01DQXdJREFNZUVnQXZNOHc1T1M4dkVUTVJFZ0VYT1JFekVUTXhNQUUyTnpNVkJnWUhJeWMwTmpNeUZoVVVCaU1pSmlVME5qTXlGaFVVQmlNaUpnSUFRUis5SVhrelVPVTBKaWt4TnlNbU5BRzBOQ1lwTVRjakpqUUZoYW1HRkVPelBRUTBMalF1TWpFeE1qUXVOQzR5TVRILy93QUFBQUFGRUFZS0FpWUFKQUFBQVFjQlZQNGcvNWNBQjdJQ0VnQUFQelVBLy84QW1BSk1BWWtEV2dJR0FIa0FBUC8vLzlRQUFBUjFCZ29BSmdBb2ZRQUJCd0ZVL2RqL2x3QUhzZ0VRQUFBL05RRC8vLy9VQUFBRnRRWUtBQ2NBS3dDV0FBQUJCd0ZVL2RqL2x3QUhzZ0VRQUFBL05RRC8vLy9rQUFBRFJBWUtBQ2NBTEFEdUFBQUJCd0ZVL2VqL2x3QUhzZ0VRQUFBL05RRC8vLy9rLyt3R0FnWUtBQ1lBTWtRQUFRY0JWUDNvLzVjQUI3SUNIQUFBUHpVQS8vLy8xQUFBQllVR0NnQW5BRHdCQ2dBQUFRY0JWUDNZLzVjQUI3SUJEUUFBUHpVQS8vLy81QUFBQmpNR0NnQW1BWFkvQUFFSEFWVDk2UCtYQUFleUFTTUFBRDgxQVAvLy8rbi83QUtUQnJRQ0pnR0dBQUFCQndGVi9zNEFBQUFNdFFNQ0FTNFJKZ0FyTlRVMS8vOEFBQUFBQlJBRnZBSUdBQ1FBQVAvL0FNa0FBQVMrQmJZQ0JnQWxBQUFBQVFESkFBQUQrQVcyQUFVQUhVQU9Bd1FFQUFZSEJRSkpXUVVEQkJJQVB6OHJFUklCT1RrUk16RXdBUlVoRVNNUkEvajllNm9GdHBuNjR3VzJBUC8vQUNjQUFBUnRCYllDQmdJb0FBRC8vd0RKQUFBRCtBVzJBZ1lBS0FBQS8vOEFVZ0FBQkQ4RnRnSUdBRDBBQVAvL0FNa0FBQVVmQmJZQ0JnQXJBQUFBQXdCOS8rd0Z2Z1hOQUFNQUR3QWJBRDlBSUFJREVCWVFDaFlFQ2dRY0hRQURTVmtBQUFjTkRSbEpXUTBFQnhOSldRY1RBRDhyQUJnL0t4RVNBRGtZTHlzUkVnRTVPUkV6RVRNUkVqazVNVEFCSVJVaEpSQUFJU0FBRVJBQUlTQUFBUkFTTXpJU0VSQUNJeUlDQWVNQ2RmMkxBOXYrbmY3RS9yMytvUUZnQVVRQk93RmkrM1A2OVBQNDkvTDErd016bFQvK29mNXVBWXNCYUFGbEFZbitjUDZnL3RqK3pBRXdBU3dCS2dFdS9zNEEvLzhBVkFBQUFsWUZ0Z0lHQUN3QUFQLy9BTWtBQUFUcEJiWUNCZ0F1QUFBQUFRQUFBQUFFMHdXMkFBb0FHa0FMQ0FBTUN3UUlDUU1CQ0JJQVB6TS9FamtSRWdFNU9URXdJU01CSmljR0J3RWpBVE1FMDdiK3RsY1dJVWYrdUxZQ0VMRURvUHhhaThuOFhnVzIvLzhBeVFBQUJuRUZ0Z0lHQURBQUFQLy9BTWtBQUFVL0JiWUNCZ0F4QUFBQUF3QklBQUFFSlFXMkFBTUFCd0FMQURSQUhRb0hBd0lHQ0FZTkRBQURTVmtBQUFvRUNndEpXUW9TQkFkSldRUURBRDhyQUJnL0t4RVNBRGtZTHlzUkVnRVhPVEV3RXlFVklRTWhGU0VCRlNFMXd3TG4vUmxTQTR2OGRRTzAvQ01EU0pZREJKZjdlWmlZLy84QWZmL3NCYjRGelFJR0FESUFBQUFCQU1rQUFBVU1CYllBQndBalFCRUJBQVFGQUFVSkNBWURTVmtHQXdFRkVnQS9NejhyRVJJQk9Ua1JNeEV6TVRBaEl4RWhFU01SSVFVTXF2MFJxZ1JEQlIvNjRRVzJBUC8vQU1rQUFBUm9CYllDQmdBekFBQUFBUUJLQUFBRVhBVzJBQXdBTlVBY0NBb0tBQWtDQ3dZREFnQUZEUTRIQ0FRSVNWa0VBd0FLU1ZrQUVnQS9Ld0FZUHlzUkFETVJFZ0VYT1JFekVUTVJNekV3TXpVQkFUVWhGU0VuQVFFaEZVb0I0ZjRyQTh2OVhHQUJ6UDRmQTFTTkFtOENLNCtaQXYzZi9acVlBUC8vQUJJQUFBUmFCYllDQmdBM0FBRC8vd0FBQUFBRWV3VzJBZ1lBUEFBQUFBTUFhdi9zQmZnRnl3QVpBQ0lBS3dCUVFDa25GQm9DRFEwckdRNGVCd2NPRkFNc0xRd1FHaW9RS2twWklpUVlKRXBaQWhnUUdCQVlEaE1BQkFBL1B6azVMeThSTXlzUkFETXJFUUF6RVRNUkVnRVhPUkV6RVRNek14RXpNeEV6TVRBQk14VXpNaFlXRlJRQ0JDTWpGU00xSXlJa0FqVTBOall6TXhNek1qWTFOQ1lyQXlJR0ZSUVdNek1DMjZ4R3EvdUZsZjc5c0Ntc0xiRCsvcEtIL0t0RHJCbkozODY1T3F3NXR0SGV5aGdGeTdTSStKK20vdjJDNGVHRUFRU2hudmlML0VYYnc3blMxTGZGMlFELy93QUlBQUFFbGdXMkFnWUFPd0FBQUFFQWJRQUFCZklGdGdBZEFENUFId29IRVFBQURnRVZHQmdCQndNZUh4MEREUU5KV1JFTkRRRVdEd2dEQVJJQVB6OHpNeEk1THpNckVRQXpFUklCRnprUk14RXpNeEV6RVRNeE1DRWpFU01pSmlZMUVUTVJGQll6TXhFekVUTXlOalVSTXhFVUJnUWpJd09EcWkydy81Q3V6OVFicWgzVHo3Q1EvdjJ2TFFHK2V2ZWtBZVArSWJ6SkEyVDhuTWE3QWVQK0g2WDNld0FBQVFCUUFBQUY5QVhOQUI4QU9VQWdBdzBkRXhnVEZoa0hDZzBJQ0NBaEVBQkpXUkFFR2hZR0NRZ0pTVmtaQ0JJQVB6TXJFUUF6TXpNWVB5c1JFZ0VYT1JFekVUTXhNQUVpQWhVVUVoY1ZJVFVoSmdJMUVBQWhJQUFSRkFJSElSVWhOVFlTTlRRQ0F5SHUrcTIwL2JZQmJKZWdBV0lCT2dFN0FXS2Vsd0ZyL2JhM3Fma0ZOZjcvL2VIK3M0U0ZtSFlCWHNzQk5nRmcvcVgreDgvK3BuaVloWVlCVHQ3OEFRTC8vd0E4QUFBQ2J3Y2xBaVlBTEFBQUFRY0FhdjhIQVZJQUNyUUNBU0VGSmdBck5UWC8vd0FBQUFBRWV3Y2xBaVlBUEFBQUFRY0Fhdi92QVZJQUNyUUNBUjRGSmdBck5UWC8vd0J6Lyt3RXh3WnpBaVlCZmdBQUFRWUJWQjBBQUFpekFqUVJKZ0FyTmYvL0FGci83QU9IQm5NQ0pnR0NBQUFCQmdGVXlBQUFDTE1CTHhFbUFDczEvLzhBc1A0VUJFUUdjd0ltQVlRQUFBRUdBVlE3QUFBSXN3RWVFU1lBS3pYLy93Q28vK3dDa3daekFpWUJoZ0FBQVFjQlZQN0VBQUFBQ0xNQkdSRW1BQ3MxLy84QXBQL3NCSEVHdEFJbUFaSUFBQUVHQVZVN0FBQU10UU1DQVRRUkpnQXJOVFUxQUFJQWMvL3NCTWNFWEFBTEFDb0FSMEFrQ1E4bkZRUUVIU0lkRHdNckxCZ1BKeWdvRmd3U0VnZEdXUklRSHdBTUFFWlpKQXdXQUQ4ekt4RUFNeGcvS3hFU0FEazVFVE1ZUHhFU0FSYzVFVE1STXpNUk16RXdKVEkyTlRVMEppTWdFUlFXRnlJQ0VSQVNNeklXRnpNMk56TUdCaFVSRkRNeU54VUdJeUltSnlNR0JnSlFxWmFZcWY3Ums0WFc3dlRoZWFFMkRCZ3BnUlVjVkIwaExrRlJXUklOTzZkM3c5b1A1Y2YrVU5UVWl3RXBBUXdCRWdFcFZGUmNPRUwyZFA1SmNncDNHbEZXVmxFQUFnQ3cvaFFFcUFZZkFCTUFLUUJNUUNnWUR3OFFKd01lQ0FnREJTSVFCU29yRUJzaklrWlpEaU1PSXdzQUN4dEdXUXNXQUJSR1dRQUFBRDhyQUJnL0t4RVNBRGs1R0M4dkt3QVlQeEVTQVJjNUVUTVJNeEV6RVRNeE1BRXlGaFVRQlJVRUVSUUVJeUltSnhFakVUUTJGeUlHRlJFV0ZqTXlOalUwSmlNak5UTXlOalUwSmdLVDNQbit4d0Y1L3ZqdWJhQlBwdjNrbnAxZG9WYXJyYjZ4Y0Z5Ym9wd0dIOUMzL3RvekNDcitrZEhoSHliOTR3WTA0ZmFNcktYOGlURWxscDJkcEk2VGlYdUZBQUVBQ3Y0VUJBNEVTQUFTQUNGQUVBOEVBUVVFRXhRS0NRa0JEZ1VQQVJzQVB6OHpFamt2TXhFU0FSYzVNVEFCSXpRU053RXpFeFlYTXo0Q0V6TUJCZ0lDRkxSQUsvNC9yUEJlRXdnRktTdnFyUDVyTURYK0ZHQUJKbklFUFAyNDYyY2Vqb0VDYmZ2VGZQN2NBQUlBY2Yvc0JHQUdFZ0FlQUNvQU8wQWdKUndRQXg4V0Zna0FBeHdGS3l3UUFDSURHUVlaS0VaWkdSWUdEVVpaQmdBQVB5c0FHRDhyRVJJQUZ6a1JFZ0VYT1JFekVUTVJNekV3QVNZbU5UUTJNeklXRndjbUppTWlCaFVVRmhjV0ZoVVVBQ01pSkRVMEVnRTBKaWNHQmhVVUZqTXlOZ0loakhUQ3BHZTlma2h3bjFGVllXdW4wckgrOE96ai92RGlBbUY3amM2L3NwT2lyZ09vVHA5amdwZ3RQNGMrTEU5Q1IyOWJjL0drNi83NCtOS3hBUVgrYzRDM1NqWFpvSkNydWdBQUFRQmEvK3dEaHdSY0FDVUFUVUFyQkJBakZ4MExBUk1YRUFZbUp4UWxBaVVDUmxrUEpSOGxBZ3NESlNVTkdob2hSbGthRUEwSFJsa05GZ0EvS3dBWVB5c1JFZ0E1R0M5ZlhsMHJFUklBT1JFU0FSYzVFVE1STXpFd0FSVWpJQlVVRmpNeU5qY1ZCaU1pSmpVME5qYzFKaVkxTkRZek1oWVhCeVltSXlJVkZDRUN5NVQreVpPU1ZLWmtpZDNTOFc2Q1ltdmd3R0dsWkQ5ZWdrLzZBVDBDZ1kzRFdtSW5MNVJMcVpSaWd5a0xISDljaFo0aExZVXFIS0tzQUFBQkFIUCtid09nQmhRQUlBQXdRQmdIR1I0VEV3NE9Bd0FaQkNFaUVTTWVBd0FCQUVaWkFRQUFQeXNSQURNekdEOFJFZ0VYT1JFekVUTVJNekV3RXpVaEZRWUFBaFVVRmhZWEZoWVZGQWNqTmpVMEppY21KalUwUGdJM0JpR3dBdkRYL3VDS08zMnNsWWgvcG4xdmo4dThPM0RKOGlqKzhRV0hqWUcwL3IzKzM2Wmlka2tsSDIxYmxhU2hhemc5R2lUYnduTFF3K1hhQ0FBQUFRQ3cvaFFFUkFSY0FCUUFMMEFZQUJRTUNBZ0pGQWtXRlJBRVJsa1FFQXdKQ2c4SkZRQWJBRDgvUHhJNVB5c1JFZ0U1T1JFekVUTVJNekV3QVJFMEppTWlCaFVSSXhFekZ6TTJOak15RmhVUkE1NTZncXlncG9jYkNETzRjY2JJL2hRRXNZYUV1dGI5d1FSSWxsRlp2OUw3U1FBREFIUC83QVJLQmlzQUN3QVNBQmtBU1VBbkZoQVFCaGNQRHdBR0FCb2JGaEJHV1E4V3Z4WUNDd01XRmdNSkNSTkdXUWtCQXd4R1dRTVdBRDhyQUJnL0t4RVNBRGtZTDE5ZVhTc1JFZ0U1T1JFekVUTVJNeEV6TVRBQkVBSWpJZ0lSRUJJek1oSUJNaElUSVJJU0V5SUNBeUVDQWdSSzlQcncrZlgwOVByK0VxU2NCdjE1Qkphbm9aWUtBb1VMbUFNTS9tcitkZ0dUQVkwQmx3R0kvbXY3NFFFeEFUUCswUDdNQlNuKzRmN25BUmtCSHdBQkFLai83QUtUQkVnQUR3QWZRQTRCRGdjT0VSQVBEd3NFUmxrTEZnQS9Ld0FZUHhFU0FUazVFVE14TUFFUkZCWXpNalkzRlFZR0l5SW1OUkVCVGtsWEpXVWJIMmt5b0pFRVNQejZhR1VOQjM4TkVhaXBBd3YvL3dDd0FBQUVHd1JHQWdZQStnQUFBQUgvOHYvc0JFWUdJUUFpQUROQUd3Z0JGUU1rQUFBakdCTkdXUmdXSGg4ZkFBc0xCa1paQ3dFQUZRQS9QeXNSRWdBNUVUTVlQeXNSQVRNUkVoYzVNVEFqQVNjdUFpTWlCelUyTXpJV0ZoY0JGaFl6TWpjVkJpTWlKaWNESmljakJnY0REZ0haT2g0eVF6RTZPVVEvVzNsWU5nRnJFeW9qR3lFd1BVcFRIWnhVRmdrY1dQNEVONkpWUmlRTmhSRThncGo4RERFekNua1lURk1CdFBCZ2ROSDl0Z0QvL3dDdy9oUUVSQVJJQWdZQWR3QUFBQUVBQUFBQUJBSUVTQUFPQUJ4QURBa0tDZ0FRRHdVT0ZRa0FEd0EvTWo4NUVSSUJPVGtSTXpFd0VUTVRGaFlYTXpZU0VUTVFBZ2Nqck5zYVV4QUlzWitteitHNkJFajlza1B1UHE4QnZRRlIvcFgrQk9FQUFRQngvbThEb0FZVUFERUFTVUFuQkJrdEh4MGNFd3dNS0FBY0h5VVpCekl6SERBQk1BRkhXVEF3RUNZcEpTWWxSbGttQUJBakFEOC9LeEVBTXhFU09SZ3ZLeEVTQURrUkVnRVhPUkV6RVRNUk14RXpNVEFCSXlJR0ZSUWVBaGNXRmhVVUJnY2pOalkxTkNZbkppWTFORFkzTlNZMU5EWTNCaU1qTlNFVkl5SUdCaFVVRmpNekExYXlzTlV5WDRkVWpvYzJRNXcxUW5PUHlNZWVnTm1McG9CelJBSzZNNExnZjZldnFnTHlzbzVRWWowa0VoMXVXa0dWWTBlVE5EYzlHU0xJc0l6U0p3eEEyWFdlTWd5TmcxQ1FYM05zLy84QWMvL3NCR0lFWEFJR0FGSUFBQUFCQUJuLzdBVDBCRWdBRlFBMlFCMEtDd2NURUFNVEN3MEZGaGNTQ1EwUERVWlpEdzhMRlFVQVJsa0ZGZ0EvS3dBWVB6OHJFUUF6TXhFU0FSYzVFVE1STXpFd0pUSTNGUVlqSWpVUklSRWpFU00xTnlFVkl4RVVGZ1I5SmpBclZOditJNmJkandSTTFUTjFFb01ZL1FMUi9FWUR1a3BFanYwOFNqY0FBZ0NtL2hRRVlnUmNBQkFBSEFBMlFCc1ZDUWtLR2dBS0FCMGVCZ01PRGhGR1dRNFFDaHNERjBaWkF4WUFQeXNBR0Q4L0t4RVNBRGtSRWdFNU9SRXpFVE1STXpFd0FSQUFJeUluSXhZVkVTTVJFQkl6TWhJbElnWVZFUll6TWpZMU5DWUVZdjhBNmJONENBaW8rK3JiL1A0aG5wZDZ0NStZa0FJbC92SCsxbDQ5MVA3YkJCOEJDZ0VmL3RHaXo5SCtybWJRM3RiVUFBQUJBSFArYndPaUJGd0FJQUF1UUJjT0J3QVZGUWNiQXlJaEJCSVNHQXNZSGtaWkdCQUxJd0EvUHlzUkVnQTVFVE1SRWdFWE9SRXpFVE14TUFFVUZoWVhGaFlWRkFZSEl6WTJOVFFtSmljbUpqVVFBRE15RmhjSEppTWlCZ0VmTzQrZ2xJTTJRNXcyUXpOdVljekRBUlQ0VDU0Mk5ZSnlzS29DQ29lRVVDSWdhMXBDbUY5R2xESW9MeVlTSmY3YkFSNEJOaUVZalRQYUFBSUFjLy9zQkxZRVNBQU5BQmtBTUVBWkZBQU9Cd2NNQUFzRUd4b01Gd2tYUmxrSkR3UVJSbGtFRmdBL0t3QVlQeXNSQURNUkVnRVhPUkV6RVRNeE1BRVVCZ1lqSWdBMUVDRWhGU0VXQVJRV016STJOUkFuSXlJR0JHQjc1WnJyL3ZnQ1VBSHovdml5L0wrcW9aK3Jya0hleUFIOG5mR0NBU0QrQWo2T3AvNzN3dEhGdGdFT3V0QUFBQUVBRXYvbkE1TUVTQUFUQUN4QUZ3TVBBQWtQRVFRVUZRSVJFeEZHV1JNUERBVkdXUXdXQUQ4ckFCZy9LeEVBTXhFU0FSYzVFVE14TUFFVklSRVVNekkyTnhVR0JpTWlKalVSSVRVM0E1UCtVTTB2WWhzamJ6QzFxdjdYbEFSSWp2MlczdzBIZlE4U3Fxb0NmMHBFQUFBQkFLVC83QVJ4QkVnQUZRQWxRQkVNRXdZREV3TVhGZzhFRHdBSlJsa0FGZ0EvS3dBWVB6TVJFZ0U1T1JFekVUTXhNQVVpSmhFUk14RVVGak15TmpVMEppY3pGaFlWRUFBQ2MrZm9wcDZacDZFY0lxWWtIUDcrRlBvQkNnSlkvYkRBdys3N2d1Q0lrTmFNL3NMKzFBQUFBZ0J6L2hRRlRBUmNBQmdBSWdCQlFDTUtCQ0FZR0F3QUdSTVRBQWNFQkNNa0VCeEdXUkFRQmc4Z0RBRU1SbGtYQVJZQUd3QS9Qek1yRVFBekdEOC9LeEVTQVJjNUVUTVJNek1STXhFek1UQUJFU1FBRVJBM0Z3WUdGUkFGRVRRMk16SVNGUlFDQmdjUkFUUW1JeUlHRlJFMk5nS0QvdnorOU0rRFdWRUJhS2FWdE5xSStLVUJlWHhtU1U2enh2NFVBZG9MQVNNQkR3RW8vVnAxNEh6K2RTTUNiTHUrL3R2NnN2NzdrQWorSmdRbnVkdDRjdjJTRU93QUFmL3MvaFFFVUFST0FDQUFPVUFoRGdjSUJSVVlIZ2NpRnlFRkdBZ1ZCQVlYR3hFTVJsa1JHd1lQQUJ4R1dRQVBBRDhyQUJnL1B5c0FHRDhTRnprUkFUTVNGemt4TUJNeUZoWVhFd0V6QVJNV0ZqTXlOeFVHSXlJbUp3TUJJd0VESmlZaklnYzFOckkyVGo0c2tRRSt0UDVVdmpCU1B5MHRQRHR6alR1Vy9wYXlBZENzSmtZckpSc3hCRTRyVzNEK2p3SmgvUHorSEhwS0NJRVBkcDhCZy8xb0EwUUJ2R05RQzRFUkFBRUFwUDRVQlljR0VnQWFBRDFBSHhZVEFRNE9HUThFQ2dvUEV3TWJIQm9BQnhRUEFSa1FHVVpaRFJBV0R4c0FQejh6S3hFQU14Zy9NejhSRWdFWE9SRXpFVE16RVRNUk16RXdBUkUyTmpVMEppY3pFaFVRQUFVUkl4RWtBQkVSTXhFVUZoY1JBMXE4eXhvbHBqLys0Lzd3cFA3NC92YW10TGdHRXZwcEQrZk1lT3VvL3ZEMC91eit6aEQrSmdIYUNRRWlBUkFDSC8zYnc5b05CWmtBQVFCei8rd0Z2QVJJQUNjQVBVQWVDZ01tRXhNUUdTQWdFQU1ES0NrbUVSRUFIQVlQRmcwQURVWlpJd0FXQUQ4eUt4RUFNeGcvTXhJNUx6a1JFZ0VYT1JFekVUTVNPUkV6TVRBRklnSTFOQkkzTXdZR0ZSUVdNekkyTlJFekVSUVdNekkyTlRRQ0p6TVdFaFVVQWlNaUp5TUdBZlMyeXpkRXJFUTVlR3RlYWFGcVhXdDROMFdzUVRuTHR0eEVDVUVVQVNqK25BRUJtWnovbmNIWWozMEJOLzdKZ0l6WXdaY0JCSjJTL3ZtZC9QN1d0cmIvL3dBSi8rd0Nrd1hUQWlZQmhnQUFBUWNBYXY3VUFBQUFDclFDQVNVUkpnQXJOVFgvL3dDay8rd0VjUVhUQWlZQmtnQUFBUVlBYWprQUFBcTBBZ0VyRVNZQUt6VTEvLzhBYy8vc0JHSUdjd0ltQUZJQUFBRUdBVlFoQUFBSXN3SWlFU1lBS3pYLy93Q2svK3dFY1FaekFpWUJrZ0FBQVFZQlZDY0FBQWl6QVI4UkpnQXJOZi8vQUhQLzdBVzhCbk1DSmdHV0FBQUJCd0ZVQU1rQUFBQUlzd0V4RVNZQUt6WC8vd0RKQUFBRCtBY2xBaVlBS0FBQUFRY0FhZ0FuQVZJQUNyUUNBU0VGSmdBck5UVUFBUUFTLyt3RlFnVzJBQjBBUmtBbUZnNE9Ed2diR3hRQ0R4RUZIaDhXRFVsWkZoWVBFaFVSRWhGSldSSUREeElBQlVsWkFCTUFQeXNBR0Q4L0t4RUFNeEVTT1Jndkt4RVNBUmM1RVRNUk14RXpNVEFGSWljMUZqTXlOalUxTkNZaklSRWpFU0UxSVJVaEVTRXlGaFVWRkFZRHoyQTJOMXRsYUlPTS9vT3EvckFEdC81REFZek4zY1FVRnBZVGZIQ0RnSEg5R3dVZmw1ZitYcit5ajc3VC8vOEF5UUFBQS9nSGN3SW1BV0VBQUFFSEFIWUFXZ0ZTQUFpekFROEZKZ0FyTlFBQkFIMy83QVRqQmMwQUdBQTRRQjRHQXhFV0RBVVJCQmthQXdaSldRTUREaFFVQUVsWkZBUU9DVWxaRGhNQVB5c0FHRDhyRVJJQU9SZ3ZLeEVTQVJjNUVUTXpNVEFCSWdRSElSVWhFZ0F6TWpjVkJpTWdBQkVRQUNFeUZ3Y21BMExpL3ZNZUF0UDlLUW9CQy9taXlhSGkvclQrb2dGNUFVN3Rza2VwQlRQNjhaYis3djdqTjVVNUFZUUJiUUZmQVpGWWxGTC8vd0JxLyt3RUFnWExBZ1lBTmdBQS8vOEFWQUFBQWxZRnRnSUdBQ3dBQVAvL0FEd0FBQUp2QnlVQ0pnQXNBQUFCQndCcS93Y0JVZ0FLdEFJQklRVW1BQ3MxTmYvLy8yRCtmd0ZvQmJZQ0JnQXRBQUFBQWdBQS8ra0hJd1cyQUJvQUl3QkhRQ1lZR3hzRUh3QUFCQTBESkNVWUkwbFpHQmdMRmhZR1NWa1dBd3NRU2xrTEVnUWJTbGtFRWdBL0t3QVlQeXNBR0Q4ckVSSUFPUmd2S3hFU0FSYzVFVE1STXhFek1UQUJGQVFoSVJFaEFnSUdCaU1pSnpVV016SStBaElUSVJFeklBRXpNalkxTkNZakl3Y2ovdTMrL1A2NS9wTTVWRkNMYTBWQU1qOHdRU3MzUkVFQ3Bub0NPdjFNaGNhM3dOeG1BYXJPM0FVZi9rajk5dnQ1R1k4YVBtZjZBYjRCNHYyUS9VMkxqSXA4QUFJQXlRQUFCMVFGdGdBUkFCb0FTa0FtQ3djSENBOFNFZ3dFRmdBQUJBZ0RHeHdhQmdzR1NWa1BDd3NFRFFrRENCSUVFa3BaQkJJQVB5c0FHRDgvTXhJNUx6TXJFUUF6RVJJQkZ6a1JNeEV6TXhFekVUTVJNekV3QVJRRUlTRVJJUkVqRVRNUklSRXpFVE1nQVRNeU5qVTBKaU1qQjFUKzhQNzcvcmY5ZmFxcUFvT3NlUUk1L1U2RnhMbkIyMllCcXM3Y0FyRDlVQVcyL1pJQ2J2MlEvVTJMaklsOUFBQUJBQklBQUFWQ0JiWUFFd0E2UUI4QURBd05CZ1VGRWcwUEJCUVZFdzhRRDBsWkFBdEpXUUFBRFJBREJnMFNBRDh6UHhJNUx5c3JFUUF6RVJJQkZ6a1JNeEV6RVRNeE1BRWhNaFlWRVNNUk5DWWpJUkVqRVNFMUlSVWhBZ3dCa00zWnFuMk0vbjJxL3JBRDl2NEVBMzI4dGYzMEFmWitjZjBiQlIrWGwvLy9BTWtBQUFUbEIzTUNKZ0cwQUFBQkJ3QjJBS0lCVWdBSXN3RVVCU1lBS3pYLy93QWIvK3dFK0FkZUFpWUJ2UUFBQVFjQ05nQkVBVklBQ0xNQkZ3VW1BQ3MxQUFFQXlmNkRCUXdGdGdBTEFEQkFHQWdGQWdNSkFBQURCUU1NRFFvR0F3VUlTVmtCQlJJRElnQS9Qek1yQUJnL014RVNBUmM1RVRNUk14RXpNVEFoSVJFakVTRVJNeEVoRVRNRkRQNHZzUDQrcWdMdnF2NkRBWDBGdHZya0JSd0EvLzhBQUFBQUJSQUZ2QUlHQUNRQUFBQUNBTWtBQUFSOUJiWUFEUUFXQUQxQUlCSUFDUTRPQkFRSEFBTVlGd2tXU1ZrSkNRUUZCUWhKV1FVREJBNUtXUVFTQUQ4ckFCZy9LeEVTQURrWUx5c1JFZ0VYT1JFekVUTVJNekV3QVJRRUlTRVJJUlVoRVRNeUZoWUJNekkyTlRRbUl5TUVmZjc5L3Z2K1ZBTmUvVXpqd2ZKMC9QYnZ2cTJ3Mjg4QnF0clFCYmFYL2lkWnJ2NVVncFdPZUFELy93REpBQUFFdmdXMkFnWUFKUUFBLy84QXlRQUFBL2dGdGdJR0FXRUFBQUFDQUE3K2d3VktCYllBRFFBVEFFTkFKQVFGRXdjUUNnNE1BUUFBREFvSEJRVVVGUW9RU1ZrS0F3RUZJaE1NQmdNR1NWa0RFZ0EvS3hFQU16TVlQek0vS3hFU0FSYzVFVE1STXhFekVUTVJNekV3QVNNUklSRWpFVE1TRWhNaEVUTWhFU0VHQWdjRlNxTDhDS0p4bXRzTUFwRzUvcDMrc3hMT2lmNkRBWDMrZ3dJWEFRTUM1Z0V6K3VRRWcvTDlXZW9BLy84QXlRQUFBL2dGdGdJR0FDZ0FBQUFCQUFJQUFBYThCYllBRVFBOFFCOEdEUTBERGdvSkNBRU9BQkVIRWhNUERBa0dBd0FBQVE0TEVSSUhCQUVEQUQ4ek16OHpNeEk1RVRNek16TXpFUklCRnprUk16TVJNekV3QVFFekFSRXpFUUV6QVFFakFSRWpFUUVqQWxiOXdiNENPYVFDT3I3OXdBSlN4UDI2cFAyN3h3THdBc2I5UEFMRS9Ud0N4UDA4L1E0QzVmMGJBdVg5R3dBQkFFci83QVExQmNzQUtBQkRRQ1FjQUJNSEJ3QURGeU1NQmlrcUF4Z1hHQmRLV1JnWUNpWW1IMHBaSmdRS0VFcFpDaE1BUHlzQUdEOHJFUklBT1Jndkt4RVNBRGtSRWdFWE9SRXpFVE14TUFFVUJnY1ZGaFlWRkFRaElpYzFGaFl6TWpZMU5DWWpJelV6TWpZMU5DWWpJZ1lISnpZMk16SVdCQm0zb2JlOS9zNys2ZitqWU45bnhzdmgzOXJSemVHaWlXNnlkVlJsKzRmaC93UmdrTFFZQ0JtMGtjM2xUNTR1TXBhTmhvcVBrNFJyZ0RKS2NrdE54UUFCQU1zQUFBVlNCYllBRHdBMFFCZ09BZ0lQQmdrSkNBOElFQkVGQkF3TkJBMEpEeElHQUFNQVB6SS9Nems1RVRNUk14RVNBVGs1RVRNUk14RXpFVE14TUJNekVSUUhNd0V6RVNNUk5EY2pBU1BMbnc0SUF6UzZvQkVKL011NkJiYjgwK0cyQk1UNlNnTWx5ZDM3TlFELy93RExBQUFGVWdkZUFpWUJzZ0FBQVFjQ05nRGhBVklBQ0xNQkVBVW1BQ3MxQUFFQXlRQUFCT1VGdGdBS0FDMUFGZ2NEQXdRQUNRb0VCQXNNQ2djQ0J3UUlCUU1CQkJJQVB6TS9NeEk1T1JFekVSSUJGemtSTXhFek1UQWhJd0VSSXhFekVRRXpBUVRsenYxY3Fxb0NrOFA5ZVFMbC9Sc0Z0djA4QXNUOU9nQUJBQUQvNXdUWkJiWUFFd0F0UUJnREVnRUFBQklLQXhRVkVnTkpXUklEQ0ExS1dRZ1RBUklBUHo4ckFCZy9LeEVTQVJjNUVUTVJNekV3SVNNUklRY0NBZ1luSWljMUZqTXlOallTRXlFRTJhcitKUjg5WFpoK1NqczJPelZQUFYwNEF4SUZIL0QrSWY1RnJnSVpqeHBYMXdKWkFiai8vd0RKQUFBR2NRVzJBZ1lBTUFBQS8vOEF5UUFBQlI4RnRnSUdBQ3NBQVAvL0FIMy83QVcrQmMwQ0JnQXlBQUQvL3dESkFBQUZEQVcyQWdZQmJnQUEvLzhBeVFBQUJHZ0Z0Z0lHQURNQUFQLy9BSDMvN0FUUEJjc0NCZ0FtQUFELy93QVNBQUFFV2dXMkFnWUFOd0FBQUFFQUcvL3NCUGdGdGdBV0FDcEFGUklJQWdrRUZ4Z09EUWdOQUJFSkF3QUZTVmtBRXdBL0t3QVlQek1TT1RrUk14RVNBUmM1TVRBRklpYzFGak15TmpjQk13RVdGek0yTndFekFRNENBU1Z2VkYxZ2JvVkMvY2U4QWJBWkRnZ2NDd0ZudFA0dFZJZXBGQjZtSzJXTEJFSDh3VEV2VkJZRE5mdnF1NnBQLy84QWF2L3NCZmdGeXdJR0FYTUFBUC8vQUFnQUFBU1dCYllDQmdBN0FBQUFBUURKL29NRnVBVzJBQXNBTWtBWkNBVUpBQU1DQWdBRkF3d05DZ1lEQUFnRkNFbFpCUklESWdBL1B5c1JBRE1ZUHpNUkVnRVhPUkV6RVRNUk16RXdKVE1SSXhFaEVUTVJJUkV6QlF5c29mdXlxZ0x2cXByOTZRRjlCYmI2NUFVY0FBQUJBS29BQUFUSEJiWUFFd0F0UUJZTENCRUJBUUFJQUJRVkJRNUpXUVVGQVJJSkF3RVNBRDgvTXhJNUx5c1JFZ0U1T1JFekVUTVJNekV3SVNNUkJnWWpJaVkxRVRNUkZCWXpNalkzRVRNRXg2cVZ4bXJQMzZwL2oyR3hxYW9DWERVbnZyTUNSZjNQZVhRZE53TEtBQUVBeVFBQUIza0Z0Z0FMQURGQUdBUUJDQVVKQUFBRkFRTU1EUW9HQWdNSUJBRUVTVmtCRWdBL0t4RUFNeGcvTXpNUkVnRVhPUkV6RVRNUk16RXdJU0VSTXhFaEVUTVJJUkV6QjNuNVVLb0NXS29DV0t3RnR2cmtCUno2NUFVY0FBRUF5ZjZEQ0FRRnRnQVBBRHRBSGdNQUJ3UUlDdzRORFFzRUFBUVFFUTRpQ1FVQkF3c0hBd0FEU1ZrQUVnQS9LeEVBTXpNWVB6TXpQeEVTQVJjNUVUTVJNeEV6RVRNeE1ETVJNeEVoRVRNUklSRXpFVE1SSXhISnFnSkhyQUpJcXF5aUJiYjY1QVVjK3VRRkhQcmsvZWtCZlFBQUFnQVNBQUFGRndXMkFBd0FGUUE5UUNBSkRRMEVFUUFBQkFZREZoY0pGVWxaQ1FrRUJ3Y0dTVmtIQXdRTlNsa0VFZ0EvS3dBWVB5c1JFZ0E1R0M4ckVSSUJGemtSTXhFekVUTXhNQUVVQkNNaEVTRTFJUkV6SUFRQk16STJOVFFtSXlNRkYvNzkrZjVIL3JBQit2UUJCUUVTL1BYOHRhbXZ5K0FCcXM3Y0JSK1gvWkROL2hxTGpJaCtBQUFEQU1rQUFBWUtCYllBQ2dBVEFCY0FQMEFnQXdzTEFBOEhGUlFVQndBREdCa1ZFZ01UU1ZrREF3QVdBUU1BQzBwWkFCSUFQeXNBR0Q4ekVqa3ZLd0FZUHhFU0FSYzVFVE1STXhFekVUTXhNRE1STXhFeklBUVZGQVFqSlRNeU5qVTBKaU1qQVNNUk04bXE3d0VGQVJMKy9mbis5dmUxcXJQSTJ3U1hxcW9GdHYyUXpjL08zSkdOaklsNy9WSUZ0Z0FDQU1rQUFBUzZCYllBQ2dBU0FESkFHUWNMQ3dRT0FBUUFFeFFIRWtsWkJ3Y0VCUU1FQzBwWkJCSUFQeXNBR0Q4U09TOHJFUklCT1RrUk14RXpFVE14TUFFVUJDTWhFVE1SSVNBRUFTRWdFVFFtSXlFRXV2N3grLzRacWdFakFRc0JHZnk1QVNzQmJMdk8vdklCcXN2ZkJiYjlrTlArSUFFWGgzOEFBUUE5Lyt3RWlRWExBQm9BT2tBZkdCVVZDUWtXRHdNRUd4d1hGa2xaRnhjTUJRd1NTVmtNRXdVQVNWa0ZCQUEvS3dBWVB5c1JFZ0E1R0M4ckVSSUJGemtSTXhFek1UQUJJZ2NuTmpNeUJCSVZFQUFoSWljMUZoWXpJQUFUSVRVaEpnQUIwNnlpU0t6czJRRTVvdjZVL3Fyam5GT3NZd0VQQVJRSS9URUN6UmIrOFFVelRKQlVzUDY2M2Y2SS9tdzVsUlVpQVNFQkVKamxBUUlBQWdESi8rd0g1d1hOQUJJQUhnQkhRQ1lNQ0FnSkV3MEdHUUFBQmdrREh5QVFIRWxaRUFRTUIwbFpEQXdKQ2dNSkVnTVdTVmtERXdBL0t3QVlQejhTT1M4ckFCZy9LeEVTQVJjNUVUTVJNek1STXhFek1UQUJFQUFoSUFBRElSRWpFVE1SSVJJQUlTQUFBUkFTTXpJU0VSQUNJeUlDQitmK3EvN1EvdFArcXd2K25xcXFBV1FYQVZFQkh3RXpBVmI3b083bjZ1M3I2T253QXQzK252NXhBVzhCVmYxUUJiYjlrZ0UzQVU3K2IvNmgvdGorekFFeUFTb0JLZ0V1L3M4QUFnQXpBQUFFVGdXMkFBMEFGUUE5UUNBVkRBd0xFZ1lDQmdNTEJCY1dBQlJLV1FNSkFBQUNDUWtQU2xrSkF3d0NFZ0EvTXo4ckVSSUFPUmd2RWprckVSSUJGemtSTXhFekVUTXhNQUVCSXdFbUpqVTBKQ0VoRVNNUkVTTWlCaFVRSVRNQ2UvNkJ5UUdhb1pJQkR3RVRBWktxNDdlK0FYdmRBbUw5bmdKL004K2V4TlA2U2dKaUFzRitqdjdkLy84QVh2L3NBODBFV2dJR0FFUUFBQUFDQUhmLzdBUlVCaUVBRndBaUFEdEFIaG9TSUFzQUFBWVNBeVFqREFzUEhFWlpDdzhQRlFVVkdFWlpGUllGQVFBL1B5c1JFZ0E1R0M4NUt4RUFNeEVTQVJjNUVUTXpFVE14TUJNUUVqY2tOeGNFQndZR0J6TTJOak15RWhVUUFDTWlBQVVnRVJBaElnWUdCeEFTZDlUbUFSN2FILzZsbFpHUkJ3dyt4R3ZLNHY3NjZ1ZisrZ0g4QVRIKzYweU5kU0NtQXBFQmFBR1RNajBta2pvaUlmYlVWR0QrK3VqKy8vN2ZBV0xYQVlVQmN6OW9OLzc1L3UwQUF3Q3dBQUFFVEFSSUFBNEFGZ0FmQUVsQUpod1VGQXNYQUE4SEJ3QURDd1FnSVFRY0V4d1RSbGtjSEFzTURCdEdXUXdQQ3hSR1dRc1ZBRDhyQUJnL0t4RVNBRGtZTHlzUkVnQTVFUklCRnprUk14RXpFVE1STXpFd0FSUUdCeFVXRmhVVUJpTWhFU0VnQXpRbUl5RVJJU0FETkNZaklSRWhNallFS1h0dmpJSGgyUDRkQWVFQm1JT0huUDdUQVRFQkh4OTdmZjdIQVJtYWZnTTFhMjhUQ1JOK2I1bW1CRWo5QWxsUi9wY0NtbEJEL3N0TUFBQUJBTEFBQUFORUJFZ0FCUUFkUUE0Q0F3QURCd1lFQVVaWkJBOERGUUEvUHlzUkVnRTVPUkV6TVRBQklSRWpFU0VEUlA0U3BnS1VBN3I4UmdSSUFBSUFLZjZGQkdnRVNBQU5BQk1BUTBBa0JBVVRCeEFLRGd3QkFBQU1DZ2NGQlJRVkNoQkhXUW9QQVFVaUV3d0dBd1pHV1FNVkFEOHJFUUF6TXhnL016OHJFUklCRnprUk14RXpFVE1STXhFek1UQUJJeEVoRVNNUk16WVNFeUVSTXlFUkl3WUNCd1Jvb2YwQ29GYUdtQU1DSzUzK3cvWU5rV3oraFFGNy9vVUNDcllCNmdFWi9FY0ROdDcrT1pFQS8vOEFjLy9zQkJJRVhBSUdBRWdBQUFBQkFBUUFBQVhmQkVZQUVRQThRQjhDQ1FrUkNnWUVCUW9PRHcwSEV4SVJDd2dGQWc0T0RRTUFEdzhLQncwVkFEOHpNejh6TXhJNUVUTXpNek16RVJJQkZ6a1JNek1STXpFd0FUTVJBVE1CQVNNQkVTTVJBU01CQVRNQkFxU1pBY1cyL2pZQjhjRCtIcG4rSDc4QjhQNDN0Z0hEQkViOTdRSVQvZTM5elFJci9kVUNLLzNWQWpNQ0UvM3RBQUVBUlAvc0EzOEVYQUFpQUUxQUt3SU5IaE1URFE4aENCZ0dJeVFRSWlFaUlVWlpEeUlmSWdJTEF5SWlGZ29XRzBaWkZoWUtCRVpaQ2hBQVB5c0FHRDhyRVJJQU9SZ3ZYMTVkS3hFU0FEa1JFZ0VYT1JFekVUTXhNQUVnTlRRaklnWUhKell6TWhZVkZBY1ZGaFlWRkFZaklpYzFGak15TmpVMElTTTFBWUVCTi94TmZtWTdxc205MnMxK2RQWFk3WUczdTVDVC9zbVlBb0dzb2h3cWgweWJocmc1Q0NXSlo1aXBSNWhXWTEyL2pRQUJBTEFBQUFSaUJFZ0FEUUEwUUJrSUJBY0hCZ3NEQXd3R0RBOE9Bd29NQkEwUERCVUhGUVFQQUQ4L1B6OFJFams1RVJJQk9Ua1JNeEV6RVRNUk16TXhNQUVSQndjQk14RWpFVGMzQVNNUkFVd0hBd0pSejVzREJmMnd6d1JJL1VtMk9RT20rN2dDbm9TQy9Gd0VTQUQvL3dDd0FBQUVZZ1lNQWlZQjBnQUFBUVlDTmowQUFBaXpBUTRSSmdBck5RQUJBTEFBQUFRTUJFZ0FDZ0F0UUJZS0JnWUhBd0VDQndRTUN3SUtCUW9IQUFnUEJBY1ZBRDh6UHpNU09Ua1JNeEVTQVJjNUVUTVJNekV3QVRNQkFTTUJFU01STXhFREw3YitKd0lBd3Y0TXBxWUVTUDN2L2NrQ0svM1ZCRWo5NndBQkFCRC84Z1BoQkVnQUVBQXRRQmdCQUFNUENnOEFBeElSRHdOR1dROFBCd3hIV1FjV0FSVUFQejhyQUJnL0t4RVNBUmM1RVRNUk16RXdJU01SSVFJQ0JpTWlKelVXTXpJU0V5RUQ0YWordHh0Z21YWTJJQlljYzRnakFvRUR1djZjL2w3Q0RIc0dBZVlCN3dBQkFMQUFBQVV2QkVZQUZBQTFRQmtEQmdZRkVnOFBFQVVRRmhVSERnQU9Dd01SRHdZUUZRc1ZBRDgvTXo4ekVqazVFVE1SRWdFNU9SRXpFVE1STXhFek1UQWxOemNCTXhFakVRY0hBU01CSmljUkl4RXpBUllDNlI4ckFTblRreFE2L3VXTC91VTFGSlRMQVI4cm9GMTJBdFA3dWdPSk9wbjlTZ0s0aGt2OGR3UkcvVWx1QUFFQXNBQUFCR0lFU0FBTEFEbEFIZ0lHQmdVQkNRa0tCUW9OREFFSVJsa3ZBVDhCQWdFQkNnTUxEd1lLRlFBL016OHpFamt2WFNzUkVnRTVPUkV6RVRNUk14RXpNVEFCRVNFUk14RWpFU0VSSXhFQlZnSm1wcWI5bXFZRVNQNDFBY3Y3dUFIdS9oSUVTUC8vQUhQLzdBUmlCRndDQmdCU0FBQUFBUUN3QUFBRVNBUklBQWNBSTBBUkFBRUZCQUVFQ0FrQ0IwWlpBZzhGQVJVQVB6TS9LeEVTQVRrNUVUTVJNekV3SVNNUklSRWpFU0VCVnFZRG1Lajl0Z1JJKzdnRHVBRC8vd0N3L2hRRWRRUmNBZ1lBVXdBQS8vOEFjLy9zQTRzRVhBSUdBRVlBQUFBQkFDa0FBQU9UQkVnQUJ3QWtRQklDQXdBREJRTUlDUUVGQmdWR1dRWVBBeFVBUHo4ckVRQXpFUklCRnprUk16RXdBU0VSSXhFaE5TRURrLzZjcHY2Z0Eyb0R1dnhHQTdxTy8vOEFBdjRVQkFZRVNBSUdBRndBQUFBREFISCtGQVZHQmhRQUVRQVlBQjRBVEVBbkVna2NEd1FFRlF3RkdRQUFCUWtESHlBTkFCc1dEQlpHV1E4TUVCd1ZCaFZHV1FNR0ZnVWJBRDgvTXlzUkFETVlQek1yRVFBekdEOFJFZ0VYT1JFekVUTXpNeEV6TXhFek1UQUJGQUFIRVNNUkpnQTFOQUEzRVRNUkZnQUZGQllYRVFZR0JSQWxFVFkyQlViKzVmNmsrUDdnQVIvL252c0JIdnZac01DNXR3TjcvcE8rcndJbCtmN1pGZjRrQWR3VEFTNzArUUVtRkFHOC9rUVgvdFR3d05vU0ExUVJ6OGdCZnlmOHJoUGEvLzhBSndBQUJBZ0VTQUlHQUZzQUFBQUJBTEQraFFUZEJFZ0FDd0F5UUJrR0F3Y0tBUUFBQ2dNRERBMElCQThLQmdNR1Jsa0RGUUVpQUQ4L0t4RUFNeGcvTXhFU0FSYzVFVE1STXhFek1UQUJJeEVoRVRNUklSRXpFVE1FM2FiOGVhWUNScWFiL29VQmV3UkkvRWNEdWZ4SEFBRUFuQUFBQkMwRVNBQVNBQzFBRmdZS0Nna0JFUWtSRkJNRERrWlpBd01LQnhJUENoVUFQejh6RWprdkt4RVNBVGs1RVRNUk14RXpNVEFCRVJRek1qWTNFVE1SSXhFR0JpTWlKalVSQVVMYlc2WnBwcVpwczNHa3VnUkkvbkRBT0VNQjFmdTRBZkJJTzZ5VEFad0FBUUN3QUFBR2J3UklBQXNBTVVBWUNBVUFDUUVFQkFrRkF3d05DZ0lHRHdBSUJRaEdXUVVWQUQ4ckVRQXpHRDh6TXhFU0FSYzVFVE1STXhFek1UQWxJUkV6RVNFUk14RWhFVE1ENFFIbXFQcEJwZ0hscG84RHVmdTRCRWo4UndPNUFBQUJBTEQraHdjS0JFWUFEd0E3UUI0TUNRQU5BUVFIQmdZRURRa0VFQkVPQWdvUEJBQU1DUXhHV1FrVkJ5SUFQejhyRVFBek14Zy9Nek1SRWdFWE9SRXpFVE1STXhFek1UQWxJUkV6RVRNUkl4RWhFVE1SSVJFekErRUI1cWFkcVBwT3BnSGxwbzhEdC94Si9mZ0JlUVJHL0VrRHR3QUFBZ0FwQUFBRkhRUklBQXdBRkFBOVFDQUFFaElJRFFRRUNBb0RGUllBRVVaWkFBQUlDd3NLUmxrTER3Z1NSbGtJRlFBL0t3QVlQeXNSRWdBNUdDOHJFUklCRnprUk14RXpFVE14TUFFaE1oWVZGQVlqSVJFaE5TRUJOQ1lqSVJFaElBSXRBVG5nMTkvYy9pWCtvZ0lFQWt4OG5mN05BVGtCRXdLRG1wdW1xQU82anZ6OFhWUCtsd0FBQXdDd0FBQUZlUVJJQUFvQURnQVdBRDlBSUFBUUVBZ0VFd3dMQ3hNSUF4Y1lEQlVBRDBaWkFBQUlEUWtQQ0JCR1dRZ1ZBRDhyQUJnL014STVMeXNBR0Q4UkVnRVhPUkV6RVRNUk14RXpNVEFCSVRJV0ZSUUdJeUVSTXdFakVUTUJFU0VnTlRRbUl3RldBU3ZSeWRYUC9qbW1CQ09tcHZ2ZEFSa0JDSHFUQW9PYm1xV3BCRWo3dUFSSS9heitsN2xjVkFBQ0FMQUFBQVJNQkVnQUNRQVNBREpBR1E4REFBc0xCd01IRkJNQUNrWlpBQUFIQ0E4SEMwWlpCeFVBUHlzQUdEOFNPUzhyRVJJQk9Ua1JNeEV6RVRNeE1BRWhJQkVVQmlNaEVUTVJFU0V5TmpVMEppTUJWZ0ZTQWFUYjAvNFNwZ0ZBaEl5QmxBS0Qvc3VpckFSSS9heitsMXhkVzFVQUFRQTUvK3dEZlFSY0FCb0FSRUFtREFrSkdCZ0tFZ0lFR3h3TENrWlpEd3NmQ3dJTEF3c0xBQlVWRDBaWkZSQUFCa1paQUJZQVB5c0FHRDhyRVJJQU9SZ3ZYMTVkS3hFU0FSYzVFVE1STXpFd0JTSW5OUllXTXpJMk55RTFJU1ltSXlJSEp6WTJNeUFBRVJBQUFWYW5kanlNVzY2OUN2M1ZBaWtRcWFGbmx5ODNwRkFCQUFFSy90OFVPWk1YSkxxNWpheWdOb3dhSS83Yi91eis4LzdXQUFJQXNQL3NCak1FWEFBU0FCNEFVVUF0REFnSUNSTU5CaGtBQUFZSkF4OGdFQnhHV1JBUURBZEdXUThNSHd3Q0N3TU1EQWtLRHdrVkF4WkdXUU1XQUQ4ckFCZy9QeEk1TDE5ZVhTc0FHRDhyRVJJQkZ6a1JNeEV6TXhFekVUTXhNQUVRQUNNaUFpY2hFU01STXhFaE5qWXpNZ0FCRkJZek1qWTFOQ1lqSWdZR00vNy80Tlg2RHY3aHBxWUJJUlQ4ejl3QkFmenVrcUdlbFpLaG9aSUNKZjd6L3RRQkMvZitFZ1JJL2pYaysvN1AvdnJUMjlYWjB0allBQUlBSlFBQUE4RUVTQUFOQUJRQVBVQWdFUXNMQ2c0RkFRVUNDZ1FXRlEwUVJsa0NDQTBOQVFnSUUwWlpDQThMQVJVQVB6TS9LeEVTQURrWUx4STVLeEVTQVJjNUVUTVJNeEV6TVRBekl3RW1KalUwTmpNaEVTTVJJUUVVSVNFUklTTG53Z0U3ZjRmS3RRSG9wdjdyL3ZZQkZBRUwvdFB5QWM4Y29YcVdyUHU0QWJZQlRyNEJjdi8vQUhQLzdBUVNCZE1DSmdCSUFBQUJCZ0JxQ0FBQUNyUURBakFSSmdBck5UVUFBUUFVL2hRRVJBWVVBQ2NBWmtBNkhSc1hEdzhVRUFjbEpSa0NFQklGS0NrZUhTRUxSbGthRWhNU1Ixa1hFdzhUSHhNdkV3TUpBeDBoRXhNaEhRTVFGUUFRRlFBRlJsa0FHd0EvS3dBWVB6OFNGemt2THk5ZlhsMFJNeXNSQURNckVRQXpFUklCRnprUk14RXpNeEV6TXpNeE1BRWlKelVXTXpJMUVUUW1JeUlHRlJFakVTTTFNelV6RlNFVklSVVVCek0yTmpNeUZoVVJGQVlETDA4ME9qZUJlb0t0bmFpY25LWUJrZjV2Q0FveHRYVEp5WW4rRkJtSkZLb0RVb2FFdk5QOTV3VGJmN3E2ZjhSVU9FOWJ2OUw4dHB5cS8vOEFzQUFBQTBRR0lRSW1BYzBBQUFFR0FIYnhBQUFJc3dFUEVTWUFLelVBQVFCei8rd0RxZ1JjQUJrQVJFQW1EeElTQXdrWUVRTUVHaHNQRWtaWkR3OGZEd0lMQXc4UEFBWUdERVpaQmhBQUZVWlpBQllBUHlzQUdEOHJFUklBT1JndlgxNWRLeEVTQVJjNUVUTVJNekV3QlNJQUVSQUFNeklXRndjbUl5SUdCeUVWSVJZV016STNGUVlDZWZqKzhnRVQrMUtlT1RHUGJhU3FFQUlwL2RVSnFxZU1sM1FVQVNNQkVBRVRBU29nR1kwem82bU52clU3a3puLy93QnEvK3dEY3dSY0FnWUFWZ0FBLy84QW9nQUFBV1lGM3dJR0FFd0FBUC8vLyt3QUFBSWZCZE1DSmdEekFBQUJCd0JxL3JjQUFBQUt0QUlCR1JFbUFDczFOZi8vLzVIK0ZBRm1CZDhDQmdCTkFBQUFBZ0FRLy9JR1FnUklBQlVBSFFCTVFDa0pGQUFiR3djV0JBUUhGQTRFSGg4QUdrWlpBQUFNRkJRSlJsa1VEd3dSUjFrTUZRY2JSbGtIRlFBL0t3QVlQeXNBR0Q4ckVSSUFPUmd2S3hFU0FSYzVFVE1STXhFekVUTXhNQUV6TWhZVkVDRWhFU0VDQWlNaUp6VVdNeklTRXlFQk5DWWpJeEV6SUFPdzlOUEwva3YrWmY3K0tMV3JPQ0FXSEhPSUl3SlFBZXg5bnVmdEFSVUNnNXVhL3JJRHV2MzYvajRNZXdZQjVnSHYvUHhiVmY2WEFBSUFzQUFBQnFRRVJnQVJBQmtBU2tBbUR3c0xEQUVURXhBSUZnVUZDQXdER2hzU0NnOEtSbGtCRHc4SUVRMFBEQlVJRTBaWkNCVUFQeXNBR0Q4L014STVMek1yRVFBekVSSUJGemtSTXhFek14RXpFVE1STXpFd0FSRWhNaFlWRUNFaEVTRVJJeEV6RVNFUkV4RXpJRFUwSmlNRUFBRUEyY3YrVHY1Zy9ncXNyQUg2cHZBQkZJQ1pCRWIrTzVtYS9ySUI3djRTQkViK053SEovYTcrbDdsY1ZBRC8vd0FVQUFBRVJBWVVBZ1lBNlFBQS8vOEFzQUFBQkF3R0lRSW1BZFFBQUFFR0FIWXpBQUFJc3dFVUVTWUFLelgvL3dBQy9oUUVCZ1lNQWlZQVhBQUFBUVlDTnJjQUFBaXpBUllSSmdBck5RQUJBTEQraHdSR0JFWUFDd0F5UUJrRUFRb0xCUWdJQ3dFRERBMExJZ1lDRHdrQkFRUkdXUUVWQUQ4ckVRQXpHRDh6UHhFU0FSYzVFVE1STXhFek1UQWhJUkV6RVNFUk14RWhFU01DTC82QnBnSktwdjZQcGdSRy9Fa0R0L3U2L29jQUFBRUF5UUFBQkFnRzR3QUhBQ05BRVFBREJRWURCZ2tJQndSSldRRUhBd1lTQUQ4L3hpc1JFZ0U1T1JFekVUTXhNQUVSTXhFaEVTTVJBMmFpL1d1cUJiWUJMZjQ2K3VNRnRnQUFBUUN3QUFBRFJBV0pBQWNBSjBBU0JRQUNBd0FEQ1FnR0JBUUJSMWtFRHdNVkFEOC9Ld0FZRU1ZUkVnRTVPUkV6RVRNeE1BRWhFU01SSVJFekEwVCtFcVlCN3FZRHgvdzVCRWdCUVFELy93QWJBQUFIVEFkekFpWUFPZ0FBQVFjQVF3RVhBVklBQ0xNQkd3VW1BQ3MxLy84QUZ3QUFCaU1HSVFJbUFGb0FBQUVHQUVOekFBQUlzd0VlRVNZQUt6WC8vd0FiQUFBSFRBZHpBaVlBT2dBQUFRY0FkZ0d3QVZJQUNMTUJJd1VtQUNzMS8vOEFGd0FBQmlNR0lRSW1BRm9BQUFFSEFIWUJHd0FBQUFpekFTWVJKZ0FyTmYvL0FCc0FBQWRNQnlVQ0pnQTZBQUFCQndCcUFXUUJVZ0FLdEFJQkx3VW1BQ3MxTmYvL0FCY0FBQVlqQmRNQ0pnQmFBQUFCQndCcUFNOEFBQUFLdEFJQk1oRW1BQ3MxTmYvL0FBQUFBQVI3QjNNQ0pnQThBQUFCQndCRC81UUJVZ0FJc3dFS0JTWUFLelgvL3dBQy9oUUVCZ1loQWlZQVhBQUFBUWNBUS85aEFBQUFDTE1CRnhFbUFDczFBQUVBVWdIWkE2NENjUUFEQUJHMUFBSUVCUUFCQUM4ekVSSUJPVGt4TUJNMUlSVlNBMXdCMlppWUFBRUFVZ0haQjY0Q2NRQURBQkcxQUFJRUJRQUJBQzh6RVJJQk9Ua3hNQk0xSVJWU0Ixd0IyWmlZLy84QVVnSFpCNjRDY1FJR0FnTUFBQUFDLy96K01RTk8vOU1BQXdBSEFCeEFDd1FBQ1FVQkFRZ0ZCZ0lCQUM4ekx6TVJBVE1STXhFek1qRXdBU0UxSVRVaE5TRURUdnl1QTFMOHJnTlMvakdMaklzQUFBRUFHUVBCQVVRRnRnQUhBQksyQVFVSUNRQUVBd0EvelJFU0FUazVNVEFUSnpZU056TUdCeVVNRm1JNGUwSWxBOEVXV2dFTWVmNzNBQUFCQUJrRHdRRkVCYllBQndBU3RnVUJDQWtGQndNQVA4WVJFZ0U1T1RFd0FSY0dBZ2NqRWpjQk5ROGFZalY2UmlBRnRoWmsvdmR5QVIzWUFQLy9BRC8rK0FGdEFPNENCZ0FQQUFBQUFRQVpBOEVCUmdXMkFBY0FFcllDQmdrSUF3Y0RBRC9ORVJJQk9Ua3hNQk1XRnlNbUFpYzMzeVZDZXkxdEdBNEZ0dnY2WGdFY1pSWUFBQUlBR1FQQkFyUUZ0Z0FIQUE4QUdrQU1CQUVOQ1FRUUVRQUlBd3dEQUQ4enpUSVJFZ0VYT1RFd0FTYzJFek1HQWdjaEp6WVNOek1HQndHV0R6aDZleDQ3RGYzWERCWmlPSHRDSlFQQkZ0Y0JDSFArMzJFV1dnRU1lZjczQUFBQ0FCa0R3UUswQmJZQUJ3QVFBQnBBREFrTkFRVUVFUklOQlJBSEF3QS9NOFl5RVJJQkZ6a3hNQUVYQmdJSEl4STNJUmNHQWdjak5oSTNBVFVQR21JMWVrWWdBaWNPR0dBNGZScENEUVcyRm1UKzkzSUJIZGdXVy83MmVtUUJORjBBLy84QUdmNzVBclFBN2dFSEFnc0FBUHM0QUNDM0FRQUhRQTBOU0FlNC84Q3pEQXhJQjdqL3dMTUpDVWdIQUJFckt5czFOUUFCQUhzQUFBT0pCaFFBQ3dCRFFDRUpBZ0lJQXdvQkFRY0VBQVFEQlFRTURRQUZCUXNHQmdjSUFBRUVCQW9IQXhJQVB5NHpNeEV6UHhJNUx6TXpFVE1SRWdFWE9SRXpNeEV6RVRNekVUTXhNQUVsRXlNVEJUVUZBek1ESlFPSi9xQXh4REgrdEFGTU1jUXhBV0FENXgvNytnUUdINm9lQWFIK1h4NEFBUUI3QUFBRG1nWVVBQlVBZFVBNkRBY1ZFQVFFRHdvRkZCRUFBd01PQ3drR0V3RUJCZ1VIQkJZWEFRZ0lBZ2NEQmdZQUNSUUxDeEVPRXd3TUVna09EUWNOQncwRkR3QUZFZ0EvUHhJNU9TOHZFams1TWpJUk14RXpNeEV6RVRNekVUTVJNek1STXhFU0FSYzVFVE1STXpNek14RXpNek1STXpNekVUTXpFVE14TUFFbEZTVVRJeE1GTlFVREV3VTFCUU16QXlVVkpSTUNPUUZoL3A4eHhqSCtwZ0ZhS3l2K3BnRmFNY1l4QVdIK255c0I1eCtvSGY2RkFYc2RxQjhCS3dFYkg2Z2VBWHoraEI2b0gvN2xBQUVBcEFIMEFsNEQ0d0FMQUJPMkJnQUFEQTBKQXdBdnpSRVNBVGtSTXpFd0V6UTJNeklXRlJRR0l5SW1wSEZzYVhSemFtdHlBdXg1Zm54N2Q0R0RBUC8vQUpqLzR3V3VBUElBSmdBUkFBQUFKd0FSQWhJQUFBQUhBQkVFSlFBQUFBY0FaUC9zQ1RzRnl3QUpBQlFBR0FBa0FDOEFPd0JHQUZ0QU1BQVFCUW93UWpZOEdTc2ZKU1VyUEJWQ0NoY1FDRWRJSERNektEOFpBdzBpT1RrdFJBMUVEVVFYR0FZWEdBY1NCd0EvTXo4L0VqazVMeThSTXpNUk14RXpQek16RVRNUkVnRVhPUkV6RVRNUk14RXpFVE1STXpFd0V4UVdNeklSRUNNaUJnVVVCaU1pSmpVUUlUSVdKUUVqQVFFVUZqTXlOalUwSmlNaUJnVVVCaU1pSmpVUUlUSVdCUlFXTXpJMk5UUW1JeUlHQlJRR0l5SW1OUkFoTWhic1UxMjB0RjFUQWUyaG5KV2pBVGlZcFFKcC9OV1VBeXNDb0ZOZFcxbFpXMTFUQWUyaW01U2pBVGVXcC9zNFVWMWJXVmxiWFZFQjY2S2JsYU1CT0phbkJBS3FxZ0ZVQVZLb3F1Ym43dDhCeWZEYitrb0Z0dndDcTZtbnJhdWxwYXZtNXUvZEFjbnMzYXVwcDYycnBhV3I1dWJ1M2dISjdBRC8vd0NGQTZZQlB3VzJBZ1lBQ2dBQS8vOEFoUU9tQXJBRnRnQUdBQVVBQUFBQkFGSUFkUUlmQTc0QUJnQWFRQW9FQWdNR0FnWUlCd1VCQUM4dkVSSUJPVGtSTXhFek1UQVRBUmNCQVFjQlVnRldkLzdmQVNGMy9xb0NKd0dYUmY2aS9xRkhBWmNBQVFCUUFIVUNIUU8rQUFZQUdrQUtBd0FFQWdBQ0NBY0ZBUUF2THhFU0FUazVFVE1STXpFd0FRRW5BUUUzQVFJZC9xaDFBUi8rNFhVQldBSU0vbWxIQVY4QlhrWCthUUQvL3dDWS8rTURTZ1cyQUNZQUJBQUFBQWNBQkFIQkFBQUFBZjU1QUFBQ2p3VzJBQU1BRTdjQUJRSUVBd01DRWdBL1B4RUJNeEV6TVRBQkFTTUJBby84ZVk4RGh3VzIra29GdGdBQkFHMERJUUxEQmNjQUVnQW1RQkVBRWd3SUNBa1NDUlFUQkE4ZkFBa0tId0EvelRJL014RVNBVGs1RVRNUk14RXpNVEFCRVRRbUl5SUdGUkVqRVRNWE16WXpJQlVSQWt4T1VISmJkR0FPQ2t1UkFRSURJUUdrVkVkcGV2NmtBcGxZWmZyK1ZBQUJBR0lBQUFRakJiWUFFUUJMUUNnT0FBUUVDUVVMRUFJRkJ3VVNFd01IQ0FkT1dRQUlEaEZNV1FnT0NBNEZDZ29OVEZrS0JnVVlBRDgvS3hFU0FEazVHQzh2S3hFQU15c1JBRE1SRWdFWE9SRXpNeEV6TXpFd0FTRVZJUkVqRVNNMU14RWhGU0VSSVJVaEFiZ0JOUDdNcHJDd0F4SDlsUUpFL2J3Qmk0SCs5Z0VLZ1FRcmwvM3Bsd0FCQUVRQUFBUklCY2tBSlFCd1FFQU5DUkVSSWg0YUN3OFZBZzhhSENBWEJ5WW5FQndkSEU1WkRSME1JQ0VnVGxrSklROGhIeUUvSVU4aEJBa0RIU0VkSVJjQUZ4Uk1XUmNZQUFWTFdRQUhBRDhyQUJnL0t4RVNBRGs1R0M4dlgxNWRFVE1yRVFBekVUTXJFUUF6RVJJQkZ6a1JNeEV6TXpNUk16TXhNQUV5RndjbUl5SUdGUlVoRlNFVklSVWhGUlFHQnlFVklUVTJOVFVqTlRNMUl6VXpOVFEyQXJESm5qeVlrM3ArQWFUK1hBR2svbHhCU2dNYisvek95TWpJeU9BRnlWQ0RSNGVCdW9HbWdTRmtpQ3lhalREekk0R21nYyt5elFBQUF3Q2EvK3dGMFFXMkFCWUFJUUFxQUdCQU55SWNIQjBtRnhBVUZBMEpBaElKRndzZEJpc3NHeUpMV1JBVFRsa0RHd3NRRGc0UUN4c0RCUjBlSGlwTFdSNEdIUmdHQUUxWkJoa0FQeXNBR0Q4L0t4RVNBQmM1R0M4dkx5OHZLeXNSRWdFWE9SRXpNeEV6RVRNUk14RXpNVEFsTWpZM0ZRWWpJaVkxRVNNMU56Y3pGVE1WSXhFVUZnRVVCQ0VqRVNNUklTQVdBVE15TmpVMEppTWpCVTRpVmdzOGJtMkJuWjArWXQzZE5QNlIvdXYrOWtDbEFRWUJBUDc5b1RUSXVheTNVblVPQkgwZWlJb0J6MUJGdjlPQi9rZE5VZ09YNCtyOXdRVzIwLzN1a2FLUmpnQUFBUUEvLyt3RWlRWExBQ1lBY1VBL0hSY2ZGaFlhQ3dJSEJ4b2tFUVFLR2hjR0p5Z0xGeGdYVGxrSUdBVWRIaDFPV1FJZUR4NGZIaThlQXdrREdCNFlIaE1pSWdCTVdTSUhFdzVNV1JNWkFEOHJBQmcvS3hFU0FEazVHQzh2WDE1ZEVUTXJFUUF6RVRNckVRQXpFUklCRnprUk14RXpNeEV6RVRNUk16RXdBU0FESVJVaEJ4VVhJUlVoRmhZek1qY1ZCaU1pQUFNak5UTW5OVGNqTlRNU0FETXlGd2NtQXh2K3dVOEIvdjMwQWdJQnovNUJKY3VxbkptU3ErMyszeTZtbUFJQ21LUW5BU1R0eWFWSHBnVTEvbTJCT1VBdGdiVEZRcFpCQVEwQkFZRXFMRkNCQVFVQkpHR0xWZ0FFQUkzLytBWUtCY0VBQXdBUEFCY0FLd0JGUUNRbEd5QXFFQW9VQkFRQUNpb0NHd1lzTFNNZUJoSUhHQllOSnhnTkdBMFlBZ01HQWhnQVB6OFNPVGt2THhFekVUTS9Nejh6RVJJQkZ6a1JNeEV6RVRNUk16RXdBUUVqQVFFVUJpTWlKalUwTmpNeUZnVVVNekkxTkNNaUpTSW1OVFEyTXpJWEJ5WWpJaFVVTXpJM0ZRWUZIL3pWbEFNckFYK3BsSXVxcDVTTnF2NFZzckN3c3YzS3ByYThxMmhZSVZGUTROeGlXazRGdHZwS0JiYjdtSiszdVoyZXVMcWM3dTdyMjdHaHFMTWpaeC91NnlGbEpRQUNBSGYvN0FPY0Jjc0FIQUFrQUQxQUh5TWFHZzhKSFJZREZna01CQ1VtSXc4TkdRb0ZEQk1DREFJTUJoOFRBQVlBTHpNdk14STVPUzh2RVJJWE9SRVNBUmM1RVRNUk16TVJNekV3SlRJM013WUdJeUltTlRVR0J6VTJOeEUwTmpNeUZoVVVBZ2NSRkJZVE5DTWlCaFVSSkFKOXJoSmZDSm1PbHFCZ1lFNXlsb2QxaDg2dlVxNS9RejRCQUcvVnBySzFxZk1qRm5FVkpnSHlpcCtoaXJuKzBFcis1V2g3QkN2Q1ZteitTNGtBQUFRQXlRQUFCOE1GdGdBUEFCc0FKd0FyQUY5QU1Ra0dCZ2NCRFEwQUhCWWlFQkFyS0JZQUJ3WXNMUjhUSlJrTEtCTURHUWdUR1JNWktBZ29LVXBaS0JJT0NBTUJCeElBUHpNL016OHJFUklBT1RrWUx5OFJFamtSRWprUk14RXpFUklCRnprUk14RXpFVE1STXhFekVUTXhNQ0VqQVNNU0ZSRWpFVE1CTXlZMUVUTUJGQVlqSWlZMU5EWXpNaFlGRkJZek1qWTFOQ1lqSWdZRE5TRVZCTWU3L1V3SUVKZkNBcW9JRHBnQy9LR1RpNktoazR1aS9pSlJYVnRQVDF0Y1VsWUNBQVRML3VCcy9NRUZ0dnM2OVlvRFIveTNvN2k3b0tPMXU1MXlkblZ6YzNCdy9TQ0hod0FDQUNVQzVRV0ZCYllBQndBWUFFOUFKd0FCRHd3TURSRVVGQk1URFFZQkF3VVpHaGNXQ1FvS0VRNE9CQWNEQXdRUUNBZ1VEUUVFQXdBL3hESXlPUzh6RVRNUk14RXpFVE16RVRNek14RVNBUmM1RVRNUk14RXpFVE1STXpFd0FTTVJJelVoRlNNQkF5TVhFU01STXhNVE14RWpFVGNqQXdGeGU5RUNIOU1DV01rSUJuZTd4TXUwZndZSTB3TGxBbWRxYXYyWkFpK0IvbElDMGYzUkFpLzlMd0draWYzVEFQLy9BRkFBQUFYMEJjMENCZ0YyQUFBQUFnQm0vOTBFaXdSSUFCY0FId0EwUUJvZkRnNEVHQXdNRlFRRElDRU5GQzhmUHg4Q0h4OFJIQWdSQUFBdk1pOHpFamt2WFRrekVSSUJGemtSTXhFekVUTXhNQVVpSmdJMU5EWTJNeklXRWhVaEVSWVdNekkyTnhjR0JoTVJKaVlqSWdjUkFubWQ4WVdLOUpXWTg0Zjh4VEdtVW9PM1VVaGkyWk15bzFpdGVpT1RBUVdkcS8rTWp2NzlwZjZjTlVacGdTbWJmQUtMQVJVMVFuWCs2Zi8vQUVmLzdBWHpCYllBSndJWEFsd0FBQUFtQUh2N0FBRUhBa0FEWVAyekFBdTBCQU1DR1JrQVB6VTFOUUQvL3dBZy8rd0dDQVhKQUNjQ0Z3S2lBQUFBSndKQUEzWDlzd0VHQUhYL0FBQUx0QUVEQWc0WkFEODFOVFVBLy84QVIvL3NCZ1FGdGdBbkFoY0NuQUFBQUNZQ1BRd0FBUWNDUUFOeC9iTUFDN1FFQXdJc0dRQS9OVFUxQVAvL0FHci83QVlBQmJZQUp3SVhBa1lBQUFBbkFrQURiZjJ6QVFZQ1B6RUFBQXUwQVFNQ0Roa0FQelUxTlFBQUFnQm0vK3dFTlFYSEFCb0FLQUJCUUNJbUJ4OFBEd0FBRkFjREtTb0xJa2RaRGdRTEN4Z0VHQkZHV1JnREJCdEdXUVFXQUQ4ckFCZy9LeEVTQURrWUx4STVLeEVTQVJjNUVUTVJNeEV6TVRBQkVBSUVJeUltTlRRU05qTXlGaGMzRUNFaUJnYzFOall6TWhJQk1qWVNOeVltSXlJR0JoVVVGZ1ExcC83c3JheTdpT2lYWVpJckJQN21QcEF3TDV0SzB0ajlvbCttZUJZWmdGQmxwV1ZsQTZiKyt2NDE2Y25BcVFFem9WMUxXZ0dWTENHZkZ5WCs3UHZHa0FFRGxtRnNoUHFBZG9JQUFnQW5BQUFFYlFXMkFBVUFEQUFvUUJNSkJRb0VCUVFPRFFZRkFRVUpTVmtGRWdFREFEOC9LeEVTQURrUkVnRTVPUkV6RVRNeE1EY0JNd0VWSVFFR0J3RWhBU1luQWMrbUFkSDd1Z0loUFNqKy9BTFIvdjVFYUFWTytyQm1CUFRoZWZ6K0F2bktBQUFCQU1uK0VBVWhCYllBQndBalFCRUFCd01FQndRSkNBVUNTVmtGQXdBRUd3QS9NejhyRVJJQk9Ua1JNeEV6TVRBQkVTRVJJeEVoRVFSMy9QeXFCRmorRUFjTitQTUhwdmhhQUFFQVRQNFFCTjBGdGdBTEFERkFHZ2NKQ1FNQUNBSUtCZ0lBQkF3TkJBZEpXUVFEQUFsSldRQWJBRDhyQUJnL0t4RVNBUmM1RVRNUk16TVJNekV3RXpVQkFUVWhGU0VCQVNFVlRBSjMvWmtFUVB5d0FrUDlwQU9xL2hCckE1d0RNMnlYL1B6OGpaZ0FBUUJvQW8wRUtRTVhBQU1BRlVBSkFnQUZCQUVBVUZrQkFDOHJFUklCT1RreE1CTTFJUlZvQThFQ2pZcUtBQUVBSmYveUJMd0dtQUFJQUJ4QUN3Z0tBd2tEQmdRRUFRZ0JBQzh2RWprdk9UTVJBVE1STXpFd0JTTUJJelVoRXdFekFtOS8vdW0wQVNIckFnS0pEZ01PaC8xVUJiMEFBQU1BZHdHVEJTMEVEQUFWQUNFQUxRQXpRQmdmRENzQUFDVVpEQVF1THlJY0hCRUdDUk1QS0JZV0F3a0FMek16RVRNdk14STVPVE1STXhFU0FSYzVFVE1STXpFd0FSUUdJeUltSndZR0l5SW1OVFEyTXpJWE5qTXlGZ0V5TmpjbUppTWlCaFVVRmdFaUJnY1dGak15TmpVMEpnVXRwNEJkbVVFOG1WaURxS2lEdFhwOHVZV2kvSDFDYlRZeWJVaE1aR0VDb1VKdE56TnVSMHhrWlFMUGc3bHFkR2h4clk2R3M5dlhyLzY3VzJSaFhXbFhVMm9CZVZ4aVlWNXJWRlZwQUFFQURQNFVBdmdHRkFBVUFCeEFEQWdTQWhJTkF4VVdFQXNGQUFBdk1pOHpFUklCRnprUk16RXdBVElYRlNZakloVVJGQVlqSWljMUZqTXlOUkVRQW4xUExERStzS1dqU2pzOU9yWUdGQkNKRnZQNjRiQzdFNGNXOHdVZkFXb0FBQUlBWWdHSEJDMEVId0FYQUM4QWNFQkFLQThiQXc4RE1UQW5IaDRZVUZrUEhoOGVMeDREQ1FNZUtrQXFKRkJaR3lwQUR3WUdBRkJaRHdZZkJpOEdBd2tEQmhKQUVneFFXUU1BRWhBU0lCSURFZ0F2WGNRckFCb1lFTTFmWGwwckFCQVl4QnJleENzQUdoZ1F6VjllWFNzQUVCakVFUklCT1RrUk14RXpNVEFCSWdZSE5UWXpNaFlYRmhZek1qWTNGUVlqSWlZbkppWURJZ1lITlRZek1oWVhGaFl6TWpZM0ZRWWpJaVluSmlZQlVEWi9PV3lVUTNCWVRWc3ROWUEyWlpsRGIxaEpXekU1Z0RWcWxrVjBVa1ZmTVRlQk0yU2FSWFpQVkZVQ0FFQTVsbTRjSlNFWlFqbVhiUjBsSGhrQmxrUTFsVzBnSWgwYVFqZVdiaUFoSWhnQUFBRUFhQUNtQkNrRkFnQVRBRVpBSmdVQkVBc0xDUW9PQkFBVEFRZ1VGUTBGQmdWUVdRb0lEd1lCQ1FNR0RnSUJBbEJaRWhFQkFDOHp4Q3NSQURNWUwxOWVYY1l6S3hFQU14RVNBUmM1RVRNUk16RXdBU0UxSVJNaE5TRVRGd2NoRlNFRElSVWhBeWNCZmY3ckFWUi8vaTBDRTRkOWJRRVgvcXFCQWRmOTZZTjlBY0dKQVJDSkFSODU1b24rOEluKzVUZi8vd0JvQUFFRUtRVFpBaVlBSHdBQUFRY0NLd0FBL1hRQUNiTUJBQWNTQUQ4MU5RRC8vd0JvQUFFRUtRVFpBaVlBSVFBQUFRY0NLd0FBL1hRQUNiTUJBQWNTQUQ4MU5RQUFBZ0J2QUFBRVBRWERBQVVBQ1FBZ1FBMElBQVlEQUFNS0N3a0hBZ1VDQUM4dkVqazVFUklCT1RrUk14RXpNVEFUQVRNQkFTTUpBMjhCd2tnQnhQNDhTQUZpL3NQK3d3RTlBdDhDNVAwYy9TRUM0UUlUL2UzOTdBRC8vd0FkQUFBRUhBWWZBQ1lBU1FBQUFBY0FUQUsyQUFELy93QWRBQUFFREFZZkFDWUFTUUFBQUFjQVR3SzJBQUFBQVFEYkJOa0R2Z1lNQUEwQUdFQUpDd01QRGdvRWdBY0FBQzh5R3N3eUVSSUJPVGt4TUFFaUppY3pGaFl6TWpZM013WUdBa2k1cWdxY0NWdHhaMk1MblF5eUJObVBwR2hTV0dLZWxRQUFBZitSL2hRQlZnUklBQXdBSFVBTkN3Z0lEZzBKRHdBRlJsa0FHd0EvS3dBWVB4RVNBVGtSTXpFd0V5SW5OUll6TWpZMUVUTVJFQ3RmTzBWRFRrbW0vaFFaaHhSVlZ3VDgreEQrdkFBQUFRR0pCTTBDZFFZVUFBa0FFN1lKQkFvTEJJQUpBQzhhelJFU0FUazVNVEFCTmpZM014VUdCZ2NqQVlrVEp3cW9DMWd2V2dUbE42ZFJFak84UmdBQkFYSCtPd0p2LzRNQUNRQVR0Z2tFQ2dzSmdBUUFMeHJORVJJQk9Ua3hNQUUyTmpjekZRWUdCeU1CY1J3ekI2Z0xZamRhL2xSQXVqVVNNOEZDQUFFQmdRVFpBbjhHSVFBSkFCTzJDUVFLQ3dtQUJBQXZHczBSRWdFNU9URXdBUVlHQnlNMU5qWTNNd0ovSFRVR3BnNWpNVndHQ0QzQk1STTl2emtBQWdBbkFqa0NuZ1hIQUFzQUZRQWdRQTRHREFBUkRCRVhGZ2tUSHdNT0lRQS9Nejh6RVJJQk9Ua1JNeEV6TVRBVEZCWXpNalkxTkNZaklnWUZFQ0VpSmpVUUlUSVdzRkplWGxaV1hsNVNBZTcreEo2ZEFUdWVuZ1FBcUthbHE2cWtwYW4rTit6ZEFjWG9BQUlBRkFKS0FyUUZ2QUFLQUJRQVBFQWZGQVVMQndNRENRSUFBZ1VERlJZQkJRVUpEeFFmRkFJVUZBTU9CeDhESUFBL1B6TVNPUzlkTXpNUk14RVNBUmM1RVRNekVUTXpFVE14TUFFakZTTTFJVFVCTXhFeklUVTBOdzREQndjQ3RIMlIvbTRCbUl0OS92SUdCUmdlSGd1b0F4VEt5bVVDUS8zTnc0WkxEQ2N0TFJIMkFBRUFPd0kzQW9rRnFnQWRBQ3RBRlJBREhCY0pGeG9EQkI4ZUV3QUFCaHNZSGcwR0lRQS9Nejh6RWprdk14RVNBUmM1RVRNUk16RXdBVElXRlJRR0l5SW1KelVXRmpNeU5qVTBKaU1pQmdjbkV5RVZJUWMyQVVpUnNLcW1Tb3NwT0l3MlgyNXRaamxNSHpzaEFlLytneFErQkdpUGU0eWJIeGVESWlaVFdVNVlFUWdwQWFCbzVnd0FBQUlBS1FJNUFxSUZ4d0FYQUNNQU5rQWNHeEloQ3dBQUJoSURKU1FlQ3hVQUR4QVBBZzhQQXhnVklRZ0RId0EvTXo4ekVqa3ZYUkk1TXhFU0FSYzVFVE16RVRNeE1CTVFOak15RnhVbUl5SUdCek0yTmpNeUZoVVVCaU1pSmdVeU5qVTBKaU1pQmhVVUZpbmIyMG94TkZPTmxnb0lIWEZWZlpTbWpabXRBVVJSWTFoV1ZYQnFBOE1CQmY4UGNoS1pwaXM3bEg2UXBOSmpYV05QVzFvN1dYd0FBQUVBT1FKS0FvOEZ0Z0FHQUJ4QURRRUZCUUFDQXdjSUFnTWVBQ0FBUHo4ekVSSUJGemtSTXpFd0V3RWhOU0VWQWFJQlh2NDVBbGIrb0FKS0F2aDBYdnp5QUFNQU13STVBcE1GeHdBVkFDSUFMUUEvUUNJV0RTWVRLd01jQndjREJSQVREUVl1THdVUUlDQUxLUnNwQWlrcEdRb2hJd0FmQUQ4eVB6TTVMMTB6RWprNUVSSUJGemtSTXhFekVUTVJNekV3QVRJV0ZSUUhGaFVVQmlNaUpqVTBOamNtSmpVME5nTVVGak15TmpVMEppY25CZ1lUSWdZVkZCWVhOalUwSmdGa2ZKZVVzS1dLa3A5SlZVbzVuVFZVVmxwVVhWRWNTRWFzUkV0RVVZeE9CY2QyYUlKTVNwNXhpWUIwUlhRdUxsMUVabjc5Wmp4SlNUdy9UeHdLSWxRQjd6dzVMMGNoTm1FNVBBQUNBQ01DT1FLY0Jja0FGZ0FpQUR4QUh4b1JJQW9BQUFVUkF5TWtIUTRLQ3dzVUR3NGZEZ0lPRGdNWEZCOElBeUVBUHpNL014STVMMTBTT1JFekVUTVJFZ0VYT1JFek14RXpNVEFCRUFZaklpYzFGak1nRXlNR0JpTWlKalUwTmpNeUZpVWlCaFVVRmpNeU5qVTBKZ0tjMnRSVE1URmRBUlFWQ2lOMFFZT1pxWWlZc1A2NFVWOVZWMVJ6WndSRy92TC9EM1FVQVVZek5KS0RpS1hLVzE5WFVWOVZQbUZ5QUFBV0FGVCtnUWZCQmU0QUJRQUxBQkVBRndBYkFCOEFJd0FuQUNzQUx3QXpBRGNBT3dBL0FFTUFSd0JUQUZzQWF3QjBBSHdBaVFENFFJZEJRRDA4TVRBUEJRQU1WRTVZU0hacmNHQjZaNFdHUlVRcEtDVWtGQW9KRnhlR0JoSTdHMzluWURnWU55OXJOQ3hJSXg4Z0hBTVJUZ3daaW9zS0FDcENXbEdHWEhSY0tVRkdQbVIxZFd4RlBZSjlWa3RyZG1zbU1pVXhGUTBBUWdGQlBsdzliQTB4TWdOckRGeHNhMnRzWEFNQkxTd2RIQmtZRXhJUEREazROVFFoSUFjR0JBRUFMek16TXpNek16TXpNeTh6TXpNek16TXpNek1TRnprdkx5OFJFaGM1RVRrU09Ua1JPVGtSTXhFekVUTVJNeERFTXNReUVUTVJNeEk1RVRNUk14RXpFTVRFTWhFekVUTVJFZ0VYT1JFek16TXpNek16TXpNUk14RXpFVE1STXhFekVUTVJNek16TXpNek16TXpNVEFURVNFVkl4VWxOU0VSSXpVQkVUTVZNeFVoTlRNMU14RWhOU0VWSVRVaEZRRTFJUlVCSXhFekVTTVJNd0UxSVJVQkl4RXpBVFVoRlRNMUlSVUJJeEV6TlNNUk13RWpFVE1GRkFZaklpWTFORFl6TWhZRkZETXlOVFFqSWlVek1oWVZGQVlIRlJZV0ZSUUdJeU1UTXpJMk5UUW1JeU1WRlRNeU5qVTBJd0VpSnpVV016STFFVE1SRkFaVUFTL0FCYzRCTUczNUFHL0FCUTdEYmYxSkFSSDc0UUVPL3ZJQkRnUzNiVzF0YmZ2Q0FSRDhNRzl2QXNBQkVIY0JFZnFvYjI5dmJ3YitiVzM3bjRkL2Y0ZUhmMzZJL25PSGg0ZUhBZUdzYlhBdUxEMHViVjdQZTBJdUpDb3ZPMG94SlZvQlhqUWNLeGxXZldrRXZnRXdiOEhCYi83UXdma0NBUy9DYlczQy90RnRiVzF0QnY1dmIvcW9BUTRDQWdFUCtqdHRiUUdtQVE0RVNtOXZiMi84THdFUWVRRVAvV2dCRUVtUm5KeVJrcHVhazhYRnhHRkRVekZDQ0FnT1JEVlJXUUZpSWlBaUhlT2FLeVZLL3ZvS1pnaFdBWkwrY2w5akFBQURBRlQrd1FlcUJoUUFBd0FlQUNvQUxrQVpBUXNYSlFRZUh4RURDU3NzS0I0VURpSWVEZzRlSWdNQ0FBQXZMeGM1THk4dkVUTVJNeEVTQVJjNU1UQUpBd1UxTkRZM05qWTFOQ1lqSWdZSEZ6WXpNaFlWRkFZSEJnWVZGUU1VRmpNeU5qVTBKaU1pQmdQK0E2ejhWUHhXQStzc1FXZEp1NlZQdWtkU29Gby9QakZJVkRzYlIwWkNTVWhEU0VVR0ZQeFcvRmNEcWZzdk1rRXhVbjVZaDVvNEtySlFPaTgxU3paRWNFbzcvdTAvU0VrK1FFbEkvLy8va2Y0VUFsY0dJUUltQWpjQUFBRUhBVXorcVFBQUFBaXpBUmdSSmdBck5mLy9BQmtEd1FGRUJiWUNCZ0lIQUFBQUFnQUsvK3dFM3dZckFDMEFOZ0JtUURrYkJ4Y0xOQ1V1SHg4ckFpMENKUXNIRWdZM09CUU9SMWtBSVM0aFIxa3JMZzh1SHk0Q0NRTVVMaFF1QlNnb01VWlpLQUVGSFVaWkJSWUFQeXNBR0Q4ckVSSUFPVGtZTHk5ZlhsMFJNeXNSQURNckVSSUJGemtSTXpNUk14RXpFVE1STXpFd0FSWVZFQUFoSUJFME56WTFOQ1lqSWdZSEp6WXpNaFlWRkFjR0ZSUXpJQkUwSnlZa0pqVTBOak15QUJNekZTVW1BaU1pQmhVVUJBUldCUDdnL3YzK2R4QVBKQ0FaTmc4aFUxOVlYUThRNlFGM0JOLyt5YUMycU5BQkFDcVAvc2NjdDN0ZFlRRVRBMDR1UWY2Zi9tNEJXRGw3ZWhjdkl3OEpkaWRkWFNPRGhEclBBbkEvTEFKcHZJT1FvLzdOL3RlQmdkTUJBRjlMalpvQUFRQUFBQUFFZXdYREFCVUFLRUFVRVJJSEVoUURGaGNBRWhRREVoSUZDa3BaQlFRQVB5c0FHRDgvRWprUkVnRVhPUkV6TVRBQkVoSTJOak15RnhVbUl5SU9Bd2NSSXhFQk13STVlbzFOWERvd0tCb2ZLRHRXZkdVZnJQNGp1Z0xOQVNNQk4yd3dENGNHT0tIODdGWDk0d0l2QTRjQUFBSUFFdi9zQm5jRVNBQVVBQ2tBVEVBbkdBTVNJU0VlSncwS0RSNERCZ1VxS3hNZkh3QUlGUXNHQ0FaR1dRZ1BKQnNBRzBaWkVBQVdBRDh5S3hFQU14Zy9LeEVBTXpNUkVqa1lMemtSRWdFWE9SRXpFVE1TT1JFek1UQUZJaVkxTkJNaE5UY2hGU01XRlJRR0l5SW5Jd1lCQmdJVkZCWXpNalkxTlRNVkZCWXpNalkxTkNjQ0tickhoLzdqamdYWCtuWEl1ZDFFQ0VUK3p6OUNiSFZkYktKclhYVnRieFRuOFBBQkIwcEVqdno3OE9lMnRnUE9oUDcrWjY2b2ozMjh2SHFTcWEzKzd3RC8vd0RKQUFBR2NRZDFBaVlBTUFBQUFRY0FkZ0djQVZRQUNMTUJIUVVtQUNzMS8vOEFzQUFBQnNzR0lRSW1BRkFBQUFFSEFIWUJ6UUFBQUFpekFTMFJKZ0FyTmYvL0FBRDkxUVVRQmJ3Q0pnQWtBQUFBQndKYkFUVUFBUC8vQUY3OTFRUE5CRm9DSmdCRUFBQUFCd0piQU1jQUFQLy8vdC8vN0FYU0JjMEFKZ0F5RkFBQkJ3SmMva2NBQUFBSnN3TUNHZ01BUHpVMUFBQUNBSFg5MVFJMS80TUFDd0FYQUI1QURCSUdEQUFHQUJnWkZRTVBDUUF2TTh3eUVSSUJPVGtSTXhFek1UQUJGQVlqSWlZMU5EWXpNaFlITkNZaklnWVZGQll6TWpZQ05YMW1aWGg0WldWK2JrSXpNMEk4T1RWQS9xNWhlSFZpWW5WMllUazhQRGs0UFQwQUFnQ1lCR2dDendYRkFBZ0FGd0FlUUE0T0NRTUlEQk1KQlJnWkFnc0lGUUF2eE56R0VSSUJGemtSTXpFd0FUWTNNeFVHQmdjakpUUTNGUVlWRkI0Q0ZSUWpJaVlCc0VZY3ZTbDNNVTcrNk8xNUh5VWZYVGREQkllMWVoUk9yRGwyb3oxSUtUVVVFeEFhSEVwRUFQLy9BQjBBQUFiVEJoOEFKd0JKQXJBQUFBQW1BRWtBQUFBSEFFd0ZiUUFBLy84QUhRQUFCc01HSHdBbkFFa0NzQUFBQUNZQVNRQUFBQWNBVHdWdEFBQUFBZ0I5Lyt3R1pBWVVBQlVBSVFBOFFCOFdCZzhSRVJ3QUFCUUxCZ1FpSXhRTEF3a0pIMGxaRHdrRUF4bEpXUU1UQUQ4ckFCZy94aXNSRWdBNU9SRVNBUmM1RVRNekVUTVJNekV3QVJBQUlTQUFFUkFBSVNBWFBnSTFNeGNHQmdjV0FSQVNNeklTRVJBQ0l5SUNCYnorbmY3Ry9yMytvUUZoQVVNQlJiTXlPaHUyRGgyRGFHRDdkZnIwOC9iMTh2UDlBdDMrbnY1eEFZa0JhZ0ZvQVliWERFTm1hUmFiclNldy92NysxdjdPQVRFQkt3RW5BVEgrMFFBQUFnQnovK3dGR1FUd0FCWUFJZ0E4UUI4WEJ4QVNFaDBBQUJVTUJ3UWpKQlVNQXdvS0lFWlpFQW9RQXhwR1dRTVdBRDhyQUJnL3hpc1JFZ0E1T1JFU0FSYzVFVE16RVRNUk16RXdBUkFBSXlJbUFqVVFBRE15Rno0Q05UTVhCZ1lIRmdVVUZqTXlOalUwSmlNaUJnUmkvdkx1aytSOEFRenUyWWt6T2hxMER4OTVaa2Y4dlo2dHI1MmZyNjJjQWlYKzlQN1RpZ0VDclFFTUFTdU5EMEZqYmhlY3J5YUt1ZFBiMjlQUzJOZ0FBUUM2Lyt3R2V3WVVBQnNBTTBBWUJRY0hBUXNVRVFzUkhSd0tBUTRiQlJJRERoZEpXUTRUQUQ4ckFCZy94ak1TT1RrUkVnRTVPUkV6RVRNekVUTXhNQUVWUGdJMU14Y0dCZ2NSRUFBaElBQTFFVE1SRkJZek1qWTFFUVVaT2tZZnRRNGhySlgrNGY3NC92VCsxS3JNeHJqQkJiYkdDRDV3YmhhMnVCbjlqZjcrL3VvQkgvMERydnhHdDhUQnZBTzRBQUFCQUtULzdBV1dCUElBSFFCRVFDSUJIQTBQRHhNVUJ3Y0tFeHdUSGg4VkZnb1NGZ01VRFFnZER4a0VSbGtaRmhRVkFEOC9Ld0FZUHpQR0VoYzVFVE1SRWdFNU9SRXpNeEV6RVRNUk14RXpNVEFCRVJRV016STJOUkV6RlRZMk5UTVhCZ1lIRVNNbkl3WUdJeUltTlJFQlRIcUNySittVWtxeUR5Q3dqWWtZQ1RTMWI4dklCRWI5TzRhRXZOVUNQbmtMZ0pvWHVyOE8vS3lUVWxXKzBRTExBUC8vL0ZNRTJmM2NCaUVBQndCRCtzb0FBUC8vL1EwRTJmNldCaUVBQndCMis0UUFBUC8vL0JrRTJmOEJCZDBBQndGUyt4RUFBQUFCL1FnRXVQNXpCbzhBRVFBZVFBd0NCUVVORFFnQUFCTUxFQVFBTDh3eUVRRXpFVE16RWprUk16RXdBUlFIQnlNbk5qWTFOQ1lqSWdjMU5qTWcvbk9tQ21rTVZrNURTVDRnSmtVQkFBWFhqQ0p4c0E0eUt5c3BCbVFLQUFIOU8vNmcvZ0wvZlFBTEFCRzFCZ0FBRFFrREFDL05FUUV6RVRNeE1BVTBOak15RmhVVUJpTWlKdjA3T3lvb09qb29LanZ5T1RZMk9UYzNOd0QvL3dESkFBQUQrQWR6QWlZQUtBQUFBUWNBUS8vWUFWSUFDTE1CRFFVbUFDczEvLzhBeXdBQUJWSUhjd0ltQWJJQUFBRUhBRU1BYUFGU0FBaXpBUkVGSmdBck5mLy9BSFAvN0FRU0JpRUNKZ0JJQUFBQkJnQkR0d0FBQ0xNQ0hCRW1BQ3MxLy84QXNBQUFCR0lHSVFJbUFkSUFBQUVHQUVQY0FBQUlzd0VQRVNZQUt6VUFBUUNGLyt3SGtRWEpBREVBUlVBa0loWXFKeThKQ1FRbkd4WUZNak1BSHhrZlNWa1FLQ2dUQmhrRUxDVVRKVWxaREJNVEFEOHpLeEVBTXhnL014STVMemtyRVFBekVSSUJGemtSTXhFekVUTXhNQUVpQmdjbk5qTXlBQkVRQUNNaUppY2pCZ1lqSUFBUkVCSXpNaGNISmlZaklnSVJFQkl6TWpjUk14RVdNeklTRVJBQ0JhUThYaTFGZnBia0FRSCs1ZjlzckZNSVVLbHIvd0QrNWYva21YeEdMVjA4azZYUHU0dG1xbWFPdTg2bEJTOHBINUpRL29qK3JmNk4vbUV0TXpJdUFac0Jkd0ZUQVhoUWtoOHAvdGYrOXY3VC9ySk1BY24rTjB3QlN3RXdBUXNCS0FBQkFBQUFBQVlkQkVnQUhRQW9RQllYQUEwT0JRVWVIeHNWRFFBU0NnUUVGZzRGRHdRVkFEOC9Nek1TRnprL0VSSUJGemt4TUFFR0JnTWpBVE1URmhjek5qWVRBek1BRmhjek5oSVJNeEFDQnlNREpnTW5DaFN6MWY1L3JQWWdMZ2dUU282c3NnRUpMUW9JclptbXc5dTJmU0VCeVJvei9vUUVTUDFKWGIwMW93RWtBZFg4LzVBc3VBR3pBVkwrbHY0SDVRRmFYQUFDQUJjQUFBVDhCaFFBRVFBYUFFeEFLQWdFRWhJQkR4WUxDd1lQQUFRYkhBY1JBQkZKV1FRQUNCcEpXUUFJQUFnUEFnQVBFa3BaRHhJQVB5c0FHRDhTT1Rrdkx5c1JBRE1yRVFBekVSSUJGemtSTXhFek14RXpNekV3RXlFUk14RWhGU0VSTXlBUkZBUWhJUkVoQVRNeU5qVTBKaU1qRndFL3JBR2kvbDdKQWpIKzkvNzcvbWord1FIcjFjQzF1dHEyQlBvQkd2N21sUDdnL21UUTJnUm0vQ3VKa0lwNkFBQUNBQmNBQUFTY0JTY0FFUUFaQUVkQUpnUUFFeE1QQ3hZSEJ3SUxEUVFhR3dNTkRnMUdXUVFTUmxrRUJBc1FBQTRQQ3hOR1dRc1ZBRDhyQUJnL004WVNPUzhyS3hFQU14RVNBUmM1RVRNUk16TVJNek14TUFFaEZTRVJJU0FSRkFZaklSRWpOVE0xTXhFUklTQTFOQ1lqQWFnQldQNm9BVDhCdGQvYy9pSHI2NllCTVFFZmg1d0VTSXoreGY3TnBxZ0R2SXpmL00zK2w3bGNWQUFCQU1uLzdBY2hCY3NBSUFCS1FDa1hFeE1VQmhnZERBVVlFUlFHSVNJYkFFbFpHd1FHRWhjU1NWa0RGeGNVRlFNVUVnNEpTVmtPRXdBL0t3QVlQejhTT1M4ekt4RUFNeGcvS3hFU0FSYzVFVE1STXhFek1UQUJJZ1FISVJVaEVnQXpNamNWQmlNZ0FBTWhFU01STXhFaEVnQWxNaGNISmlZRmorUCsvQjhDdi8wOUNBRUo5NXJDbU43K3dmNmxDUDZpcXFvQlpCNEJjUUV3MWJaSVpKMEZNL3J4bHY3di91STNsVGtCY0FGVS9WQUZ0djJTQVRNQlRnSmNrakFtQUFBQkFMRC83QVdjQkZ3QUlRQlpRRElXR1JrS0F3a0ZCUVlRSUJnREJnVWlJdzBUUmxrTkVCa0VDUVJHV1JZUENSOEpBZ3NEQ1FrR0J3OEdGUUFjUmxrQUZnQS9Ld0FZUHo4U09TOWZYbDB6S3hFQU14Zy9LeEVTQVJjNUVUTVJNeEV6TXhFek1UQUZJZ0FuSVJFakVUTVJJVFlrTXpJV0Z3Y21JeUlHQnlFVklSWVdNekkyTnhVR0JIZnIvdlFML3VHbXBnRWhHQUVOMzFHYU5qS0taYU9uRUFJWS9lWUpxYVE5ZDJKdUZBRUsrUDRTQkVqK00rdjJJQm1OTTZTcWpieTFGaVdUT1FBQ0FBQUFBQVZ0QmJZQUN3QVNBRFJBR3dJREJ3d0REUW9GRkJNQkJRd0ZTVmtRQ0F3TUJ3Z0RDd01IRWdBL016TS9Famt2RWprckVRQXpFUklCRnprUk16RXdBU01SSXhFakFTTUJNd0VqQVNFbkppY0dCd09ZbEp5Vi90K3lBbWllQW1lMy9Wd0JURkk0SGhoQUFxcjlWZ0txL1ZZRnR2cEtBei9Qa0dSaXBBQUFBZ0FLQUFBRWVRUklBQXNBRWdBMVFCd0ZCZ29NQmcwREFRWVVFd1FJREFoR1dSRUxEQXdLQ3c4R0Fnb1ZBRDh6TXo4U09TOFNPU3NSQURNUkVnRVhPUkV6TVRBQkFTTURJeEVqRVNNREl3RURJU1ltSnlNR0FxZ0IwYXpQY1pkenphd0IwU0VCRHlzNElna2NCRWo3dUFIcC9oY0I2ZjRYQkVqK0xXeUthbHdBQUFJQXlRQUFCMTRGdGdBVEFCb0FSa0FsRGdvS0N3SURFaFVERkFnSEN3Y2JIQVVCQ1E0SlNWa1VHQXdPRGdzUURBTVRCd01MRWdBL016TXpQek1TT1M4U09UTXJFUUF6TXhFU0FSYzVFVE1STXhFek1UQUJJeEVqRVNNQkl3RWhFU01STXhFaEFUTUJJd0VoQWlZbkJnWUZoWSthay83anVnRWkvbCtxcWdIaEFRYWVBbWE4L1dZQlBuWWNEQk1qQXJEOVVBS3cvVkFDc1AxUUJiYjlrZ0p1K2tvRFNBRTFWaTlEYUFBQ0FMQUFBQVlVQkVnQUV3QVpBRTFBS3hFTkRRNEZCZ0VaQmhnTENnNEhHaHNJQkF3UkRFWlpHQlVUTHhFL0VRSVJFUTRURHc4UENnWUNEaFVBUHpNek16OC9Famt2WFJJNU15c1JBRE16RVJJQkZ6a1JNeEV6RVRNeE1BRUJJd01qRVNNUkl3TWpFeUVSSXhFekVTRVRGeU1HQmdjaEJFWUJ6cXJRY1podTBhelIvdCttcGdGZXhXZ0lDaUJaQVF3RVNQdTRBZTcrRWdIdS9oSUI3djRTQkVqK013SE5jeUpmMlFBQUFnQVVBQUFGcmdXMkFCOEFJZ0JMUUNnZ0FROFFJUjRlSFJBQ0FRY0dKQ01lQVNFZkh5RkpXUTRTSFJKS1dTSUNIUjBZSHdNUUNCZ1NBRDh6TXo4U09TOHpNeXNSQURNckVSSUFPVGtSRWdFWE9SRXpFVE1STXpFd0FSVUJIZ0lYRXlNRExnSWpJeEVqRVNNaUJnWUhBeU1UUGdJM0FUVUZJUUVGS2Y1YWRwcGtNb1d1aVNORVpWa2JxaHBiWTBFZ2g3bUlMMk9WZHY1bEE3NzlDZ0Y3QmJhRi9oRUdTSXVrL2pzQnlXOWdKdjFDQXI0blgyLytOd0hGbjQ1SkJ3SHZoWm4rT1FBQUFnQU1BQUFGRkFSSUFDQUFJd0JPUUNvaEFROFFJaDhZSHg0UUFnRUhCeVVrSHdFaUlDQWlSbGtSRGhJZUVrZFpJd0llSGhnZ0R4QUlHQlVBUHpNelB4STVMek16S3hFQU16TXJFUklBT1RrUkVnRVhPUkV6RVRNUk16RXdBUlVCSGdNVEl3TXVBaU1qRVNNUkl5SUdCZ2NESXhNK0F6Y0JOUVVoQVFTTC9xNVhiMGt4bTZ5RklqcFVUQXFaQzB0U09DZUhxb01ZTUVsdVYvNnhBeUQ5dEFFbEJFaHAvcUFITUZCcC9uRUJVRmRISFAzMkFnb2FRRjcrcmdGUVBXbFBNZ2dCWUdtTS9zRUFBQUlBeVFBQUI4VUZ0Z0FrQUNjQVlVQTFJUjBkSGlZakR4QUNKeVVCQndFbkVDSWJJeGdlQ1Nrb0l3RWtKaVFtU1ZrU0Rod2hIRWxaSndJaElSNGtBeDhER0JBSUhoSUFQek16TXo4L0Vqa3ZNek1yRVFBek15c1JFZ0E1T1JFU0FSYzVFVE1STXhFekVUTVJNeEV6TVRBQkZRRWVBaGNUSXdNdUFpTWpFU01SSXlJR0JnY0RJeE0yTnlFUkl4RXpFU0VCTlFVaEFRYzkvbDE0bVdVdGlLaUtIMFpwWHhpc0dWNWtRaUdIc29jM09QNVNxcW9DMS81b0E4SDlDZ0Y3QmJhRi9nNEdTSkNjL2pzQnlXaGpLUDFFQXJ3b1gyeitOd0crdURyOVVBVzIvWklCNllXWi9qY0FBQUlBc0FBQUJyb0VTQUFrQUNjQVowQTZJUjBkSGlZakR4QUNKeVVCQndFbkVDSWJJeGdlQ1Nrb0l3RWtKaVFtUmxrU0Rod2hIRVpaSndJdklUOGhBaUVoSGlRUEh3OFlFQWdlRlFBL016TXpQejhTT1M5ZE16TXJFUUF6TXlzUkVnQTVPUkVTQVJjNUVUTVJNeEV6RVRNUk14RXpNVEFCRlFFZUF4TWpBeTRDSXlNUkl4RWpJZ1lHQndNakV6WTNJUkVqRVRNUklRRTFCU0VCQmpIK3JsaHZTVENicklVaU9sWktDcG9LUzFRM0pvZXFneThsL3MybXBnSTEvckFESWYyMEFTVUVTR24rbmdjeFRtbitjZ0ZRVmtZYy9mZ0NDQnMvWFA2dUFWQjRLUDRRQkVqK05RRmlhWXoreHdBQkFELytUZ1ExQnRFQVN3Q0VRRTBBRXlFL0dVWkdDajgzUXp3cUhDMG9Fd3RNVFVrV1NsbEpFemswTVE4dUh5NHZMZ01KQXk0cVFFTWRIQjBjU2xrZEhSQThLaW9rU2xrcUJBb0pTVmtLRUJBRFNWa1FJd3dIU1ZrTUlnQS9Ld0FZUHlzQUdCREdLd0FZUHlzUkFETVNPUmd2S3hFU0FEa2FHQkRkWDE1ZE9jUXlQeXNSRWdFWE9SRXpFVE1STXpFd0Z4UVdNekkzTmpNeUZ4VW1JeUlIQmlNaUpqVTBOamMyTmpVUUlTTTFNekkyTlRRbUl5SUdCeWMyTnlZbkp6VXpGaGMyTmpNeUZ4VW1JeUlHQnhZV0ZSUUdCeFVXRmhVVUJBVUdCdkJYV1dGNGVFYWJSMUNnUkdscGFiTzQyZWpNdGY1QTJ0SE40YUtKYXJ0dVZxaStPWFV4ZTF5RFhJTkFNakFZS3l4dk1MTEJ2NnE2eS83bC91YUtob2szTWdjR0o2WXpCUVY5aFg2QkNRaUtqUUVNajVPRWE0QTNSWEp5SEVKNU5CczdpSE5XRG5FS1VrY1h2WStNdUJvSUdMS1EwTlVKQlRjQUFBRUFHZjU3QTM4RlRnQkdBSU5BVGhjcE5nc3VFQkFnQ3dNT0NENHlRRHdwQzBkSVJENUJBQVZIV1FBUFFSOUJMMEVEQ1FOQlBpWWFSbGtqSFVaWkRqTXlNekpHV1NZak16TWpKZ01nUGo0NFJsa0lQaEFnSWhNc1Ixa1RGZ0EvS3dBWVB6OHpLeEVTQUJjNUdDOHZMeXNSRWdBNUt5c0FHQkRVWDE1ZHhDc1JFZ0E1RVJJQkZ6a1JNeEV6RVRNeE1BRXlGeFVtSXlJR0J4WVdGUlFIRlJZVkZBWUhEZ0lWRkJZek1qYzNNaGNWSmlZakJ3WWpJaVkxTkRZM0pEVTBKaU1qTlRNZ05UUWpJZ1lISnpZM0ppYzFNeFlYTmpZQytETXRHQ2t2WnkxNmpOUDQ4dUZkYlRCTFdWWjZyMzBuRlZRM3M0SmNrSisrdEFGT25KK1Vkd0UzL0VxUFdEdDhmbHhuZTB1TVdJWUZUZzl3Q2s4K0hJcHJ1RGtJUjhxVXFBTUNGeW9zTVNzRkJTZVBFeGdGQlhkd2RIMERCTDVoV28yc29pSWtoemNQZFdJYk5JbHVWZi8vQUcwQUFBWHlCYllDQmdGMUFBRC8vd0NrL2hRRmh3WVNBZ1lCbFFBQUFBTUFmZi9zQmI0RnpRQUxBQklBR1FCSFFDVVdFQkFHRnc4UEFBWUFHaHNXRUVsWkR4WUJDd01XRmdNSkNSTkpXUWtFQXd4SldRTVRBRDhyQUJnL0t4RVNBRGtZTDE5ZVhTc1JFZ0U1T1JFekVUTVJNeEV6TVRBQkVBQWhJQUFSRUFBaElBQUJNaElUSVJJU0V5SUNBeUVtQWdXKy9wMyt4UDY5L3FFQllBRkVBVHNCWXYxaDVmY04vQ3NOK2VqZyt4TUQweEgwQXQzK29mNXVBWXNCYUFGbEFZbitjUHhFQVJFQkRQNzEvdTRFdFA3Ky93RCtBUVFBQUFNQWMvL3NCR0lFWEFBTUFCTUFHZ0JKUUNjWEVSRUhHQkFRQUFjQUd4d1hFVVpaRHhjZkZ3SUxBeGNYQXdvS0ZFWlpDaEFERFVaWkF4WUFQeXNBR0Q4ckVSSUFPUmd2WDE1ZEt4RVNBVGs1RVRNUk14RXpFVE14TUFFUUFDTWlKZ0kxRUFBek1nQUJNalkzSVJZV0V5SUdCeUVtSmdSaS92THVrK1I4QVF6dTVnRVAvZ2llcEFyOWFRbWdvSnllRFFLVEQ2RUNKZjcwL3RPS0FRS3RBUXdCSy83Ty9VMjR2N3E5QTFpdHA2aXNBQUFCQUFBQUFBVklCY01BRlFBZ1FCQUdGaE1YRVFCS1dSRUVDZ1VHQXdVU0FEOC9FamsvS3hFQk14STVNVEFCSWdZSEFTTUJNd0VXRnpZM0V6NENNeklYRlNZRTRUdE9PZjY0eGYzdXRBRlNTQ01nUnFJN1ZHNVpLazg0QlRkbnRmdmxCYmI4VnNlUGtOOENCcitZUVJPTkZBQUJBQUFBQUFROUJGSUFGZ0FlUUE4QkZ3OFlEUkpIV1EwUUJRRVBBQlVBUHo4NVB5c1JBVE1TT1RFd0lRRXpFeElYTXpZVEV6NENNeklYRlNZaklnWUhBd0dXL21xdTRXUVRDQmRTWUNWSFcxUXRIaDBtTHpvYytBUkkvWnYrOUdSMkFRc0JOWHA3TkFwL0NGUmMvTi8vL3dBQUFBQUZTQWR6QWlZQ2dBQUFBUWNEZGdUWEFWSUFDclFDQVNFRkpnQXJOVFgvL3dBQUFBQUVQUVloQWlZQ2dRQUFBUWNEZGdSa0FBQUFDclFDQVNJUkpnQXJOVFVBQXdCOS9oUUpvZ1hOQUFzQUZ3QXVBRVJBSmd3R0VnQWhMaWNZQUFZR0x6QWxLa3BaSlJzZEhCd0RJQmdQQ1JWSldRa0VBdzlKV1FNVEFEOHJBQmcvS3dBWVB6TVNPUkV6UHlzUkVnRVhPUkV6RVRNeE1BRVFBQ0VnQUJFUUFDRWdBQUVRRWpNeUVoRVFBaU1pQWlVekV4WVhNelkyRXpNQkJnWWpJaWMxRmpNeU5qYzNCVlQrdWY3Yy90Zit2UUZEQVN3Qkl3RkYrOTNmMmRyZDNOamE0UVJ2c1BaT0ZBZ0xVK1N3L2l0RnZJaE1TamRDWG5ValBRTGQvcUQrYndHTEFXZ0JaZ0dJL25EK29QN1gvczBCTVFFckFTa0JMLzdTUWYyTHoyWXMrd0tEK3lDMm5oR0ZER2RablAvL0FIUCtGQWg3QkZ3QUpnQlNBQUFBQndCY0JIVUFBQUFDQUgzL2h3WVFCaTBBRXdBb0FGRkFLaFFLSmcwSEVTSWlBeHdmQUFBY0J4Y0tCU2txSkNJbURTWkpXUkVQRFFNY0doY0hGMGxaQlFNSEVnQS9Nek1yRVFBek14Zy9Nek1yRVFBek14RVNBUmM1RVRNUk16TVJNeEV6TXhFek1UQUJFQUFGQmlNaUp5UUFFUkFBSlRZek1oY0VBQUVVRWhjMk5qTXlGellTTlRRQ0p3WWpJaWNHQWdZUS90SCsrQnAzZkJUKzlQN1JBU3NCRUJSOGVSWUJEQUV0K3lIS3ZSRkpObTRmdmNyS3ZSOXVjUis5eWdMZC90TCtjeXh2YnlrQmlnRTJBVEVCaFN4c2JDeitjLzdWOVA3UEtUQW1WaWtCTWZUMEFTOG5XRlluL3RNQUFBSUFjLytUQk04RXRBQVhBQzBBVUVBcUdBd1BDU3NiSlJVREl3QUFBeUFiQ1F3R0xpOG9KU3NQSzBaWkZSSVBFQ0FlR3drYlJsa0dBd2tWQUQ4ek15c1JBRE16R0Q4ek15c1JBRE16RVJJQkZ6a1JNeEV6TXhFekVUTVJNekV3QVJRQ0J3WUdJeUltSnlZQ05UUVNOelkyTXpJV0Z4WVNCUlFXRnpZMk16SVhOalkxRUNVR0JpTWlKaWNHQmdUUDRNd0pRRGc1UFFuTDVlRFFDRDQ1T0VBSnl1TDhVSDJKRER3MVp4aUdmUDc4RFQwek5Ud01pWDBDSmVuKzN5VTJMU3M0SkFFbTVla0JJQ1E0S2lzNUp2N2M0YkhTSHlvaVNoL1Nyd0ZnUGlvZ0lDd2YwUUFBQXdCOS8rd0hmd2c3QUJVQVJRQlVBRlZBTGtNM0h5c3JBU1pHUzFCSVBBdzNDbFZXRlFJQ0J3Y1FERkpBU0RvaVFEcEFTVmtvT2dRY0ZqUVdTVmt1TkJNQVB6TXJFUUF6R0Q4ekt4RUFNeGdRMWhyYzFNMHlFamt2TXhFU0FSYzVFVE1STXpFd0FSVWpJaTRDSXlJR0ZSVWpOVFEyTXpJZUFqTUJNalkzRmhZek1oSVJFQUlqSWdZSEp6WXpNZ0FSRUFBaElpWW5CZ1lqSUFBUkVBQXpNaGNISmlZaklnSVJFQklCRkFjMU5qVTBMZ0kxTkRNeUZnV2lFVlNPZUdZckx6eDlkSEE2Y0hlRlR2MG9XS3M5TjZ0ZHZOS2xrenhmSzBaNW11UUJBZjdnL3Yxb3FreExwMjcrL1A3akFRSGttbmxHSzE0OGxLWFNBb0R0ZUI4a0gxdzRRd2ZIZVNRckpEUXpFQnhuYmlRc0pQaTZRajg1U0FGT0FTMEJDd0VvS3grU1V2NkkvcTMralA1aUtEQXRLd0dkQVhVQlZRRjJVcElmSy83Wi92VCswZjYwQm1paVBVZ3BOUlFTRVJvY1NVUUFBQU1BYy8vc0JnUUhCZ0FxQUQ4QVRnQmNRRE1UQnh3b0tDd2lRRVVOU2tJMkJ3cFBVREk2UHkwdE5reENDa0FmRUFvUVJsa0NGMFpaQWdRbENoQWFGUVFWUmxrQUJCWUFQek1yRVFBekdEOHpFamtyS3hFQU14b1lFTjdjMURJUk04MHlFUklCRnprUk14RXpNVEFGSWljR0l5SUNFUkFTTXpJV0Z3Y21JeUlHRlJBaE1qY1dGak1nRVRRbUl5SUhKelkyTXpJU0VSQUNBeFVqSWk0Q0l5SVZGU00xTkRZek1oNENNd1VVQnpVMk5UUXVBalUwTXpJV0JDdVVYbHlQNGZyUHVqNTNLRGxaUjNSdEFURjdjRDV2UXdFdGJuTkhXVGtvZHo2N3p2ZFJFRlNQZUdVcmEzMXpjRHB4ZG9OTy92RHVkeDRrSGx3NFF4UkJRUUVqQVE0QkZ3RW9JQm1MTTliVy9sNVFLaVlCb3RiV000c1pJUDdYL3VyKzlmN2FCcVY0SkNva1poRWZaRzhsS3lYZG9UNUlLRGdVRVJFWkcwcEVBQUFDQUY3LzdBZC9Cd1FBRFFCQUFGOUFOREFrT1RZK0Z4Y0JFallwRENRSFFVSU9MU2N0U1ZrZU56Y2hKd1VKQ1ExQUNROUlEUWNEQzBBVUp3UTdNeUV6U1ZrYUlSTUFQek1yRVFBekdEOHpHdDR5TXMwck1oRXpFUkk1THprckVRQXpFUklCRnprUk14RXpFVE14TUFFVkJ5TW5Jd2NqSnlNSEl5YzFBU0lHQnljMk16SVNFUkFBSVNJbUp5TUdCaU1nQUJFUUFETXlGd2NtSmlNaUFoRVFFak15TmpjUk14RVdNeklTRVJBQ0JZdFFJREs2TVNFeHZDOGhVQU5EUEYwdFJueVo1UC8rNHY3OWRLeE1DVTZzY1A3OC91TUJBZVdXZmtZdFhUeVRwZEsrUVlJenFtYVJ2TlNsQndRYnJHZG5aMmVzRy80cktSK1NVUDZJL3EzK2kvNWpNREF4THdHZ0FYSUJWUUYyVUpJZktmN1gvdmIrMGY2MEppWUJ5ZjQzVEFGS0FURUJDd0VvQUFBQ0FBQUFBQVlkQmFRQURRQXFBRDlBSkNRQkRob2JEQklIS3l3b0ZRNGZGZ01SRWdVSkNRMUFDUTlJRFFjREN5TWJFZzhSRlFBL1B6TXozakl5elNzeUVUTVJFaGM1UHhFU0FSYzVNVEFCRlFjakp5TUhJeWNqQnlNbk5RRUhBeU1CTXhNV0Z6TTJOaE1ETXdBV0Z6TTJFaEV6RUFJSEl3TW1CTFpTSGpLOE1SOHh2REllVUFHc0o2clYvbitzOWljcENBd2p1cXl5QVFrdENnaXRtYWJEMjdaOUlRV2tHNnhuWjJkbnJCdjhKVi8rbGdSSS9VbHZxeU5SQVlnQjFmei9rQ3k0QWJNQlV2NlcvZ2ZsQVZwY0FBQUJBSDMrRkFUakJjc0FGd0F0UUJnRER3a0tGUW9QQXhnWkV3QkpXUk1FREFaSldRd1RDaHNBUHo4ckFCZy9LeEVTQVJjNUVUTVJNekV3QVNJQUVSQUFJVEkzRVNNUkl5QUFFVFFTSkRNeUZ3Y21BMGoxL3VBQkNnRUNiem1xRlA2MS9wK3ZBVWpZN2FwSHF3VXovc0QrNlA3YS90UVgvWFFCMkFHRUFXM2dBVmE0VkpKT0FBRUFjLzRVQTZJRVhBQVlBQzlBR0E4REZ4WUpGZ01ER1JvWEd3WU1SbGtHRUFBU1Jsa0FGZ0EvS3dBWVB5c0FHRDhSRWdFWE9SRXpFVE14TUFVaUFCRVFBRE15RmhjSEppTWlCaFVVRmpNeU5qY1JJeEVDZGY3Ky9BRVIrMCtrTURHT2FMR3JxNnMxVURtbUZBRWZBUklCRkFFckloZU5NODNkM01nUkd2MXVBZGdBQUFFQWF2LzhCSFVGQmdBVEFDOUFJUVFDQ0FNR0FCRUhDaEFORWd3T0RoVVVFd0FERVFZUEJSQUhEUW9KREFzQkVnQS96UmM1RVJJQkZ6a3hNQUVESnhNbE53VVRKVGNGRXhjREJRY2xBd1VIQWdLMmViYis0VUlCSWMzKzMwTUJJYmwydUFFaFJQN2h6QUVlUVFFNS9zTkRBVUttYzZnQlpLWjFxQUU5US83QXBuT20vcDZvY3dBQkFNc0VrUU9zQmJRQUV3QWVRQXdBQmdvUUJoQVVGUU1BRFFrQUx6TXpNaEVTQVRrNUVUTVJNekV3QVFZR0l5SW1OVFEyTXlFMk5qTXlGaFVVQmlNQmh3WXFNRE1wS2pZQndRWXJMek10TERZRThDMHlNalUxS1M0d01UTTRLQUFCQVBnRTVRUGJCZGNBRXdBY1FBc0hFaFVVQUJJU0RBU0FDUUF2R3N3eU14RXpFUklCT1RreE1BRXlOell6TWhZVkZTTTFOQ01pRGdJakl6VUJCSGlXbFZGdmRIMXFLMlo1amxRUUJXSTdPbTlrSHhGbUpDc2tlUUFCQWQ4RTF3TE5CalVBRGdBWVFBb0tBQXdGQUFNUEVBTU5BQy9NRVJJQkZ6a1JNekV3QVRRMk16SVZGQTRDRlJRWEZTWUIzME00WEI0a0huZnVCYmc0UlV3YkdSQVNGRFlvU2tBQUFRSGhCTmNDendZMUFBNEFHRUFLQlFBQUNnSUREeEFNQWdBdnpCRVNBUmM1RVRNeE1BRVVCelUyTlRRdUFqVTBNeklXQXMvdWR4NGtIbHc0UXdXNG9VQktLRFlVRWhBWkcweEZBQWdBS2Y3QkI4RUZrUUFNQUJvQUtBQTJBRVFBVWdCZkFHMEFnRUJKWHloRVdpSStEQm9IRkZJMmJVd3daeEJ1YndBSE9raElRVTlGUkQ1TVZtTmpYR3BtWDFwdEhpd3NKVE12SWlnRE5oQVhCMDlNYW0wek5oY1hOak50YWt4UEJ3Z0pEUlFEQ1FBdk15OHpFaGM1THk4dkx5OHZMeThSTXhFWE14RXpNeEV6RVRNek14RXpNeEV6RVRNek14RXpNeEV6RVRNUkVnRVhPVEV3QVNZbUl5SUdCeU0yTXpJV0Z3TW1KaU1pQmdjak5qWXpNaFlYQVNZbUl5SUdCeU0yTmpNeUZoY2hKaVlqSWdZSEl6WTJNeklXRndFbUppTWlCZ2NqTmpZek1oWVhJU1ltSXlJR0J5TTJOak15RmhjQkppWWpJZ1lISXpZek1oWVhJU1ltSXlJR0J5TTJOak15RmhjRWJ3VThSVTR5QlVzTHhWMXhCMDhGUEVWT01nVkxCV1JuWEhNR0FmUUZQRVJPTWdWTUJXVm5YSE1HK3k4RlBFUk9NZ1ZNQldWblhITUdCREVGUEVST01nVk1CV1ZuWEhNRyt5OEZQRVJPTWdWTUJXVm5YSE1HQlBBRlBFUk9Nd1ZMQzhaY2N3YjV2Z1U4UkU0eUJVd0ZaV2RjY3dZRXp5d3NLUy9DWlYzNThpd3NLUzlaYVdaY0FSWXRLeWN4V21sbVhTMHJKekZhYVdaZEE5c3RLeWN4V21sbVhTMHJKekZhYVdaZC9oa3NMQ2d3d21oYUxTc25NVnBvWmx3QUFBZ0FLZjUvQjMwRjB3QUhBQThBRndBZkFDY0FMZ0ExQUQ0QU5FQWxGUmNsSUQ0NkJRRXBMQjhjTWpVSkRSQS9RRHNyQnk0MkdSVWRFUzhuRHlRekRnVU1CUUF2THhJWE9SRVNBUmM1TVRBRkZ3WUdCeU0yTndNbk5qWTNNd1lIQVRjV0ZoY1ZKaWNGQnlZbUp6VVdGd0UzTmpZM0Z3WUhBUWNHQnljMk53TW5KaWMzRmhjQkZ4WVdGd2NtSmljRU53c1JSaVJoTlJFN0N4TkpIMkUwRWdJakRrZklRZDJCKzJnT1FyOVAzWUVEcGdKRHZrTkZzWGo4NmdLYnFVV3hlQ3NSVWtWRGUwd0RhaEVuV2haREg0SW1JdzVDdjAvZGdRU1lEa2ZJUWR5Qy9oWUxFMGtmWVRVUk93c1JSaVJoTlJFQnFoQW5XQmxFYmxqOGxSQlpQMFJ1V0FMZUFveTNSc1pqL09rQ1JjSThSakxETkFBQUFnREovb01HQ0FkZUFCUUFJZ0JaUUM4TkNnd0hEZzRKRXdJQ0ZCUVlJQWtLQlNRakZCSUdCUkVTQlJJT0FBNEpTVmtPRWd3aUh3OFlBUmdjRlFjQUF3QS9NdDR5elYweVB6OHJFUklBT1RrUk14RXpHRDhSRWdFWE9SRXpFVE1STXhFek14RXpNVEFUTXhFVUJ3Y3pBVE1STXdNakV5TVJORGNqQVNNQklpWW5NeFlXTXpJMk56TUdCc21oQ2dRSUF6UzR1SS9GbktBVENmekp1Z0pEdXFnS213cGRibWxqQ1o0TXRRVzIvTkYyemxNRXh2cmkvZXNCZlFNbHIvZjdOUVlyajZSc1RsMWRuNVFBQWdDdy9vY0ZFZ1lNQUJFQUh3QlBRQ29LQndrRUN3c0dEd0VCRUJBVkhRWUhCU0VnQXc0UUVROExCa1paQ3hBVkNTSWNEeFVCRlJrU0JBOEFQOTR5elYweVB6OHpLd0FZUHhJNU9SRVNBUmM1RVRNUk14RXpFVE16RVRNeE1BRVJGQWNCTXhFekF5TVRJeEUwTndFakVTVWlKaWN6RmhZek1qWTNNd1lHQVV3S0FsSFBzSUdzZlpzSS9hN05BZXk1cWdxY0IxcDBaMlFLblF5eUJFajlhb2lJQTZiOFIvMzRBWGtDb0o1by9Gb0VTSkdQcEdaVVdtQ2VsUUFDQUM4QUFBUjlCYllBRVFBWkFFMUFLUWdFRWhJQkR4VUxDd1lQRVFRYUd3Z1pTVmtIRVFBUlNWa0VBQWdBQ0FBUEFnOFNTbGtQRWdJREFEOC9LeEVTQURrNUdDOHZFVE1yRVFBekt4RVNBUmM1RVRNUk16TVJNek14TUJNek5UTVZJUlVoRVRNZ0VSUUVJU0VSSXdFeklCRTBKaU1qTDVxcUFWYitxc0FDU3Y3cy92SCtiNW9CUk4wQmU3akoxd1Q4dXJxVy91RCtaTkxZQkdiOEt3RVpoSUFBQUFJQUZBQUFCRXdHRkFBU0FCb0FTMEFvQkFBVUZCQU1Gd2dJQWd3T0JCc2NCQk5HV1FNT0R3NUhXUUFQQkE4RUR3d1JBQXdVUmxrTUZRQS9Ld0FZUHhJNU9TOHZFVE1yRVFBekt4RVNBUmM1RVRNUk16TVJNek14TUFFaEZTRVJJVElXRlJRR0l5RVJJelV6TlRNUkVTRWdOVFFtSXdGV0FTZisyUUZBMzlmZzNmNGhuSnltQVRFQkg0U2ZCUitCL2VXYW02U3FCSjZCOWZ2Zy9wZTVYRlFBQUFJQXlRQUFCSGtGdGdBUEFCd0FTRUFwRUFvS0N4Z0FBQVFGQXhZR0ZSTVVDd29kSGhZVEhCQU1IRXBaQ1JCS1dRWUREQWtKQ3d3REN4SUFQejhTT1M4U09Ua3JLeEVTQURrNUVSSUJGemtSTXhFekVUTXhNQUVVQmdjWEJ5Y0dJeU1SSXhFaElBUUJNekkzSnpjWE5qVTBKaU1qQkhsemJIaGtsV2FJdUtvQmlRRVNBUlg4K3FaWFRHeHNqSC9DeXNnRURIL0pPWjFVd0J2OXdRVzIxLzN5Q28xU3NFaXlrWTRBQWdDdy9oUUVkUVJjQUJnQUtRQlZRREVkQ3dRSEJ3Z25FaElWRmhRbEZ5SWtJd2dLS2lzbEloa2dEeGxHV1F3TEN3UVVGd1FBRHhBSkR3Z2JBQ0JHV1FBV0FEOHJBQmcvUHo4U0Z6a1JNeXNSRWdBNU9SRVNBUmM1RVRNUk14RXpNek14TUFVaUppY2pGaFVSSXhFekZ6TTJOak15RWhFUUJ4Y0hKd1lESWdZSEZSUVdNekkzSnpjWE5qVTBKZ0t1YTdFOERBeW1oeGtJUUtsdDJ1MjNjMlNEUjIyb2xnS2FxaThwZVdxQlpaWVVUMUtVSXY0OUJqU1dXbEQrMXY3ei9xNlJuRkN1R0FQanVzc2w1OGNNbmxDcVovblgwUUFBQVFBdkFBQUVDQVcyQUEwQVBFQWZBd2NIREFnQUJRZ0tCQTRQQmdvTENrbFpBd3NMQ0EwTkFrbFpEUU1JRWdBL1B5c1JFZ0E1R0M4ekt4RUFNeEVTQVJjNUVUTXpFVE14TUFFVklSRWhGU0VSSXhFak5UTVJCQWo5YXdHby9saXFtcG9GdHBuK0FwYjlkd0tKbGdLWEFBRUFFZ0FBQTBJRVNBQU5BRHhBSHdJR0Jnc0hBQVFIQ1FRT0R3VUpDZ2xIV1FJS0NnY01EQUZHV1F3UEJ4VUFQejhyRVJJQU9SZ3ZNeXNSQURNUkVnRVhPUkV6TXhFek1UQUJJUkVoRlNFUkl4RWpOVE1SSVFOQy9oUUJXdjZtcHA2ZUFwSUR2UDZvZi80YkFlVi9BZVFBQUFFQXlmNEFCTnNGdGdBYkFFRkFJd2tEQXdRWkRnNEhGQVFFSEIwUkYwbFpFUndMQUVsWkN3c0VCUVVJU1ZrRkF3UVNBRDgvS3hFU0FEa1lMeXNBR0Q4ckVSSUJGemtSTXhFekVUTXhNQUVpQnhFakVTRVZJUkUyTXlBQUVSQUFJU0ltSnpVV015QVJOQUFDTVdSYXFnTkovV0ZhZVFGQUFWWCs0djc5VTMxR2U0a0JmLzhBQW84TS9YMEZ0cG45L0FyK3JmN0cvc1grcFJVY21ERUIvdlVCQkFBQUFRQ3cvZ29EK2dSSUFCc0FRVUFqQ0JrVURnNFBEd0lTR1FRZEhCWUxSbGtXRmc4UUVCTkdXUkFQRHhVQUJVWlpBQnNBUHlzQUdEOC9LeEVTQURrWUx5c1JFZ0VYT1JFekVUTVJNekV3QVNJbk5SWXpNalkxTkNZaklnY1JJeEVoRlNFUk5qTWdBQkVRQWdKR2tXVjBlNFdJc3JWRlNxWUNtdjRNVWpzQkVBRUg1UDRLUEpVL3l0ZmYwQkgrSlFSSWp2NjNEUDdsL3RuKzlmN2FBQUFCQUFMK2d3YjRCYllBRlFCTlFDa0dFUkVERWcwTURBZ0pFZ0FCRlFjV0Z4SVZFaE1RQ1FZREFBQVBBUThLU1ZrUEVnMGlCd1FCQXdBL016TS9QeXNSRWdBNUVUTXpNek16R0Q4ekVSSUJGemtSTXhFek14RXpNVEFCQVRNQkVUTVJBVE1CQVRNUkl4RWpBUkVqRVFFakFsYjl3YjRDT2FRQ09yNzl3QUhhdEtKZS9icWsvYnZIQXZBQ3h2MDhBc1Q5UEFMRS9UejlxUDNwQVgwQzVmMGJBdVg5R3dBQUFRQUUvb2NHSHdSSUFCVUFTMEFvQWcwTkZRNEpDQWdFQlE0U0V4RUhGaGNWRHd3RkFoSVNDd01BRXc4T0VSVUxCa1paQ3hVSklnQS9QeXNBR0Q4elB6TXpFamtSTXpNek16TVJFZ0VYT1JFekVUTXpFVE14TUFFekVRRXpBUUV6RVNNUkl3RVJJeEVCSXdFQk13RUNwSmtCeGJiK05nRnd3YUplL2g2Wi9oKy9BZkQrTjdZQnd3UkkvZTBDRS8zdC9scjkrQUY1QWkzOTB3SXQvZE1DTlFJVC9lMEEvLzhBU3Y1Q0JEVUZ5d0ltQWJFQUFBQUhBMzhCV0FBQS8vOEFSUDVDQTM4RVhBSW1BZEVBQUFBSEEzOEJDQUFBQUFFQXlmNkRCU3NGdGdBUEFEdEFJQXdJQ0FrREFnSU9Ed1lKQlJBUkR3d0dBd1VOQ2dNSkVnVUFTVmtGRWdNaUFEOC9Ld0FZUHo4ekVoYzVFUklCRnprUk14RXpFVE14TUNVekVTTVJJd0VIRVNNUk14RUJNd0VFZjZ5aVp2M3BtYXFxQXBmSi9iU2EvZWtCZlFMRmlQM0RCYmI5S3dMVi9ZVUFBUUN3L29VRVBRUklBQTRBT2tBZkRnb0tDd1lGQlFFQ0N3UVBFQUlPQ1FNSUFBd1BDeFVJQTBaWkNCVUdJZ0EvUHlzQUdEOC9NeElYT1JFU0FSYzVFVE1STXhFek1UQUJNd0VCTXhFakVTTUJFU01STXhFREw3YitKd0Yvc3A5VS9neW1wZ1JJL2UvK1dQMzJBWHNDSy8zVkJFajk2d0FBQVFESkFBQUU2UVcyQUJJQU9FQWVCZ0lDQXdvUkVRY1NEZ3dTQXdRVEZBZ0tCZ0FRRWdZREN3UUREd01TQUQ4elB6TVNGemtSRWdFWE9SRXpNeEV6RVRNUk16RXdBUWNSSXhFekVUY1JNeFVCTXdFQkl3RVJJd0h3ZmFxcWZYMEJtOHY5dEFKaXlQNU1mUUtvYS8zREJiYjlKWXNCWGRNQnh2MkYvTVVDWFA3UEFBRUFzQUFBQkRzRVNBQVRBRHBBSHdZQ0FnTU9DaElTQnhNUERCTURCQlFWQ0FvR0FSRVRCZ01MQkE4UUF4VUFQek0vTXhJWE9SRVNBUmM1RVRNekVUTXpFVE1STXpFd0FTY1JJeEV6RVRjUk14VUJNd0VWQVNNQkZTTUJ6WGVtcG5lREFRNjIvandCNjhMKzFZRUJzbm45MVFSSS9ldDVBVXJOQVIvK0pXdjkvZ0U3M1FBQUFRQXZBQUFFNlFXMkFCTUFSMEFtQ0FRUUVBRVJDdzRNQ2dZT0VSTUdGQlVIRXdBVFNWa0VDd2dPQXhFQUFBSU5FUklKQWdNQVB6TS9NeEk1THhJWE9UTXJFUUF6RVJJQkZ6a1JNeEV6TXhFek16RXdFek0xTXhVekZTTVJBVE1CQVNNQkJ4RWpFU012bXFyZDNRS1Z5LzIwQW1MTy9mR1pxcG9GQkxLeWwvNXVBdHY5aGZ6RkFzV0cvY0VFYlFBQUFRQVVBQUFFR3dZVUFCa0FUVUFyQ2dnRUZoWUJGeElRQmhFWEdRWWFHeFFLRHhNWEZRY1pBQmxIV1FRUEFCOEFMd0FEQUFBQ0R3OENBQUEvUHhJNUwxMHpLeEVBTXhnL014STVPUkVTQVJjNUVUTXpFVE16TXpFd0V6TTFNeFVoRlNFUkJ3Y3pOelkyQVRNQkFTTUJCeEVqRVNNVW5LUUJmZjZEQXdNSUVqY29BWERIL2tRQjJjZitmWDJrbkFWYXVycC8vZWhiTnhoS01BR0YvaTM5aXdJRWF2NW1CTnNBQVFBUUFBQUZnd1cyQUEwQU5VQWJBZ29LQ3dVSUJnUUlDd1FPRHdnQ0FBY0xFZ01EQUExSldRQURBRDhyQUJnL1B6TVNPVGtSRWdFWE9SRXpFVE1STXpFd0V5RVJBVE1CQVNNQkJ4RWpFU0VRQWZ3Q2xzdjl0QUppeWYzc21xcityZ1cyL1NVQzIvMkYvTVVDeFlqOXd3VWRBQUFCQUNrQUFBVGpCRWdBREFBMVFCc0ZBUUVKQ1FvTUNnUUdCQTROQ0FJQUJ3b1ZBdzhBREVaWkFBOEFQeXNBR0Q4L014STVPUkVTQVJjNUVUTVJNeEV6TVRBVElSRUJNd0VCSXdFUkl4RWhLUUlDQWR1Mi9pY0NBTUwrQ3FUK29nUkkvZXNDRmYzdC9jc0NLLzNWQTd3QUFRREovb01Gd1FXMkFBOEFSRUFrREFnSUNRMEZCUUFEQWdJQUNRTVFFUXdIU1ZrTURBVU9DZ01KRWdVQVNWa0ZFZ01pQUQ4L0t3QVlQejh6RWprdkt4RVNBUmM1RVRNUk14RXpFVE1STXpFd0pUTVJJeEVqRVNFUkl4RXpFU0VSTXdVZm9xS3EvUDZxcWdNQ3Fwcjk2UUY5QXJEOVVBVzIvWklDYmdBQUFRQ3cvb2NFK0FSSUFBOEFUa0FyQVEwTkRnSUtDZ1VJQndjRkRnTVFFUUVNUmxrUEFSOEJBZ3NEQVFFS0F3OFBEaFVLQlVaWkNoVUlJZ0EvUHlzQUdEOC9NeEk1TDE5ZVhTc1JFZ0VYT1JFekVUTVJNeEV6RVRNeE1BRVJJUkV6RVRNUkl4RWpFU0VSSXhFQlZnSm1wcGFtbHYyYXBnUkkvalVCeS94SC9mZ0JlUUh1L2hJRVNBQUFBUURKQUFBR2J3VzJBQTBBUDBBaENnWUdCd3NEQXdJQUFnY0REZzhLQlVsWkNnb0hEQXdCU1ZrTUF3Z0RBd2NTQUQ4elB6OHJFUklBT1Jndkt4RVNBUmM1RVRNUk14RXpFVE14TUFFaEVTTVJJUkVqRVRNUklSRWhCbS8rc0t6OUFLcXFBd0FCL0FVZCt1TUNzUDFRQmJiOWtnSnVBQUVBc0FBQUJjRUVTQUFOQUVsQUp3RUxDd3dDQ0FnSEJBY01BdzRQRFE4QkNrWlpEd0VmQVFJTEF3RUJBd2dNRlFNR1Jsa0REd0EvS3dBWVB6TVNPUzlmWGwwckFCZy9FUklCRnprUk14RXpFVE1STXpFd0FSRWhFU0VWSVJFakVTRVJJeEVCVmdKbUFnWCtvYWI5bXFZRVNQNDFBY3VNL0VRQjd2NFNCRWdBQVFESi9nQUlIUVcyQUIwQVIwQW1CQVVJQUFBQkZ3ME5FZ0VGQkI0ZkVCVkpXUkFjQ2hwSldRb0tCUVlHQTBsWkJnTUJCUklBUHpNL0t4RVNBRGtZTHlzQUdEOHJFUklCRnprUk14RXpFVE1STXpFd0lTTVJJUkVqRVNFUk5qTWdBQkVRQUNFaUp6VVdNeUFSTkFJaklnWUhCTm1xL1VTcUJCQkVmUUV5QVZIKzVmNytuSHVHZndGNjV1Z3FmeGdGSGZyakJiYjlZUXorcVA3SS9zZitwakdZTVFIKzhnRUZCd1VBQUFFQXNQNEtCcWdFU0FBY0FFZEFKaEVTRlEwTkRnY2FHZ0lPRWdRZEhoY0tSbGtYRnhJVEV4QkdXUk1QRGhJVkFBVkdXUUFiQUQ4ckFCZy9NejhyRVJJQU9SZ3ZLeEVTQVJjNUVUTVJNeEV6RVRNeE1BRWlKelVXTXpJUk5DWWpJZ2NSSXhFaEVTTVJJUkUyTXpJQUVSQUNCUmVEWVcxczhLYXNRMGlvL2QrbUEyOUxRdllCQnRIK0NqeVZQd0doMzlBVi9pa0R1UHhJQkVqK0p3NysxLzduL3ZUKzJ3QUNBSDMvckFYaEJjMEFLQUEwQUZCQUxCc1JMeU1wQUFnQUF4WWdJeEVITlRZbUxFcFpEREltSmc0VUZCbEpXUlFFQ2dWSldRb09EaDVKV1E0VEFEOHJBQmdReENzQUdEOHJFUklBT1Jndk9Ua3JFUklCRnprUk14RXpFVE14TUFFVUFnY1dNekkzRlFZaklpY0dJeUFBRVJBQUlUSVhCeVlqSUJFUUVqTXlOeVlDTlRRU016SVNBelFtSXlJR0ZSUVdGelkyQmJpS2RFSmFUajA0VzdLVVpwRCt5djZoQVVrQk9uOWNMMVJhL2pQLzZ6WXVWbHpHcjdYQnNHZGRYbWRkVTJaekFxYTEvc3RXSGhhWkdXUWtBWWtCVmdGNEFZb2prUno5bnY3Zy9zNEtad0Vjb1BRQkN2NzIvdjZ4ek1td2pQNVZRLzhBQUFJQWMvL0hCTk1FWEFBS0FEVUFVRUFzSGhNQUpnWXNOQ3d2R0NRbUV3YzJOeWtJUjFrTkF5a3BEeFlXRzBaWkZoQUxNVVpaQ3c4UElVWlpEeFlBUHlzQUdCREVLd0FZUHlzUkVnQTVHQzg1T1NzUkVnRVhPUkV6RVRNUk16RXdBUlFXRnpZMk5UUWpJZ1lCSWljR0l5SW1KalVRRWpNeUZ3Y21JeUlHRlJRV016STJOeVkxTkRZek1oWVZGQVlIRmpNeU54VUdBdTVFUDBSVGgwaExBV2FUZ21CN2xlSjYrT05iVFNVMlQ1eVJxcVFsTlFhTHFKZVVuV3RlTkVOQ01TY0I4bDZoTlN5ZWJ1dDkvV05OS0l2K3BBRVRBVEFXaWhQUjU4N1NDUU9VNGEzQnZiRjkwVUFhRG9rT0FQLy9BSDMrUWdUUEJjc0NKZ0FtQUFBQUJ3Ti9BaVVBQVAvL0FIUCtRZ09MQkZ3Q0pnQkdBQUFBQndOL0FZTUFBQUFCQUJEK2d3UmFCYllBQ3dBeVFCc0dDd2dKQXdrTEFRUU1EUXNHU1ZrTEVna2lCUUVDQVVsWkFnTUFQeXNSQURNWVB6OHJFUklCRnprUk14RXpNVEFCSVRVaEZTRVJNeEVqRVNNQjMvNHhCRXIrTWFLaXJBVWRtWm43ZmYzcEFYMEFBQUVBS2Y2SEE1RUVTQUFMQURSQUd3WUxDQWtEQ1FzQkJBd05DU0lGQVFJQlJsa0NEd3NHUmxrTEZRQS9Ld0FZUHlzUkFETVlQeEVTQVJjNUVUTVJNekV3QVNFMUlSVWhFVE1SSXhFakFZbitvQU5vL3A2V3BwWUR2SXlNL05QOStBRjVBUC8vQUFBQUFBUjdCYllDQmdBOEFBQUFBUUFBL2hRRUFnUklBQTBBS1VBVUFBRU1BUU1ERGc4SUJ3MEhBZ3NERHdJVkFSc0FQejgvTXhJNU9SRXpFUklCRnprUk16RXdBU01SQVRNVEZoY3pOamNUTXdFQ1ZLYitVcXpzVXhNSUlVYnByUDVTL2hRQjZBUk0vWnZlWVlxMUFtWDd0QUFBQVFBQUFBQUVld1cyQUJBQU9rQWVCQWdJRFFrQ0Jna0xEd1VSRWdjTERBdEpXUVFBRHd3TUNRRVBBd2tTQUQ4L014STVMeEk1TXlzUkFETVJFZ0VYT1JFek14RXpNVEFCQVRNQkZTRVZJUkVqRVNFMUlUVUJNd0k5QVlhNC9oZ0JLLzdWclA3VEFTMytHYm9DMndMYi9JRTdtUDZjQVdTWU13T0hBQUVBQVA0VUJBSUVTQUFUQUR4QUh4RUJBUVlDRUJNQ0JBY0ZGQlVNQ3dzRkR3Y1BBQVFGQkVkWkVRVVZBaHNBUHo4ekt4RUFNeGcvTXhJNUVUTVJFZ0VYT1JFek14RXpNVEFGRVNNUklUVWhBVE1URmhjek5qY1RNd0VoRlFKVXB2N3FBUlQrVkt6c1V4TUlJVWJwclA1VUFSS0IvcFVCYTRFRVNQMmIzbUdLdFFKbCs3aUJBQUFCQUFqK2d3VFZCYllBRHdBM1FDQURBZ0lPRHd3R0NRb0lDQkFSREE4SkJnUUZEUW9EQ0JJRkFFbFpCUklESWdBL1B5c0FHRDgvTXhJWE9SRVNBUmM1RVRNeE1DVXpFU01SSXdFQkl3RUJNd0VCTXdFRU02S2lYdjUzL25DMEFlYitPN3dCYXdGdXRmNDdtdjNwQVgwQ2cvMTlBdndDdXYyOUFrUDlUQUFCQUNmK2hRUTNCRWdBRHdBNVFDRUtDUWtGQmdNTkFBRVBDQkFSRHhVREJnQU5CQXdCREFkR1dRd1ZDaUlFQVE4QVB6TS9QeXNSRWdBWE9SZy9FUklCRnprUk16RXdBUUV6QVFFekFRRXpFU01SSXdFQkl3RzQvb085QVNFQklMditnd0VybGFaRi9zMyt5cndDTVFJWC9sd0JwUDNwL2w3OTlnRjdBYnorUkFBQUFRQVEvb01HcUFXMkFBOEFRRUFpREFVQURRTUNBZzBLQlFjRkVCRU9Bd3NIQ0FkSldRZ0RBQXdGREVsWkJSSURJZ0EvUHlzUkFETVlQeXNSQURNWVB4RVNBUmM1RVRNUk14RXpNVEFsTXhFakVTRVJJVFVoRlNFUklSRXpCZjZxb3Z1MC9sWUVMLzRsQXZDcW12M3BBWDBGSFptWiszMEZIQUFCQUNuK2h3V1lCRVlBRHdBL1FDSUNDd1lEQ1FnSUF3QUxEUVVRRVFFTkRnMUdXUTRQQmdJTEFrWlpDeFVKSWdRUEFEOC9QeXNSQURNWVB5c1JBRE1SRWdFWE9SRXpFVE1STXpFd0FTRVJJUkV6RVRNUkl4RWhFU0UxSVFONS9wY0NScWFjcHZ4NC9yOERVQU82L05VRHQveEovZmdCZVFPNmpBQUFBUUNxL29NRmFBVzJBQmNBTzBBZkZRQUZBd0lQREFJRkRBTVlHUklKU1ZrU0VnVVdEUU1GQUVsWkJSSURJZ0EvUHlzQUdEOHpFamt2S3hFU0FSYzVFVE1STXhFek16RXdKVE1SSXhFakVRWUdJeUltTlJFekVSUVdNekkyTnhFekJNZWhvYXFWeG1yUDM2cC9qMkd4cWFxYS9la0JmUUpjTlNlK3N3SkYvYzk1ZEIwM0Fzb0FBQUVBblA2RkJNTUVTQUFXQUR0QUh3RVZDUVlPREFzTERoVURGeGdERWtaWkF3TU9CeFlQRGdsR1dRNFZEQ0lBUHo4ckFCZy9NeEk1THlzUkVnRVhPUkV6RVRNekVUTXhNQUVSRkRNeU5qY1JNeEV6RVNNUkl4RUdCaU1pSmpVUkFVTGJXNlpwcHBhbWxtbXpjYVM2QkVqK2NNQTRRd0hWL0VmOTlnRjdBZkJJTzZ5VEFad0FBUUNxQUFBRXh3VzJBQllBU2tBbUJRSUxGUlVJRmcwUkVSQVFGZ0lERnhnVUFBZ0FTVmtMQ0JZSUNRa0lGZ01ERVJJT0F3TUFQek0vRWhjNUx5OHZFVE1yRVFBekVSSUJGemtSTXhFekVUTXpFVE1STXpFd0FTQVJFVE1SRkJZekVUTVJOamNSTXhFakVRWUhFU01DZGY0MXFvZWFmWWFqckt5b2dYMENBQUZ4QWtYOXozZDJBVnorcWcwOEFzLzZTZ0pZUVJIK3p3QUJBSndBQUFRZEJFZ0FGd0JLUUNZQkZnWVFFQU1SQ0F3TUN3c1JGZ01ZR1E4VEF4TkdXUVlERVFNRUJBTVJBd3dKRnc4TUZRQS9Qek1TRnprdkx5OFJNeXNSQURNUkVnRVhPUkV6RVRNUk16TVJNeEV6TVRBQkVSUVhFVE1STmpjUk14RWpFUVlIRlNNMUl5SW1OUkVCUXNoM2NZV21wb0IyZHhhZ3VBUkkvbkM2QmdFdC90MFlXUUhWKzdnQjhGc2ErT3FxbFFHY0FBRUF5UUFBQk9VRnRnQVNBQzlBRndJUkVSSUpDQWdTRkJNRURVbFpBaElFQkFrU0VnQURBRDgvTXprdkVqa3JFUklCT1RrUk14RXpFVE14TUJNekVTUXpNaFlWRVNNUk5DWWpJZ1lIRVNQSnFnRUF4TS9mcW4rUGE3cVZxZ1cyL2FSY3Y3SDl1Z0l4ZUhZaU12MDFBQUFCQUxBQUFBUkNCRWdBRWdBdlFCY0FFZ3NIQndnU0NCUVREZ05HV1FzT0RnZ0pEd0FJRlFBL016OFNPUzg1S3hFU0FUazVFVE1STXhFek1UQWhFVFFqSWdZSEVTTVJNeEUyTmpNeUZoVVJBNXJaV0p4M3BxWmZ1bktqdmdHTndURksvaTBFU1A0T1JUNm9sLzVtQUFJQVBmL3NCajhGelFBZ0FDY0FVVUFxQlFNQUpCRVJDQjRsRUJBWUhnQUVLQ2tSSGdjZVNWa2tCd0lIQWhzTUd4UkpXUnNURENGSldRd0VBRDhyQUJnL0t4RVNBRGs1R0M4dk15c1JBRE1SRWdFWE9SRXpFVE16RVRNUk16TXhNQk0wTnpNR0ZSUXpNemNTQUNFZ0FCRVZJUklBTXpJMk54VUdCaU1nQUFNaUpnRWlBZ2NoRUNZOUc1RVVjU0lGSFFGTkFSY0JLUUVvKzl3T0FRWDNaY3FOY3QyQy9zYitveE9PbXdPdjBmQVFBMjdMQTRkSk5qSThaeXNCS2dGSC9vWCtqMFgrK1A3dkh5dWNKeDRCWkFGTWRnSWovdlg1QVFuN0FBQUNBRFAvN0FUZEJGb0FId0FtQUV4QUtBb0lCUllOSkJVVkhRMERCUVVuS0JZRERBTkdXU01NQnd3SEFCRVJJRVpaRVJBQUdVWlpBQllBUHlzQUdEOHJFUklBT1RrWUx5OHpLeEVBTXhFU0FSYzVFVE1STXhFek16RXdCU0lBSnlRMU5EY3pCaFVVTXpNM05qWXpNaElWRlNFV0ZqTXlOamNWQmdZRElnWUhJVFFtQTByei91d0cvdllaalJScUZRWWkrcmZQOGYwTUJxeXRaWjlpV0oyZ2hwY09BajJNRkFFZS9BVGRSVEl2TzJjanl1RCs5K0pweHNNZ0twUW1JUVBqcEo2ZHBRQUNBRDMrZ3dZL0JjMEFJZ0FwQUYxQU1Rc0pCaVlYRnc0RElTSW5GaFllSWdNR0JTb3JJaUlnRXhjRERRTkpXU1lOQ0EwSUFCSVNJMGxaRWdRQUdrcFpBQk1BUHlzQUdEOHJFUklBT1RrWUx5OHpLeEVBTXhnL1B4RVNBUmM1RVRNUk14RXpNeEV6RVRNek1UQUZKQUFESWlZMU5EY3pCaFVVTXpNM0VnQWhJQUFSRlNFU0FETXlOamNWQmdjUkl4TWlBZ2NoRUNZRG9QNysvdHNUanBzYmtSUnhJZ1VkQVUwQkZ3RXBBU2o3M0E0QkJmZGx5bzJ3NjZaTTBmQVFBMjdMREIwQldnRXhkblZKTmpJOFp5c0JLZ0ZIL29YK2owWCsrUDd2SHl1Y1BnWCtsUWF5L3ZYNUFRbjdBQUlBTS82SEJOMEVXZ0FoQUNnQVdFQXZDZ2dGRmcwZ0lTWVZGUjBoRFFNRkJpa3FJU0lmRmhZRERBTkdXU1VNQnd3SEFCRVJJa1paRVJBQUdVWlpBQlVBUHlzQUdEOHJFUklBT1RrWUx5OHpLeEVBTXhnL1B4RVNBUmM1RVRNUk14RXpFVE16TVRBRkpnSW5KRFUwTnpNR0ZSUXpNemMyTmpNeUVoVVZJUllXTXpJMk54VUdCeEVqRXlJR0J5RTBKZ0xWdjlNRy92WVpqUlJxRlFZaStyZlA4ZjBNQnF5dFpaOWlqcVdtUklhWERnSTlqQW9mQVJIZ0JOMUZNaTg3WnlQSzRQNzM0bW5Hd3lBcWxFRUUvcGtGU0tTZW5hVUEvLzhBVkFBQUFsWUZ0Z0lHQUN3QUFQLy9BQUlBQUFhOEIyQUNKZ0d3QUFBQkJ3STJBUkFCVkFBSXN3RVNCU1lBS3pYLy93QUVBQUFGM3dZTUFpWUIwQUFBQVFjQ05nQ2tBQUFBQ0xNQkVoRW1BQ3MxQUFFQXlmNEFCUmtGdGdBY0FFSkFKUWNEQXdRYURnNEpDaFFFQlIwZUVSZEpXUkVjQndKSldRc0FTbGtIQ3dzRUNBVURCQklBUHo4ekVqa3ZPU3NyQUJnL0t4RVNBUmM1RVRNUk14RXpNVEFCSWdjUkl4RXpFUUV6QVRjZ0FCRVFBQ0VpSmljMUZqTXlFalUwSkFKZWpGK3FxZ0tKemYyRkdnRlBBV0wrMmY3MVVueEdlcGk3eVA3ckFuc2YvYVFGdHYwOEFzVDlWQUwrdS83UC9zYitwQlFkbURFQkRmSG8vUUFBQVFDdy9nb0VJUVJJQUJ3QVFrQWxCQUFBQVJjS0VBb0dCd0VGSFI0T0ZFWlpEaHNFSEVkWkJ4cEdXUVFIQndFRkFnOEJGUUEvUHpNU09TODVLeXNBR0Q4ckVSSUJGemtSTXhFekVUTXhNQ0VqRVRNUkFUTUJCQklSRkFZR0l5SW5OUllXTXpJMk5UUW1JeUlIQVZTa3BBSGp0LzQzQVFEOGJzeUZpRjh1YkVlSG1MdStVbHdFU1AzNkFnYitIZ1QrNVA3MXNmeUVQSkVaSnRuSTA4OFlBQUVBQVA2REJaRUZ0Z0FYQURsQUh3TUFCUVFCQVFVT0F4Z1pGZ2RKV1JZRERCRktXUXdTQlFCSldRVVNBeUlBUHo4ckFCZy9Ld0FZUHlzUkVnRVhPUkV6RVRNek1UQWxNd01qRXlNUklRY0NBZ1luSWljMUZqTXlOallTRXlFRTJiaVB4WnlxL2lVZlBWMllma283TmpzMVR6MWRPQU1TbXYzcEFYMEZIL0QrSWY1RnJnSVpqeHBYMXdKWkFiZ0FBQUVBRVA2SEJJOEVSZ0FVQURsQUh3TUFCUVFCQVFVTkF4VVdFd2RHV1JNUEN4QkhXUXNWQlFCR1dRVVZBeUlBUHo4ckFCZy9Ld0FZUHlzUkVnRVhPUkV6RVRNek1UQWxNd01qRXlNUklRSUNCaU1pSnpVV016SVNFeUVEMzdDQnJIMm0vclVjWHBoMk9od1dISEdKSWdLQmovMzRBWGtEdVA2WS9tVEFDbjhHQWRrQjlnQUFBUURKL2dBRkh3VzJBQlVBUFVBZ0VnNE9EeE1MQ3dBQUJnOERGaGNTRFVsWkVoSVBGQkFERHhJRENVbFpBeHdBUHlzQUdEOC9NeEk1THlzUkVnRVhPUkV6RVRNUk14RXpNVEFsRUFBaElpWW5OUll6SUJFUklSRWpFVE1SSVJFekJSLys1djc3VW5wTmU0Y0JqUHorcXFvREFxcVcvc0wrcUJNZWxqRUI5d0lqL1ZBRnR2MlNBbTRBQVFDdy9nb0VZZ1JJQUJVQVIwQW5Ed3NMREJBSUNCTVRBZ3dERmhjUENrWlpEdzhmRHdJTEF3OFBEQkVORHd3VkFBVkdXUUFiQUQ4ckFCZy9Qek1TT1M5ZlhsMHJFUklCRnprUk14RXpFVE1STXpFd0FTSW5OUll6TWpZMUVTRVJJeEV6RVNFUk14RVFBZ0xUaEYxdlpuMTIvWnltcGdKa3FNLytDanFWUGNiUEFiMytFZ1JJL2pVQnkvdnIvdlQrNHdBQkFNbitnd1hYQmJZQUR3QkVRQ1FNQ0FnSkRRTUFCUVFCQVFVSkF4QVJEQWRKV1F3TUJRNEtBd2tTQlFCSldRVVNBeUlBUHo4ckFCZy9Qek1TT1M4ckVSSUJGemtSTXhFek16TVJNeEV6TVRBbE13TWpFeU1SSVJFakVUTVJJUkV6QlIrNGtjV2VxdnorcXFvREFxcWEvZWtCZlFLdy9WQUZ0djJTQW00QUFBRUFzUDZIQlJJRVJnQVBBRVJBSkFFTkRRNElCUUlLQ1FZR0NnNERFQkVCREVaWkFRRUtBdzhQRGhVS0JVWlpDaFVJSWdBL1B5c0FHRDgvTXhJNUx5c1JFZ0VYT1JFekVUTXpNeEV6RVRNeE1BRVJJUkV6RVRNREl4TWpFU0VSSXhFQlZnSm1wckNCckgybS9acW1CRWIrTndISi9FbjkrQUY1QWU3K0VnUkdBQUFCQUtyK2d3VEhCYllBRndBOVFDQVBEQUlERlFVRkFBQUREQU1ZR1JJSlNWa1NFZ0VXRFFNRElnRUVTVmtCRWdBL0t3QVlQejh6RWprdkt4RVNBUmM1RVRNUk14RXpFVE14TUNFakVTTVJNeEVHQmlNaUpqVVJNeEVVRmpNeU5qY1JNd1RIcXFLaWxjWnF6OStxZjQ5aHNhbXEvb01DRndIQ05TZStzd0pGL2M5NWRCMDNBc29BQVFDYy9vVUVMUVJJQUJZQVBVQWdBUlVMREFZT0Rna0pEQlVERnhnREVrWlpBd01LQnhZUERDSUtEVVpaQ2hVQVB5c0FHRDgvTXhJNUx5c1JFZ0VYT1JFekVUTVJNeEV6TVRBQkVSUXpNalkzRVRNUkl4RWpFVE1SQmdZaklpWTFFUUZDMjF1bWFhYVZwcFZwczNHa3VnUkkvbkRBT0VNQjFmdTQvb1VDQ2dGaFNEdXNrd0djQUFFQXlmNkRCeWtGdGdBWUFFaEFKUWtHQmdjUkRnd1RFZzhQRXdjREdSb1hGZ0lMQWhNSUV3NUpXUk1TRVNJTUNBTUFCeElBUHpNL016OC9LeEVTQURrNUVUTXpFUklCRnprUk14RXpNek1STXhFek1UQWhBU01YRmhVUkl4RWhBVE1CTXhFekF5TVRJeEUwTnlNQkExRCtFQWdIQjUwQkFBSFJDQUhSL3JpUHg1NnFEZ2orREFVUWY4QXYvRjRGdHZ0S0JMYjY1UDNwQVgwRHJvVGMrdklBQUFFQXNQNkhCZDhFUmdBWUFEOUFJQk1VQ0FVS0NRWUdDaFFER1JvTEVnQVNEd01WRHhRVkNnVkdXUW9QRlFnaUFEOC9NeXNBR0Q4L014STVPUkV6RVJJQkZ6a1JNeEV6TXhFek1UQWxOemNCTXhFekF5TVRJeEVIQndFakFTWW5FU01STXdFV0F1a2ZLd0VwMDdDQnJIMlRGRHIrNVl2KzVUVVVsTXNCS1MyZ1hYWUMwL3hKL2ZnQmVRT0pPcG45U2dLNGhrdjhkd1JHL1MxdS8vOEFWQUFBQWxZRnRnSUdBQ3dBQVAvL0FBQUFBQVVRQjE0Q0pnQWtBQUFCQndJMkFEa0JVZ0FJc3dJUEJTWUFLelgvL3dCZS8rd0R6UVlNQWlZQVJBQUFBUVlDTnVnQUFBaXpBaVVSSmdBck5mLy9BQUFBQUFVUUJ5VUNKZ0FrQUFBQkJ3QnFBRDBCVWdBS3RBTUNKQVVtQUNzMU5mLy9BRjcvN0FQTkJkTUNKZ0JFQUFBQkJnQnE4d0FBQ3JRREFqb1JKZ0FyTlRYLy8vLytBQUFHZ1FXMkFnWUFpQUFBLy84QVh2L3NCbk1FWEFJR0FLZ0FBUC8vQU1rQUFBUDRCMTRDSmdBb0FBQUJCd0kyQUJBQlVnQUlzd0VNQlNZQUt6WC8vd0J6Lyt3RUVnWU1BaVlBU0FBQUFRWUNOZ3dBQUFpekFoc1JKZ0FyTlFBQ0FIWC83QVZZQmMwQUVnQVpBRDFBSUJjT0VCWVdDUWtDRGdNYUd3OFhTVmtQRHd3R0RCTkpXUXdUQmdCSldRWUVBRDhyQUJnL0t4RVNBRGtZTHlzUkVnRVhPUkV6RVRNUk16RXdBU0lITlRZMk15QUFFUkFBSVNBUk5TRUNBQU15RWpjaEVCWUNtT1BpYzlLR0FVc0JiLzZtL3N2OXJBUXZFZjc1dzlMNUVQeUh6QVUxVEo0bUlQNXgvcHYrb3Y1eEF1dEdBUW9CRHZ0T0FRMzMvdmo4QUFBQ0FHYi83QVFHQkZ3QUZBQWJBRHRBSHhrSkdBc0RBeEVKQXh3ZENobEdXUW9LQmdBR0ZVWlpCaFlBRGtaWkFCQUFQeXNBR0Q4ckVSSUFPUmd2S3hFU0FSYzVFVE16RVRNeE1BRXlBQkVRQUNNaUFqVTFJU1ltSXlJR0J6VTJOaE15TmpjaEZCWUIrdlVCRi83OTJ0RHpBdlFGczZaaXBWOVpvcHFGbWd6OXc0MEVYUDdVL3Z2KytQN0pBUXpoYWN5N0lTbVRLQ0w4RzZXY25hUUEvLzhBZGYvc0JWZ0hKUUltQXVFQUFBRUhBR29Ba3dGU0FBcTBBd0l2QlNZQUt6VTEvLzhBWnYvc0JBWUYwd0ltQXVJQUFBRUdBR3JxQUFBS3RBTUNNUkVtQUNzMU5mLy9BQUlBQUFhOEJ5VUNKZ0d3QUFBQkJ3QnFBUkFCVWdBS3RBSUJKd1VtQUNzMU5mLy9BQVFBQUFYZkJkTUNKZ0hRQUFBQkJ3QnFBS0lBQUFBS3RBSUJKeEVtQUNzMU5mLy9BRXIvN0FRMUJ5VUNKZ0d4QUFBQkJ3QnEvL01CVWdBS3RBSUJQZ1VtQUNzMU5mLy9BRVQvN0FOL0JkTUNKZ0hSQUFBQkJnQnFsQUFBQ3JRQ0FUZ1JKZ0FyTlRVQUFRQksvK3dFTndXMkFCa0FRRUFqQUJNVkdROERBeGtURmdnRkdoc1pGaGNXU1ZrQUVrcFpBQUFHRndNR0RFcFpCaE1BUHlzQUdEOFNPUzhyS3hFQU14RVNBUmM1RVRNUk14RXpNVEFCQkFRVkZBUWhJQ2MxRmhZek1qWTFOQ1lqSXpVQklUVWhGUUg4QVJjQkpQN04vdXIrLzZOZzNtckh5dUhmakFIdS9VNERod00vQ2RQQnp1aFBuaTR5bVpDR2lvMEIzcG1MQUFBQkFCditGQU9tQkVnQUdRQkFRQ01BRXhVWkR3UUVHUk1XQ1FVYUd4a1dGeFpHV1FBU1Ixa0FBQWNYRHdjTVJsa0hHd0EvS3dBWVB4STVMeXNyRVFBekVSSUJGemtSTXhFekVUTXhNQUVlQWhVVUFDTWlKelVXTXpJMk5UUW1JeU0xQVNFMUlSVUJySlhtZi83WTcrcUt0OGloeGRiS2VRSEYvWWtET0FIUEIzTEtpTjcrN2thYVZyNmdwS3B5QWY2T2V3RC8vd0RMQUFBRlVnYTBBaVlCc2dBQUFRY0JUUUMwQVZJQUNMTUJFd1VtQUNzMS8vOEFzQUFBQkdJRllnSW1BZElBQUFFR0FVMHhBQUFJc3dFUkVTWUFLelgvL3dETEFBQUZVZ2NsQWlZQnNnQUFBUWNBYWdDK0FWSUFDclFDQVNVRkpnQXJOVFgvL3dDd0FBQUVZZ1hUQWlZQjBnQUFBUVlBYWowQUFBcTBBZ0VqRVNZQUt6VTEvLzhBZmYvc0JiNEhKUUltQURJQUFBRUhBR29BMFFGU0FBcTBBd0l0QlNZQUt6VTEvLzhBYy8vc0JHSUYwd0ltQUZJQUFBRUdBR29kQUFBS3RBTUNMaEVtQUNzMU5mLy9BSDMvN0FXK0JjMENCZ0orQUFELy93QnovK3dFWWdSY0FnWUNmd0FBLy84QWZmL3NCYjRISlFJbUFuNEFBQUVIQUdvQTBRRlNBQXEwQkFNdkJTWUFLelUxLy84QWMvL3NCR0lGMHdJbUFuOEFBQUVHQUdvYkFBQUt0QVFETUJFbUFDczFOZi8vQUQzLzdBU0pCeVVDSmdISEFBQUJCd0JxLyswQlVnQUt0QUlCTUFVbUFDczFOZi8vQURuLzdBTjlCZE1DSmdIbkFBQUJCZ0JxamdBQUNyUUNBVEFSSmdBck5UWC8vd0FiLyt3RStBYTBBaVlCdlFBQUFRY0JUUUF2QVZJQUNMTUJHZ1VtQUNzMS8vOEFBdjRVQkFZRllnSW1BRndBQUFFR0FVMnRBQUFJc3dFWkVTWUFLelgvL3dBYi8rd0UrQWNsQWlZQnZRQUFBUWNBYWdBN0FWSUFDclFDQVN3RkpnQXJOVFgvL3dBQy9oUUVCZ1hUQWlZQVhBQUFBUVlBYXJjQUFBcTBBZ0VyRVNZQUt6VTEvLzhBRy8vc0JQZ0hjd0ltQWIwQUFBRUhBVk1BalFGU0FBcTBBZ0VxQlNZQUt6VTEvLzhBQXY0VUJBWUdJUUltQUZ3QUFBRUdBVk1FQUFBS3RBSUJLUkVtQUNzMU5mLy9BS29BQUFUSEJ5VUNKZ0hCQUFBQkJ3QnFBR29CVWdBS3RBSUJLUVVtQUNzMU5mLy9BSndBQUFRdEJkTUNKZ0hoQUFBQkJnQnFGd0FBQ3JRQ0FTZ1JKZ0FyTlRVQUFRREovb01FQ0FXMkFBa0FMVUFZQkFrR0J3RUhDUU1LQ3drRVNWa0pFZ2NpQUFOSldRQURBRDhyQUJnL1B5c1JFZ0VYT1JFekVUTXhNQk1oRlNFUk14RWpFU1BKQXovOWE2R2hxZ1cybWZ0OS9la0JmUUFCQUxEK2h3TkNCRVlBQ1FBdFFCZ0VDUVlIQVFjSkF3b0xDUVJHV1FrVkJ5SUFBMFpaQUE4QVB5c0FHRDgvS3hFU0FSYzVFVE1STXpFd0V5RVZJUkV6RVNNUkk3QUNrdjRVbHFhV0JFYU0vTlg5K0FGNS8vOEF5UUFBQmdvSEpRSW1BY1VBQUFFSEFHb0JHd0ZTQUFxMEJBTXRCU1lBS3pVMS8vOEFzQUFBQlhrRjB3SW1BZVVBQUFFSEFHb0F4UUFBQUFxMEJBTXNFU1lBS3pVMS8vOEFMLzUxQkFnRnRnSW1BcHNBQUFBSEE0QUFrd0FBLy84QUV2NTFBMElFU0FJbUFwd0FBQUFHQTRGMUFQLy9BQWorZFFUSkJiWUFKZ0E3QUFBQUJ3T0FBMWdBQVAvL0FDZitkUVEwQkVnQUpnQmJBQUFBQndPQkFzTUFBQUFCQUFZQUFBU1dCYllBRVFBN1FDSVBBaEVCRUEwRUNnY0pCZ3NNRXhJS0VRQVJTVmtIRFE4RUFBQUNEQThTQlFJREFEOHpQek1TT1M4NUVqa3pLeEVBTXhFU0FSYzVNVEFUSVFFekFRRXpBU0VWSVFFakFRRWpBU0YvQVRQK2Q3d0Jhd0ZzdC81d0FUeit1Z0c5d2Y1My9uQzJBYi8rdWdOVUFtTDl1d0pGL1o2WS9VUUNnLzE5QXJ3QUFBRUFKd0FBQkFnRVNBQVJBRHRBSWc4Q0VRRVFEUVFLQndrR0N3d1RFZ29SQUJGSFdRY05Ed1FBQUFJTUR4VUZBZzhBUHpNL014STVMemtTT1RNckVRQXpFUklCRnpreE1CTWhBVE1CQVRNQklSVWhBU01CQVNNQklYVUJFdjYwdlFFaEFTQzcvcklCR1A3aUFXaTgvczMreXJ3Qlp2N29BbmNCMGY1Y0FhVCtMNEgrQ2dHOC9rUUI5Z0FBQWdDREFBQUVOd1cyQUFvQUV3QTBRQm9FRXhNSER3QUhBQlVVQXd4SldRTURDQVVJRWtwWkNCSUZBd0EvUHlzUkVnQTVHQzhyRVJJQk9Ua1JNeEV6RVRNeE1CTTBKQ0V6RVRNUklTQWtBU01pQmhVVUZqTXpnd0VrQVNER3F2NWovdlgrOUFNS3V0N0N0c3ZaQWFUVXpnSncra3JWQWR0OGpvK0UvLzhBYy8vc0JEY0dGQUlHQUVjQUFBQUNBSVAvN0FaM0JiWUFHUUFqQUVaQUpCNERHQW9LQnlNUEVoSWpBd01rSlFZYlNWa1lCaEFHRUFBSUF3d2dBQ0JLV1JVQUV3QS9NaXNSQURNWVB4STVPUzh2T1NzUkVnRVhPUkV6RVRNekVqa1JNekV3QlNJbU5UUWtJVE1STXhFVU16STJOUkV6RVJRR0l5SW1Kd1lUSXlJR0ZSQWhNalkxQWs3aTZRRXFBU0tScXVaa2VhclB1SGFmTTNFcGw5VENBU0YvalJMUjBObmVBbkQ3dCt4N2JnSG0vaGl1emxKYXFnTEFpNWIrOUhkd0FBQUNBSFAvN0FhSEJoUUFJZ0F1QUZGQUtTd1REQ0FnSFJvbUF3WUdKaE1ETHpBZUFBMFFHaFlFQkJBV0ZpcEdXUllRQUNNUUkwWlpDUkFXQUQ4ekt4RUFNeGcvS3hFU0FEa1lMeEk1RWprL0VSSUJGemtSTXhFek16TVNPUkV6TVRBbE1qWTFFVE1SRkFZaklpWW5Jd1lHSXlJQ0VSQVNNeklXRnpNbUpqVVJNeEVVRmlFeU5qVTFOQ1lqSUJFVUZnVCtkbXVveUwyQm5pc0lTN21CME9qbnoycWZQd3dDQ0tadC9ibWlrcFNpL3VLTGQ0U0lBVG4rdmNqRlczRnhXd0VwQVF3QkRBRXZUVlVSY0JzQnZ2dU1vSW01emlQbnlmNU8xdElBQVFCTy8rd0dnUVhMQUNvQVMwQW9CaE1vR1I4aUloWVpFd0VOQmlzc0Z3SUJBZ0ZLV1FJZ0FpQWxFQ1VjU1ZrbEV4QUpTbGtRQkFBL0t3QVlQeXNSRWdBNU9SZ3ZMeXNSRWdBNUVSSUJGemtSTXhFekVUTXhNQUVqTlRNeU5qVTBKaU1pQmdjbk5qWXpNaFlWRkFZSEZRUVRGaFl6TWpZMUVUTVJGQVlqSWlZbkppWUJyc25Cd05XYWdHZXhaMVJkOW9MVzliS2NBV0lHQW14OGQzQ28wcjNLMEFJQ3pRS3NqNU9FYkg4M1JYSklVTVNuamJjYUNEUCswWlovZVljQnpmNHB4c2ZSeUphUkFBRUFVUC9zQmNVRVhBQWxBRXRBS0JJZUNpUUNCUVVrSGlBT0dBWW1KeUVQRGc4T1Jsa1BBdzhEQ0JzYkZFWlpHeEFJQUVaWkNCWUFQeXNBR0Q4ckVSSUFPVGtZTHk4ckVSSUFPUkVTQVJjNUVUTVJNeEV6TVRBbE1oRVJNeEVVQmlNZ0F5WW1JeU0xTXlBMU5DTWlCZ2NuTmpZek1oWVZGQWNWRmhZWEZnUkMzYWE3eFA2R0VBV05sSXh2QVNIeVM0ZE5PVldqYUxqVHdHTjdCUWwzQVF3Qk9mNjl5c01CVFdOWWpheWlKQ0tIS0NTYmhyZzVDQlI2YXRNQUFRQk8vb01FMFFYTEFDTUFTa0FvR1JvZUl5RWdJQllhSXdRUUJpUWxHZ1VFQlFSS1dRVUZJeE1qSGtsWkl4SWhJaE1NU2xrVEJBQS9Ld0FZUHo4ckVSSUFPUmd2S3hFU0FEa1JFZ0VYT1JFekVUTVJNekV3QVRRbUl5TTFNekkyTlRRbUl5SUdCeWMyTmpNeUZoVVVCZ2NWRmhZVkVUTVJJeEVqQTRQbDR0blJ6ZUdraDJuRGFWUmgvb1RjL2IyanVNT3NvcXdCbklXTGo1T0VhNEE2UW5KS1RzU25qTGNaQ0JtemxQNysvZWtCZlFBQUFRQlEvb2NFRUFSYUFCNEFTa0FvQnhJWkhod2JHeFVlRWdNTkJpQWZGUVFEQkFOR1dRUUVIZzhlR1VaWkhoVWNJZzhLUmxrUEVBQS9Ld0FZUHo4ckVSSUFPUmd2S3hFU0FEa1JFZ0VYT1JFekVUTVJNekV3QVRRaEl6VXpJRFUwSmlNaUJ5YzJNeklXRlJRSEZSWVdGUlV6RVNNUkl3TFYvc3VXZFFFNWhYZVpsajJoeTcvVnkzNXduYWFWQVMzSGpheFNVRWFIU3BxSHRqa0xKWWxtblAzNEFYa0FBQUVBQVAvcEJ5RUZ0Z0FqQURwQUhSUWpHaDBkSXdrREpDVWJHd2NTRWdGSldSSURGd3dIREVwWklBY1RBRDh6S3hFQU14Zy9LeEVTQURrWUx4RVNBUmM1RVRNUk16RXdBU0VIQWdJR0JpTWlKelVXTXpJMk5oSVNFeUVSRkJZek1qWTFFVE1SRkFZaklpWTFCQXorU0I4clRGT0NaRVZBTWo4eFFDdzRTamNDNzI5emNIR296YnpFeUFVZjhQNnUva1RTWmhtUEdqNW9BUUlCNlFHdSs4K0plWG1IQWMzK0tjSE16TVVBQUFFQUVQL3NCaWtFUmdBZEFEcEFIUUFPQlFnSURoWURIeDRHQmhRY0hCQkdXUndQQXhrVUdVZFpDeFFXQUQ4ekt4RUFNeGcvS3hFU0FEa1lMeEVTQVJjNUVUTVJNekV3QVJRV016SVJFVE1SRkFZaklpWTFFU0VDQWdZaklpYzFGak15RWhNaEE4OW9kOVdtdTc2OHkvN0ZIRjZZZGpvY0ZoeHhpU0lDY1FHRGlZTUJDZ0U3L3IzS3c4VExBajMrbVA1a3dBcC9CZ0haQWZZQUFBRUF5Zi9zQjE0RnRnQVpBRU5BSXhjQUR3WUpGaElTRXdrUEV3TWFHeFlSU1ZrV0J4WUhFeGdVQXhNU0RBTkpXUXdUQUQ4ckFCZy9Qek1TT1Rrdkx5c1JFZ0VYT1JFekVUTVJNeEV6TXpFd0FSUVdNekkyTlJFekVSUUdJeUltTlJFaEVTTVJNeEVoRVRNRTltNXpjSEdteUwvRHlQMG5xcW9DMmFvQmhZbDVlWWNCemY0cHY4N0x4Z0V6L1ZBRnR2MlNBbTRBQUFFQXNQL3NCcWdFU0FBWUFFMUFLZ1VDRXdvTkFSWVdGdzBURndNWkdnRVZSbGtQQVI4QkFnc0RBUXNCQ3hjREdBOFhGUkFJUmxrUUZnQS9Ld0FZUHo4ekVqazVMeTlmWGwwckVSSUJGemtSTXhFekVUTVJNek14TUFFUklSRXpFUlFXTXpJUkVUTVJGQVlqSWlZMU5TRVJJeEVCVmdKUXBtcDMxYWE3d0xyTi9iQ21CRWorTlFITC9UMkpoUUVNQVRuK3ZjckR4c2x6L2hJRVNBQUFBUUI5Lyt3Rm1nWExBQndBT2tBZkZnZ2JBZ0lQSEFnRUhSNEFIRWxaQUFBRkRBd1RTVmtNQkFVWlNWa0ZFd0EvS3dBWVB5c1JFZ0E1R0M4ckVSSUJGemtSTXhFek1UQUJJUlVRQUNFZ0FCRTBFaVF6TWhZWEJ5WW1JeUFBRVJBQU15QVJJUU5tQWpUK3pQN0ovcnYrazdNQlZlcDQ3Vk5DV3RaWC92WCszZ0VMOXdHMC9uOEM4RmIrb2Y2eEFaRUJZT1VCVkxVeEo1UW1MdjdGL3VQKzQvN0RBZGNBQUFFQWMvL3NCTEFFWEFBWkFEcEFIeElIR0FJQ0RCa0hCQm9iQUJsR1dRQUFCQW9LRDBaWkNoQUVGVVpaQkJZQVB5c0FHRDhyRVJJQU9SZ3ZLeEVTQVJjNUVUTVJNekV3QVNFVkVDRWdBQkVRQUNFeUZ3Y21JeUlHRlJRV016STJOU0VDc2dIKy9mNys3djdYQVVNQklkU3ZPNmltemVYTXhhbXYvcW9DUDBQOThBRW5BUkFCRGdFclVJTkszdExQMzZDZEFBQUJBQkQvN0FUMEJiWUFGQUE1UUIwRkV3b05EUU1UQUFRVkZnc0xFQUVRQ0VsWkVCTUVBQUVBU1ZrQkF3QS9LeEVBTXhnL0t4RVNBRGtZTHhFU0FSYzVFVE1STXpFd0V6VWhGU0VSRkJZek1oRVJNeEVVQmlNaUpqVVJFQVE4L2k5M2N1aW8wNzNHelFVZG1abjhhSWw3QVFBQnovNHB3TTNPd3dPZ0FBQUJBQ24vN0FTSEJFWUFGQUEyUUJ3Q0VBY0tDZ0FRRWdRVkZnRVNFeEpHV1FnSURSTVBEUVZHV1EwV0FEOHJBQmcvRWprdkt4RUFNeEVTQVJjNUVUTVJNekV3QVNFUkZCWXpNaEVSTXhFVUJpTWlKalVSSVRVaEE0SCtwbTEyMTZhOXdNREovcWdEV0FPNi9jbUpnd0VFQVVIK3ZjckR5OFFDUDR3QUFRQnYvK3dFV0FYTEFDWUFSMEFtRlNBTUFDUWpCUnNSSXdBZ0JpY29JdzhTRHhKS1dROFBIUU1kR0VwWkhSTURDVXBaQXdRQVB5c0FHRDhyRVJJQU9SZ3ZLeEVTQURrUkVnRVhPUkV6RVRNUk16RXdFelFrTXlBWEJ5WW1JeUlHRlJRV016TVZJeUlHRlJRV016STNGUVloSUNRMU5EWTNOU1ltbkFFSTRRRUMwVjVwdFdXTW45SEkyZFhlNk1xMzZjZXYvdnYrOVA3Yno3eXF0QVJjcWNhUWVFUTBlM0tBazQyT2lvNk5YSjVOM01XWHdCWUlHYkwvL3dCYS8rd0Rod1JjQWdZQmdnQUEvLzhBQVA1MUJXc0Z0Z0FtQWJVQUFBQUhBNEFEK2dBQS8vOEFFUDUxQkhNRVNBSW1BZFVBQUFBSEE0RURBZ0FBLy84QUFQNmdCUkFGdkFJbUFDUUFBQUFIQW1jRTZRQUEvLzhBWHY2Z0E4MEVXZ0ltQUVRQUFBQUhBbWNFZVFBQS8vOEFBQUFBQlJBSDRRSW1BQ1FBQUFFSEFtWUUvQUZTQUFpekFoTUZKZ0FyTmYvL0FGNy83QVBOQm84Q0pnQkVBQUFCQndKbUJLWUFBQUFJc3dJcEVTWUFLelgvL3dBQUFBQUZFQWZSQWlZQUpBQUFBUWNEZHdUbEFWSUFDclFEQWhVRkpnQXJOVFgvL3dCZS8rd0VRUVovQWlZQVJBQUFBUWNEZHdTVEFBQUFDclFEQWlzUkpnQXJOVFgvL3dBQUFBQUZFQWZSQWlZQUpBQUFBUWNEZUFUZEFWSUFDclFEQWhVRkpnQXJOVFgvL3dBdC8rd0R6UVovQWlZQVJBQUFBUWNEZUFTVEFBQUFDclFEQWlzUkpnQXJOVFgvL3dBQUFBQUZFQWhLQWlZQUpBQUFBUWNEZVFUWkFWSUFDclFEQWhVRkpnQXJOVFgvL3dCZS8rd0VGd2I0QWlZQVJBQUFBUWNEZVFTY0FBQUFDclFEQWlzUkpnQXJOVFgvL3dBQUFBQUZFQWhpQWlZQUpBQUFBUWNEZWdUbEFWSUFDclFEQWkwRkpnQXJOVFgvL3dCZS8rd0R6UWNRQWlZQVJBQUFBUWNEZWdTUkFBQUFDclFEQWtNUkpnQXJOVFgvL3dBQS9xQUZFQWR6QWlZQUpBQUFBQ2NDWndUcEFBQUJCd0ZMQUNzQlVnQUlzd01wQlNZQUt6WC8vd0JlL3FBRHpRWWhBaVlBUkFBQUFDY0Nad1I1QUFBQkJnRkwxQUFBQ0xNRFBoRW1BQ3MxLy84QUFBQUFCUkFJRXdJbUFDUUFBQUVIQTNzRTdBRlNBQXEwQXdJWEJTWUFLelUxLy84QVh2L3NBODBHd1FJbUFFUUFBQUVIQTNzRW1nQUFBQXEwQXdJdEVTWUFLelUxLy84QUFBQUFCUkFJRXdJbUFDUUFBQUVIQTN3RTZRRlNBQXEwQXdJWEJTWUFLelUxLy84QVh2L3NBODBHd1FJbUFFUUFBQUVIQTN3RW1BQUFBQXEwQXdJdEVTWUFLelUxLy84QUFBQUFCUkFJV0FJbUFDUUFBQUVIQTMwRTZRRlNBQXEwQXdJaEJTWUFLelUxLy84QVh2L3NBODBIQmdJbUFFUUFBQUVIQTMwRW9BQUFBQXEwQXdJM0VTWUFLelUxLy84QUFBQUFCUkFJWGdJbUFDUUFBQUVIQTM0RTR3RlNBQXEwQXdJbkJTWUFLelUxLy84QVh2L3NBODBIREFJbUFFUUFBQUVIQTM0RW1BQUFBQXEwQXdJOUVTWUFLelUxLy84QUFQNmdCUkFIU1FJbUFDUUFBQUFuQVU0QUxRRmtBUWNDWndUcEFBQUFDTE1DRHdVbUFDczEvLzhBWHY2Z0E4MEY1UUltQUVRQUFBQW1BVTdZQUFFSEFtY0VlUUFBQUFpekFpVVJKZ0FyTmYvL0FNbitvQVA0QmJZQ0pnQW9BQUFBQndKbkJNRUFBUC8vQUhQK29BUVNCRndDSmdCSUFBQUFCd0puQkxnQUFQLy9BTWtBQUFQNEIrRUNKZ0FvQUFBQkJ3Sm1CTkVCVWdBSXN3RVFCU1lBS3pYLy93QnovK3dFRWdhUEFpWUFTQUFBQVFjQ1pnVEpBQUFBQ0xNQ0h4RW1BQ3MxLy84QXlRQUFBL2dITHdJbUFDZ0FBQUVIQVZMLzVBRlNBQWl6QVJVRkpnQXJOZi8vQUhQLzdBUVNCZDBDSmdCSUFBQUJCZ0ZTMEFBQUNMTUNKQkVtQUNzMS8vOEF5UUFBQkc4SDBRSW1BQ2dBQUFFSEEzY0V3UUZTQUFxMEFnRVNCU1lBS3pVMS8vOEFjLy9zQkZ3R2Z3SW1BRWdBQUFFSEEzY0VyZ0FBQUFxMEF3SWhFU1lBS3pVMS8vOEFYUUFBQS9nSDBRSW1BQ2dBQUFFSEEzZ0V3d0ZTQUFxMEFnRVNCU1lBS3pVMS8vOEFTdi9zQkJJR2Z3SW1BRWdBQUFFSEEzZ0VzQUFBQUFxMEF3SWhFU1lBS3pVMS8vOEF5UUFBQkRrSVNnSW1BQ2dBQUFFSEEza0V2Z0ZTQUFxMEFnRVNCU1lBS3pVMS8vOEFjLy9zQkIwRytBSW1BRWdBQUFFSEEza0VvZ0FBQUFxMEF3SWhFU1lBS3pVMS8vOEF5UUFBQS9nSVlnSW1BQ2dBQUFFSEEzb0V1QUZTQUFxMEFnRXFCU1lBS3pVMS8vOEFjLy9zQkJJSEVBSW1BRWdBQUFFSEEzb0VvZ0FBQUFxMEF3STVFU1lBS3pVMS8vOEF5ZjZnQS9nSGN3SW1BQ2dBQUFBbkFtY0V2Z0FBQVFjQlN3QUNBVklBQ0xNQ0pRVW1BQ3MxLy84QWMvNmdCQklHSVFJbUFFZ0FBQUFuQW1jRXNBQUFBUVlCUy9FQUFBaXpBelFSSmdBck5mLy9BRlFBQUFKV0IrRUNKZ0FzQUFBQkJ3Sm1BOGtCVWdBSXN3RVFCU1lBS3pYLy93QjdBQUFCNWdhUEFpWUE4d0FBQVFjQ1pnTnpBQUFBQ0xNQkNCRW1BQ3MxLy84QVZQNmdBbFlGdGdJbUFDd0FBQUFIQW1jRHRBQUEvLzhBbmY2Z0FXWUYzd0ltQUV3QUFBQUhBbWNEWWdBQS8vOEFmZjZnQmI0RnpRSW1BRElBQUFBSEFtY0Zmd0FBLy84QWMvNmdCR0lFWEFJbUFGSUFBQUFIQW1jRXlRQUEvLzhBZmYvc0JiNEg0UUltQURJQUFBRUhBbVlGandGU0FBaXpBaHdGSmdBck5mLy9BSFAvN0FSaUJvOENKZ0JTQUFBQkJ3Sm1CTmtBQUFBSXN3SWRFU1lBS3pYLy93QjkvK3dGdmdmUkFpWUFNZ0FBQVFjRGR3VjlBVklBQ3JRREFoNEZKZ0FyTlRYLy93QnovK3dFZFFaL0FpWUFVZ0FBQVFjRGR3VEhBQUFBQ3JRREFoOFJKZ0FyTlRYLy93QjkvK3dGdmdmUkFpWUFNZ0FBQVFjRGVBVjlBVklBQ3JRREFoNEZKZ0FyTlRYLy93QmgvK3dFWWdaL0FpWUFVZ0FBQVFjRGVBVEhBQUFBQ3JRREFoOFJKZ0FyTlRYLy93QjkvK3dGdmdoS0FpWUFNZ0FBQVFjRGVRVjdBVklBQ3JRREFoNEZKZ0FyTlRYLy93QnovK3dFWWdiNEFpWUFVZ0FBQVFjRGVRVEhBQUFBQ3JRREFoOFJKZ0FyTlRYLy93QjkvK3dGdmdoaUFpWUFNZ0FBQVFjRGVnVjVBVklBQ3JRREFqWUZKZ0FyTlRYLy93QnovK3dFWWdjUUFpWUFVZ0FBQVFjRGVnVEZBQUFBQ3JRREFqY1JKZ0FyTlRYLy93QjkvcUFGdmdkekFpWUFNZ0FBQUNjQ1p3Vi9BQUFCQndGTEFNRUJVZ0FJc3dNeEJTWUFLelgvL3dCei9xQUVZZ1loQWlZQVVnQUFBQ2NDWndUTkFBQUJCZ0ZMRGdBQUNMTURNaEVtQUNzMS8vOEFmZi9zQm1RSGN3SW1BbDhBQUFFSEFIWUJLd0ZTQUFpekFpc0ZKZ0FyTmYvL0FIUC83QVVaQmlFQ0pnSmdBQUFCQmdCMmJRQUFDTE1DS3hFbUFDczEvLzhBZmYvc0JtUUhjd0ltQWw4QUFBRUhBRU1BaHdGU0FBaXpBaU1GSmdBck5mLy9BSFAvN0FVWkJpRUNKZ0pnQUFBQkJnQkQxQUFBQ0xNQ0pCRW1BQ3MxLy84QWZmL3NCbVFINFFJbUFsOEFBQUVIQW1ZRmp3RlNBQWl6QWlZRkpnQXJOZi8vQUhQLzdBVVpCbzhDSmdKZ0FBQUJCd0ptQk5rQUFBQUlzd0luRVNZQUt6WC8vd0I5Lyt3R1pBY3ZBaVlDWHdBQUFRY0JVZ0NnQVZJQUNMTUNLd1VtQUNzMS8vOEFjLy9zQlJrRjNRSW1BbUFBQUFFR0FWTDFBQUFJc3dJakVTWUFLelgvL3dCOS9xQUdaQVlVQWlZQ1h3QUFBQWNDWndWN0FBRC8vd0J6L3FBRkdRVHdBaVlDWUFBQUFBY0Nad1RKQUFELy93QzYvcUFGR1FXMkFpWUFPQUFBQUFjQ1p3VktBQUQvL3dDay9xQUVPUVJJQWlZQVdBQUFBQWNDWndTNEFBRC8vd0M2Lyt3RkdRZmhBaVlBT0FBQUFRY0NaZ1ZVQVZJQUNMTUJGZ1VtQUNzMS8vOEFwUC9zQkRrR2p3SW1BRmdBQUFFSEFtWUUxUUFBQUFpekFSa1JKZ0FyTmYvL0FMci83QVo3QjNNQ0pnSmhBQUFCQndCMkFPNEJVZ0FJc3dFbEJTWUFLelgvL3dDay8rd0ZsZ1loQWlZQ1lnQUFBUVlBZG5rQUFBaXpBU1lSSmdBck5mLy9BTHIvN0FaN0IzTUNKZ0poQUFBQkJ3QkRBRm9CVWdBSXN3RWRCU1lBS3pYLy93Q2svK3dGbGdZaEFpWUNZZ0FBQVFZQVE3c0FBQWl6QVI4UkpnQXJOZi8vQUxyLzdBWjdCK0VDSmdKaEFBQUJCd0ptQldBQlVnQUlzd0VnQlNZQUt6WC8vd0NrLyt3RmxnYVBBaVlDWWdBQUFRY0NaZ1RiQUFBQUNMTUJJaEVtQUNzMS8vOEF1di9zQm5zSEx3SW1BbUVBQUFFSEFWSUFmd0ZTQUFpekFTVUZKZ0FyTmYvL0FLVC83QVdXQmQwQ0pnSmlBQUFCQmdGUy93QUFDTE1CSGhFbUFDczEvLzhBdXY2Z0Juc0dGQUltQW1FQUFBQUhBbWNGVEFBQS8vOEFwUDZnQlpZRThnSW1BbUlBQUFBSEFtY0VzZ0FBLy84QUFQNmdCSHNGdGdJbUFEd0FBQUFIQW1jRW5BQUEvLzhBQXY0VUJBWUVTQUltQUZ3QUFBQUhBbWNGbnYvOS8vOEFBQUFBQkhzSDRRSW1BRHdBQUFFSEFtWUVxZ0ZTQUFpekFRMEZKZ0FyTmYvL0FBTCtGQVFHQm84Q0pnQmNBQUFCQndKbUJHb0FBQUFJc3dFYUVTWUFLelgvL3dBQUFBQUVld2N2QWlZQVBBQUFBUWNCVXYvQ0FWSUFDTE1CRWdVbUFDczEvLzhBQXY0VUJBWUYzUUltQUZ3QUFBRUdBVktLQUFBSXN3RWZFU1lBS3pYLy93Qnovc1VFMHdZVUFpWUEwd0FBQUFjQVFnQzBBQUFBQXZ2bEJObit0QVloQUFrQUV3QWVRQXdFQ2c0T0FBQVZEd2FBQ3dFQUx6TWF6VElSQVRNUk14STVPVEV3QVNNbUppYzFNeFlXRndVakppWW5OVE1XRmhmK3RHQTBzU1c2SEdNeC9weGdPSzRsdXh4ak1RVFpLc28vRlQydVJCa3N5RDhWUGE1RUFBQUMvSEVFMmYrdUJuOEFEUUFWQUNoQUVSVUFCaEVSRndNR0NoVUtGUW9Sd0FZQkFDOHpHc3c1T1M4dkVSSTVFUUV6RVRNNU9URXdBU01tSndZSEl6VTNOamN6Rmhjbk5qY3pGUVlISS83VFhuQmpjbUZlTlhBMHNFS1hVRWsyckZONFlBVFpTMXRsUVJrOGUwMWVwc0piY0JWdVlBQUFBdnVhQk5uKzF3Wi9BQTBBRlFBcVFCSUdEaEVSQUFBWEF3WUtEd29QQ2hQQUJnRUFMek1hekRrNUx5OFJFamtSQVRNUk14STVPVEV3QVNNbUp3WUhJelUzTmpjekZoY2xJeVluTlRNV0YvN1hYbUZ5YW1sZU5YQTBzRUtYL2U1ZmVGU3NORXNFMlVGbFlFWVhQSHROWHFhc1huQVZiR0VBQXZ4eEJObi9ld2I0QUEwQUh3QTBRQmdRRXdBVEd3TUdCaFlPRGlFRENnWVNDaElLR1I3QUJnRUFMek1hekRJNU9TOHZFUkk1RVFFekVUTXpFaGM1RVRNeE1BRWpKaWNHQnlNMU56WTNNeFlYRXhRSEJ5TW5OalkxTkNZaklnYzFOak15L3ROZWNHTnlZVjQxY0RTd1FwZW9md1pRQ2prL09Tc3VHaGszd3dUWlMxdGxRUms4ZTAxZXBnRjdaeDFSZ3drZ0ppVVpCbEFHQUFMOGFBVFovdWNIRUFBWEFDVUFPa0FiR0I0SkNSVVZKeHNlSWg0WkVRa0FCUXdpQUF3TUFDSURGY0FaQUM4YXpCYzVMeTh2RVRNUXhETVJNeEVTT1JFQk14RXpFams1TVRBQklpNENJeUlHQnlNMk5qTXlIZ0l6TWpZM013WUdFeU1tSndZSEl6VTNOamN6RmhmK0xTVkhRejhjS0NvT1d3MWxTeVZKUXo0YktDb01XZ3RqWGw1aGNtcHBYalZ3TkxCQ2x3WTFIaVVlTVRKcWNSNGtIakV4YUhQK3BFRmxZRVlYUEh0TlhxWUFBdng1Qk5uK3h3YkJBQWNBRkFBa1FBOEhCQW9LRWhJV0EwQUhFUXFBRGdnQUx6TWEzVExVR3MwUkFUTVJNeEk1T1RFd0FUWTNNeFVHQnlNVElBTXpGaFl6TWpZM013WUcvVjVRTWF4V2QyQSsvdXdQWmdsTWFtSldDR2tMbFFYMGFHVVZjbDMrL0FFRVNEbEJRSGlNQUFMOGVRVFovc2NHd1FBSEFCUUFKRUFQQndRS0NoSVNGZ1JBQVJFS2dBNElBQzh6R3QweTFCck5FUUV6RVRNU09Ua3hNQUVqSmljMU14WVhBeUFETXhZV016STJOek1HQnYzUlhuZFdyRFJMTmY3c0QyWUpUR3BpVmdocEM1VUYzVjF5Rld4aC91VUJCRWc1UVVCNGpBQUMvSGtFMmY3SEJ3WUFFUUFlQUM1QUZRZ0FBQVVOQXhRVUhCd2dDeEFFQkJnWUd4U0FFZ0F2R3MweU14RTVMOFF5RVFFekVUTVNGemtSTXpFd0FSUUhCeU1uTmpZMU5DWWpJZ2MxTmpNeUF5QURNeFlXTXpJMk56TUdCdjR4ZndaU0NqbENPU3dsSkJZK3dKWCs3QTltQ1V4cVlsWUlhUXVWQm5sa0hTbGFDU0FsSlJvR1Rnajkwd0VFU0RsQlFIaU1BQUw4YUFUWi91Y0hEQUFYQUNRQU1FQVZHaUlKQ1JVbUJRd01IaDRZRlVBUkNRQWhHb0FZQUM4YTNUTFd4RE1helJFekVUa3ZNeEVCTXpJUk9Ua3hNQUVpTGdJaklnWUhJelkyTXpJZUFqTXlOamN6QmdZRElBTXpGaFl6TWpZM013WUcvaTBsUjBNL0hDZ3FEbHNOWkV3bFNVTStHeWdxREZvTFk5Mys3QTltQ1V4cVlsWUlhUXVWQmpNZUpCNHdNbWh4SGlRZU1URm5jdjZtQVFSSU9VRkFlSXdBQVFBeC9rSUJiUUFBQUE4QUdrQUxBQVVGQWdvREVCRU5DQU1BTDh3eUVSSUJGemtSTXpFd0Z6UW5NeFlWRkFZaklpYzFGak15TnQrTGU1NW1ZMEV5SURZbE0rNW5oM2lFVzJjUWJBb3dBQUFCQUJuK2RRRnhBSm9BQ3dBWVFBa0tBQVlBREEwSUF3QUFMOHd5RVJJQk9Ua1JNekV3SlJFUUl5SW5OUll6TWpVUkFYSGtPRHdwUFY2YS90LysvQmlNRTJRQk1BQUFBUUFaL25VQmNRQ1BBQXNBR0VBSkNnQUdBQXdOQ0FNQUFDL01NaEVTQVRrNUVUTXhNQ1VSRUNNaUp6VVdNekkxRVFGeDVEZzhLVDFlai83cS92d1lqQk5rQVNVQS8vOEFOQUFBQWtNRnRnQUhBQlQvZUFBQUFBSUFjLy9zQkJjRWN3QUxBQmNBS0VBVURBWVNBQVlBR0JrSkZVdFpDU1lERDAxWkF4a0FQeXNBR0Q4ckVSSUJPVGtSTXhFek1UQUJFQUlqSWdJUkVCSXpNaElCRkJZek1qWTFOQ1lqSWdZRUYvZmUyZmI1MnRqNS9RU2JqbzJlbm8rTm1nSXYvdlgreUFFMUFRNEJEd0UxL3N2KzhkRG82czdNN09rQUFBRUFMUUFBQWpjRVhnQUtBQ1pBRVFrQkFRQUlBQXNNQndRSEJBRUpFQUVZQUQ4L0VqazVMeThSRWdFNU9SRXpFVE14TUNFakVUUTNCZ2NISndFekFqZWhDRU0rbGxvQmY0c0NNZStNUXpCd2NnRWpBQUVBS1FBQUE5Y0Vjd0FaQUN4QUdBY1RBQk1YRGdFRkdoc1FDa3RaRUNZWUZ3RVhURmtCR0FBL0t4RUFNeGcvS3hFU0FSYzVFVE14TUNFaE5RRStBalUwSmlNaUJnY25Oak15RmhVVUJnY0ZGeUVEMS94U0FaR2RjU3lMZDFpY1hGckE4c2JhZ3JyK3VRSUN2b1VCTDNkb1UwRlhaejFLYmFpb2xuTzdnT2NHQUFBQkFGNytsUVFiQkhRQUp3QkhRQ1lEQkJzQUV3Y0hBQVFXSWcwR0tDa0VGeFlYRmt0WkZ4Y0tKU1VlUzFrbEpnb1JTMWtLSlFBL0t3QVlQeXNSRWdBNUdDOHJFUklBT1JFU0FSYzVFVE1STXhFek1UQUJGQVlIRlJZV0ZSUUVJU0ltSnpVV0ZqTWdFUkFoSXpVek1qWTFOQ1lqSWdZSEp6WTJNeklXQSs2ZGtMQ3EvdDcrOVhUQlcxL1hZQUY3L2w2UWtxdklrMzVncW0xVVd1dUMxZXdEQjR5eUhnZ1d0SkxSNFNNc25pOHhBU2tCQ28rWGhtdDZORVp3UjFIREFBQUNBQmYrcUFSbUJGNEFDZ0FTQUVKQUlSSUZDUUlDQ3djREFBTUZBeE1VQVFVU0JVMVpDUklPRHc4SEVoSURCeEFESkFBL1B4STVMeEk1RVRNUk15c1JBRE1SRWdFWE9SRXpNek1STXhFek1UQWxJeEVqRVNFMUFUTVJNeUVSTkRjakJnY0JCR2JacVAweUFyNjQyZjZHREFvcFJQNDVHLzZOQVhOOUE4YjhSQUZjMnQ1V1hQMmVBQUFCQUlYK2xRUWRCRjhBR2dBNlFCOFBBeGtVQ0JRWEF3UWNHd0FSUzFrQUFBWVZGUmhNV1JVUUJneExXUVlsQUQ4ckFCZy9LeEVTQURrWUx5c1JFZ0VYT1JFekVUTXhNQUV5QkJVVUFDTWlKelVXRmpNeU5qVVFJU0lISnhNaEZTRUROZ0l0NXdFSi90Lys5NEpHMEdXd3cvNkpYcUJXTndMWC9iY2xjd0ltNWNmai92NVBvQzB6cHAwQk1oMDNBcXlaL2trWEFQLy9BSFgvN0FRdkJjc0NCZ0FaQUFBQUFRQmUvcWtFS3dSZkFBWUFIMEFRQVFVRkFBSURCd2dEQWt4WkF4QUFKQUEvUHlzUkVnRVhPUkV6TVRBQkFTRTFJUlVCQVIwQ1h2empBODM5cXY2cEJSMlpoZnJQLy84QWFQL3NCQ2tGeXdJR0FCc0FBQUFDQUdyK2xRUWxCSFFBRndBbEFFRkFJaHNSSWdvS0FBQUVFUU1tSnc0ZVRWa0tGQTRPQWhRVUdFdFpGQ1lDQjAxWkFpVUFQeXNBR0Q4ckVSSUFPUmd2RWprckVSSUJGemtSTXhFekVUTXhNQUVRSVNJbk5SWXpNaElUSXdZR0l5SW1OVFFTTXpJV0VnRWlCaFVVRmpNeU5qWTFOQ1ltQkNYOWFIUkVVR2J3OVFzTU43Wnl3dVQvMEpYZmVQNFVqNXlRazF1WldGS1RBZS84cGhTUEdnRXBBVE5UVitqUTVBRUltZjdiQVRDNHBKQ2xTb0JHYWJKbUFQLy9BQjBBQUFYRUJoOEFKd0JKQXJZQUFBQUdBRWtBQUFBQ0FGd0MzUVdxQmNFQUlnQXpBRnBBTGl3d01DNHFKaVlvQ2dBY0VRVVJGZ0FvTGdZMU5Dc3hKQU10THkwcEx5TWpLQndLRkFnREF5Z3BHUlFVS1FNQVB6TXZNeEROTWk4ekVqazVFVE1STXhFekVSSVhPUkVTQVJjNUVUTVJNeEV6RVRNUk14RXpNVEFCRkFZaklpYzFGak15TlRRbUppY21KalUwTmpNeUZ3Y21JeUlHRlJRV0ZoY1dGZ0VESXhjUkl4RXpFeE16RVNNUk55TURBa2lWZkpGS2FuZVVGelpWZUZHT2JuMWNJbVJUUEVzU0sxK0JVQUdteVFnR2Q3ekR5N1IvQmdqVEE2eGliU0ZzS0dRaEtDRWZMRnRNVm1rbll5VXVLQjBrSENReVd2N3NBaStCL2xJQzBmM1JBaS85THdHa2lmM1QvLzhBRXY0VUJGb0Z0Z0ltQURjQUFBQUhBSG9CUHdBQS8vOEFILzRVQXFnRlJnSW1BRmNBQUFBSEFIb0F4UUFBQUFJQWNmNFVCRGNFWEFBTUFDb0FSMEFtQ2hVYUF5b3FIaDRrRlFNckxDRW5SbGtrSVJzY0R4b1BHQklZQjBaWkdCQVNBRVpaRWhZQVB5c0FHRDhyRVJJQU9Ua1lQejh6S3hFU0FSYzVFVE1STXpNUk16RXdKVEkyTnpVMEppTWlCaFVVRmdVME55TUdJeUlDRVJBU016SVhNemN6RVJRR0l5SW5OUllXTXpJMk5RSk1xcGNFbnF1UW1aY0Iyd2tMY09iWjcvUFQzM3NMR0lQcytmS1ZTOUoyanFWM3Q4b3I0c3pnME5IWmF5Umpwd0V0QVFvQkNBRXhwcEw3cE96c1JwNHFMcW1TLy84QWNmNFVCRGNHSVFJbUE1RUFBQUVHQVVzR0FBQUlzd0k1RVNZQUt6WC8vd0J4L2hRRU53WGxBaVlEa1FBQUFRWUJUZ3dBQUFpekFpc1JKZ0FyTmYvL0FISCtGQVEzQmQ4Q0pnT1JBQUFCQndGUEFWWUFBQUFJc3dJMEVTWUFLelgvL3dCeC9oUUVOd1loQWlZRGtRQUFBUVlDT25jQUFBaXpBaThSSmdBck5RQUJBTWtBQUFGekJiWUFBd0FSdGdBRUJRRURBQklBUHo4UkVnRTVNVEF6RVRNUnlhb0Z0dnBLQVAvL0FBVUFBQUdPQjNNQ0pnT1dBQUFCQndCRC9ud0JVZ0FJc3dFRkJTWUFLelgvL3dDekFBQUNQQWR6QWlZRGxnQUFBUWNBZHY4cUFWSUFDTE1CRFFVbUFDczEvLy8veHdBQUFta0hjd0ltQTVZQUFBRUhBVXYrdXdGU0FBaXpBUklGSmdBck5mLy9BQVVBQUFJNEJ5VUNKZ09XQUFBQkJ3QnEvdEFCVWdBS3RBSUJHUVVtQUNzMU5mLy8vNnNBQUFLVEJ5OENKZ09XQUFBQkJ3RlMvcU1CVWdBSXN3RU5CU1lBS3pYLy8vL3pBQUFDU3dhMEFpWURsZ0FBQVFjQlRmN0dBVklBQ0xNQkJ3VW1BQ3MxLy8vLzV3QUFBbE1ITndJbUE1WUFBQUVIQVU3K3dnRlNBQWl6QVFRRkpnQXJOZi8vQUZiK1FnR2lCYllDSmdPV0FBQUFCZ0ZSTVFELy93QzdBQUFCZndjeEFpWURsZ0FBQVFjQlR3QVpBVklBQ0xNQkRRVW1BQ3MxLy84QXlmNS9BNk1GdGdBbUE1WUFBQUFIQUMwQ093QUEvLy8vNUFBQUFoMEdDZ0FuQTVZQXFnQUFBUWNCVlAzby81Y0FCN0lCQ0FBQVB6VUEvLzhBeVFBQUFYTUZ0Z0lHQTVZQUFQLy9BQVVBQUFJNEJ5VUNKZ09XQUFBQkJ3QnEvdEFCVWdBS3RBSUJHUVVtQUNzMU5mLy9BTWtBQUFGekJiWUNCZ09XQUFELy93QUZBQUFDT0FjbEFpWURsZ0FBQVFjQWF2N1FBVklBQ3JRQ0FSa0ZKZ0FyTlRYLy93REpBQUFCY3dXMkFnWURsZ0FBLy84QXlRQUFBWE1GdGdJR0E1WUFBUC8vQUprQUFBSUVCK0VDSmdPV0FBQUJCd0ptQTVFQlVnQUlzd0VJQlNZQUt6WC8vd0M0L3FBQmZ3VzJBaVlEbGdBQUFBY0Nad045QUFBQUFRQUFBNm9BaWdBV0FGWUFCUUFDQUJBQUx3QmNBQUFCRGdENEFBTUFBUUFBQUI4QUh3QWZBQjhBVVFCM0FQOEJld0hzQW1vQ2d3S3VBdGtERlFOQkExOERkQU9XQTY4RDhRUWFCRnNFdVFUN0JVWUZvd1hGQmpRR2tRYkhCdnNIR3dkRUIyUUh1d2hCQ0lBSTJ3a1pDVlVKaWdtNENnZ0tPUXBzQ3BRS3d3cmhDeDhMVmd1Y0M5a01MQXg1RE13TThBMGtEVXNOancyL0RlWU9FZzQyRGs4T2NnNlREcWtPeUE4a0Qza1B0QkFIRUZRUWxCRW9FV1lSbEJIU0VoQVNKeEovRXJrUytoTlBFNk1UMWhRb0ZHZ1VwUlRNRlJjVlJ4V0FGYXdWN2hZR0Zrc1doUmFGRnJZWEFSZFRGNkVYOVJnYUdKVVl5eGxIR1pRWnp4bnRHZlVhZnhxVkdzMGEyUnNURzJNYmdodkJHL0VjRXh4RkhHd2NwUnpkSFBNZENCMGVIWHNkakIyZEhhNGR2eDNSSGQwZUt4NDNIa2dlV1I1cUhud2VqUjZlSHE4ZXdSOFpIeW9mT3g5TUgxMGZiaCtBSDY0Z0dTQXFJRHNnVENCZUlHOGdzU0VZSVNnaE9DRklJVmdoYVNGNklnVWlFU0loSWpFaVFTSlNJbU1pZENLRklwY2kveU1QSXg4akx5TS9JMDhqWUNPbUpBd2tIQ1FzSkR3a1RTUmRKTFFreFNUV0pPWWs5eVVISlJNbEh5VXdKVUFsVVNWaEpYSWxneVdVSmFRbHRTWEdKYzRtT2laTEpsc21iQ1o4Sm8wbW5pYXFKcllteHliWEp1Z20rQ2NKSnhrbktpYzdKMGNuVnlkb0oza255U2dpS0RNb1JDaFZLR1lvZHlpSUtKTW9uaWl2S01ZbzBpamVLTzhwQUNrTUtSY3BUQ2xkS1c0cGVTbUZLWllwcGlteUtiNHArQ290S2o0cVRpcGFLbVVxZGlxR0twY3EzaXNuS3pnclNDdFpLMmtyZXl1TUsrOHNhU3g2TElvc2xTeWhMTElzd3l6VUxPUXM5UzBGTFJFdEhTMHVMVDR0U1MxVUxXVXRkUzJ5TGdRdUZTNGxMall1Umk1WExtY3VlUzZLTHB3dXJTNjVMc1V1MWk3bkx2Z3ZDQzhhTHlzdk95OU1MMTB2Ymk5K0w2VXYrREIzTVJZeEp6RTRNVWt4V1RGa01XOHhtREhCTWRjeC96SWZNbFF5ZXpLME11WXpCVE5PTTE4elp6TjRNNG96bkRPdE03OHowRFBqTStzejh6UVNOQm8wSWpRcU5ESTBpelNUTkpzMHdUVEpOTkUxQmpVT05USTFPalZ4TlhrMWdUWG9OZkEyUERhUU5xSTJ0RGJFTnRRMjVEYjFOd2MzYXpmUU9BWTRaempGT1JJNVREbW1PZEk1Mmpvc09qUTZYenJLT3RJN0VEdGNPNmc3N1R3bFBGMDh1ajBRUFY4OXVUM0xQZHc5N0QzOFBnMCtIejV2UG9BK3lqN1NQdG8rN0Q3MFAxTS9wai9sUC9aQUIwQTNRRDlBaGtDT1FKWkEzMERuUVN4QmlVSEJRZEpDQVVJOFFrUkNURUpVUWx4Q1pFSnNRblJDczBLN1FzTkM5RU1yUTF0RGxVUGJSQ05FWVVTdlJROUZWa1ZlUmJwR0ZVWTBSbnhHaEViS1J5TkhXMGRyUjV0SDBVZ1VTRWxJVVVoMVNIMUloVWlxU0xKSkUwa2JTVXhKZzBtMFNlOUtORXA5U3JoTENFdGxTNmxMdWt3bFREVk1nMHlMVEpOTXBVeXRUUVpOV0UxZ1RYQk5nRTJ4VGRaTi9VNE9UaDVPTDA1QVRsSk9aRTUxVG9aT20wNndUcmhPMms3M1R4VlBIVTg2VDJsUG1rKzBUL0pRV2xCNlVJcFJKRkVzVVRSUlYxRjdVWWRSb0ZIVFVoaFNobEw0VTI1VDFGUXNWS0JVOUZUOFZVdFZZbFY1VlpCVnAxWUtWajVXWTFhWFZxNVcwbGN5VjJKWDQxZ3NXRDVZVUZoOVdJbFlsVmk4V09OWkFsa2hXVUJaZFZtM1dmeGFUVnB1V3ROYkoxc25XeWRiSjFzbld5ZGJKMXNuV3lkYkoxc25XeWRiSjFzblhIRmN6RnpkWE9WZGJGMm5YZ3RlSEY0dFhqbGVSVjVYWG94ZXcxN1RYdU5mUUYrWFgrQmdNV0E2WUVOZ1RHQjZZSmxncW1DN1lNdGcyMkZPWVpsaDdXSTdZcHRpL21NL1k0QmoxbVFzWkk5azlHVnBaZUJtakdjd1p6aG5RR2VkWi9ab0wyaG5hSGxvaTJrQmFRMXBnR256YXAxck8ydlJiRHBzZld5L2JRTnRNMjFnYlladHJHNlFieHR2Z1cvZmNERndnbkRYY1VOeGUzRzBjZ1p5VlhLb2N2dHpCM01UYzFCempIUE5kQkIwV0hTc2RPWjFIblZkZGFKMTNYWWRkbk4yeG5kQ2Q3bDN4WGZSZUFKNE5IZzhlRzk0clhqeGVUQjVjWG11ZWV4Nk1IcHplcjk3QzN0RGUzcDc2SHhMZk1GOUxYMDFmVVo5VjMyc2ZmeCtSSDZIZnN4L0ZYOVZmNVovMm9BZWdHK0F2WURGZ05hQTVvRDRnUW1CRVlFWmdTcUJPb0dMZ2RxQjdJSDlnZytDSVlJemdrU0NrSUxhZ3V1Qys0TU5neDZETUlOQmcwbURVWU5qZzNTRGhvT1hnNmlEdUlQS2c5dUQ3WVAraEJDRUlZUk1oSGVFaVlTYmhLZUVzb1MraE1xRkVJVldoWlNGbklYMmhtU0d5WWNuaDRHSDFJZ3JpSG1JeElrVGlXYUpzSW52aWkyS2lvcVNpcDZLcW9xMmlzS0swNHJraXZhTENJc2FpeXlMUG90UWkyS0xkSXVKaTUyTHI0dkJpOU9MNVl2M2pBbU1HNHd0akVLTVZveGlqRzZNZjR5UWpLR01zWXpEak5XTTU0ejVqUXVOSFkwdmpVR05WbzFxalh1TmpJMllqYVNOc0kyOGpjMk4zbzN3amdLT0ZJNG1qamlPU281Y2ptNk9nNDZYanFpT3VJN0pqdG1PNm83N2p3eVBISThvanpTUFFJOU1qMTJQYm85L2o0K1BvSSt3ajhHUDBvL2pqL09QLzVBTGtCZVFJNUEwa0VXUVZwQm1rSEtRcHBEaGtSMlJhcEhDa2ZxU01wSjdrczJTOVpNWWt6dVRSSk9EazYyVDdwUk9sSk9VM3BUbWxRbVZFWlZ1bFhxVjlwWUNsZzZXY1phQmxwR1dvcGF5bHNlVzJKYnBsdnFYREpjZGx5NlhQNWRLbDF1WFo1ZDVsNEdYazVlYmw2Mlh0WmU5bDg2WDJnQUFBQUVBQUFBQkdkc2ZQYlY5WHc4ODlRQUpDQUFBQUFBQXlUVXhpd0FBQUFEVks4elYrNXI5MVFtaUNHSUFBQUFKQUFJQUFBQUFBQUFFelFEQkFBQUFBQVFVQUFBQ0ZBQUFBaU1BbUFNMUFJVUZLd0F6QkpNQWd3YVdBR2dGMXdCeEFjVUFoUUplQUZJQ1hnQTlCR29BVmdTVEFHZ0I5Z0EvQXBNQVZBSWhBSmdDOEFBVUJKTUFaZ1NUQUx3RWt3QmtCSk1BWGdTVEFDc0Vrd0NGQkpNQWRRU1RBRjRFa3dCb0JKTUFhZ0loQUpnQ0lRQS9CSk1BYUFTVEFIY0Vrd0JvQTI4QUd3Y3hBSGtGRUFBQUJTOEF5UVVNQUgwRjFRREpCSE1BeVFRaEFNa0Ywd0I5QmVjQXlRS3FBRlFDSS85Z0JPa0F5UVFuQU1rSE9RREpCZ2dBeVFZN0FIMEUwUURKQmpzQWZRVHlBTWtFWkFCcUJHMEFFZ1hUQUxvRXd3QUFCMmdBR3dTZUFBZ0Vld0FBQkpFQVVnS2lBS1lDOEFBWEFxSUFNd1JXQURFRGx2LzhCSjRCaVFSekFGNEU1d0N3QTg4QWN3VG5BSE1FZlFCekFyWUFIUVJpQUNjRTZRQ3dBZ1lBb2dJRy81RUVNd0N3QWdZQXNBZHhBTEFFNlFDd0JOVUFjd1RuQUxBRTV3QnpBMFFBc0FQUkFHb0Mwd0FmQk9rQXBBUUNBQUFHT1FBWEJERUFKd1FJQUFJRHZnQlNBd2dBUFFSb0FlNERDQUJJQkpNQWFBSVVBQUFDSXdDWUJKTUF2Z1NUQUQ4RWt3QjdCSk1BSHdSb0FlNEVJUUI3Qko0Qk5RYW9BR1FDMVFCR0Evb0FVZ1NUQUdnQ2t3QlVCcWdBWkFRQS8vb0RiUUIvQkpNQWFBTEhBREVDeHdBaEJKNEJpUVQwQUxBRlBRQnhBaUVBbUFIUkFDVUN4d0JNQXdBQVFnUDZBRkFHUFFCTEJqMEFMZ1k5QUJvRGJ3QXpCUkFBQUFVUUFBQUZFQUFBQlJBQUFBVVFBQUFGRUFBQUJ2ei8vZ1VNQUgwRWN3REpCSE1BeVFSekFNa0Vjd0RKQXFvQVBBS3FBRlFDcXYvL0Fxb0FQQVhIQUM4R0NBREpCanNBZlFZN0FIMEdPd0I5QmpzQWZRWTdBSDBFa3dDRkJqc0FmUVhUQUxvRjB3QzZCZE1BdWdYVEFMb0Vld0FBQk9NQXlRVDZBTEFFY3dCZUJITUFYZ1J6QUY0RWN3QmVCSE1BWGdSekFGNEczUUJlQTg4QWN3UjlBSE1FZlFCekJIMEFjd1I5QUhNQ0J2L2FBZ1lBcVFJRy83TUNCdi9zQk1VQWNRVHBBTEFFMVFCekJOVUFjd1RWQUhNRTFRQnpCTlVBY3dTVEFHZ0UxUUJ6Qk9rQXBBVHBBS1FFNlFDa0JPa0FwQVFJQUFJRTV3Q3dCQWdBQWdVUUFBQUVjd0JlQlJBQUFBUnpBRjRGRUFBQUJITUFYZ1VNQUgwRHp3QnpCUXdBZlFQUEFITUZEQUI5QTg4QWN3VU1BSDBEendCekJkVUF5UVRuQUhNRnh3QXZCT2NBY3dSekFNa0VmUUJ6QkhNQXlRUjlBSE1FY3dESkJIMEFjd1J6QU1rRWZRQnpCSE1BeVFSOUFITUYwd0I5QkdJQUp3WFRBSDBFWWdBbkJkTUFmUVJpQUNjRjB3QjlCR0lBSndYbkFNa0U2UUN3QmVjQUFBVHBBQlFDcXYvaUFnYi9rQUtxQUNvQ0J2L2FBcW9BSGdJRy84d0NxZ0JVQWdZQU5RS3FBRlFDQmdDd0JNMEFWQVFNQUtJQ0kvOWdBZ2Iva1FUcEFNa0VNd0N3QkNVQXNBUW5BTWtDQmdDakJDY0F5UUlHQUZrRUp3REpBZ1lBc0FRbkFNa0Nnd0N3QkM4QUhRSVgvL3dHQ0FESkJPa0FzQVlJQU1rRTZRQ3dCZ2dBeVFUcEFMQUZjd0FCQmdnQXlRVHBBTEFHT3dCOUJOVUFjd1k3QUgwRTFRQnpCanNBZlFUVkFITUhZZ0I5QjRrQWNRVHlBTWtEUkFDd0JQSUF5UU5FQUdBRThnREpBMFFBZ2dSa0FHb0QwUUJxQkdRQWFnUFJBR29FWkFCcUE5RUFhZ1JrQUdvRDBRQnFCRzBBRWdMVEFCOEViUUFTQXRNQUh3UnRBQklDMHdBZkJkTUF1Z1RwQUtRRjB3QzZCT2tBcEFYVEFMb0U2UUNrQmRNQXVnVHBBS1FGMHdDNkJPa0FwQVhUQUxvRTZRQ2tCMmdBR3dZNUFCY0Vld0FBQkFnQUFnUjdBQUFFa1FCU0E3NEFVZ1NSQUZJRHZnQlNCSkVBVWdPK0FGSUNqd0N3Qko0QXd3VVVBQUFFY3dCZUJ2ei8vZ2JkQUY0R093QjlCTlVBY3dSa0FHb0QwUUJxQkx3QkRBUzhBUXdFc2dFdEJMd0JKUUlHQUtJRW5nRnZBWk1BSlFTOEFRZ0VuZ0RuQko0Qi9BU2VBUnNGRUFBQUFpRUFtQVR5LzlRR2ZmL1VBNWovNUFhQi8rUUZoZi9VQm9ILzVBSzIvK2tGRUFBQUJTOEF5UVFwQU1rRWt3QW5CSE1BeVFTUkFGSUY1d0RKQmpzQWZRS3FBRlFFNlFESkJOTUFBQWM1QU1rR0NBREpCRzBBU0FZN0FIMEYxUURKQk5FQXlRU0pBRW9FYlFBU0JIc0FBQVppQUdvRW5nQUlCbDRBYlFaQ0FGQUNxZ0E4QkhzQUFBVGpBSE1EelFCYUJPa0FzQUsyQUtnRTN3Q2tCT01BY3dVR0FMQUVHUUFLQktRQWNRUE5BRm9EM1FCekJPa0FzQVM4QUhNQ3RnQ29CQ1VBc0FSRy8vSUU5QUN3QkZZQUFBUE5BSEVFMVFCekJUTUFHUVRWQUtZRDJ3QnpCT2NBY3dQSkFCSUUzd0NrQmI0QWN3UmUvK3dHQmdDa0JpOEFjd0syQUFrRTN3Q2tCTlVBY3dUZkFLUUdMd0J6QkhNQXlRWGZBQklFS1FESkJSMEFmUVJrQUdvQ3FnQlVBcW9BUEFJai8yQUhid0FBQjZBQXlRWGZBQklFNVFESkJQZ0FHd1hWQU1rRkVBQUFCT2NBeVFVdkFNa0VLUURKQlhjQURnUnpBTWtHd1FBQ0JLWUFTZ1laQU1zR0dRRExCT1VBeVFXaUFBQUhPUURKQmVjQXlRWTdBSDBGMVFESkJORUF5UVVNQUgwRWJRQVNCUGdBR3daaUFHb0VuZ0FJQmVVQXlRV1BBS29JUWdESkNFUUF5UVdCQUJJRzB3REpCU1VBeVFVS0FEMElaZ0RKQlJjQU13UnpBRjRFeFFCM0JJMEFzQU50QUxBRWt3QXBCSDBBY3dYakFBUUQzUUJFQlJJQXNBVVNBTEFFSndDd0JKRUFFQVhoQUxBRkVnQ3dCTlVBY3dUNEFMQUU1d0N3QTg4QWN3TzhBQ2tFQ0FBQ0JiZ0FjUVF4QUNjRkFnQ3dCTjBBbkFjZkFMQUhMUUN3Qlk4QUtRWXBBTEFFdkFDd0EvQUFPUWFtQUxBRWNRQWxCSDBBY3dUcEFCUURiUUN3QS9BQWN3UFJBR29DQmdDaUFnYi83QUlHLzVFR3NnQVFCeGNBc0FUcEFCUUVKd0N3QkFnQUFnVDRBTEFFTndESkEyMEFzQWRvQUJzR09RQVhCMmdBR3dZNUFCY0hhQUFiQmprQUZ3UjdBQUFFQ0FBQ0JBQUFVZ2dBQUZJSUFBQlNBMHIvL0FGY0FCa0JYQUFaQWZZQVB3RmNBQmtDelFBWkFzMEFHUU05QUJrRUJBQjdCQlFBZXdNQ0FLUUdSZ0NZQ1o0QVpBSEZBSVVESlFDRkFtOEFVZ0p2QUZBRDR3Q1lBUXIrZVFNbkFHMEVrd0JpQkpNQVJBWWJBSm9FdUFBL0JwZ0FqUVFwQUhjSUp3REpCalVBSlFaQ0FGQUU5QUJtQmowQVJ3WTlBQ0FHUFFCSEJqMEFhZ1NtQUdZRWt3QW5CZWtBeVFVTUFFd0Vrd0JvQkdRQUpRV2tBSGNERWdBTUJKTUFZZ1NUQUdnRWt3Qm9CSk1BYUFTcUFHOEV2QUFkQkx3QUhRU2VBTnNDQnYrUkJBQUJpUVFBQVhFRUFBR0JBc2NBSndMSEFCUUN4d0E3QXNjQUtRTEhBRGtDeHdBekFzY0FJd1FBQUFBSUFBQUFCQUFBQUFnQUFBQUNxZ0FBQWdBQUFBRldBQUFFZVFBQUFpRUFBQUdhQUFBQXpRQUFBQUFBQUFBQUFBQUlBQUJVQ0FBQVZBSUcvNUVCWEFBWkJQb0FDZ1NGQUFBR3VBQVNCemtBeVFkeEFMQUZFQUFBQkhNQVhnWlMvdDhDcWdCMUF6TUFtQWQxQUIwSGRRQWRCajBBZlFUZkFITUdKUUM2QlZJQXBBQUEvRk1BQVAwTkFBRDhHUUFBL1FnQUFQMDdCSE1BeVFZWkFNc0VmUUJ6QlJJQXNBZ1hBSVVHalFBQUJXWUFGd1VPQUJjSFdnREpCZU1Bc0FWdEFBQUVnd0FLQjE0QXlRWWhBTEFGeFFBVUJTTUFEQWZMQU1rR3hRQ3dCS2dBUHdQZEFCa0dYZ0J0QmdZQXBBWTlBSDBFMVFCekJRSUFBQVFNQUFBRkFnQUFCQXdBQUFtc0FIMElmUUJ6Qm8wQWZRVkNBSE1IL2dCOUJuY0Fjd2ZmQUY0R2pRQUFCUjBBZlFQbkFITUUzd0JxQkhVQXl3U2VBUGdFbmdIZkJKNEI0UWZwQUNrSHBnQXBCaWtBeVFVbEFMQUU1d0F2Qkx3QUZBVGpBTWtFNXdDd0JEY0FMd050QUJJRkl3REpCRE1Bc0FjZkFBSUdQUUFFQktZQVNnUGRBRVFGU2dESkJGd0FzQVRwQU1rRVJBQ3dCT2tBTHdRakFCUUZnd0FRQk93QUtRWDRBTWtGTHdDd0JvRUF5UVhqQUxBSWlRREpCdXdBc0FZN0FIMEZId0J6QlF3QWZRUFBBSE1FYlFBUUE3d0FLUVI3QUFBRUFnQUFCSHNBQUFRQ0FBQUU5QUFJQkZZQUp3YlhBQkFGdkFBcEJZa0FxZ1RmQUp3Rmp3Q3FCTTBBbkFXUEFNa0VyZ0N3QnJRQVBRVkdBRE1HdEFBOUJVWUFNd0txQUZRR3dRQUNCZU1BQkFXREFNa0VaQUN3QmFZQUFBU1RBQkFGMFFESkJPNEFzQVgyQU1rRk9RQ3dCWThBcWdUZEFKd0hPd0RKQmVNQXNBS3FBRlFGRUFBQUJITUFYZ1VRQUFBRWN3QmVCdnovL2diZEFGNEVjd0RKQkgwQWN3WFhBSFVFZVFCbUJkY0FkUVI1QUdZR3dRQUNCZU1BQkFTbUFFb0QzUUJFQktvQVNnUHBBQnNHR1FETEJSSUFzQVlaQU1zRkVnQ3dCanNBZlFUVkFITUdQUUI5Qk5VQWN3WTlBSDBFMVFCekJRb0FQUVB3QURrRStBQWJCQWdBQWdUNEFCc0VDQUFDQlBnQUd3UUlBQUlGandDcUJOMEFuQVEzQU1rRGJRQ3dCdE1BeVFZcEFMQUVOd0F2QTIwQUVnVDRBQWdFVWdBbkJKNEFCZ1F4QUNjRTV3Q0RCT2NBY3djeEFJTUhLd0J6QnpzQVRnWnFBRkFGQUFCT0JDOEFVQWZaQUFBR3p3QVFDQmtBeVFkT0FMQUdEQUI5QlI4QWN3V3VBQkFGTFFBcEJLb0Fid1BOQUZvRm1nQUFCSkVBRUFVUUFBQUVjd0JlQlJBQUFBUnpBRjRGRUFBQUJITUFYZ1VRQUFBRWN3QXRCUkFBQUFSekFGNEZFQUFBQkhNQVhnVVFBQUFFY3dCZUJSQUFBQVJ6QUY0RkVBQUFCSE1BWGdVUUFBQUVjd0JlQlJBQUFBUnpBRjRGRUFBQUJITUFYZ1J6QU1rRWZRQnpCSE1BeVFSOUFITUVjd0RKQkgwQWN3UnpBTWtFZlFCekJITUFYUVI5QUVvRWN3REpCSDBBY3dSekFNa0VmUUJ6QkhNQXlRUjlBSE1DcWdCVUFnWUFld0txQUZRQ0JnQ2RCanNBZlFUVkFITUdPd0I5Qk5VQWN3WTdBSDBFMVFCekJqc0FmUVRWQUdFR093QjlCTlVBY3dZN0FIMEUxUUJ6QmpzQWZRVFZBSE1HUFFCOUJOOEFjd1k5QUgwRTN3QnpCajBBZlFUZkFITUdQUUI5Qk44QWN3WTlBSDBFM3dCekJkTUF1Z1RwQUtRRjB3QzZCT2tBcEFZbEFMb0ZVZ0NrQmlVQXVnVlNBS1FHSlFDNkJWSUFwQVlsQUxvRlVnQ2tCaVVBdWdWU0FLUUVld0FBQkFnQUFnUjdBQUFFQ0FBQ0JIc0FBQVFJQUFJRTV3QnpBQUQ3NVFBQS9IRUFBUHVhQUFEOGNRQUEvR2dBQVB4NUFBRDhlUUFBL0hrQUFQeG9BYVFBTVFHa0FCa0JwQUFaQXkwQU5BU0pBSE1DOUFBdEJCUUFLUVNUQUY0RWp3QVhCSk1BaFFTVEFIVUVrd0JlQkpNQWFBU1RBR29GYlFBZEJsb0FYQVJ0QUJJQzB3QWZCT2NBY1FUbkFIRUU1d0J4Qk9jQWNRVG5BSEVDT3dESkFqc0FCUUk3QUxNQ08vL0hBanNBQlFJNy82c0NPLy96QWp2LzV3STdBRllDT3dDN0JGNEF5UUxsLytRQ093REpBQVVBeVFBRkFNa0F5UUNaQUxnQUFBQUJBQUFJamYyb0FBQUpyUHVhL25zSm9nQUJBQUFBQUFBQUFBQUFBQUFBQUFBRG93QURCTFlCa0FBRkFBQUZtZ1V6QUFBQkh3V2FCVE1BQUFQUkFHWUI4UWdDQWdzR0JnTUZCQUlDQk9BQUF1OUFBQ0JiQUFBQUtBQUFBQUF4UVZOREFFQUFJUC85QmgvK0ZBQ0VDSTBDV0NBQUFaOEFBQUFBQkVnRnRnQUFBQ0FBQXdBQUFBRUFBd0FCQUFBQURBQUVBM3dBQUFER0FJQUFCZ0JHQUVnQVNRQitBTXNBendFbkFUSUJZUUZqQVg4QmtnR2hBYkFCOEFIL0Foc0NOd0s4QXNjQ3lRTGRBdk1EQVFNREF3a0REd01qQTRrRGlnT01BNWdEbVFPaEE2a0RxZ1BPQTlJRDFnUU5CRThFVUFSY0JGOEVoZ1NQQkpFRXZ3VEFCTTRFendVVEhnRWVQeDZGSHNjZXloN3hIdk1lK1I5TklBc2dGU0FlSUNJZ0ppQXdJRE1nT2lBOElFUWdjQ0I1SUg4Z3BDQ25JS3doQlNFVElSWWhJQ0VpSVNZaExpRmVJZ0lpQmlJUEloSWlHaUllSWlzaVNDSmdJbVVseXZzRS92Ly8vZi8vQUFBQUlBQkpBRW9Bb0FETUFOQUJLQUV6QVdJQlpBR1NBYUFCcndId0Fmb0NHQUkzQXJ3Q3hnTEpBdGdDOHdNQUF3TURDUU1QQXlNRGhBT0tBNHdEamdPWkE1b0Rvd09xQTZzRDBRUFdCQUFFRGdSUUJGRUVYUVJnQklnRWtBU1NCTUFFd1FUUEJOQWVBQjQrSG9BZW9CN0lIc3NlOGg3MEgwMGdBQ0FUSUJjZ0lDQW1JREFnTWlBNUlEd2dSQ0J3SUhRZ2Z5Q2pJS2NncXlFRklSTWhGaUVnSVNJaEppRXVJVnNpQWlJR0lnOGlFU0lhSWg0aUt5SklJbUFpWkNYSyt3RCsvLy84Ly8vLzR3Tk4vK1Avd2dMTC84SUFBUC9DQWkzL3d2K3dBTDhBc2dCaC8wa0FBQUFBLzViK2hmNkUvbmIvYVA5ai8yTC9YUUJuLzBUOTBBQVgvYy85emdBSi9jNzl6Zi81L2MzK2d2NS9BQUQ5bXY0YS9aa0FBUDRNL2d2OWFQNEovdWIrQ2Y3WS9nbmtXT1FZNDNya2ZRQUE1SDNqRHVSNzR3M2lRdUh2NGU3aDdlSHE0ZUhoNE9IYjRkcmgwK0hMNGNqaG1lRjI0WFFBQU9FWTRRdmhDZUp1NFA3ZysrRDA0TWpnSmVBaTRCcmdHZUFTNEEvZ0E5L24zOURmemR4cEFBQURUd0pUQUFFQUFBQUFBQUFBQUFBQUFBQUF1Z0FBQUFBQUFBQUFBQUFBQUFBQUFBQUF2Z0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBSmdBQUFBQUFBQUFyQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQ1lBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBZGdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFGSUFBQUFBQUFBRG13RHJBNXdBN1FPZEFPOERuZ0R4QTU4QTh3T2dBVWtCU2dFa0FTVUNhQUdjQVowQm5nR2ZBYUFEcEFPbEFhTUJwQUdsQWFZQnB3SnBBbXNCOWdIM0E2Z0RSZ09wQTNVQ0hBT05BalFDTlFKZEFsNUFSMXRhV1ZoVlZGTlNVVkJQVGsxTVMwcEpTRWRHUlVSRFFrRkFQejQ5UERzNk9UZzNOalV4TUM4dUxTd29KeVlsSkNNaUlSOFlGQkVRRHc0TkN3b0pDQWNHQlFRREFnRUFMQ0N3QVdCRnNBTWxJQkZHWVNORkkyRklMU3dnUlJob1JDMHNSU05HWUxBZ1lTQ3dSbUN3QkNZalNFZ3RMRVVqUmlOaHNDQmdJTEFtWWJBZ1liQUVKaU5JU0Mwc1JTTkdZTEJBWVNDd1ptQ3dCQ1lqU0VndExFVWpSaU5oc0VCZ0lMQW1ZYkJBWWJBRUppTklTQzBzQVJBZ1BBQThMU3dnUlNNZ3NNMUVJeUM0QVZwUldDTWdzSTFFSTFrZ3NPMVJXQ01nc0UxRUkxa2dzQVFtVVZnaklMQU5SQ05aSVNFdExDQWdSUmhvUkNDd0FXQWdSYkJHZG1pS1JXQkVMU3dCc1FzS1F5TkRaUW90TEFDeENndERJME1MTFN3QXNDZ2pjTEVCS0Q0QnNDZ2pjTEVDS0VVNnNRSUFDQTB0TENCRnNBTWxSV0Zrc0ZCUldFVkVHeUVoV1Mwc1NiQU9JMFF0TENCRnNBQkRZRVF0TEFHd0JrT3dCME5sQ2kwc0lHbXdRR0d3QUlzZ3NTekFpb3k0RUFCaVlDc01aQ05rWVZ4WXNBTmhXUzBzaWdORmlvcUhzQkVyc0NralJMQXBldVFZTFN4RlpiQXNJMFJGc0NzalJDMHNTMUpZUlVRYklTRlpMU3hMVVZoRlJCc2hJVmt0TEFHd0JTVVFJeUNLOVFDd0FXQWo3ZXd0TEFHd0JTVVFJeUNLOVFDd0FXRWo3ZXd0TEFHd0JpVVE5UUR0N0Mwc3NBSkRzQUZTV0NFaElTRWhHMFlqUm1DS2lrWWpJRWFLWUlwaHVQK0FZaU1nRUNPS3NRd01pbkJGWUNDd0FGQllzQUZodVArNml4dXdSb3hac0JCZ2FBRTZXUzBzSUVXd0F5VkdVa3V3RTFGYldMQUNKVVlnYUdHd0F5V3dBeVUvSXlFNEd5RVJXUzBzSUVXd0F5VkdVRml3QWlWR0lHaGhzQU1sc0FNbFB5TWhPQnNoRVZrdExBQ3dCME93QmtNTExTd2hJUXhrSTJTTHVFQUFZaTBzSWJDQVVWZ01aQ05raTdnZ0FHSWJzZ0JBTHl0WnNBSmdMU3doc01CUldBeGtJMlNMdUJWVllodXlBSUF2SzFtd0FtQXRMQXhrSTJTTHVFQUFZbUFqSVMwc1MxTllpckFFSlVsa0kwVnBzRUNMWWJDQVlyQWdZV3F3RGlORUl4Q3dEdlliSVNPS0VoRWdPUzlaTFN4TFUxZ2dzQU1sU1dScElMQUZKckFHSlVsa0kyR3dnR0t3SUdGcXNBNGpSTEFFSmhDd0R2YUtFTEFPSTBTd0R2YXdEaU5Fc0E3dEc0cXdCQ1lSRWlBNUl5QTVMeTlaTFN4RkkwVmdJMFZnSTBWZ0kzWm9HTENBWWlBdExMQklLeTBzSUVXd0FGUllzRUJFSUVXd1FHRkVHeUVoV1Mwc1JiRXdMMFVqUldGZ3NBRmdhVVF0TEV0UldMQXZJM0N3RkNOQ0d5RWhXUzBzUzFGWUlMQURKVVZwVTFoRUd5RWhXUnNoSVZrdExFV3dGRU93QUdCanNBRmdhVVF0TExBdlJVUXRMRVVqSUVXS1lFUXRMRVVqUldCRUxTeExJMUZZdVFBei8rQ3hOQ0Fic3pNQU5BQlpSRVF0TExBV1ExaXdBeVpGaWxoa1pyQWZZQnRrc0NCZ1ppQllHeUd3UUZtd0FXRlpJMWhsV2JBcEkwUWpFTEFwNEJzaElTRWhJVmt0TExBQ1ExUllTMU1qUzFGYVdEZ2JJU0ZaR3lFaElTRlpMU3l3RmtOWXNBUWxSV1N3SUdCbUlGZ2JJYkJBV2JBQllTTllHMlZac0NralJMQUZKYkFJSlFnZ1dBSWJBMW13QkNVUXNBVWxJRWF3QkNValFqeXdCQ1d3QnlVSXNBY2xFTEFHSlNCR3NBUWxzQUZnSTBJOElGZ0JHd0Jac0FRbEVMQUZKYkFwNExBcElFVmxSTEFISlJDd0JpV3dLZUN3QlNXd0NDVUlJRmdDR3dOWnNBVWxzQU1sUTBpd0JDV3dCeVVJc0FZbHNBTWxzQUZnUTBnYklWa2hJU0VoSVNFaExTd0NzQVFsSUNCR3NBUWxJMEt3QlNVSXNBTWxSVWdoSVNFaExTd0NzQU1sSUxBRUpRaXdBaVZEU0NFaElTMHNSU01nUlJnZ3NBQlFJRmdqWlNOWkkyZ2dzRUJRV0NHd1FGa2pXR1ZaaW1CRUxTeExVeU5MVVZwWUlFV0tZRVFiSVNGWkxTeExWRmdnUllwZ1JCc2hJVmt0TEV0VEkwdFJXbGc0R3lFaFdTMHNzQUFoUzFSWU9Cc2hJVmt0TExBQ1ExUllzRVlyR3lFaElTRlpMU3l3QWtOVVdMQkhLeHNoSVNGWkxTeXdBa05VV0xCSUt4c2hJU0VoV1Mwc3NBSkRWRml3U1NzYklTRWhXUzBzSUlvSUkwdFRpa3RSV2xnak9Cc2hJVmt0TEFDd0FpVkpzQUJUV0NDd1FEZ1JHeUZaTFN3QlJpTkdZQ05HWVNNZ0VDQkdpbUc0LzRCaWlyRkFRSXB3UldCb09pMHNJSW9qU1dTS0kxTllQQnNoV1Mwc1MxSllmUnQ2V1Mwc3NCSUFTd0ZMVkVJdExMRUNBRUt4SXdHSVViRkFBWWhUV2xpNUVBQUFJSWhVV0xJQ0FRSkRZRUpac1NRQmlGRll1U0FBQUVDSVZGaXlBZ0lDUTJCQ3NTUUJpRlJZc2dJZ0FrTmdRZ0JMQVV0U1dMSUNDQUpEWUVKWkc3bEFBQUNBaUZSWXNnSUVBa05nUWxtNVFBQUFnR080QVFDSVZGaXlBZ2dDUTJCQ1dibEFBQUVBWTdnQ0FJaFVXTElDRUFKRFlFSlpzU1lCaUZGWXVVQUFBZ0JqdUFRQWlGUllzZ0pBQWtOZ1FsbTVRQUFFQUdPNENBQ0lWRml5QW9BQ1EyQkNXVmxaV1ZsWnNRQUNRMVJZUUFvRlFBaEFDVUFNQWcwQ0c3RUJBa05VV0xJRlFBaTZBUUFBQ1FFQXN3d0JEUUVic1lBQ1ExSllzZ1ZBQ0xnQmdMRUpRQnV5QlVBSXVnR0FBQWtCUUZtNVFBQUFnSWhWdVVBQUFnQmp1QVFBaUZWYVdMTU1BQTBCRzdNTUFBMEJXVmxaUWtKQ1FrSXRMRVVZYUNOTFVWZ2pJRVVnWkxCQVVGaDhXV2lLWUZsRUxTeXdBQmF3QWlXd0FpVUJzQUVqUGdDd0FpTStzUUVDQmd5d0NpTmxRckFMSTBJQnNBRWpQd0N3QWlNL3NRRUNCZ3l3QmlObFFyQUhJMEt3QVJZQkxTeXdnTEFDUTFDd0FiQUNRMVJiV0NFakVMQWdHc2tiaWhEdFdTMHNzRmtyTFN5S0VPVXRRSmtKSVVnZ1ZTQUJIbFVmU0FOVkh4NEJEeDQvSHE4ZUEwMUxKaDlNU3pNZlMwWWxIeVkwRUZVbE15UlZHUlAvSHdjRS94OEdBLzhmU2trekgwbEdKUjhUTXhKVkJRRURWUVF6QTFVZkF3RVBBejhEcndNRFIwWVpIK3RHQVNNeklsVWNNeHRWRmpNVlZSRUJEMVVRTXc5VkR3OVBEd0lmRDg4UEFnOFAvdzhDQmdJQkFGVUJNd0JWYndCL0FLOEE3d0FFRUFBQmdCWUJCUUc0QVpDeFZGTXJLMHU0Qi85U1M3QUpVRnV3QVlpd0pWT3dBWWl3UUZGYXNBYUlzQUJWV2x0WXNRRUJqbG1GalkwQVFoMUxzREpUV0xBZ0hWbExzR1JUV0xBUUhiRVdBRUpaYzNNcksxNXpkSFVyS3lzckszUXJjM1FyS3lzckt5c3JLeXNyS3lzcmMzUXJLeXNZWGdBQUFBWVVBQmNBVGdXMkFCY0FkUVcyQmMwQUFBQUFBQUFBQUFBQUFBQUFBQVJJQUJRQWtRQUEvK3dBQUFBQS8rd0FBQUFBLyt3QUFQNFUvK3dBQUFXMkFCUDhsUC90L29YLzZ2NnAvK3dBR1A2OEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUNBQUFBQUFBQUlzQWdRRGRBSmdBandDT0FKa0FpQUNCQVE4QWlnQUFBQUFBRFFDaUFBTUFBUVFKQUFBQWNnQUFBQU1BQVFRSkFBRUFFZ0J5QUFNQUFRUUpBQUlBRGdDRUFBTUFBUVFKQUFNQU5BQ1NBQU1BQVFRSkFBUUFJZ0RHQUFNQUFRUUpBQVVBR0FEb0FBTUFBUVFKQUFZQUlBRUFBQU1BQVFRSkFBY0FwQUVnQUFNQUFRUUpBQWdBS0FIRUFBTUFBUVFKQUFzQU9BSHNBQU1BQVFRSkFBd0FYQUlrQUFNQUFRUUpBQTBBWEFLQUFBTUFBUVFKQUE0QVZBTGNBRVFBYVFCbkFHa0FkQUJwQUhvQVpRQmtBQ0FBWkFCaEFIUUFZUUFnQUdNQWJ3QndBSGtBY2dCcEFHY0FhQUIwQUNBQXFRQWdBRElBTUFBeEFEQUFMUUF5QURBQU1RQXhBQ3dBSUFCSEFHOEFid0JuQUd3QVpRQWdBRU1BYndCeUFIQUFid0J5QUdFQWRBQnBBRzhBYmdBdUFFOEFjQUJsQUc0QUlBQlRBR0VBYmdCekFGSUFaUUJuQUhVQWJBQmhBSElBTVFBdUFERUFNQUE3QURFQVFRQlRBRU1BT3dCUEFIQUFaUUJ1QUZNQVlRQnVBSE1BTFFCU0FHVUFad0IxQUd3QVlRQnlBRThBY0FCbEFHNEFJQUJUQUdFQWJnQnpBQ0FBVWdCbEFHY0FkUUJzQUdFQWNnQldBR1VBY2dCekFHa0Fid0J1QUNBQU1RQXVBREVBTUFCUEFIQUFaUUJ1QUZNQVlRQnVBSE1BTFFCU0FHVUFad0IxQUd3QVlRQnlBRThBY0FCbEFHNEFJQUJUQUdFQWJnQnpBQ0FBYVFCekFDQUFZUUFnQUhRQWNnQmhBR1FBWlFCdEFHRUFjZ0JyQUNBQWJ3Qm1BQ0FBUndCdkFHOEFad0JzQUdVQUlBQmhBRzRBWkFBZ0FHMEFZUUI1QUNBQVlnQmxBQ0FBY2dCbEFHY0FhUUJ6QUhRQVpRQnlBR1VBWkFBZ0FHa0FiZ0FnQUdNQVpRQnlBSFFBWVFCcEFHNEFJQUJxQUhVQWNnQnBBSE1BWkFCcEFHTUFkQUJwQUc4QWJnQnpBQzRBUVFCekFHTUFaUUJ1QUdRQVpRQnlBQ0FBUXdCdkFISUFjQUJ2QUhJQVlRQjBBR2tBYndCdUFHZ0FkQUIwQUhBQU9nQXZBQzhBZHdCM0FIY0FMZ0JoQUhNQVl3QmxBRzRBWkFCbEFISUFZd0J2QUhJQWNBQXVBR01BYndCdEFDOEFhQUIwQUhRQWNBQTZBQzhBTHdCM0FIY0Fkd0F1QUdFQWN3QmpBR1VBYmdCa0FHVUFjZ0JqQUc4QWNnQndBQzRBWXdCdkFHMEFMd0IwQUhrQWNBQmxBR1FBWlFCekFHa0Fad0J1QUdVQWNnQnpBQzRBYUFCMEFHMEFiQUJNQUdrQVl3QmxBRzRBY3dCbEFHUUFJQUIxQUc0QVpBQmxBSElBSUFCMEFHZ0FaUUFnQUVFQWNBQmhBR01BYUFCbEFDQUFUQUJwQUdNQVpRQnVBSE1BWlFBc0FDQUFWZ0JsQUhJQWN3QnBBRzhBYmdBZ0FESUFMZ0F3QUdnQWRBQjBBSEFBT2dBdkFDOEFkd0IzQUhjQUxnQmhBSEFBWVFCakFHZ0FaUUF1QUc4QWNnQm5BQzhBYkFCcEFHTUFaUUJ1QUhNQVpRQnpBQzhBVEFCSkFFTUFSUUJPQUZNQVJRQXRBRElBTGdBd0FBQUFBZ0FBQUFBQUFQOW1BR1lBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFPcUFBQUJBZ0FDQUFNQUJBQUZBQVlBQndBSUFBa0FDZ0FMQUF3QURRQU9BQThBRUFBUkFCSUFFd0FVQUJVQUZnQVhBQmdBR1FBYUFCc0FIQUFkQUI0QUh3QWdBQ0VBSWdBakFDUUFKUUFtQUNjQUtBQXBBQ29BS3dFREFDMEFMZ0F2QURBQU1RQXlBRE1BTkFBMUFEWUFOd0E0QURrQU9nQTdBRHdBUFFBK0FEOEFRQUJCQUVJQVF3QkVBRVVBUmdCSEFFZ0FTUUJLQUVzQVRBQk5BRTRBVHdCUUFGRUFVZ0JUQUZRQVZRQldBRmNBV0FCWkFGb0FXd0JjQUYwQVhnQmZBR0FBWVFDc0FLTUFoQUNGQUwwQWxnRG9BSVlBamdDTEFKMEFxUUNrQVFRQWlnRUZBSU1Ba3dEeUFQTUFqUUNYQUlnQXd3RGVBUEVBbmdDcUFQVUE5QUQyQUtJQXJRREpBTWNBcmdCaUFHTUFrQUJrQU1zQVpRRElBTW9CQmdFSEFRZ0JDUURwQUdZQTB3RFFBTkVBcndCbkFQQUFrUURXQU5RQTFRQm9BT3NBN1FDSkFHb0FhUUJyQUcwQWJBQnVBS0FBYndCeEFIQUFjZ0J6QUhVQWRBQjJBSGNBNmdCNEFIb0FlUUI3QUgwQWZBQzRBS0VBZndCK0FJQUFnUURzQU80QXVnRUtBUXNCREFFTkFRNEJEd0Q5QVA0QkVBRVJBUklCRXdEL0FRQUJGQUVWQVJZQkFRRVhBUmdCR1FFYUFSc0JIQUVkQVI0Qkh3RWdBU0VCSWdENEFQa0JJd0VrQVNVQkpnRW5BU2dCS1FFcUFTc0JMQUV0QVM0Qkx3RXdBVEVCTWdFekFOY0JOQUUxQVRZQk53RTRBVGtCT2dFN0FUd0JQUUUrQVQ4QlFBRkJBVUlBNGdEakFVTUJSQUZGQVVZQlJ3RklBVWtCU2dGTEFVd0JUUUZPQVU4QlVBRlJBTEFBc1FGU0FWTUJWQUZWQVZZQlZ3RllBVmtCV2dGYkFQc0EvQURrQU9VQlhBRmRBVjRCWHdGZ0FXRUJZZ0ZqQVdRQlpRRm1BV2NCYUFGcEFXb0Jhd0ZzQVcwQmJnRnZBWEFCY1FDN0FYSUJjd0YwQVhVQTVnRG5BWFlBcGdGM0FYZ0JlUUY2QVhzQmZBRjlBWDRBMkFEaEFOb0Eyd0RjQU4wQTRBRFpBTjhCZndHQUFZRUJnZ0dEQVlRQmhRR0dBWWNCaUFHSkFZb0Jpd0dNQVkwQmpnR1BBWkFCa1FHU0FaTUJsQUdWQVpZQmx3R1lBWmtCbWdHYkFad0JuUUdlQVo4Qm9BR2hBYUlCb3dHa0FhVUJwZ0duQWFnQnFRR3FBYXNCckFHdEFhNEJyd0d3QWJFQnNnR3pBYlFCdFFHMkFiY0Ftd0c0QWJrQnVnRzdBYndCdlFHK0FiOEJ3QUhCQWNJQnd3SEVBY1VCeGdISEFjZ0J5UUhLQWNzQnpBSE5BYzRCendIUUFkRUIwZ0hUQWRRQjFRSFdBZGNCMkFIWkFkb0Iyd0hjQWQwQjNnSGZBZUFCNFFIaUFlTUI1QUhsQWVZQjV3SG9BZWtCNmdIckFld0I3UUh1QWU4QjhBSHhBZklCOHdIMEFmVUI5Z0gzQWZnQitRSDZBZnNCL0FIOUFmNEIvd0lBQWdFQ0FnSURBZ1FDQlFJR0FnY0NDQUlKQWdvQ0N3SU1BZzBDRGdJUEFoQUNFUUlTQWhNQ0ZBSVZBaFlDRndJWUFoa0NHZ0liQWh3Q0hRSWVBaDhDSUFJaEFpSUNJd0lrQWlVQ0pnSW5BaWdDS1FJcUFpc0FzZ0N6QWl3Q0xRQzJBTGNBeEFJdUFMUUF0UURGQUlJQXdnQ0hBS3NBeGdJdkFqQUF2Z0MvQWpFQXZBSXlBUGNDTXdJMEFqVUNOZ0kzQWpnQWpBQ2ZBamtDT2dJN0Fqd0NQUUNZQUtnQW1nQ1pBTzhBcFFDU0FKd0Fwd0NQQUpRQWxRQzVBajRDUHdKQUFrRUNRZ0pEQWtRQ1JRSkdBa2NDU0FKSkFrb0NTd0pNQWswQ1RnSlBBbEFDVVFKU0FsTUNWQUpWQWxZQ1Z3SllBbGtDV2dKYkFsd0NYUUplQWw4Q1lBSmhBbUlDWXdKa0FtVUNaZ0puQW1nQ2FRSnFBbXNDYkFKdEFtNENid0p3QW5FQ2NnSnpBblFDZFFKMkFuY0NlQUo1QW5vQ2V3SjhBbjBDZmdKL0FvQUNnUUtDQW9NQ2hBS0ZBb1lDaHdLSUFva0NpZ0tMQW93Q2pRS09BbzhDa0FLUkFwSUNrd0tVQXBVQ2xnS1hBcGdDbVFLYUFwc0NuQUtkQXA0Q253S2dBcUVDb2dLakFxUUNwUUttQXFjQ3FBS3BBcW9DcXdLc0FxMENyZ0t2QXJBQ3NRS3lBck1DdEFLMUFyWUN0d0s0QXJrQ3VnSzdBcndDdlFLK0FyOEN3QUxCQXNJQ3d3TEVBc1VDeGdMSEFzZ0N5UUxLQXNzQ3pBTE5BczRDendMUUF0RUMwZ0xUQXRRQzFRTFdBdGNDMkFMWkF0b0Myd0xjQXQwQzNnTGZBdUFDNFFMaUF1TUM1QUxsQXVZQzV3TG9BdWtDNmdMckF1d0M3UUx1QXU4QzhBTHhBdklDOHdMMEF2VUM5Z0wzQXZnQytRTDZBdnNDL0FMOUF2NEMvd01BQXdFREFnTURBd1FEQlFNR0F3Y0RDQU1KQXdvREN3TU1BdzBERGdNUEF4QURFUU1TQXhNREZBTVZBeFlERndNWUF4a0RHZ01iQXh3REhRTWVBeDhESUFNaEF5SURJd01rQXlVREpnTW5BeWdES1FNcUF5c0RMQU10QXk0REx3TXdBekVETWdNekF6UUROUU0yQXpjRE9BTTVBem9ET3dNOEF6MERQZ00vQTBBRFFRTkNBME1EUkFORkEwWURSd05JQTBrRFNnTkxBMHdEVFFOT0EwOERVQU5SQTFJRFV3TlVBMVVEVmdOWEExZ0RXUU5hQTFzRFhBTmRBMTREWHdOZ0EyRURZZ05qQTJRRFpRTm1BMmNEYUFOcEEyb0Rhd05zQTIwRGJnTnZBM0FEY1FOeUEzTURkQU4xQTNZRGR3TjRBM2tEZWdON0Ezd0RmUU4rQTM4RGdBT0JBNElEZ3dPRUE0VURoZ09IQTRnRGlRT0tBNHNEakFPTkE0NERqd09RQTVFRGtnT1RBNVFEbFFPV0E1Y0RtQU9aQTVvRG13T2NBNTBEbmdPZkFDd0F6d0RNQU0wQXpnT2dBNkVEb2dPakFQb0RwQU9sQTZZRHB3T29BNmtEcWdPckE2d0RyUVJ1ZFd4c0JVa3VZV3gwQjNWdWFUQXdRVVFKYjNabGNuTmpiM0psQ2tsbmNtRjJaUzVoYkhRS1NXRmpkWFJsTG1Gc2RBOUpZMmx5WTNWdFpteGxlQzVoYkhRTlNXUnBaWEpsYzJsekxtRnNkQWRCYldGamNtOXVCMkZ0WVdOeWIyNEdRV0p5WlhabEJtRmljbVYyWlFkQmIyZHZibVZyQjJGdloyOXVaV3NMUTJOcGNtTjFiV1pzWlhnTFkyTnBjbU4xYldac1pYZ0VRMlJ2ZEFSalpHOTBCa1JqWVhKdmJnWmtZMkZ5YjI0R1JHTnliMkYwQjBWdFlXTnliMjRIWlcxaFkzSnZiZ1pGWW5KbGRtVUdaV0p5WlhabENrVmtiM1JoWTJObGJuUUtaV1J2ZEdGalkyVnVkQWRGYjJkdmJtVnJCMlZ2WjI5dVpXc0dSV05oY205dUJtVmpZWEp2Ymd0SFkybHlZM1Z0Wm14bGVBdG5ZMmx5WTNWdFpteGxlQVJIWkc5MEJHZGtiM1FNUjJOdmJXMWhZV05qWlc1MERHZGpiMjF0WVdGalkyVnVkQXRJWTJseVkzVnRabXhsZUF0b1kybHlZM1Z0Wm14bGVBUklZbUZ5QkdoaVlYSUtTWFJwYkdSbExtRnNkQVpwZEdsc1pHVUxTVzFoWTNKdmJpNWhiSFFIYVcxaFkzSnZiZ3BKWW5KbGRtVXVZV3gwQm1saWNtVjJaUXRKYjJkdmJtVnJMbUZzZEFkcGIyZHZibVZyRGtsa2IzUmhZMk5sYm5RdVlXeDBCa2xLTG1Gc2RBSnBhZ3RLWTJseVkzVnRabXhsZUF0cVkybHlZM1Z0Wm14bGVBeExZMjl0YldGaFkyTmxiblFNYTJOdmJXMWhZV05qWlc1MERHdG5jbVZsYm14aGJtUnBZd1pNWVdOMWRHVUdiR0ZqZFhSbERFeGpiMjF0WVdGalkyVnVkQXhzWTI5dGJXRmhZMk5sYm5RR1RHTmhjbTl1Qm14allYSnZiZ1JNWkc5MEJHeGtiM1FHVG1GamRYUmxCbTVoWTNWMFpReE9ZMjl0YldGaFkyTmxiblFNYm1OdmJXMWhZV05qWlc1MEJrNWpZWEp2YmdadVkyRnliMjRMYm1Gd2IzTjBjbTl3YUdVRFJXNW5BMlZ1WndkUGJXRmpjbTl1QjI5dFlXTnliMjRHVDJKeVpYWmxCbTlpY21WMlpRMVBhSFZ1WjJGeWRXMXNZWFYwRFc5b2RXNW5ZWEoxYld4aGRYUUdVbUZqZFhSbEJuSmhZM1YwWlF4U1kyOXRiV0ZoWTJObGJuUU1jbU52YlcxaFlXTmpaVzUwQmxKallYSnZiZ1p5WTJGeWIyNEdVMkZqZFhSbEJuTmhZM1YwWlF0VFkybHlZM1Z0Wm14bGVBdHpZMmx5WTNWdFpteGxlQXhVWTI5dGJXRmhZMk5sYm5RTWRHTnZiVzFoWVdOalpXNTBCbFJqWVhKdmJnWjBZMkZ5YjI0RVZHSmhjZ1IwWW1GeUJsVjBhV3hrWlFaMWRHbHNaR1VIVlcxaFkzSnZiZ2QxYldGamNtOXVCbFZpY21WMlpRWjFZbkpsZG1VRlZYSnBibWNGZFhKcGJtY05WV2gxYm1kaGNuVnRiR0YxZEExMWFIVnVaMkZ5ZFcxc1lYVjBCMVZ2WjI5dVpXc0hkVzluYjI1bGF3dFhZMmx5WTNWdFpteGxlQXQzWTJseVkzVnRabXhsZUF0WlkybHlZM1Z0Wm14bGVBdDVZMmx5WTNWdFpteGxlQVphWVdOMWRHVUdlbUZqZFhSbENscGtiM1JoWTJObGJuUUtlbVJ2ZEdGalkyVnVkQVZzYjI1bmN3cEJjbWx1WjJGamRYUmxDbUZ5YVc1bllXTjFkR1VIUVVWaFkzVjBaUWRoWldGamRYUmxDMDl6YkdGemFHRmpkWFJsQzI5emJHRnphR0ZqZFhSbERGTmpiMjF0WVdGalkyVnVkQXh6WTI5dGJXRmhZMk5sYm5RRmRHOXViM01OWkdsbGNtVnphWE4wYjI1dmN3cEJiSEJvWVhSdmJtOXpDV0Z1YjNSbGJHVnBZUXhGY0hOcGJHOXVkRzl1YjNNSVJYUmhkRzl1YjNNTlNXOTBZWFJ2Ym05ekxtRnNkQXhQYldsamNtOXVkRzl1YjNNTVZYQnphV3h2Ym5SdmJtOXpDazl0WldkaGRHOXViM01SYVc5MFlXUnBaWEpsYzJsemRHOXViM01GUVd4d2FHRUVRbVYwWVFWSFlXMXRZUWQxYm1rd016azBCMFZ3YzJsc2IyNEVXbVYwWVFORmRHRUZWR2hsZEdFSVNXOTBZUzVoYkhRRlMyRndjR0VHVEdGdFltUmhBazExQWs1MUFsaHBCMDl0YVdOeWIyNENVR2tEVW1odkJWTnBaMjFoQTFSaGRRZFZjSE5wYkc5dUExQm9hUU5EYUdrRFVITnBCM1Z1YVRBelFUa1FTVzkwWVdScFpYSmxjMmx6TG1Gc2RBOVZjSE5wYkc5dVpHbGxjbVZ6YVhNS1lXeHdhR0YwYjI1dmN3eGxjSE5wYkc5dWRHOXViM01JWlhSaGRHOXViM01KYVc5MFlYUnZibTl6RkhWd2MybHNiMjVrYVdWeVpYTnBjM1J2Ym05ekJXRnNjR2hoQkdKbGRHRUZaMkZ0YldFRlpHVnNkR0VIWlhCemFXeHZiZ1I2WlhSaEEyVjBZUVYwYUdWMFlRUnBiM1JoQld0aGNIQmhCbXhoYldKa1lRZDFibWt3TTBKREFtNTFBbmhwQjI5dGFXTnliMjREY21odkJuTnBaMjFoTVFWemFXZHRZUU4wWVhVSGRYQnphV3h2YmdOd2FHa0RZMmhwQTNCemFRVnZiV1ZuWVF4cGIzUmhaR2xsY21WemFYTVBkWEJ6YVd4dmJtUnBaWEpsYzJsekRHOXRhV055YjI1MGIyNXZjd3gxY0hOcGJHOXVkRzl1YjNNS2IyMWxaMkYwYjI1dmN3bGhabWxwTVRBd01qTUpZV1pwYVRFd01EVXhDV0ZtYVdreE1EQTFNZ2xoWm1scE1UQXdOVE1KWVdacGFURXdNRFUwRFdGbWFXa3hNREExTlM1aGJIUU5ZV1pwYVRFd01EVTJMbUZzZEFsaFptbHBNVEF3TlRjSllXWnBhVEV3TURVNENXRm1hV2t4TURBMU9RbGhabWxwTVRBd05qQUpZV1pwYVRFd01EWXhDV0ZtYVdreE1EQTJNZ2xoWm1scE1UQXhORFVKWVdacGFURXdNREUzQ1dGbWFXa3hNREF4T0FsaFptbHBNVEF3TVRrSllXWnBhVEV3TURJd0NXRm1hV2t4TURBeU1RbGhabWxwTVRBd01qSUpZV1pwYVRFd01ESTBDV0ZtYVdreE1EQXlOUWxoWm1scE1UQXdNallKWVdacGFURXdNREkzQ1dGbWFXa3hNREF5T0FsaFptbHBNVEF3TWprSllXWnBhVEV3TURNd0NXRm1hV2t4TURBek1RbGhabWxwTVRBd016SUpZV1pwYVRFd01ETXpDV0ZtYVdreE1EQXpOQWxoWm1scE1UQXdNelVKWVdacGFURXdNRE0yQ1dGbWFXa3hNREF6TndsaFptbHBNVEF3TXpnSllXWnBhVEV3TURNNUNXRm1hV2t4TURBME1BbGhabWxwTVRBd05ERUpZV1pwYVRFd01EUXlDV0ZtYVdreE1EQTBNd2xoWm1scE1UQXdORFFKWVdacGFURXdNRFExQ1dGbWFXa3hNREEwTmdsaFptbHBNVEF3TkRjSllXWnBhVEV3TURRNENXRm1hV2t4TURBME9RbGhabWxwTVRBd05qVUpZV1pwYVRFd01EWTJDV0ZtYVdreE1EQTJOd2xoWm1scE1UQXdOamdKWVdacGFURXdNRFk1Q1dGbWFXa3hNREEzTUFsaFptbHBNVEF3TnpJSllXWnBhVEV3TURjekNXRm1hV2t4TURBM05BbGhabWxwTVRBd056VUpZV1pwYVRFd01EYzJDV0ZtYVdreE1EQTNOd2xoWm1scE1UQXdOemdKWVdacGFURXdNRGM1Q1dGbWFXa3hNREE0TUFsaFptbHBNVEF3T0RFSllXWnBhVEV3TURneUNXRm1hV2t4TURBNE13bGhabWxwTVRBd09EUUpZV1pwYVRFd01EZzFDV0ZtYVdreE1EQTROZ2xoWm1scE1UQXdPRGNKWVdacGFURXdNRGc0Q1dGbWFXa3hNREE0T1FsaFptbHBNVEF3T1RBSllXWnBhVEV3TURreENXRm1hV2t4TURBNU1nbGhabWxwTVRBd09UTUpZV1pwYVRFd01EazBDV0ZtYVdreE1EQTVOUWxoWm1scE1UQXdPVFlKWVdacGFURXdNRGszQ1dGbWFXa3hNREEzTVFsaFptbHBNVEF3T1RrSllXWnBhVEV3TVRBd0NXRm1hV2t4TURFd01RbGhabWxwTVRBeE1ESUpZV1pwYVRFd01UQXpDV0ZtYVdreE1ERXdOQWxoWm1scE1UQXhNRFVKWVdacGFURXdNVEEyQ1dGbWFXa3hNREV3TndsaFptbHBNVEF4TURnSllXWnBhVEV3TVRBNUNXRm1hV2t4TURFeE1BbGhabWxwTVRBeE9UTUpZV1pwYVRFd01EVXdDV0ZtYVdreE1EQTVPQVpYWjNKaGRtVUdkMmR5WVhabEJsZGhZM1YwWlFaM1lXTjFkR1VKVjJScFpYSmxjMmx6Q1hka2FXVnlaWE5wY3daWlozSmhkbVVHZVdkeVlYWmxDV0ZtYVdrd01ESXdPQTExYm1SbGNuTmpiM0psWkdKc0RYRjFiM1JsY21WMlpYSnpaV1FHYldsdWRYUmxCbk5sWTI5dVpBbGxlR05zWVcxa1ltd0pibk4xY0dWeWFXOXlDV0ZtYVdrd09EazBNUVp3WlhObGRHRUVSWFZ5YndsaFptbHBOakV5TkRnSllXWnBhVFl4TWpnNUNXRm1hV2syTVRNMU1nbGxjM1JwYldGMFpXUUpiMjVsWldsbmFIUm9ESFJvY21WbFpXbG5hSFJvY3d0bWFYWmxaV2xuYUhSb2N3eHpaWFpsYm1WcFoyaDBhSE1IZFc1cFJrSXdNUWQxYm1sR1FqQXlEV041Y21sc2JHbGpZbkpsZG1VSVpHOTBiR1Z6YzJvUVkyRnliMjVqYjIxdFlXRmpZMlZ1ZEF0amIyMXRZV0ZqWTJWdWRCRmpiMjF0WVdGalkyVnVkSEp2ZEdGMFpReDZaWEp2YzNWd1pYSnBiM0lNWm05MWNuTjFjR1Z5YVc5eURHWnBkbVZ6ZFhCbGNtbHZjZ3R6YVhoemRYQmxjbWx2Y2cxelpYWmxibk4xY0dWeWFXOXlEV1ZwWjJoMGMzVndaWEpwYjNJTWJtbHVaWE4xY0dWeWFXOXlCM1Z1YVRJd01EQUhkVzVwTWpBd01RZDFibWt5TURBeUIzVnVhVEl3TURNSGRXNXBNakF3TkFkMWJta3lNREExQjNWdWFUSXdNRFlIZFc1cE1qQXdOd2QxYm1reU1EQTRCM1Z1YVRJd01Ea0hkVzVwTWpBd1FRZDFibWt5TURCQ0IzVnVhVVpGUmtZSGRXNXBSa1pHUXdkMWJtbEdSa1pFQjNWdWFUQXhSakFIZFc1cE1ESkNRd2QxYm1rd00wUXhCM1Z1YVRBelJESUhkVzVwTURORU5nZDFibWt4UlRORkIzVnVhVEZGTTBZSGRXNXBNVVV3TUFkMWJta3hSVEF4QjNWdWFURkdORVFIZFc1cE1ESkdNd2xrWVhOcFlXOTRhV0VIZFc1cFJrSXdNd2QxYm1sR1FqQTBCVTlvYjNKdUJXOW9iM0p1QlZWb2IzSnVCWFZvYjNKdUIzVnVhVEF6TURBSGRXNXBNRE13TVFkMWJta3dNekF6QkdodmIyc0laRzkwWW1Wc2IzY0hkVzVwTURRd01BZDFibWt3TkRCRUIzVnVhVEEwTlRBSGRXNXBNRFExUkFkMWJta3dORFl3QjNWdWFUQTBOakVIZFc1cE1EUTJNZ2QxYm1rd05EWXpCM1Z1YVRBME5qUUhkVzVwTURRMk5RZDFibWt3TkRZMkIzVnVhVEEwTmpjSGRXNXBNRFEyT0FkMWJta3dORFk1QjNWdWFUQTBOa0VIZFc1cE1EUTJRZ2QxYm1rd05EWkRCM1Z1YVRBME5rUUhkVzVwTURRMlJRZDFibWt3TkRaR0IzVnVhVEEwTnpBSGRXNXBNRFEzTVFkMWJta3dORGN5QjNWdWFUQTBOek1IZFc1cE1EUTNOQWQxYm1rd05EYzFCM1Z1YVRBME56WUhkVzVwTURRM053ZDFibWt3TkRjNEIzVnVhVEEwTnprSGRXNXBNRFEzUVFkMWJta3dORGRDQjNWdWFUQTBOME1IZFc1cE1EUTNSQWQxYm1rd05EZEZCM1Z1YVRBME4wWUhkVzVwTURRNE1BZDFibWt3TkRneEIzVnVhVEEwT0RJSGRXNXBNRFE0TXdkMWJta3dORGcwQjNWdWFUQTBPRFVIZFc1cE1EUTROZ2QxYm1rd05EZzRCM1Z1YVRBME9Ea0hkVzVwTURRNFFRZDFibWt3TkRoQ0IzVnVhVEEwT0VNSGRXNXBNRFE0UkFkMWJta3dORGhGQjNWdWFUQTBPRVlIZFc1cE1EUTVNZ2QxYm1rd05Ea3pCM1Z1YVRBME9UUUhkVzVwTURRNU5RZDFibWt3TkRrMkIzVnVhVEEwT1RjSGRXNXBNRFE1T0FkMWJta3dORGs1QjNWdWFUQTBPVUVIZFc1cE1EUTVRZ2QxYm1rd05EbERCM1Z1YVRBME9VUUhkVzVwTURRNVJRZDFibWt3TkRsR0IzVnVhVEEwUVRBSGRXNXBNRFJCTVFkMWJta3dORUV5QjNWdWFUQTBRVE1IZFc1cE1EUkJOQWQxYm1rd05FRTFCM1Z1YVRBMFFUWUhkVzVwTURSQk53ZDFibWt3TkVFNEIzVnVhVEEwUVRrSGRXNXBNRFJCUVFkMWJta3dORUZDQjNWdWFUQTBRVU1IZFc1cE1EUkJSQWQxYm1rd05FRkZCM1Z1YVRBMFFVWUhkVzVwTURSQ01BZDFibWt3TkVJeEIzVnVhVEEwUWpJSGRXNXBNRFJDTXdkMWJta3dORUkwQjNWdWFUQTBRalVIZFc1cE1EUkNOZ2QxYm1rd05FSTNCM1Z1YVRBMFFqZ0hkVzVwTURSQ09RZDFibWt3TkVKQkIzVnVhVEEwUWtJSGRXNXBNRFJDUXdkMWJta3dORUpFQjNWdWFUQTBRa1VIZFc1cE1EUkNSZ3QxYm1rd05FTXdMbUZzZEFkMWJta3dORU14QjNWdWFUQTBReklIZFc1cE1EUkRNd2QxYm1rd05FTTBCM1Z1YVRBMFF6VUhkVzVwTURSRE5nZDFibWt3TkVNM0IzVnVhVEEwUXpnSGRXNXBNRFJET1FkMWJta3dORU5CQjNWdWFUQTBRMElIZFc1cE1EUkRRd2QxYm1rd05FTkVCM1Z1YVRBMFEwVUxkVzVwTURSRFJpNWhiSFFIZFc1cE1EUkVNQWQxYm1rd05FUXhCM1Z1YVRBMFJESUhkVzVwTURSRU13ZDFibWt3TkVRMEIzVnVhVEEwUkRVSGRXNXBNRFJFTmdkMWJta3dORVEzQjNWdWFUQTBSRGdIZFc1cE1EUkVPUWQxYm1rd05FUkJCM1Z1YVRBMFJFSUhkVzVwTURSRVF3ZDFibWt3TkVSRUIzVnVhVEEwUkVVSGRXNXBNRFJFUmdkMWJta3dORVV3QjNWdWFUQTBSVEVIZFc1cE1EUkZNZ2QxYm1rd05FVXpCM1Z1YVRBMFJUUUhkVzVwTURSRk5RZDFibWt3TkVVMkIzVnVhVEEwUlRjSGRXNXBNRFJGT0FkMWJta3dORVU1QjNWdWFUQTBSVUVIZFc1cE1EUkZRZ2QxYm1rd05FVkRCM1Z1YVRBMFJVUUhkVzVwTURSRlJRZDFibWt3TkVWR0IzVnVhVEEwUmpBSGRXNXBNRFJHTVFkMWJta3dORVl5QjNWdWFUQTBSak1IZFc1cE1EUkdOQWQxYm1rd05FWTFCM1Z1YVRBMFJqWUhkVzVwTURSR053ZDFibWt3TkVZNEIzVnVhVEEwUmprSGRXNXBNRFJHUVFkMWJta3dORVpDQjNWdWFUQTBSa01IZFc1cE1EUkdSQWQxYm1rd05FWkZCM1Z1YVRBMFJrWUhkVzVwTURVd01BZDFibWt3TlRBeEIzVnVhVEExTURJSGRXNXBNRFV3TXdkMWJta3dOVEEwQjNWdWFUQTFNRFVIZFc1cE1EVXdOZ2QxYm1rd05UQTNCM1Z1YVRBMU1EZ0hkVzVwTURVd09RZDFibWt3TlRCQkIzVnVhVEExTUVJSGRXNXBNRFV3UXdkMWJta3dOVEJFQjNWdWFUQTFNRVVIZFc1cE1EVXdSZ2QxYm1rd05URXdCM1Z1YVRBMU1URUhkVzVwTURVeE1nZDFibWt3TlRFekIzVnVhVEZGUVRBSGRXNXBNVVZCTVFkMWJta3hSVUV5QjNWdWFURkZRVE1IZFc1cE1VVkJOQWQxYm1reFJVRTFCM1Z1YVRGRlFUWUhkVzVwTVVWQk53ZDFibWt4UlVFNEIzVnVhVEZGUVRrSGRXNXBNVVZCUVFkMWJta3hSVUZDQjNWdWFURkZRVU1IZFc1cE1VVkJSQWQxYm1reFJVRkZCM1Z1YVRGRlFVWUhkVzVwTVVWQ01BZDFibWt4UlVJeEIzVnVhVEZGUWpJSGRXNXBNVVZDTXdkMWJta3hSVUkwQjNWdWFURkZRalVIZFc1cE1VVkNOZ2QxYm1reFJVSTNCM1Z1YVRGRlFqZ0hkVzVwTVVWQ09RZDFibWt4UlVKQkIzVnVhVEZGUWtJSGRXNXBNVVZDUXdkMWJta3hSVUpFQjNWdWFURkZRa1VIZFc1cE1VVkNSZ2QxYm1reFJVTXdCM1Z1YVRGRlF6RUhkVzVwTVVWRE1nZDFibWt4UlVNekIzVnVhVEZGUXpRSGRXNXBNVVZETlFkMWJta3hSVU0yQjNWdWFURkZRemNMZFc1cE1VVkRPQzVoYkhRSGRXNXBNVVZET1F0MWJta3hSVU5CTG1Gc2RBZDFibWt4UlVOQ0IzVnVhVEZGUTBNSGRXNXBNVVZEUkFkMWJta3hSVU5GQjNWdWFURkZRMFlIZFc1cE1VVkVNQWQxYm1reFJVUXhCM1Z1YVRGRlJESUhkVzVwTVVWRU13ZDFibWt4UlVRMEIzVnVhVEZGUkRVSGRXNXBNVVZFTmdkMWJta3hSVVEzQjNWdWFURkZSRGdIZFc1cE1VVkVPUWQxYm1reFJVUkJCM1Z1YVRGRlJFSUhkVzVwTVVWRVF3ZDFibWt4UlVSRUIzVnVhVEZGUkVVSGRXNXBNVVZFUmdkMWJta3hSVVV3QjNWdWFURkZSVEVIZFc1cE1VVkZNZ2QxYm1reFJVVXpCM1Z1YVRGRlJUUUhkVzVwTVVWRk5RZDFibWt4UlVVMkIzVnVhVEZGUlRjSGRXNXBNVVZGT0FkMWJta3hSVVU1QjNWdWFURkZSVUVIZFc1cE1VVkZRZ2QxYm1reFJVVkRCM1Z1YVRGRlJVUUhkVzVwTVVWRlJRZDFibWt4UlVWR0IzVnVhVEZGUmpBSGRXNXBNVVZHTVFkMWJta3hSVVkwQjNWdWFURkZSalVIZFc1cE1VVkdOZ2QxYm1reFJVWTNCM1Z1YVRGRlJqZ0hkVzVwTVVWR09RZDFibWt5TUVGQ0IzVnVhVEF6TUVZVFkybHlZM1Z0Wm14bGVHRmpkWFJsWTI5dFloTmphWEpqZFcxbWJHVjRaM0poZG1WamIyMWlFbU5wY21OMWJXWnNaWGhvYjI5clkyOXRZaE5qYVhKamRXMW1iR1Y0ZEdsc1pHVmpiMjFpRG1KeVpYWmxZV04xZEdWamIyMWlEbUp5WlhabFozSmhkbVZqYjIxaURXSnlaWFpsYUc5dmEyTnZiV0lPWW5KbGRtVjBhV3hrWldOdmJXSVFZM2x5YVd4c2FXTm9iMjlyYkdWbWRCRmplWEpwYkd4cFkySnBaMmh2YjJ0VlF4RmplWEpwYkd4cFkySnBaMmh2YjJ0TVF3aHZibVV1Y0c1MWJRZDZaWEp2TG05ekJtOXVaUzV2Y3daMGQyOHViM01JZEdoeVpXVXViM01IWm05MWNpNXZjd2RtYVhabExtOXpCbk5wZUM1dmN3aHpaWFpsYmk1dmN3aGxhV2RvZEM1dmN3ZHVhVzVsTG05ekFtWm1CM1Z1YVRJeE1qQUlWR05sWkdsc2JHRUlkR05sWkdsc2JHRUZaeTVoYkhRUFoyTnBjbU4xYldac1pYZ3VZV3gwQ21kaWNtVjJaUzVoYkhRSVoyUnZkQzVoYkhRUVoyTnZiVzFoWVdOalpXNTBMbUZzZEFaSmRHbHNaR1VIU1cxaFkzSnZiZ1pKWW5KbGRtVUhTVzluYjI1bGF3SkpTZ2xKYjNSaGRHOXViM01FU1c5MFlReEpiM1JoWkdsbGNtVnphWE1KWVdacGFURXdNRFUxQ1dGbWFXa3hNREExTmdkMWJta3dORU13QjNWdWFUQTBRMFlIZFc1cE1VVkRPQWQxYm1reFJVTkJBQUFCQUFNQUNBQUtBQTBBQi8vL0FBOEFBUUFBQUF3QUFBQUFBQUFBQWdBRkFBQUNOUUFCQWpjQ053QUJBanNDV3dBQkFsMERkZ0FCQTRJRHFRQUJBQUFBQVFBQUFBb0FEQUFPQUFBQUFBQUFBQUVBQUFBS0FHNEJXZ0FCYkdGMGJnQUlBQkFBQWsxUFRDQUFLRkpQVFNBQVFnQUEvLzhBQ1FBREFBZ0FDd0FBQUE0QUVRQVVBQmNBR2dBQS8vOEFDZ0FFQUFZQUNRQU1BQUVBRHdBU0FCVUFHQUFiQUFELy93QUtBQVVBQndBS0FBMEFBZ0FRQUJNQUZnQVpBQndBSFd4cFoyRUFzR3hwWjJFQXNHeHBaMkVBc0d4dWRXMEF0bXh1ZFcwQXRteHVkVzBBdG14dlkyd0F2R3h2WTJ3QXZHOXVkVzBBd205dWRXMEF3bTl1ZFcwQXduQnVkVzBBeW5CdWRXMEF5bkJ1ZFcwQXluTmhiSFFBMEhOaGJIUUEwSE5oYkhRQTBITnpNREVBMEhOek1ERUEwSE56TURFQTBITnpNRElBMkhOek1ESUEySE56TURJQTJITnpNRE1BM25Oek1ETUEzbk56TURNQTNuUnVkVzBBNUhSdWRXMEE1SFJ1ZFcwQTVBQUFBQUVBQ1FBQUFBRUFCd0FBQUFFQUNBQUFBQUlBQWdBREFBQUFBUUFFQUFBQUFnQUFBQUVBQUFBQkFBQUFBQUFCQUFFQUFBQUNBQVVBQmdBS0FCWUFQQUI4QUpRQXpBRGdBTzRCQWdFdUFWQUFBUUFBQUFFQUNBQUNBQkFBQlFPUkE1SURrd09VQTVVQUFRQUZBRW9BM3dEaEFPTUE1UUFCQUFBQUFRQUlBQUlBTGdBVUFDd0FqZ0NQQUpBQWtRRHFBT3dBN2dEd0FQSUE5QUZhQVdjQmR3R2hBYUlDeVFMWUEwVURSd0FDQUFFRGxnT3BBQUFBQVFBQUFBRUFDQUFCQUFZRGNBQUNBQUVBRXdBY0FBQUFBUUFBQUFFQUNBQUNBQm9BQ2dPREE0VURoZ09IQTRnRGlRT0tBNHNEakFPRUFBSUFBd0FUQUJNQUFBQVZBQndBQVFPQ0E0SUFDUUFCQUFBQUFRQUlBQUVBQmdOdUFBRUFBUUFVQUFFQUFBQUJBQWdBQVFBOC9KQUFBUUFBQUFFQUNBQUJBQWI4a2dBQkFBRURnZ0FCQUFBQUFRQUlBQUlBR2dBS0FCTURnZ0FWQUJZQUZ3QVlBQmtBR2dBYkFCd0FBZ0FCQTRNRGpBQUFBQUVBQUFBQkFBZ0FBZ0FPQUFRRGp3T1FBU0FCSVFBQkFBUUJKQUVsQVVrQlNnQUVBQUFBQVFBSUFBRUFOZ0FCQUFnQUJRQU1BQlFBSEFBaUFDZ0NYZ0FEQUVrQVR3SmRBQU1BU1FCTUE0MEFBZ0JKQWpVQUFnQlBBalFBQWdCTUFBRUFBUUJKQUFBPVwiIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__["default"] = ("data:font/ttf;base64,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ApsAQwKbAEMCmwBDApsAQwKbAEMCmwBDApsAQwKbAEMCmwBDApsAQwKbAEMCmwBDApsAQwJjAEMCY//kAwoAKgMKACoDCgAqAwoAKgMKACoDCgAqAwoAKgLSAEMC0gAHAtIAQwLSAEMBFgBDA0IAQwEWAEMBFv/qARb/5QEW/+UBFv+dARb/5wEWAEMBFgBDARYABQEWADkBFv/rARb/8wEWACwBFv/vAiwAGQNCAEMCLAAZAtIAQwLSAEMCYwBDBI8AQwJjAEMCYwBDAmMAQwJjAEMDeQBDAmMAAANBAEMC0gBDBP4AQwLSAEMC0gBDAtIAQwLSAEMC0gBDAtL/5APoAEMC0gBDAwoAKgMKACoDCgAqAwoAKgMKACoDCgAqAwoAKgMKACoDCgAqAwoAKgMKACoDCgAqAwoAKgMKACoDCgAqAwoAKgMKACoDCgAqAwoAKgMKACoDCgAqAwoAKgMKACoDCgAqAwoAKgMKACoDCgAqAwoAKgMKACoDCgAqAwoAKgPoACoCmwBDApsAQwMKACoC0gBDAtIAQwLSAEMC0gBDAtIAQwLSAEMC0gBDApsAKgKbACoA3wAxApsAKgKbACoCmwAqApsAKgKbACoDHgBDAu8AKgJjABUCYwAVAmMAFQJjABUCYwAVAmMAFQLSAEMC0gBDAtIAQwLSAEMC0gBDAtIAQwLSAEMC0gBDAtIAQwLSAEMC0gBDAtIAQwLSAEMC0gBDAtIAQwLSAEMC0gBDAtIAQwLSAEMC0gBDAtIAQwLSAEMC0gBDAtIAQwLSAEMC0gBDApsABAOwAAIDsAACA7AAAgOwAAIDsAACApsAAAKbAAACmwAAApsAAAKbAAACmwAAApsAAAKbAAACmwAAApsAAAJjABECYwARAmMAEQJjABECYwARApsAQwKbAEMCmwBDApsAQwKbAEMCmwBDApsAQwLSACoC0gBDAwoAKgKbACoCYwARAiwAHQIsAB0CLAAdAiwAHQIsAB0CLAAdAiwAHQIsAB0CLAAdAiwAHQIsAB0CLAAdAiwAHQIsAB0CLAAdAiwAGgIsAB0CLAAdAiwAHQIsAB0CLAAdAiwAHQIsAB0CLAAdAiwAHQIsAB0DeQAdA3kAHQJjAEcCLAAmAiwAJgIsACYCLAAmAiwAJgIsACYCYwAlAmMAJgJjACUCYwAlAmMAJQRXACUEVwAlAiwAJAIsACQCLAAkAiwAJAIsACQCLAAkAiwAJAIsACQCLAAkAiwAJAIsACECLAAkAiwAJAIsACQCLAAkAiwAJAIsACQCLAAkAiwAJAIsACQCLAAjAU0ACQJjABgCYwAYAmMAGAJjABgCYwAYAmMAGAJjABgCYwBHAmMAAAJj/+UCYwBHARYARgEWAEYBFgBGARb/5wEW/+IBFv/iARb/kAEW/+QBFgBEARYARgEW//0BFgA2ARb/6AIsAEYBFv/wARYAKQEW/+IBFv/oARb/6AIsAEYBFv/gAiwARwIsAEcCLABHARYARwEWAEcBFgBHARYARwEWAEcCLABHARb//gN5AEcCYwBHAmMARwJj/8kCYwBHAmMARwJjAEcCYwBHAmP/6AN5AEcCYwBHAmMAJgJjACYCYwAmAmMAJgJjACYCYwAmAmMAJgJjACYCYwAmAmMAJgJjACYCYwAmAmMAJgJjACYCYwAmAmMAJgJjACYCYwAmAmMAJgJjACYCYwAmAmMAJgJjACYCYwAmAmMAJgJjACYCYwAmAmMAJgJjACYCYwAmAmMAJgOwACYCYwBHAmMARwJjACUBhQBHAYUARwGFADUBhQBHAYX/4wGFAEcBhQA7AiwALgIsAC4AxgAxAiwALgIsAC4CLAAuAiwALgIsAC4CYwBBARYACQFNAAsBTQALAU0ACwFNAAsBTQALAU0ACwJjAEQCYwBEAmMARAJjAEQCYwBEAmMANgJjAEQCYwBEAmMARAJjAEQCYwBEAmMARAJjAEQCYwBEAmMARAJjAEQCYwBEAmMARAJjAEQCYwBEAmMARAJjAEQCYwBEAmMARAJjAEQCYwBEAiwACQMKAAQDCgAEAwoABAMKAAQDCgAEAiwABgIsAAkCLAAJAiwACQIsAAkCLAAJAiwACQIsAAkCLAAJAiwACQH0ABUB9AAVAfQAFQH0ABUB9AAVAmMARAJjAEQCYwBEAmMARAJjAEQCYwBEAmMARAIsACYCYwBHAmMAJgIsAC4B9AAVAoYACQOcAAkDnAAJAmQACQJjAAkBcgAeAW0AFQGMADsCzwABAyIAIQJAADQC/gAhAYwAOwIsACoCLABUAiwAKwIsACICLAAUAiwAJAIsACoCLAAjAiwAIQIsAB4CLAAqAiwAVAIsACsCLAAiAiwAFAIsACQCLAAqAiwAIwIsACECLAAeAiwAKgIsADkCLABgAiwANgIsAC0CLAAhAiwALwIsADQCLAAyAiwAMwIsADMCLAA5AiwAKgIsAFQCLAArAiwAIgIsABQCLAAkAiwAKgIsACMCLAAhAiwAHgIsACoCLAA5AiwAYAIsADYCLAAtAiwAIQIsAC8CLAA0AiwAMgIsADMCLAAzAiwAOQIsACoBTQAhAU0ANwFNACkBTQAlAU0AHQFNACcBTQAdAU0AJQFNACMBTQAdAU0AIQFNADcBTQApAU0AJQFNAB0BTQAnAU0AHQFNACUBTQAjAU0AHQFNACEBTQA3AU0AKQFNACUBTQAdAU0AJwFNAB0BTQAlAU0AIwFNAB0BTQAhAU0ANwFNACkBTQAlAU0AHQFNACcBTQAdAU0AJQFNACMBTQAdAKf/FgNCAC4DQQA3A0EAKQNCAC4DQgAmA0EANwNBACUDQQAnAxYAJQEWAEYBFgBGAU0AYQFNAGED6ABiAU0AWgFNAFoCYwA5AmMASgFNAGABXgAoAYUAHwINAFoCLAAJARYAAQEWAAEBTf/xAU0AWgJjAEoAsgAUALIAFAFNADMBTQAcAYUAHQGFAC4BTQBHAU0ALgFNAC4BTQAuAiwAAAPoAAAD6ABkAlgALgFNAC4CLAAAAigAAAFNAC4BTQAuAiwAAAPoAAABTQAuARYARgH0AEYB9ABGAfQARgEWAEYBFgBGARYARgIsADsCLAAnAU0AOwFNACcB2gA1AO4AMQIiADcCIgA3A+gAAAJYAAAA+gAAARYAAACyAAABTQAAAAAAAALSAD4CLAAmAtIAPgIsABwCLAAoAmMASgIsAAoCLAAXAk8ACgLiACoCvgAQAiwACwI7AAoC+gA1AtYAEAKpAAoCqQAKAqkACgJeADYCLAALA7AAEAIsAAABXgBkAtwAMQCn/xYCRwA4AlwAsQJcAO8CSAA4AkgAOAJIAEsCJQAnAkgAOAIlACYCSAA4AkgANgIlACYCJQAmAiUAJwIlABsCSAApAkgAKgHVABkCyQAvAiwAHQLSAF4BEgAXAyIAIQLPAAEDNwApAskAOwIlAB4B7gAjAkAANAPTALEDeQAuA+gAEgJIACoB9ABEA+gAKgH0AEQD6AAqA+gAKgH0AEEB9ABBAlgAKgPPACcC0gA9AiwAEgIsACkC4QANAuEADQLhAA0D6ABOA3UAKQGQACwA8AAz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ARoAPAEkAEIBKgAzARsASgEyAEgBMABMATQASwEzAE8BNwBOATYAYAFJAF4BRwBUATwAXwFIAFkBOgBSAUYAYwFNAGUBTwFQAGgBUgBqAVQAaQFTAGsBVQBtAVcAcQFaAHMBXQByAVwBWwB1AV8AkgF8AHsBZQCQAXoAmAGCAJ0BhwCfAYkAngGIAKQBjgCoAZIApwGRAKYBkACwAZoArwGZAK4BmADMAbYAyQGzALUBnwDLAbUAxwGxAMoBtADQAboA1gHAANcA3gHIAOABygDfAckBlgBFApQAigF0AMEBqwApAC8BFwBnAGwBVgBwAHcBYQAMAPYAVQE9AHwBZgC2AaAAvQGnALoBpAC7AaUAvAGmAEkBMQCTAX0AKAAuARYARwEvABwBBgAfAQkAlQF/ABMA/QAYAQIAOgEiAEABKABXAT8AXQFFAIMBbQCRAXsAoAGKAKIBjAC4AaIAyAGyAKkBkwCxAZsAhQFvAJcBgQCGAXAA2wHFAuYC5QMJAwcDBgMLAxADDwMRAw0C6gLrAu4C8gLzAvAC6QLoAvQC8QLsAu8ALQEVAFABOAB0AV4AoQGLAKoBlACyAZwA0gG8AM8BuQDRAbsA4QHLABUA/wAXAQEADgD4ABAA+gARAPsAEgD8AA8A+QAHAPEACQDzAAoA9AALAPUACADyAD0BJQA/AScAQwErADUBHQA3AR8AOAEgADkBIQA2AR4AXAFEAFoBQgCHAXEAiQFzAH4BaACAAWoAgQFrAIIBbAB/AWkAiwF1AI0BdwCOAXgAjwF5AIwBdgC+AagAwAGqAMIBrADEAa4AxQGvAMYBsADDAa0A2QHDANgBwgDaAcQA3AHGAocChgKLAogCcQJ7AnwCdwJ9AnkCegJ4At0C3wJYApUCmAKSApMClwKdApYCnwKZApoCngLgAtUCygLHAsgCyQLLAswCuQK9Ar8CqgKjAsACuALDAq4CpgKyArECqAKnAKUBjwAAsAAsILAAVVhFWSAgS7gADlFLsAZTWliwNBuwKFlgZiCKVViwAiVhuQgACABjYyNiGyEhsABZsABDI0SyAAEAQ2BCLbABLLAgYGYtsAIsIyEjIS2wAywgZLMDFBUAQkOwE0MgYGBCsQIUQ0KxJQNDsAJDVHggsAwjsAJDQ2FksARQeLICAgJDYEKwIWUcIbACQ0OyDhUBQhwgsAJD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SiywABUgR7AAI0KyAAEBFRQTLrA2Ki2wSyyxAAEUE7A3Ki2wTCywOSotsE0ssAAWRSMgLiBGiiNhOLEwARQrLbBOLLAKI0KwTSstsE8ssgAARistsFAssgABRistsFEssgEARistsFIssgEBRistsFMssgAARystsFQssgABRystsFUssgEARystsFYssgEBRystsFcsswAAAEMrLbBYLLMAAQBDKy2wWSyzAQAAQystsFosswEBAEMrLbBbLLMAAAFDKy2wXCyzAAEBQystsF0sswEAAUMrLbBeLLMBAQFDKy2wXyyyAABFKy2wYCyyAAFFKy2wYSyyAQBFKy2wYiyyAQFFKy2wYyyyAABIKy2wZCyyAAFIKy2wZSyyAQBIKy2wZiyyAQFIKy2wZyyzAAAARCstsGgsswABAEQrLbBpLLMBAABEKy2waiyzAQEARCstsGssswAAAUQrLbBsLLMAAQFEKy2wbSyzAQABRCstsG4sswEBAUQrLbBvLLEAPCsusTABFCstsHAssQA8K7BAKy2wcSyxADwrsEErLbByLLAAFrEAPCuwQistsHMssQE8K7BAKy2wdCyxATwrsEErLbB1LLAAFrEBPCuwQistsHYssQA9Ky6xMAEUKy2wdyyxAD0rsEArLbB4LLEAPSuwQSstsHkssQA9K7BCKy2weiyxAT0rsEArLbB7LLEBPSuwQSstsHwssQE9K7BCKy2wfSyxAD4rLrEwARQrLbB+LLEAPiuwQCstsH8ssQA+K7BBKy2wgCyxAD4rsEIrLbCBLLEBPiuwQCstsIIssQE+K7BBKy2wgyyxAT4rsEIrLbCELLEAPysusTABFCstsIUssQA/K7BAKy2whiyxAD8rsEErLbCHLLEAPyuwQistsIgssQE/K7BAKy2wiSyxAT8rsEErLbCKLLEBPyuwQistsIsssgsAA0VQWLAGG7IEAgNFWCMhGyFZWUIrsAhlsAMkUHixBQEVRVgwWS0AAAAAS7gAyFJYsQEBjlmwAbkIAAgAY3CxAAdCtQA+ACAEACqxAAdCQApFBDEIJwMVBwQKKrEAB0JACksCOwYsAR4FBAoqsQALQr0RgAyACgAFgAAEAAsqsQAPQr0AQABAAEAAQAAEAAsquQADAABEsSQBiFFYsECIWLkAAwBkRLEoAYhRWLgIAIhYuQADAABEWRuxJwGIUVi6CIAAAQRAiGNUWLkAAwAARFlZWVlZQApHBDMIKQMXBwQOKrgB/4WwBI2xAgBEswVkBgBERAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYABgAGAAYAroAAAIOAAD/UwQ4/sgCugAAAg4AAP9TBDj+yABZAFkASgBK/5wEOP7I/5wEOP7IAI0AjQBwAHACrgAAAtMCDgAA/1MEOP7IArr/9ALbAhr/9P9KBDj+yABZAFkASgBKAxIBsAQ4/sgDHgGpBDj+yAAAAAAADwC6AAMAAQQJAAAAqAAAAAMAAQQJAAEADgCoAAMAAQQJAAIACAC2AAMAAQQJAAMALgC+AAMAAQQJAAQAGADsAAMAAQQJAAUAQgEEAAMAAQQJAAYAGAFGAAMAAQQJAAcATgFeAAMAAQQJAAgAGAGsAAMAAQQJAAkAGAHEAAMAAQQJAAoBjgHcAAMAAQQJAAsALgNqAAMAAQQJAAwANgOYAAMAAQQJAA0BIAPOAAMAAQQJAA4ANATuAEMAbwBwAHkAcgBpAGcAaAB0ACAAMgAwADEAOQAgAFQAaABlACAAQQByAGMAaABpAHYAbwAgAFAAcgBvAGoAZQBjAHQAIABBAHUAdABoAG8AcgBzACAAKABoAHQAdABwAHMAOgAvAC8AZwBpAHQAaAB1AGIALgBjAG8AbQAvAE8AbQBuAGkAYgB1AHMALQBUAHkAcABlAC8AQQByAGMAaABpAHYAbwApAEEAcgBjAGgAaQB2AG8AQgBvAGwAZAAxAC4AMAAwADQAOwBPAE0ATgBJADsAQQByAGMAaABpAHYAbwAtAEIAbwBsAGQAQQByAGMAaABpAHYAbwAgAEIAbwBsAGQAVgBlAHIAcwBpAG8AbgAgADEALgAwADAANAA7ACAAdAB0AGYAYQB1AHQAbwBoAGkAbgB0ACAAKAB2ADEALgA4ACkAQQByAGMAaABpAHYAbwAtAEIAbwBsAGQAQQByAGMAaABpAHYAbwAgAGkAcwAgAGEAIAB0AHIAYQBkAGUAbQBhAHIAawAgAG8AZgAgAE8AbQBuAGkAYgB1AHMALQBUAHkAcABlAC4ATwBtAG4AaQBiAHUAcwAtAFQAeQBwAGUASABlAGMAdABvAHIAIABHAGEAdAB0AGkAQQByAGMAaABpAHYAbwAgAGkAcwAgAGEAIABnAHIAbwB0AGUAcwBxAHUAZQAgAHMAYQBuAHMAIABzAGUAcgBpAGYAIAB0AHkAcABlAGYAYQBjAGUAIABmAGEAbQBpAGwAeQAgAGYAcgBvAG0AIABPAG0AbgBpAGIAdQBzAC0AVAB5AHAAZQAuACAASQB0ACAAdwBhAHMAIABvAHIAaQBnAGkAbgBhAGwAbAB5ACAAZABlAHMAaQBnAG4AZQBkACAAZgBvAHIAIABoAGkAZwBoAGwAaQBnAGgAdABzACAAYQBuAGQAIABoAGUAYQBkAGwAaQBuAGUAcwAuACAAVABoAGkAcwAgAGYAYQBtAGkAbAB5ACAAaQBzACAAcgBlAG0AaQBuAGkAcwBjAGUAbgB0ACAAbwBmACAAbABhAHQAZQAgAG4AaQBuAGUAdABlAGUAbgB0AGgAIABjAGUAbgB0AHUAcgB5ACAAQQBtAGUAcgBpAGMAYQBuACAAdAB5AHAAZQBmAGEAYwBlAHMALgBoAHQAdABwADoALwAvAG8AbQBuAGkAYgB1AHMALQB0AHkAcABlAC4AYwBvAG0AaAB0AHQAcAA6AC8ALwB3AHcAdwAuAG8AbQBuAGkAYgB1AHMALQB0AHkAcABlAC4AYwBvAG0AVABoAGkAcwAgAEYAbwBuAHQAIABTAG8AZgB0AHcAYQByAGUAIABpAHMAIABsAGkAYwBlAG4AcwBlAGQAIAB1AG4AZABlAHIAIAB0AGgAZQAgAFMASQBMACAATwBwAGUAbgAgAEYAbwBuAHQAIABMAGkAYwBlAG4AcwBlACwAIABWAGUAcgBzAGkAbwBuACAAMQAuADEALgAgAFQAaABpAHMAIABsAGkAYwBlAG4AcwBlACAAaQBzACAAYQB2AGEAaQBsAGEAYgBsAGUAIAB3AGkAdABoACAAYQAgAEYAQQBRACAAYQB0ADoAIABoAHQAdABwADoALwAvAHMAYwByAGkAcAB0AHMALgBzAGkAbAAuAG8AcgBnAC8ATwBGAEwAaAB0AHQAcAA6AC8ALwBzAGMAcgBpAHAAdABzAC4AcwBpAGwALgBvAHIAZwAvAE8ARgBMAAIAAAAAAAD/tQAyAAAAAAAAAAAAAAAAAAAAAAAAAAADLgAAAQIAAgADACQAyQEDAQQBBQEGAQcBCAEJAMcBCgELAQwBDQEOAQ8AYgEQAK0BEQESARMBFABjARUArgCQARYAJQAmAP0A/wBkARcBGAAnARkBGgDpARsBHAEdAR4BHwAoAGUBIAEhAMgBIgEjASQBJQEmAScAygEoASkAywEqASsBLAEtAS4AKQEvACoBMAD4ATEBMgEzATQAKwE1ATYBNwAsATgAzAE5AToAzQE7AM4A+gE8AM8BPQE+AT8BQAFBAC0BQgFDAC4BRAAvAUUBRgFHAUgBSQFKAOIAMAAxAUsBTAFNAU4BTwFQAVEBUgBmADIA0AFTAVQA0QFVAVYBVwFYAVkBWgBnAVsBXAFdANMBXgFfAWABYQFiAWMBZAFlAWYBZwFoAJEBaQCvAWoAsAAzAO0ANAA1AWsBbAFtAW4BbwFwADYBcQFyAOQA+wFzAXQBdQF2AXcANwF4AXkBegF7AXwAOADUAX0BfgDVAX8AaAGAAYEBggGDAYQA1gGFAYYBhwGIAYkBigGLAYwBjQGOAY8BkAGRADkAOgGSAZMBlAGVADsAPADrAZYAuwGXAZgBmQGaAZsAPQGcAOYBnQGeAZ8BoAGhAaIBowGkAaUBpgGnAagBqQGqAEQAaQGrAawBrQGuAa8BsAGxAGsBsgGzAbQBtQG2AbcAbAG4AGoBuQG6AbsBvABuAb0AbQCgAb4ARQBGAP4BAABvAb8BwABHAOoBwQEBAcIBwwHEAEgAcAHFAcYAcgHHAcgByQHKAcsBzABzAc0BzgBxAc8B0AHRAdIB0wHUAEkASgHVAPkB1gHXAdgB2QBLAdoB2wHcAEwA1wB0Ad0B3gB2Ad8AdwHgAeEAdQHiAeMB5AHlAeYB5wBNAegB6QHqAE4B6wHsAE8B7QHuAe8B8AHxAOMAUABRAfIB8wH0AfUB9gH3AfgB+QB4AFIAeQH6AfsAewH8Af0B/gH/AgACAQB8AgICAwIEAHoCBQIGAgcCCAIJAgoCCwIMAg0CDgIPAKECEAB9AhEAsQBTAO4AVABVAhICEwIUAhUCFgIXAFYCGAIZAOUA/AIaAhsCHACJAh0AVwIeAh8CIAIhAiIAWAB+AiMCJACAAiUAgQImAicCKAIpAioAfwIrAiwCLQIuAi8CMAIxAjICMwI0AjUCNgI3AFkAWgI4AjkCOgI7AFsAXADsAjwAugI9Aj4CPwJAAkEAXQJCAOcCQwJEAkUCRgJHAkgCSQJKAksCTAJNAk4CTwJQAlECUgJTAMAAwQCdAJ4CVAJVAlYCVwCbAlgAEwAUABUAFgAXABgAGQAaABsAHAJZAloCWwJcAl0CXgJfAmACYQJiAmMCZAJlAmYCZwJoAmkCagJrAmwCbQJuAm8CcAJxAnICcwJ0AnUCdgJ3AngCeQJ6AnsCfAJ9An4CfwKAAoECggKDAoQChQKGAocCiAKJAooCiwKMAo0CjgKPApACkQKSApMClAKVApYClwKYApkCmgKbApwCnQKeAp8CoAKhAqICowKkAqUCpgKnAqgCqQKqAqsCrAKtALwA9AKuAq8A9QD2ArACsQKyArMAEQAPAB0AHgCrAAQAowAiAKIAwwCHAA0CtAAGABIAPwK1ArYCtwK4ArkACwAMAF4AYAA+AEAAEAK6ALIAswK7ArwCvQBCAr4CvwLAAsECwgLDAMQAxQC0ALUAtgC3AsQAqQCqAL4AvwAFAAoCxQLGAscCyALJAsoCywLMAs0CzgCEAs8AvQAHAtAC0QCmAPcC0gLTAtQC1QLWAtcC2ALZAtoC2wCFAtwAlgLdAt4C3wLgAuEC4gAOAO8A8AC4ACAAjwAhAB8AlQCUAJMApwBhAKQAQQCSAuMC5ACcAuUC5gCaAJkApQCYAucC6AAIAMYC6QLqAusC7ALtAu4C7wLwALkAIwAJAIgAhgCLAIoC8QCMAvIAgwLzAvQAXwDoAIIC9QDCAvYC9wL4AvkC+gL7AvwC/QL+Av8DAAMBAwIDAwMEAwUDBgMHAwgDCQMKAwsDDAMNAw4DDwMQAxEDEgMTAxQDFQMWAxcDGAMZAxoAjQDbAOEA3gDYAI4A3ABDAN8A2gDgAN0A2QMbAxwDHQMeAx8DIAMhAyIDIwMkAyUDJgMnAygDKQMqAysDLAMtAy4DLwMwAzEDMgMzAzQDNQM2BE5VTEwGQWJyZXZlB3VuaTFFQUUHdW5pMUVCNgd1bmkxRUIwB3VuaTFFQjIHdW5pMUVCNAd1bmkwMUNEB3VuaTFFQTQHdW5pMUVBQwd1bmkxRUE2B3VuaTFFQTgHdW5pMUVBQQd1bmkwMjAwB3VuaTFFQTAHdW5pMUVBMgd1bmkwMjAyB0FtYWNyb24HQW9nb25lawpBcmluZ2FjdXRlB0FFYWN1dGULQ2NpcmN1bWZsZXgKQ2RvdGFjY2VudAd1bmkwMUYxB3VuaTAxQzQGRGNhcm9uBkRjcm9hdAd1bmkxRTBDB3VuaTAxRjIHdW5pMDFDNQZFYnJldmUGRWNhcm9uB3VuaTFFQkUHdW5pMUVDNgd1bmkxRUMwB3VuaTFFQzIHdW5pMUVDNAd1bmkwMjA0CkVkb3RhY2NlbnQHdW5pMUVCOAd1bmkxRUJBB3VuaTAyMDYHRW1hY3JvbgdFb2dvbmVrB3VuaTFFQkMHdW5pMDE5MQd1bmkwMUY0BkdjYXJvbgtHY2lyY3VtZmxleAd1bmkwMTIyCkdkb3RhY2NlbnQESGJhcgtIY2lyY3VtZmxleAd1bmkxRTI0AklKBklicmV2ZQd1bmkwMUNGB3VuaTAyMDgHdW5pMUVDQQd1bmkxRUM4B3VuaTAyMEEHSW1hY3JvbgdJb2dvbmVrBkl0aWxkZQt1bmkwMEE0MDMwMQtKY2lyY3VtZmxleAd1bmkwMTM2B3VuaTAxQzcGTGFjdXRlBkxjYXJvbgd1bmkwMTNCBExkb3QHdW5pMDFDOAd1bmkwMUNBBk5hY3V0ZQZOY2Fyb24HdW5pMDE0NQd1bmkxRTQ0A0VuZwd1bmkwMTlEB3VuaTAxQ0IGT2JyZXZlB3VuaTAxRDEHdW5pMUVEMAd1bmkxRUQ4B3VuaTFFRDIHdW5pMUVENAd1bmkxRUQ2B3VuaTAyMEMHdW5pMDIyQQd1bmkwMjMwB3VuaTFFQ0MHdW5pMUVDRQVPaG9ybgd1bmkxRURBB3VuaTFFRTIHdW5pMUVEQwd1bmkxRURFB3VuaTFFRTANT2h1bmdhcnVtbGF1dAd1bmkwMjBFB09tYWNyb24HdW5pMDFFQQtPc2xhc2hhY3V0ZQd1bmkwMjJDBlJhY3V0ZQZSY2Fyb24HdW5pMDE1Ngd1bmkwMjEwB3VuaTFFNUEHdW5pMDIxMgZTYWN1dGUHdW5pQTc4QgtTY2lyY3VtZmxleAd1bmkwMjE4B3VuaTFFNjIHdW5pMUU5RQd1bmkwMThGBFRiYXIGVGNhcm9uB3VuaTAxNjIHdW5pMDIxQQd1bmkxRTZDBlVicmV2ZQd1bmkwMUQzB3VuaTAyMTQHdW5pMDFENwd1bmkwMUQ5B3VuaTAxREIHdW5pMDFENQd1bmkxRUU0B3VuaTFFRTYFVWhvcm4HdW5pMUVFOAd1bmkxRUYwB3VuaTFFRUEHdW5pMUVFQwd1bmkxRUVFDVVodW5nYXJ1bWxhdXQHdW5pMDIxNgdVbWFjcm9uB1VvZ29uZWsFVXJpbmcGVXRpbGRlBldhY3V0ZQtXY2lyY3VtZmxleAlXZGllcmVzaXMGV2dyYXZlC1ljaXJjdW1mbGV4B3VuaTFFRjQGWWdyYXZlB3VuaTFFRjYHdW5pMDIzMgd1bmkxRUY4BlphY3V0ZQpaZG90YWNjZW50B3VuaTFFOTIJWS5sb2NsR1VBDllhY3V0ZS5sb2NsR1VBE1ljaXJjdW1mbGV4LmxvY2xHVUERWWRpZXJlc2lzLmxvY2xHVUEOWWdyYXZlLmxvY2xHVUEPdW5pMDIzMi5sb2NsR1VBD3VuaTFFRjgubG9jbEdVQQ5DYWN1dGUubG9jbFBMSw5OYWN1dGUubG9jbFBMSw5PYWN1dGUubG9jbFBMSw5TYWN1dGUubG9jbFBMSw5aYWN1dGUubG9jbFBMSwZhYnJldmUHdW5pMUVBRgd1bmkxRUI3B3VuaTFFQjEHdW5pMUVCMwd1bmkxRUI1B3VuaTAxQ0UHdW5pMUVBNQd1bmkxRUFEB3VuaTFFQTcHdW5pMUVBOQd1bmkxRUFCB3VuaTAyMDEHdW5pMUVBMQd1bmkxRUEzB3VuaTAyMDMHYW1hY3Jvbgdhb2dvbmVrCmFyaW5nYWN1dGUHYWVhY3V0ZQtjY2lyY3VtZmxleApjZG90YWNjZW50BmRjYXJvbgd1bmkxRTBEB3VuaTAxRjMHdW5pMDFDNgZlYnJldmUGZWNhcm9uB3VuaTFFQkYHdW5pMUVDNwd1bmkxRUMxB3VuaTFFQzMHdW5pMUVDNQd1bmkwMjA1CmVkb3RhY2NlbnQHdW5pMUVCOQd1bmkxRUJCB3VuaTAyMDcHZW1hY3Jvbgdlb2dvbmVrB3VuaTFFQkQHdW5pMDI1OQd1bmkwMUY1BmdjYXJvbgtnY2lyY3VtZmxleAd1bmkwMTIzCmdkb3RhY2NlbnQEaGJhcgtoY2lyY3VtZmxleAd1bmkxRTI1BmlicmV2ZQd1bmkwMUQwB3VuaTAyMDkJaS5sb2NsVFJLB3VuaTFFQ0IHdW5pMUVDOQd1bmkwMjBCAmlqB2ltYWNyb24HaW9nb25lawZpdGlsZGUHdW5pMDIzNwt1bmkwMDZBMDMwMQtqY2lyY3VtZmxleAd1bmkwMTM3DGtncmVlbmxhbmRpYwZsYWN1dGUGbGNhcm9uB3VuaTAxM0MEbGRvdAd1bmkwMUM5Bm5hY3V0ZQtuYXBvc3Ryb3BoZQZuY2Fyb24HdW5pMDE0Ngd1bmkxRTQ1A2VuZwd1bmkwMjcyB3VuaTAxQ0MGb2JyZXZlB3VuaTAxRDIHdW5pMUVEMQd1bmkxRUQ5B3VuaTFFRDMHdW5pMUVENQd1bmkxRUQ3B3VuaTAyMEQHdW5pMDIyQgd1bmkwMjMxB3VuaTFFQ0QHdW5pMUVDRgVvaG9ybgd1bmkxRURCB3VuaTFFRTMHdW5pMUVERAd1bmkxRURGB3VuaTFFRTENb2h1bmdhcnVtbGF1dAd1bmkwMjBGB29tYWNyb24HdW5pMDFFQgtvc2xhc2hhY3V0ZQd1bmkwMjJEBnJhY3V0ZQZyY2Fyb24HdW5pMDE1Nwd1bmkwMjExB3VuaTFFNUIHdW5pMDIxMwZzYWN1dGUHdW5pQTc4QwtzY2lyY3VtZmxleAd1bmkwMjE5B3VuaTFFNjMFbG9uZ3MEdGJhcgZ0Y2Fyb24HdW5pMDE2Mwd1bmkwMjFCB3VuaTFFNkQGdWJyZXZlB3VuaTAxRDQHdW5pMDIxNQd1bmkwMUQ4B3VuaTAxREEHdW5pMDFEQwd1bmkwMUQ2B3VuaTFFRTUHdW5pMUVFNwV1aG9ybgd1bmkxRUU5B3VuaTFFRjEHdW5pMUVFQgd1bmkxRUVEB3VuaTFFRUYNdWh1bmdhcnVtbGF1dAd1bmkwMjE3B3VtYWNyb24HdW9nb25lawV1cmluZwZ1dGlsZGUGd2FjdXRlC3djaXJjdW1mbGV4CXdkaWVyZXNpcwZ3Z3JhdmULeWNpcmN1bWZsZXgHdW5pMUVGNQZ5Z3JhdmUHdW5pMUVGNwd1bmkwMjMzB3VuaTFFRjkGemFjdXRlCnpkb3RhY2NlbnQHdW5pMUU5Mwl5LmxvY2xHVUEOeWFjdXRlLmxvY2xHVUETeWNpcmN1bWZsZXgubG9jbEdVQRF5ZGllcmVzaXMubG9jbEdVQQ55Z3JhdmUubG9jbEdVQQ91bmkwMjMzLmxvY2xHVUEPdW5pMUVGOS5sb2NsR1VBDmNhY3V0ZS5sb2NsUExLDm5hY3V0ZS5sb2NsUExLDm9hY3V0ZS5sb2NsUExLDnNhY3V0ZS5sb2NsUExLDnphY3V0ZS5sb2NsUExLA2ZfZgVmX2ZfaQVmX2ZfbAd1bmkyMDdGB3VuaTAzOTQHdW5pMDNBOQd1bmkwM0JDB3VuaTIwOTkHemVyby5sZgZvbmUubGYGdHdvLmxmCHRocmVlLmxmB2ZvdXIubGYHZml2ZS5sZgZzaXgubGYIc2V2ZW4ubGYIZWlnaHQubGYHbmluZS5sZgx6ZXJvLmxmLnplcm8IemVyby5vc2YHb25lLm9zZgd0d28ub3NmCXRocmVlLm9zZghmb3VyLm9zZghmaXZlLm9zZgdzaXgub3NmCXNldmVuLm9zZgllaWdodC5vc2YIbmluZS5vc2YNemVyby5vc2YuemVybwd6ZXJvLnRmBm9uZS50ZgZ0d28udGYIdGhyZWUudGYHZm91ci50ZgdmaXZlLnRmBnNpeC50ZghzZXZlbi50ZghlaWdodC50ZgduaW5lLnRmDHplcm8udGYuemVybwl6ZXJvLnRvc2YIb25lLnRvc2YIdHdvLnRvc2YKdGhyZWUudG9zZglmb3VyLnRvc2YJZml2ZS50b3NmCHNpeC50b3NmCnNldmVuLnRvc2YKZWlnaHQudG9zZgluaW5lLnRvc2YOemVyby50b3NmLnplcm8JemVyby56ZXJvB3VuaTIwODAHdW5pMjA4MQd1bmkyMDgyB3VuaTIwODMHdW5pMjA4NAd1bmkyMDg1B3VuaTIwODYHdW5pMjA4Nwd1bmkyMDg4B3VuaTIwODkJemVyby5kbm9tCG9uZS5kbm9tCHR3by5kbm9tCnRocmVlLmRub20JZm91ci5kbm9tCWZpdmUuZG5vbQhzaXguZG5vbQpzZXZlbi5kbm9tCmVpZ2h0LmRub20JbmluZS5kbm9tCXplcm8ubnVtcghvbmUubnVtcgh0d28ubnVtcgp0aHJlZS5udW1yCWZvdXIubnVtcglmaXZlLm51bXIIc2l4Lm51bXIKc2V2ZW4ubnVtcgplaWdodC5udW1yCW5pbmUubnVtcgd1bmkyMDcwB3VuaTAwQjkHdW5pMDBCMgd1bmkwMEIzB3VuaTIwNzQHdW5pMjA3NQd1bmkyMDc2B3VuaTIwNzcHdW5pMjA3OAd1bmkyMDc5B3VuaTIxNTMHdW5pMjE1NAlvbmVlaWdodGgMdGhyZWVlaWdodGhzC2ZpdmVlaWdodGhzDHNldmVuZWlnaHRocwlleGNsYW1kYmwHdW5pMjAzRQ9leGNsYW1kb3duLmNhc2URcXVlc3Rpb25kb3duLmNhc2UbcGVyaW9kY2VudGVyZWQubG9jbENBVC5jYXNlFnBlcmlvZGNlbnRlcmVkLmxvY2xDQVQHdW5pMDBBRAd1bmkyMDE1B3VuaTIwMTAHdW5pMjAxMQ11bmRlcnNjb3JlZGJsC2h5cGhlbi5jYXNlDHVuaTAwQUQuY2FzZQtlbmRhc2guY2FzZQtlbWRhc2guY2FzZQx1bmkyMDExLmNhc2UNcXVvdGVyZXZlcnNlZAd1bmkyN0U4B3VuaTI3RTkHdW5pMjAwMwd1bmkyMDAyB3VuaTIwMDUHdW5pMDBBMAd1bmkyMDA5B3VuaTIwMDQHdW5pRkVGRgd1bmkyMEI1DWNvbG9ubW9uZXRhcnkEZG9uZwRFdXJvB3VuaTIwQjIHdW5pMjBBRARsaXJhB3VuaTIwQkEHdW5pMjBCQwd1bmkyMEE2BnBlc2V0YQd1bmkyMEIxB3VuaTIwQkQHdW5pMjBCOQd1bmkyMEE5B3VuaTIyMTkHdW5pMjA1Mgd1bmkyMjE1C2VxdWl2YWxlbmNlCmludGVncmFsYnQKaW50ZWdyYWx0cAhlbXB0eXNldAxpbnRlcnNlY3Rpb24HdW5pMjEyNgd1bmkyMjA2B3VuaTAwQjUKb3J0aG9nb25hbA1yZXZsb2dpY2Fsbm90B2Fycm93dXAKYXJyb3dyaWdodAlhcnJvd2Rvd24JYXJyb3dsZWZ0CWFycm93Ym90aAlhcnJvd3VwZG4MYXJyb3d1cGRuYnNlB3VuaTIxMTcHdW5pMjEwNQZtaW51dGUGc2Vjb25kB3VuaTIxMTMHdW5pMjExNgllc3RpbWF0ZWQFaG91c2UNYW1wZXJzYW5kLmFsdAd1bmkwMkJDB3VuaTAyQkEHdW5pMDJCOQd1bmkwMkM5B3VuaTAzMDgHdW5pMDMwNwlncmF2ZWNvbWIJYWN1dGVjb21iB3VuaTAzMEILdW5pMDMwQy5hbHQHdW5pMDMwMgd1bmkwMzBDB3VuaTAzMDYHdW5pMDMwQQl0aWxkZWNvbWIHdW5pMDMwNA1ob29rYWJvdmVjb21iB3VuaTAzMEYHdW5pMDMxMQd1bmkwMzEyB3VuaTAzMTMHdW5pMDMxQgxkb3RiZWxvd2NvbWIHdW5pMDMyNAd1bmkwMzI2B3VuaTAzMjcHdW5pMDMy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AYEDLQABAXb+/AABAXUAAAABAYEDcwABAWYAAAABAWgDLQABAWf/SgABAWgCrgABAWkCHAABArkCrgABAIwDPgABAIwDVQABAIz/SgABAIwDVgABAIwDcwABAI0DcwABAIwDTgABAI0DTgABAaMCrgABALUAAAABArkDTgABAaMDLQABAWQAAAABAWX+/AABBAYCrgABAIsDTgABAU3+/AABAUwAAAABAIsCrgABAbsBcgABATgCDgABBHUCrgABAW8DTgABAW8DVQABAWz+/AABAW8DcwABAXADTgABAYUDPgABAYUDzQABAYUDLQABAYUD1QABAYUD8gABAYYDzQABAYUEEwABAZT/SgABAYUDVgABAYUDcwABAfQDTgABAYUDVQABAYYDcwABAYUDTgABAYECrgABAYUAAAABAYEDTgABAYYDTgABAYYD7gABAUwDTgABAWn+/AABAUwDVQABAWn/SgABAUwCrgABAWgAAAABAU0DcwABAVADTgABAVADVQABAVf/SQABAVADLQABAVj+/AABAVj/SgABATIDVQABATP+/AABATICrgABATIBTgABAWkDPgABAWkDLQABAWkEGgABAWkEGwABAWkEEwABAWj/SgABAWkDVgABAWkDcwABAhwDTgABAWkDVQABAWkDTgABAWkCrgABAWoDcwABAWcAAAABAdAAAAABAWoDTgABAhwCrgABAdkCrgABAdkDTgABAdkDLQABAdkDcwABAdkDVgABAVIDLQABAVH/SgABAVICrgABAVIDVgABAVIDcwABAVIDTgABAVAAAAABAVMDTgABATYDTgABATYDVQABATYDcwABATP/SgABAUcCrgABAUcDLQABAUcDcwABAUcDVgABAUcDTgABAUgDTgABAW8AAAABAXMCrgABAWsAAAABAW8CrgABAZMAAAABAbQAAAABAYUCrgABAYUBVwABAfQCrgABAVcAAAABAVACrgABATYCrgABATIBVwABARMCngABARMDYwABARQDYwABARMCvwABARMDhAABARQDhAABARMC0wABARMCrgABARMCDgABARQDmAABAREAAAABAiMABAABARQC0wABAb4CDgABAb4C0wABAR4CvwABAR4C0wABATIAAAABATP/SQABAbcCagABA2ECDgABA10AAAABA2EC0wABA10BBwABAk4CDgABARoCngABARoCvwABARoDhAABARsDhAABAR//SQABARoC0wABARoCrgABARoCDgABAR4AAAABAX0AAAABARsC0wABAK8CDgABAQ4CDgABAS4CDgABAS4CngABAS4CvwABAS4DJgABAS4C0wABAIwDLQABAIwCrgABALYCcwABAIkCngABAIkCvwABAIv/SQABAIkC0wABAIkCrgABAIkCDgABAIoC0wABAIcCDgABAIoAAAABALIAAAABAZ0C0wABAIcCvwABASkAAAABASr+/AABAIwDXAABAIwCvAABAUUBaAABAQICDgABAUH+/AABAT8C0wABAUAC0wABATECngABATECvwABATEDhAABATIDhAABATEDcwABATT/SQABAXQCrgABATECrgABATIC0wABATIDcwABAIz+/AABANwC0wABAIz/SQABANwCDgABAIsAAAABAN0C0wABAREC0wABARL/SQABARECvwABARP+/AABARP/SQABAMIAAAABAML/SQABAMP+/AABAMP/SQABAJEBFgABAPcCIgABAS8CngABAS8CvwABAS8DmAABAS8DcwABATL/SQABAZ0CrgABAS8C0wABAS8CrgABAS8CDgABATEAAAABAhwAAAABAZ0CDgABAYYCDgABAYYCvwABAYYC0wABARgCvwABAdT/SQABARgCDgABARgC0wABARgCrgABAdMAAAABARkC0wABAP4C0wABAPv/SQABATACDgABATACvwABATAC0wABATACrgABATEC0wABAR4CDgABAUAAAAABAT8CDgABAIQCDgABATMAAAABAV8AAAABATECDgABATIBBwABAXQCDgABARIAAAABARECDgABAPoAAAABAP4CDgABAPoBBwAGAQAAAQAIAAEADAAMAAEAKACEAAEADAL6AvsC/AL9Av8DAAMiAyMDJAMlAycDKAAMAAAAOAAAADIAAABEAAAASgAAAFAAAABWAAAAOAAAAD4AAABEAAAASgAAAFAAAABWAAH/XAAAAAH/vAAAAAH/XQAAAAH/xgAAAAH/eQAAAAH/XwAAAAH/aAAAAAwAGgAgADIAOAA+AEQAJgAsADIAOAA+AEQAAf+9/0kAAf9b/0kAAf+9/0oAAf9c/0kAAf/H/vwAAf95/0kAAf9e/0kAAf9o/0kABgIAAAEACAABAAwADAABACIBGAACAAMC6ALsAAAC7gL4AAUDEgMgABAAHwAAAKIAAAB+AAAAhAAAAIoAAACQAAAAwAAAAMAAAADGAAAAzAAAAJYAAADYAAAA3gAAAJwAAADqAAAA8AAAAPAAAACiAAAAqAAAAK4AAAC0AAAAugAAAMAAAADAAAAAxgAAAMwAAADSAAAA2AAAAN4AAADkAAAA6gAAAPAAAf+8Ag4AAf+3Ag4AAf9dAg4AAf8bAg4AAf9XAg4AAf91Ag4AAf9cAg4AAf++Ag4AAf/HAg4AAf95Ag4AAf8RAg4AAf9aAg4AAf9fAg4AAf+aAg4AAf9hAg4AAf9oAg4AAf+LAg4AAf9rAg4AAf9eAg4AAf/AAg4AHwB2AEAARgBMAFIAWABeAKAApgBkALIAuABqAMQAygBwAHYAfACCAIgAjgCUAJoAoACmAKwAsgC4AL4AxADKAAH/vALTAAH/twLTAAH/XQLTAAH/GwLTAAH/WgK/AAH/WgLTAAH/WALTAAH/dQLTAAH/wANEAAH/XALTAAH/vgLTAAH/xwK2AAH/eQKuAAH/EQK1AAH/WgKNAAH/WgK1AAH/XwKeAAH/mwLTAAH/YgKuAAH/aAKuAAH/iwLTAAH/awK1AAH/XwLTAAH/wAMmAAYDAAABAAgAAQAMAAwAAQAUACQAAQACAvkDIQACAAAACgAAAAoAAf8kAg4AAgAGAAYAAf8kAq4AAAABAAAACgKCCMQAAkRGTFQADmxhdG4AOgAEAAAAAP//ABEAAAANABsAKAA1AEIAWgBnAHQAgQCOAJsAqAC1AMIAzwDcAEYAC0FaRSAAcENBVCAAmkNSVCAAxEdVQSAA7ktBWiABGE1PTCABQk5MRCABbFBMSyABllJPTSABwFRBVCAB6lRSSyACFAAA//8AEgABAA4AGgAcACkANgBDAFsAaAB1AIIAjwCcAKkAtgDDANAA3QAA//8AEgACAA8AHQAqADcARABPAFwAaQB2AIMAkACdAKoAtwDEANEA3gAA//8AEgADABAAHgArADgARQBQAF0AagB3AIQAkQCeAKsAuADFANIA3wAA//8AEgAEABEAHwAsADkARgBRAF4AawB4AIUAkgCfAKwAuQDGANMA4AAA//8AEgAFABIAIAAtADoARwBSAF8AbAB5AIYAkwCgAK0AugDHANQA4QAA//8AEgAGABMAIQAuADsASABTAGAAbQB6AIcAlAChAK4AuwDIANUA4gAA//8AEgAHABQAIgAvADwASQBUAGEAbgB7AIgAlQCiAK8AvADJANYA4wAA//8AEgAIABUAIwAwAD0ASgBVAGIAbwB8AIkAlgCjALAAvQDKANcA5AAA//8AEgAJABYAJAAxAD4ASwBWAGMAcAB9AIoAlwCkALEAvgDLANgA5QAA//8AEgAKABcAJQAyAD8ATABXAGQAcQB+AIsAmAClALIAvwDMANkA5gAA//8AEgALABgAJgAzAEAATQBYAGUAcgB/AIwAmQCmALMAwADNANoA5wAA//8AEgAMABkAJwA0AEEATgBZAGYAcwCAAI0AmgCnALQAwQDOANsA6ADpYWFsdAV4YWFsdAV4YWFsdAV4YWFsdAV4YWFsdAV4YWFsdAV4YWFsdAV4YWFsdAV4YWFsdAV4YWFsdAV4YWFsdAV4YWFsdAV4YWFsdAV4Y2FzZQWAY2FzZQWAY2FzZQWAY2FzZQWAY2FzZQWAY2FzZQWAY2FzZQWAY2FzZQWAY2FzZQWAY2FzZQWAY2FzZQWAY2FzZQWAY2FzZQWAY2NtcAWGZG5vbQWMZG5vbQWMZG5vbQWMZG5vbQWMZG5vbQWMZG5vbQWMZG5vbQWMZG5vbQWMZG5vbQWMZG5vbQWMZG5vbQWMZG5vbQWMZG5vbQWMZnJhYwWSZnJhYwWSZnJhYwWSZnJhYwWSZnJhYwWSZnJhYwWSZnJhYwWSZnJhYwWSZnJhYwWSZnJhYwWSZnJhYwWSZnJhYwWSZnJhYwWSbGlnYQWwbGlnYQWwbGlnYQWwbGlnYQWwbGlnYQWwbGlnYQWwbGlnYQWwbGlnYQWwbGlnYQWwbGlnYQWwbGlnYQWwbGlnYQWwbGlnYQWwbG51bQW2bG51bQW2bG51bQW2bG51bQW2bG51bQW2bG51bQW2bG51bQW2bG51bQW2bG51bQW2bG51bQW2bG51bQW2bG51bQW2bG51bQW2bG9jbAW8bG9jbAXCbG9jbAXIbG9jbAXObG9jbAXUbG9jbAXabG9jbAXgbG9jbAXmbG9jbAXsbG9jbAXybG9jbAX4bWdyawX+bWdyawX+bWdyawX+bWdyawX+bWdyawX+bWdyawX+bWdyawX+bWdyawX+bWdyawX+bWdyawX+bWdyawX+bWdyawX+bWdyawX+bnVtcgYEbnVtcgYEbnVtcgYEbnVtcgYEbnVtcgYEbnVtcgYEbnVtcgYEbnVtcgYEbnVtcgYEbnVtcgYEbnVtcgYEbnVtcgYEbnVtcgYEb251bQYKb251bQYKb251bQYKb251bQYKb251bQYKb251bQYKb251bQYKb251bQYKb251bQYKb251bQYKb251bQYKb251bQYKb251bQYKb3JkbgYQb3JkbgYQb3JkbgYQb3JkbgYQb3JkbgYQb3JkbgYQb3JkbgYQb3JkbgYQb3JkbgYQb3JkbgYQb3JkbgYQb3JkbgYQb3JkbgYQcG51bQYYcG51bQYYcG51bQYYcG51bQYYcG51bQYYcG51bQYYcG51bQYYcG51bQYYcG51bQYYcG51bQYYcG51bQYYcG51bQYYcG51bQYYc2FsdAYec2FsdAYec2FsdAYec2FsdAYec2FsdAYec2FsdAYec2FsdAYec2FsdAYec2FsdAYec2FsdAYec2FsdAYec2FsdAYec2FsdAYec2luZgYkc2luZgYkc2luZgYkc2luZgYkc2luZgYkc2luZgYkc2luZgYkc2luZgYkc2luZgYkc2luZgYkc2luZgYkc2luZgYkc2luZgYkc3VicwYqc3VicwYqc3VicwYqc3VicwYqc3VicwYqc3VicwYqc3VicwYqc3VicwYqc3VicwYqc3VicwYqc3VicwYqc3VicwYqc3VicwYqc3VwcwYwc3VwcwYwc3VwcwYwc3VwcwYwc3VwcwYwc3VwcwYwc3VwcwYwc3VwcwYwc3VwcwYwc3VwcwYwc3VwcwYwc3VwcwYwc3VwcwYwdG51bQY2dG51bQY2dG51bQY2dG51bQY2dG51bQY2dG51bQY2dG51bQY2dG51bQY2dG51bQY2dG51bQY2dG51bQY2dG51bQY2dG51bQY2emVybwY8emVybwY8emVybwY8emVybwY8emVybwY8emVybwY8emVybwY8emVybwY8emVybwY8emVybwY8emVybwY8emVybwY8emVybwY8AAAAAgAAAAEAAAABACcAAAABAAMAAAABACAAAAANAAQABQAGAAcACAAJAAoACwAMAA0ADgAPABAAAAABACgAAAABACMAAAABABIAAAABABcAAAABABQAAAABABMAAAABABgAAAABABkAAAABABUAAAAB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AAIACgAkAAMAAQAsAAEAEgAAAAEAAAAwAAEAAgAEAO4AAwABABIAAQAcAAAAAQAAADAAAgABAeUB7gAAAAEAAgB5AWMABAAAAAEACAABABQAAQAIAAEABALgAAMBYwJOAAEAAQBvAAEAAAABAAgAAQAG//UAAgABAfoCAwAAAAEAAAABAAgAAgAuABQB7wHwAfEB8gHzAfQB9QH2AfcB+AH6AfsB/AH9Af4B/wIAAgECAgIDAAIAAgHlAe4AAAIQAhkACgABAAAAAQAIAAIAQgAeAgUCBgIHAggCCQIKAgsCDAINAg4B5QHmAecB6AHpAeoB6wHsAe0B7gIQAhECEgITAhQCFQIWAhcCGAIZAAIAAgHlAfgAAAH6AgMAFAABAAAAAQAIAAIALgAUAhACEQISAhMCFAIVAhYCFwIYAhkB+gH7AfwB/QH+Af8CAAIBAgICAwACAAEB5QH4AAAAAQAAAAEACAACAJQARwHvAfAB8QHyAfMB9AH1AfYB9wH4Ae8B8AHxAfIB8wH0AfUB9gH3AfgB7wHwAfEB8gHzAfQB9QH2AfcB+AHvAfAB8QHyAfMB9AH1AfYB9wH4Al8CYAJhAnICcwJ0AnUCdgMSAxMDFAMVAxYDFwMYAxkDGgMbAxwDHQMeAx8DIAMhAyIDIwMkAyUDJgMnAygAAgAMAeUB7gAAAfoCAwAKAgUCDgAUAhACGQAeAlQCVAAoAlYCVgApAmICYgAqAmkCbAArAm8CbwAvAugC7AAwAu4C9wA1AvkDAAA/AAQAAAABAAgAAQA2AAEACAAFAAwAFAAcACIAKAHZAAMBLQE5AdoAAwEtAVEB2AACAS0B2wACATkB3AACAVEAAQABAS0AAQAAAAEACAACABAABQIbAfkCBAIPAhoAAQAFAeUB7wH6AgUCEAABAAAAAQAIAAEABgATAAEAAQLQAAEAAAABAAgAAgAcAAsB5AIcAh0CHgIfAiACIQIiAiMCJAIlAAIAAgFZAVkAAAHlAe4AAQABAAAAAQAIAAIAHAALAjACMQIyAjMCNAI1AjYCNwI4AjkCRAACAAIB5QHuAAACXAJcAAoAAQAAAAEACAACABwACwKKAiYCJwIoAikCKgIrAiwCLQIuAi8AAgACAAMAAwAAAeUB7gABAAEAAAABAAgAAgAMAAMAYgFMAmIAAQADAGEBSgJXAAEAAAABAAgAAQAGAAoAAQABAlcAAQAAAAEACAACAA4ABAHdAd4B3QHeAAEABAAEAHkA7gFj");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZm9udHMvQXJjaGl2by1Cb2xkLnR0Zj80MDdiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQWUsOEVBQWUsdzk2SCIsImZpbGUiOiI2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCJkYXRhOmZvbnQvdHRmO2Jhc2U2NCxBQUVBQUFBUkFRQUFCQUFRUjBSRlJqOWdRRlFBQVRxSUFBQUEva2RRVDFQTkkyNXFBQUU3aUFBQUppWkhVMVZDV3M2dEhBQUJZYkFBQUJhc1QxTXZNbkRIcGdZQUFRSVVBQUFBWUdOdFlYQUNYbTZRQUFFQ2RBQUFDQjVqZG5RZ0RXRXVSQUFCR1hnQUFBQ2VabkJuYlo0MkZOQUFBUXFVQUFBT0ZXZGhjM0FBQUFBUUFBRTZnQUFBQUFobmJIbG1GMTkwK0FBQUFSd0FBTzFtYUdWaFpCUVREYTBBQVBVRUFBQUFObWhvWldFRnh3YW1BQUVCOEFBQUFDUm9iWFI0d0hVOUN3QUE5VHdBQUF5eWJHOWpZVnN1SW1ZQUFPNmtBQUFHWG0xaGVIQUVnUThiQUFEdWhBQUFBQ0J1WVcxbGtsaTRJZ0FCR2hnQUFBWGNjRzl6ZElNeVZXY0FBUi8wQUFBYWkzQnlaWEJuS1lhTkFBRVlyQUFBQU1zQUJRQUFBQUFCOUFLOEFBTUFCZ0FKQUF3QUR3QTFRRElPREFzS0NRZ0dCd01DQVV3QUFBQUNBd0FDWndRQkF3RUJBMWNFQVFNREFWOEFBUU1CVHcwTkRROE5EeEVSRUFVR0dTc1JJUkVoQVNFWEJ5Y1JBUWNYQnljSEFmVCtEQUdrL3F5cUhxb0JrS3FxSHFxcUFyejlSQUtLL3kzLy9nSUIvdi8vTGYvL0FBQUNBQUlBQUFMUUFxNEFCd0FQQUN0QUtBc0JCQUFCVEFVQkJBQUNBUVFDYUFBQUFETk5Bd0VCQVRRQlRnZ0lDQThJRHhFUkVSQUdDUm9yQVRNQkl5Y2hCeU1sSnlZbkl3WUhCd0VPdGdFTW5qSCt5REdXQWRGQkRCOEZId3hCQXE3OVVvT0QvSzRnWjJjZ3J2Ly9BQUlBQUFMUUExVUFJZ0FFQUFBQkJ3TVZBZXdBb0FBSXNRSUJzS0N3TlN2Ly93QUNBQUFDMEFOcEFDSUFCQUFBQVFjREdRSUdBS0FBQ0xFQ0FiQ2dzRFVyLy84QUFnQUFBdEFENVFBaUFBUUFBQUFuQXhrQ0JnQ2dBUWNERlFIc0FUQUFFYkVDQWJDZ3NEVXJzUU1CdUFFd3NEVXJBUC8vQUFML1NnTFFBMmtBSWdBRUFBQUFJd01pQWFrQUFBRUhBeGtDQmdDZ0FBaXhBd0d3b0xBMUsvLy9BQUlBQUFMUUErVUFJZ0FFQUFBQUp3TVpBZ1lBb0FFSEF4UUJuZ0V3QUJHeEFnR3dvTEExSzdFREFiZ0JNTEExS3dELy93QUNBQUFDMEFRUEFDSUFCQUFBQUNjREdRSUdBS0FCQndNZEFkb0JNQUFSc1FJQnNLQ3dOU3V4QXdHNEFUQ3dOU3NBLy84QUFnQUFBdEFEN3dBaUFBUUFBQUFuQXhrQ0JnQ2dBUWNER3dJRUFUQUFFYkVDQWJDZ3NEVXJzUU1CdUFFd3NEVXJBUC8vQUFJQUFBTFFBMVVBSWdBRUFBQUJCd01ZQWdzQW9BQUlzUUlCc0tDd05Tdi8vd0FDQUFBQzBBTlZBQ0lBQkFBQUFRY0RGd0lMQUtBQUNMRUNBYkNnc0RVci8vOEFBZ0FBQXRBRDFBQWlBQVFBQUFBbkF4Y0NDd0NnQVFjREZRSHNBUjhBRWJFQ0FiQ2dzRFVyc1FNQnVBRWZzRFVyQVAvL0FBTC9TZ0xRQTFVQUlnQUVBQUFBSXdNaUFha0FBQUVIQXhjQ0N3Q2dBQWl4QXdHd29MQTFLLy8vQUFJQUFBTFFBOVFBSWdBRUFBQUFKd01YQWdzQW9BRUhBeFFCbmdFZkFCR3hBZ0d3b0xBMUs3RURBYmdCSDdBMUt3RC8vd0FDQUFBQzBBUCtBQ0lBQkFBQUFDY0RGd0lMQUtBQkJ3TWRBZG9CSHdBUnNRSUJzS0N3TlN1eEF3RzRBUit3TlNzQS8vOEFBZ0FBQXRBRDNnQWlBQVFBQUFBbkF4Y0NDd0NnQVFjREd3SUVBUjhBRWJFQ0FiQ2dzRFVyc1FNQnVBRWZzRFVyQVAvL0FBSUFBQUxRQTFVQUlnQUVBQUFCQndNZUFmb0FvQUFJc1FJQ3NLQ3dOU3YvL3dBQ0FBQUMwQU56QUNJQUJBQUFBUWNERWdJSkFLQUFDTEVDQXJDZ3NEVXIvLzhBQXY5S0F0QUNyZ0FpQUFRQUFBQURBeUlCcVFBQS8vOEFBZ0FBQXRBRFZRQWlBQVFBQUFFSEF4UUJuZ0NnQUFpeEFnR3dvTEExSy8vL0FBSUFBQUxRQTM4QUlnQUVBQUFCQndNZEFkb0FvQUFJc1FJQnNLQ3dOU3YvL3dBQ0FBQUMwQU56QUNJQUJBQUFBUWNESHdJSEFLQUFDTEVDQWJDZ3NEVXIvLzhBQWdBQUF0QURVQUFpQUFRQUFBRUhBeHdCL1FDZ0FBaXhBZ0d3b0xBMUt3QUNBQUwvU1FMaUFxNEFHUUFoQUVWQVFoMEJCZ1FSQVFFQ0FRRUFCUU5NQ0FFR0FBSUJCZ0pvQUFRRU0wMERBUUVCTkUwSEFRVUZBR0VBQUFCQUFFNGFHZ0FBR2lFYUlRQVpBQmdSRVJFVklna0pHeXNGRlFZaklpWTFORFkzSXljaEJ5TUJNd0V6RlFZR0ZSUVdNd01uSmljakJnY0hBdUlqSEN3d0lTQldNZjdJTVpZQkRMWUJDZ0lYR0JVVytVRU1Id1VmREVGME53d3BJQnc2R0lPREFxNzlWZ1FVS3hJUUV3RndyaUJuWnlDdUFQLy9BQUlBQUFMUUE1WUFJZ0FFQUFBQkJ3TWFBY3NBb0FBSXNRSUNzS0N3TlN2Ly93QUNBQUFDMEFRNEFDSUFCQUFBQUNjQzhRSExBS0FCQndMckFna0JaUUFSc1FJQ3NLQ3dOU3V4QkFHNEFXV3dOU3NBLy84QUFnQUFBdEFEWHdBaUFBUUFBQUVIQXhzQ0JBQ2dBQWl4QWdHd29MQTFLd0FDLy9zQUFBT3hBcTRBRHdBVEFFQkFQUkVCQVFGTEFBSUFBd2dDQTJjSkFRZ0FCZ1FJQm1jQUFRRUFYd0FBQUROTkFBUUVCVjhIQVFVRk5BVk9FQkFRRXhBVEVSRVJFUkVSRVJBS0NSNHJBU0VWSVJjaEZTRVhJUlVoSnlFSEl5VURJd01CUndKay9uMG9BUy8rOGl3QkZQNTZJdjdFUEpZQjcxQUZrQUt1ZTVkN3BudURnL3dCTi83Si8vLy8rd0FBQTdFRFZRQWlBQjRBQUFFSEF4VUMxUUNnQUFpeEFnR3dvTEExS3dBREFFTUFBQUtmQXE0QUVBQVpBQ0lBUFVBNkNBRUZBZ0ZNQmdFQ0FBVUVBZ1ZuQUFNREFGOEFBQUF6VFFjQkJBUUJYd0FCQVRRQlRoc2FFaEVoSHhvaUd5SVlGaEVaRWhrc0lBZ0pHQ3NUSVRJV0ZoVVVCZ2NWRmhZVkZBWWpJUUV5TmpVMEppTWpGUk15TmpVMEppTWpGVU1CaVRaWU1qOHhPa2wzWFA1M0FXQW9MQ2trMWQ4bU1EQXUxd0t1SzAweU9WTVFCQXRiUGwxakFad3BJQ1lvbC83ZkxDa2xMcWdBQUFFQUt2LzBBcWtDdWdBYUFEWkFNd0FCQWdRQ0FRU0FBQVFEQWdRRGZnQUNBZ0JoQUFBQU8wMEFBd01GWVFZQkJRVThCVTRBQUFBYUFCa1NKQ0lUSXdjSkd5c1dFVFEyTXpJV0ZoVWpOQ1lqSWdZVkZSUXpNalkxTXhRR0JpTXFycDVYaTFHVlZrVmVYTHBKVjVCUWlsa01BV095c1R0NVYwTk5jR2tlMlV4RFdIYzcvLzhBS3YvMEFxa0RWUUFpQUNFQUFBRUhBeFVCK2dDZ0FBaXhBUUd3b0xBMUsvLy9BQ3IvOUFLcEExVUFJZ0FoQUFBQkJ3TVlBaGtBb0FBSXNRRUJzS0N3TlNzQUFRQXEvMGtDcVFLNkFDd0E1N1VQQVFNRUFVeExzQTVRV0VBOEFBY0lBQWdIQUlBQUFBa0lBQWwrQUFJQkJRUUNjZ0FGQkFFRmNBQUlDQVpoQUFZR08wMEtBUWtKQVdFQUFRRThUUUFFQkFOaUFBTURRQU5PRzB1d0VsQllRRDBBQndnQUNBY0FnQUFBQ1FnQUNYNEFBZ0VGQVFJRmdBQUZCQUVGY0FBSUNBWmhBQVlHTzAwS0FRa0pBV0VBQVFFOFRRQUVCQU5pQUFNRFFBTk9HMEErQUFjSUFBZ0hBSUFBQUFrSUFBbCtBQUlCQlFFQ0JZQUFCUVFCQlFSK0FBZ0lCbUVBQmdZN1RRb0JDUWtCWVFBQkFUeE5BQVFFQTJJQUF3TkFBMDVaV1VBU0FBQUFMQUFySWhNbEpDSWtFUklTQ3drZkt5UTJOVE1VQmdjSEZoWVZGQVlqSWljMU16STJOVFFtSXlNM0pCRTBOak15RmhZVkl6UW1JeUlHRlJVVU13SENWNUNYZXdNc05sTTFPREJZRnhZVEZ5a0svdWl1bmxlTFVaVldSVjVjdW05TVEzcUhDQmNDSWlBdEpBZ3hDZzRNREVRYkFVYXlzVHQ1VjBOTmNHa2UyZi8vQUNyLzlBS3BBMVVBSWdBaEFBQUJCd01YQWhrQW9BQUlzUUVCc0tDd05Tdi8vd0FxLy9RQ3FRTnpBQ0lBSVFBQUFRY0RFd0cxQUtBQUNMRUJBYkNnc0RVckFBSUFRd0FBQXFjQ3JnQUlBQklBSmtBakFBTURBRjhBQUFBelRRUUJBZ0lCWHdBQkFUUUJUZ29KRVE4SkVnb1NKQ0FGQ1JnckV5RXlGaFVVQmlNaEpUSTJOVFUwSmlNakVVTUJISjJycTUzKzVBRWNXRnRiV0lzQ3JxdXNyS3Q3YTJJZVltditTQUQvL3dCREFBQUZIQUt1QUNJQUp3QUFBQU1BM1FMU0FBRC8vd0JEQUFBRkhBTlZBQ0lBSndBQUFBTUEzd0xTQUFBQUF2LzRBQUFDcHdLdUFBd0FHZ0EyUURNR0FRRUhBUUFFQVFCbkFBVUZBbDhBQWdJelRRZ0JCQVFEWHdBREF6UURUZzROR1JnWEZoVVREUm9PR2lRaEVSQUpDUm9yRXlNMU14RWhNaFlWRkFZaklTVXlOalUxTkNZakl4VXpGU01WUTB0TEFSeWRxNnVkL3VRQkhGaGJXMWlMa1pFQkpXd0JIYXVzckt0N2EySWVZbXVpYktvQS8vOEFRd0FBQXFjRFZRQWlBQ2NBQUFFSEF4Z0IvQUNnQUFpeEFnR3dvTEExSy8vLy8vZ0FBQUtuQXE0QUFnQXFBQUQvL3dCRC8wb0Nwd0t1QUNJQUp3QUFBQU1ESWdHdEFBRC8vd0JEQUFBRXNBS3VBQ0lBSndBQUFBTUJ4d0xTQUFELy93QkRBQUFFc0FMVEFDSUFKd0FBQUFNQnlRTFNBQUFBQVFCREFBQUNaQUt1QUFzQUtVQW1BQUlBQXdRQ0EyY0FBUUVBWHdBQUFETk5BQVFFQlY4QUJRVTBCVTRSRVJFUkVSQUdDUndyRXlFVklSVWhGU0VWSVJVaFF3SWIvbllCWHY2aUFaRDkzd0t1ZTVkN3Buc0EvLzhBUXdBQUFtUURWUUFpQURBQUFBRUhBeFVCM0FDZ0FBaXhBUUd3b0xBMUsvLy9BRU1BQUFKa0Eya0FJZ0F3QUFBQkJ3TVpBZllBb0FBSXNRRUJzS0N3TlN2Ly93QkRBQUFDWkFOVkFDSUFNQUFBQVFjREdBSDdBS0FBQ0xFQkFiQ2dzRFVyLy84QVF3QUFBbVFEVlFBaUFEQUFBQUVIQXhjQit3Q2dBQWl4QVFHd29MQTFLLy8vQUVNQUFBSmtBOVFBSWdBd0FBQUFKd01YQWZzQW9BRUhBeFVCM0FFZkFCR3hBUUd3b0xBMUs3RUNBYmdCSDdBMUt3RC8vd0JELzBvQ1pBTlZBQ0lBTUFBQUFDTURJZ0daQUFBQkJ3TVhBZnNBb0FBSXNRSUJzS0N3TlN2Ly93QkRBQUFDWkFQVUFDSUFNQUFBQUNjREZ3SDdBS0FCQndNVUFZNEJId0FSc1FFQnNLQ3dOU3V4QWdHNEFSK3dOU3NBLy84QVF3QUFBbVFEL2dBaUFEQUFBQUFuQXhjQit3Q2dBUWNESFFIS0FSOEFFYkVCQWJDZ3NEVXJzUUlCdUFFZnNEVXJBUC8vQUVNQUFBSmtBOTRBSWdBd0FBQUFKd01YQWZzQW9BRUhBeHNCOUFFZkFCR3hBUUd3b0xBMUs3RUNBYmdCSDdBMUt3RC8vd0JEQUFBQ1pBTlZBQ0lBTUFBQUFRY0RIZ0hxQUtBQUNMRUJBckNnc0RVci8vOEFRd0FBQW1RRGN3QWlBREFBQUFFSEF4SUIrUUNnQUFpeEFRS3dvTEExSy8vL0FFTUFBQUprQTNNQUlnQXdBQUFCQndNVEFaY0FvQUFJc1FFQnNLQ3dOU3YvL3dCRC8wb0NaQUt1QUNJQU1BQUFBQU1ESWdHWkFBRC8vd0JEQUFBQ1pBTlZBQ0lBTUFBQUFRY0RGQUdPQUtBQUNMRUJBYkNnc0RVci8vOEFRd0FBQW1RRGZ3QWlBREFBQUFFSEF4MEJ5Z0NnQUFpeEFRR3dvTEExSy8vL0FFTUFBQUprQTNNQUlnQXdBQUFCQndNZkFmY0FvQUFJc1FFQnNLQ3dOU3YvL3dCREFBQUNaQU5RQUNJQU1BQUFBUWNESEFIdEFLQUFDTEVCQWJDZ3NEVXJBQUVBUS85SkFuWUNyZ0FiQUVaQVF3RUJBQWNCVEJVQkFRRkxBQVFBQlFZRUJXY0FBd01DWHdBQ0FqTk5BQVlHQVY4QUFRRTBUUWdCQndjQVlRQUFBRUFBVGdBQUFCc0FHaEVSRVJFUkZTSUpDUjByQlJVR0l5SW1OVFEyTnlFUklSVWhGU0VWSVJVaEZRWUdGUlFXTXdKMkloMHNNQ0VnL2ljQ0cvNTJBVjcrb2dHUUZ4Z1ZGblEzRENrZ0hEb1lBcTU3bDN1bWV4UXJFaEFULy84QVF3QUFBbVFEWHdBaUFEQUFBQUVIQXhzQjlBQ2dBQWl4QVFHd29MQTFLd0FCQUVNQUFBSTBBcTRBQ1FBalFDQUFBZ0FEQkFJRFp3QUJBUUJmQUFBQU0wMEFCQVEwQkU0UkVSRVJFQVVKR3lzVElSVWhGU0VWSVJFalF3SHgvcUFCTy83RmtRS3VlNmw3L3ZFQUFmL2svMG9DTkFLdUFCSUFOVUF5QWdFRkFBRk1BQU1BQkFBREJHY0FBZ0lCWHdBQkFUTk5BQUFBQldFR0FRVUZRQVZPQUFBQUVnQVJFUkVSRWlNSENSc3JGaVluTlRNeU5SRWhGU0VWSVJVaEVSUUdJeXczRVRRckFmSCtvQUU3L3NWSFM3WUtCbUFyQXNsN3FYdit5RHRTQUFBQkFDci85QUxOQXJvQUlBQjN0UjBCQmdNQlRFdXdGRkJZUUNjQUFRSUZBZ0VGZ0FBRkFBUURCUVJuQUFJQ0FHRUFBQUE3VFFBREF3WmhDQWNDQmdZMEJrNGJRQ3NBQVFJRkFnRUZnQUFGQUFRREJRUm5BQUlDQUdFQUFBQTdUUUFHQmpSTkFBTURCMkVJQVFjSFBBZE9XVUFRQUFBQUlBQWZFUkVTSlNJVEpBa0pIU3NXSmpVME5qTXlGaFlWSXpRbUl5SUdGUlVVRmpNeU5qY2pOU0VSSXljR0JpUFhyYmlvV1pOWGxtTkZhV2RmWWxGcUFkQUJZV1FOTUdwTURLNjFzYkkzYjFBNFEzQnBIbTVyVFVKMy9vdE1MaXIvL3dBcS8vUUN6UU5WQUNJQVJnQUFBUWNERlFJSUFLQUFDTEVCQWJDZ3NEVXIvLzhBS3YvMEFzMERhUUFpQUVZQUFBRUhBeGtDSWdDZ0FBaXhBUUd3b0xBMUsvLy9BQ3IvOUFMTkExVUFJZ0JHQUFBQkJ3TVlBaWNBb0FBSXNRRUJzS0N3TlN2Ly93QXEvL1FDelFOVkFDSUFSZ0FBQVFjREZ3SW5BS0FBQ0xFQkFiQ2dzRFVyLy84QUt2N3ZBczBDdWdBaUFFWUFBQUFEQXlRQnJ3QUEvLzhBS3YvMEFzMERjd0FpQUVZQUFBRUhBeE1Cd3dDZ0FBaXhBUUd3b0xBMUt3QUJBRU1BQUFLUEFxNEFDd0FoUUI0QUFRQUVBd0VFWndJQkFBQXpUUVVCQXdNMEEwNFJFUkVSRVJBR0NSd3JFek1SSVJFekVTTVJJUkVqUTVFQktwR1IvdGFSQXE3KzhBRVEvVklCSWY3ZkFBSUFCd0FBQXMwQ3JnQVRBQmNBTmtBekNRY0NCUW9FQWdBTEJRQm5BQXNBQWdFTEFtY0lBUVlHTTAwREFRRUJOQUZPRnhZVkZCTVNFUkVSRVJFUkVSRVFEQWtmS3dFakVTTVJJUkVqRVNNMU16VXpGU0UxTXhVekJ5RVZJUUxOUHBIKzFwRThQSkVCS3BFK3ovN1dBU29CNXY0YUFTSCszd0htYkZ4Y1hGeHNTUC8vQUVNQUFBS1BBMVVBSWdCTkFBQUJCd01YQWc0QW9BQUlzUUVCc0tDd05Tdi8vd0JELzBvQ2p3S3VBQ0lBVFFBQUFBTURJZ0dxQUFBQUFRQkRBQUFBMUFLdUFBTUFFMEFRQUFBQU0wMEFBUUUwQVU0UkVBSUpHQ3NUTXhFalE1R1JBcTc5VXYvL0FFUC85QU1GQXE0QUlnQlJBQUFBQXdCaEFSWUFBUC8vQUVNQUFBRVRBMVVBSWdCUkFBQUJCd01WQVJNQW9BQUlzUUVCc0tDd05Tdi8vLy9xQUFBQkxRTnBBQ0lBVVFBQUFRY0RHUUV0QUtBQUNMRUJBYkNnc0RVci8vLy81UUFBQVRJRFZRQWlBRkVBQUFFSEF4Z0JNZ0NnQUFpeEFRR3dvTEExSy8vLy8rVUFBQUV5QTFVQUlnQlJBQUFCQndNWEFUSUFvQUFJc1FFQnNLQ3dOU3YvLy8rZEFBQUJJUU5WQUNJQVVRQUFBUWNESGdFaEFLQUFDTEVCQXJDZ3NEVXIvLy8vNXdBQUFUQURjd0FpQUZFQUFBRUhBeElCTUFDZ0FBaXhBUUt3b0xBMUsvLy9BRU1BQUFEVUEzTUFJZ0JSQUFBQkJ3TVRBTTRBb0FBSXNRRUJzS0N3TlN2Ly93QkQvMG9BMUFLdUFDSUFVUUFBQUFNRElnRFBBQUQvL3dBRkFBQUExQU5WQUNJQVVRQUFBUWNERkFERkFLQUFDTEVCQWJDZ3NEVXIvLzhBT1FBQUFRRURmd0FpQUZFQUFBRUhBeDBCQVFDZ0FBaXhBUUd3b0xBMUsvLy8vK3NBQUFFdUEzTUFJZ0JSQUFBQkJ3TWZBUzRBb0FBSXNRRUJzS0N3TlN2Ly8vL3pBQUFCSkFOUUFDSUFVUUFBQVFjREhBRWtBS0FBQ0xFQkFiQ2dzRFVyQUFFQUxQOUpBTlFDcmdBVUFDZEFKQWNCQVFBQlRBQURBek5OQkFFQ0FqUk5BQUFBQVdFQUFRRkFBVTRSRVJVaUpBVUpHeXNXQmhVVUZqTXpGUVlqSWlZMU5EWTNJeEV6RVNPZUdCVVdGaU1jTERBaElDcVJIeFFyRWhBVE53d3BJQnc2R0FLdS9WTC8vLy92QUFBQkt3TmZBQ0lBVVFBQUFRY0RHd0VyQUtBQUNMRUJBYkNnc0RVckFBRUFHZi8wQWU4Q3JnQVJBRXRMc0FwUVdFQVlBQUFDQVFFQWNnQUNBak5OQUFFQkEySUVBUU1EUEFOT0cwQVpBQUFDQVFJQUFZQUFBZ0l6VFFBQkFRTmlCQUVEQXp3RFRsbEFEQUFBQUJFQUVCTWpFd1VKR1NzV0pqVTFNeFVVRmpNeU5qVVJNeEVVQmlPVGVwQXZMU3dza25oeURHaGxLeWtwTEN3cEFlditFMlZvLy84QVEvLzBBMEFEVlFBaUFGRUFBQUFuQXhVQkV3Q2dBQ01BWVFFV0FBQUJCd01WQTBBQW9BQVFzUUVCc0tDd05TdXhBd0d3b0xBMUsvLy9BQm4vOUFKSkExVUFJZ0JoQUFBQkJ3TVhBa2tBb0FBSXNRRUJzS0N3TlNzQUFRQkRBQUFDeFFLdUFBc0FJRUFkQ1FnRkFnUUNBQUZNQVFFQUFETk5Bd0VDQWpRQ1RoTVNFaEFFQ1JvckV6TVJBVE1CQVNNREJ4VWpRNUVCUGJEKzlBRVFyTVdBa1FLdS9yVUJTLzdwL21rQk1XckhBUC8vQUVQKzd3TEZBcTRBSWdCa0FBQUFBd01rQVo0QUFBQUJBRU1BQUFKR0FxNEFCUUFaUUJZQUFBQXpUUUFCQVFKZ0FBSUNOQUpPRVJFUUF3a1pLeE16RVNFVklVT1JBWEw5L1FLdS9kQisvLzhBUS8vMEJGSUNyZ0FpQUdZQUFBQURBR0VDWXdBQS8vOEFRd0FBQWtZRFZRQWlBR1lBQUFFSEF4VUJFZ0NnQUFpeEFRR3dvTEExSy8vL0FFTUFBQUpHQXRNQUlnQm1BQUFBQXdMdEFjSUFBUC8vQUVQKzd3SkdBcTRBSWdCbUFBQUFBd01rQVlZQUFQLy9BRU1BQUFKR0FxNEFJZ0JtQUFBQkJ3SmhBV0wvNVFBSnNRRUJ1UC9sc0RVckFQLy9BRVAvU2dNekF0TUFJZ0JtQUFBQUF3RktBbU1BQUFBQkFBQUFBQUpHQXE0QURRQW1RQ01KQ0FjR0F3SUJBQWdCQUFGTUFBQUFNMDBBQVFFQ1lBQUNBalFDVGhFVkZBTUpHU3MzQnpVM0VUTVJOeFVIRlNFVklVTkRRNUdob1FGeS9mM2lMV1l0QVdiKy9XMW1iY2QrQUFBQkFFTUFBQUwrQXE0QUdRQWhRQjRVRGdRREFnQUJUQUVCQUFBelRRUURBZ0lDTkFKT0ZoWVJGeEFGQ1JzckV6TVRGaGN6TmpjVE14RWpFVFEzSXdjREl3TW5JeFlWRVNORDRtQUxGUVVTQ21EWWtRWUZGWGFLZGhVRkJvd0NydjZHSzNCMUpnRjYvVklCdFIxUlVmNHVBZEpSVkJyK1N3QUJBRU1BQUFLUEFxNEFFZ0FlUUJzTkJBSUNBQUZNQVFFQUFETk5Bd0VDQWpRQ1RoY1JGaEFFQ1JvckV6TUJGaGMzSnhFekVTTUJKaWNIRmhVUkkwT05BUWdNSEFVRGpZMys5eE1VQlFPTkFxNytpeEV5QXpvQmUvMVNBWGdiSndNckVmNkZBUC8vQUVQLzlBVEJBcTRBSWdCdkFBQUFBd0JoQXRJQUFQLy9BRU1BQUFLUEExVUFJZ0J2QUFBQkJ3TVZBZllBb0FBSXNRRUJzS0N3TlN2Ly93QkRBQUFDandOVkFDSUFid0FBQVFjREdBSVZBS0FBQ0xFQkFiQ2dzRFVyLy84QVEvN3ZBbzhDcmdBaUFHOEFBQUFEQXlRQnBRQUEvLzhBUXdBQUFvOERjd0FpQUc4QUFBRUhBeE1Cc1FDZ0FBaXhBUUd3b0xBMUt3QUJBRVAvU2dLUEFxNEFIQUEzUURRVUNnSUJBZ0lCQkFBQ1RBY0JBUUZMQXdFQ0FqTk5BQUVCTkUwQUFBQUVZZ1VCQkFSQUJFNEFBQUFjQUJzV0VSa2pCZ2thS3dRbUp6VXpNalUxQVNZbkJ4WVZFU01STXdFV0Z6Y25FVE1SRkFZakFlNDVFalFyL3ZjVEZBVURqWTBCQ0F3Y0JRT05RRXEyQ2daZ0t4c0JkUnNuQXlzUi9vZ0NydjZPRVRJRE9nRjQvU2s5VUFBQi8rVC9TZ0tQQXE0QUd3QXlRQzhVQ3dJREFRSUJCQUFDVEFJQkFRRXpUUUFEQXpSTkFBQUFCR0lGQVFRRVFBUk9BQUFBR3dBYUVSWVNJd1lKR2lzV0ppYzFNekkxRVRNQkZoYzNKeEV6RVNNQkppY0hGaFVSRkFZakx6a1NOQ3VOQVFnTUhBVURqWTMrOXhNVUJRTkFTcllLQm1BckFzbitpeEV5QXpvQmUvMVNBWGdiSndNckVmNWNQVkQvL3dCRC8wb0RvZ0xUQUNJQWJ3QUFBQU1CU2dMU0FBRC8vd0JEQUFBQ2p3TmZBQ0lBYndBQUFRY0RHd0lPQUtBQUNMRUJBYkNnc0RVckFBSUFLdi8wQXVFQ3VnQUxBQmtBTEVBcEFBSUNBR0VBQUFBN1RRVUJBd01CWVFRQkFRRThBVTRNREFBQURCa01HQk1SQUFzQUNpUUdDUmNyRmlZMU5EWXpNaFlWRkFZak5qWTFOVFFtSXlJR0ZSVVVGalBndHJhbHByYTJwbUpsWldKaVpHUmlETEd5c3JHeHNyS3hlM0ZvSG1oeGNXZ2VhSEgvL3dBcS8vUUM0UU5WQUNJQWVRQUFBUWNERlFJTUFLQUFDTEVDQWJDZ3NEVXIvLzhBS3YvMEF1RURhUUFpQUhrQUFBRUhBeGtDSmdDZ0FBaXhBZ0d3b0xBMUsvLy9BQ3IvOUFMaEExVUFJZ0I1QUFBQkJ3TVlBaXNBb0FBSXNRSUJzS0N3TlN2Ly93QXEvL1FDNFFOVkFDSUFlUUFBQVFjREZ3SXJBS0FBQ0xFQ0FiQ2dzRFVyLy84QUt2LzBBdUVEMUFBaUFIa0FBQUFuQXhjQ0t3Q2dBUWNERlFJTUFSOEFFYkVDQWJDZ3NEVXJzUU1CdUFFZnNEVXJBUC8vQUNyL1NnTGhBMVVBSWdCNUFBQUFJd01pQWRjQUFBRUhBeGNDS3dDZ0FBaXhBd0d3b0xBMUsvLy9BQ3IvOUFMaEE5UUFJZ0I1QUFBQUp3TVhBaXNBb0FFSEF4UUJ2Z0VmQUJHeEFnR3dvTEExSzdFREFiZ0JIN0ExS3dELy93QXEvL1FDNFFQK0FDSUFlUUFBQUNjREZ3SXJBS0FCQndNZEFmb0JId0FSc1FJQnNLQ3dOU3V4QXdHNEFSK3dOU3NBLy84QUt2LzBBdUVEM2dBaUFIa0FBQUFuQXhjQ0t3Q2dBUWNER3dJa0FSOEFFYkVDQWJDZ3NEVXJzUU1CdUFFZnNEVXJBUC8vQUNyLzlBTGhBMVVBSWdCNUFBQUJCd01lQWhvQW9BQUlzUUlDc0tDd05Tdi8vd0FxLy9RQzRRTnpBQ0lBZVFBQUFRY0RFZ0lwQUtBQUNMRUNBckNnc0RVci8vOEFLdi8wQXVFRUZRQWlBSGtBQUFBbkF4SUNLUUNnQVFjREhBSWRBV1VBRWJFQ0FyQ2dzRFVyc1FRQnVBRmxzRFVyQVAvL0FDci85QUxoQkJVQUlnQjVBQUFBSndNVEFjY0FvQUVIQXh3Q0hRRmxBQkd4QWdHd29MQTFLN0VEQWJnQlpiQTFLd0QvL3dBcS8wb0M0UUs2QUNJQWVRQUFBQU1ESWdIWEFBRC8vd0FxLy9RQzRRTlZBQ0lBZVFBQUFRY0RGQUcrQUtBQUNMRUNBYkNnc0RVci8vOEFLdi8wQXVFRGZ3QWlBSGtBQUFFSEF4MEIrZ0NnQUFpeEFnR3dvTEExS3dBQ0FDci85QUxoQTA0QUZRQWpBR1pMc0JSUVdMVVZBUVFCQVV3YnRSVUJCQUlCVEZsTHNCUlFXRUFiQUFNQkE0VUFCQVFCWVFJQkFRRTdUUUFGQlFCaUFBQUFQQUJPRzBBZkFBTUJBNFVBQWdJelRRQUVCQUZoQUFFQk8wMEFCUVVBWWdBQUFEd0FUbGxBQ1NVbkVpRWtJd1lKSENzQUZSUUdJeUltTlRRMk16SVhNekkxTlRNVkZBWUhBelFtSXlJR0ZSVVVGak15TmpVQzRiYW1wYmEycFQwelJ5dHBMeXdwWldKaVpHUmlZbVVDR01HeXNiR3lzckVNTld0ckxEc0wvdlZvY1hGb0htaHhjV2dBLy84QUt2LzBBdUVEVlFBaUFJb0FBQUVIQXhVQ0RBQ2dBQWl4QWdHd29MQTFLLy8vQUNyL1NnTGhBMDRBSWdDS0FBQUFBd01pQWRjQUFQLy9BQ3IvOUFMaEExVUFJZ0NLQUFBQkJ3TVVBYjRBb0FBSXNRSUJzS0N3TlN2Ly93QXEvL1FDNFFOL0FDSUFpZ0FBQVFjREhRSDZBS0FBQ0xFQ0FiQ2dzRFVyLy84QUt2LzBBdUVEWHdBaUFJb0FBQUVIQXhzQ0pBQ2dBQWl4QWdHd29MQTFLLy8vQUNyLzlBTGhBMVVBSWdCNUFBQUJCd01XQW5RQW9BQUlzUUlDc0tDd05Tdi8vd0FxLy9RQzRRTnpBQ0lBZVFBQUFRY0RId0luQUtBQUNMRUNBYkNnc0RVci8vOEFLdi8wQXVFRFVBQWlBSGtBQUFFSEF4d0NIUUNnQUFpeEFnR3dvTEExS3dBQ0FDci9TUUxoQXJvQUdnQW9BRE5BTUFrQkFnRUJUQUFHQmdSaEFBUUVPMDBBQlFVQVlRTUJBQUE4VFFBQkFRSmhBQUlDUUFKT0pTUWtGU0lrRVFjSkhTc2tCZ2NHRlJRV016TVZCaU1pSmpVME5qY21KalUwTmpNeUZoVUVGak15TmpVMU5DWWpJZ1lWRlFMaG81WWpGUllXSWgwc01Cb2FsS0cycGFhMi9kNWtZbUpsWldKaVpMQ3lDU1VoRUJNM0RDa2dHVE1YQ3JHbnNyR3hzbmR4Y1dnZWFIRnhhQjRBQUFNQUt2L1FBdUVDMHdBVEFCd0FKUUErUURzVEVBSUVBaUFmRmhVRUJRUUpCZ0lBQlFOTUFBRUFBWVlBQXdNMVRRQUVCQUpoQUFJQ08wMEFCUVVBWVFBQUFEd0FUaWdsRWlVU0l3WUpIQ3NBRlJRR0l5SW5CeU0zSmpVME5qTXlGemN6QndBWEFTWWpJZ1lWRlNVMEp3RVdNekkyTlFMaHRxWnZUemxmVzJDMnBYRk5NVjVTL2o4aUFSRXRRR0prQVkwai92QXRQMkpsQWd5MXNyRW9USGhidExLeEtFRnMvb28wQVdrWmNXZ2VIbGMxL3BZWmNXZ0EvLzhBS3YvUUF1RURWUUFpQUpRQUFBRUhBeFVDQ0FDZ0FBaXhBd0d3b0xBMUsvLy9BQ3IvOUFMaEExOEFJZ0I1QUFBQkJ3TWJBaVFBb0FBSXNRSUJzS0N3TlN2Ly93QXEvL1FDNFFQd0FDSUFlUUFBQUNjREd3SWtBS0FCQndNY0FoNEJRQUFSc1FJQnNLQ3dOU3V4QXdHNEFVQ3dOU3NBQUFJQUt2LzBBN0VDdWdBV0FDSUFtMHV3RkZCWVFBb0hBUUlBRkFFR0JRSk1HMEFLQndFSUFSUUJCZ2tDVEZsTHNCUlFXRUFqQUFNQUJBVURCR2NJQVFJQ0FHRUJBUUFBTzAwTENRSUZCUVpoQ2djQ0JnWTBCazRiUURNQUF3QUVCUU1FWndBSUNBQmhBQUFBTzAwQUFnSUJYd0FCQVROTkFBVUZCbDhBQmdZMFRRc0JDUWtIWVFvQkJ3YzhCMDVaUUJnWEZ3QUFGeUlYSVIwYkFCWUFGUkVSRVJFUkVpUU1DUjByRmlZMU5EWXpNaGMxSVJVaEZTRVZJUlVoRlNFMUJpTTJOalUwSmlNaUJoVVVGak81ajQrQWJFVUJ3ZjdRQVFUKy9BRTIvamxJYVdaTFMwaFFTRWhRRExlc3JMZENObnVYZTZaN05VRjdiWHQ3YlhGM2QzRUFBQUlBUXdBQUFuRUNyZ0FLQUJNQUtrQW5CUUVEQUFFQ0F3Rm5BQVFFQUY4QUFBQXpUUUFDQWpRQ1Rnd0xFaEFMRXd3VEVTUWdCZ2taS3hNaE1oWVZGQVlqSXhVakFUSTJOVFFtSXlNVlF3RkhjM1I1ZUt5UkFUb3ZNakl2cVFLdWRXdHJkK3dCWnpZeE1EWE1BQUlBUXdBQUFuRUNyZ0FNQUJVQUxrQXJBQUVBQlFRQkJXY0dBUVFBQWdNRUFtY0FBQUF6VFFBREF6UURUZzRORkJJTkZRNFZFU1FoRUFjSkdpc1RNeFV6TWhZVkZBWWpJeFVqSlRJMk5UUW1JeU1WUTVHMmMzUjVlS3lSQVRvdk1qSXZxUUt1YTNWcmEzZUIvRFl4TURYTUFBSUFLdjkrQXVFQ3VnQVFBQjRBTVVBdURnRUFCQUZNQUFJQUFvWUFBd01CWVFBQkFUdE5CUUVFQkFCaEFBQUFQQUJPRVJFUkhoRWRKaFlrSVFZSkdpc0ZCaU1pSmpVME5qTXlGaFVVQmdjWEl5WTJOVFUwSmlNaUJoVVZGQll6QWFBSkVxVzJ0cVdtdGxwVm5MOG9aV1ZpWW1Sa1lnc0JzYkt5c2JHeWZLSWxsdkZ4YUI1b2NYRm9IbWh4QUFBQ0FFTUFBQUtxQXE0QURBQVZBREpBTHdZQkFnUUJUQVlCQkFBQ0FRUUNad0FGQlFCZkFBQUFNMDBEQVFFQk5BRk9EZzBVRWcwVkRoVVJFUlVnQndrYUt4TWhNaFlWRkFjVEl3TWpFU01CTWpZMU5DWWpJeFZEQVd4emRIaU1uWG5Ba1FGZkx6SXlMODRDcm5GbWtERCs2UUVBL3dBQmVUSXNMREM2QVAvL0FFTUFBQUtxQTFVQUlnQ2NBQUFCQndNVkFkTUFvQUFJc1FJQnNLQ3dOU3YvL3dCREFBQUNxZ05WQUNJQW5BQUFBUWNER0FIeUFLQUFDTEVDQWJDZ3NEVXIvLzhBUS83dkFxb0NyZ0FpQUp3QUFBQURBeVFCb2dBQS8vOEFRd0FBQXFvRFZRQWlBSndBQUFFSEF4NEI0UUNnQUFpeEFnS3dvTEExSy8vL0FFUC9TZ0txQXE0QUlnQ2NBQUFBQXdNaUFhd0FBUC8vQUVNQUFBS3FBM01BSWdDY0FBQUJCd01mQWU0QW9BQUlzUUlCc0tDd05Tc0FBUUFxLy9RQ2J3SzZBQzRBTmtBekFBTUVBQVFEQUlBQUFBRUVBQUYrQUFRRUFtRUFBZ0k3VFFBQkFRVmhCZ0VGQlR3RlRnQUFBQzRBTFNNVExDTVVCd2tiS3hZbUpqVTNNd2NVRmpNeU5qVTBKaVluTGdJMU5EWXpNaFlWRlNNMU5DWWpJZ1lWRkJZV0Z4NENGUlFHSS91RFRnR1RBVTVHU2tJclFUbFJaRWlZZm5lWGtFVTdQME1vUERkU2FVeWRpQXd4WUVRV0VDdzBKeUVkSnhjUUZ5cFRSRjVpWldVTUNTWXNJaDRYSVJVUEZpdFVSRzVvLy84QUt2LzBBbThEVlFBaUFLTUFBQUVIQXhVQjF3Q2dBQWl4QVFHd29MQTFLd0FCQURFQXp3QzNBcTRBQkFBWlFCWUNBUUVBQVV3QUFRRUFYd0FBQURNQlRoSVFBZ2tZS3hNekZRTWpNWVlyV3dLdWVQNlpBUC8vQUNyLzlBSnZBMVVBSWdDakFBQUJCd01ZQWZZQW9BQUlzUUVCc0tDd05Tc0FBUUFxLzBrQ2J3SzZBRUFBaUxVTEFRRUNBVXhMc0E1UVdFQXpBQWNJQkFnSEJJQUFCQVVJQkFWK0FBQUZBd0lBY2dBRkFBTUNCUU5wQUFnSUJtRUFCZ1k3VFFBQ0FnRmlBQUVCUUFGT0cwQTBBQWNJQkFnSEJJQUFCQVVJQkFWK0FBQUZBd1VBQTRBQUJRQURBZ1VEYVFBSUNBWmhBQVlHTzAwQUFnSUJZZ0FCQVVBQlRsbEFEQ01UTENNVkpDSWtFd2tKSHlza0JnY0hGaFlWRkFZaklpYzFNekkyTlRRbUl5TTNKaVkxTnpNSEZCWXpNalkxTkNZbUp5NENOVFEyTXpJV0ZSVWpOVFFtSXlJR0ZSUVdGaGNlQWhVQ2IzOXhBeXcyVXpVNE1GZ1hGaE1YS1FwdmtRR1RBVTVHU2tJclFUbFJaRWlZZm5lWGtFVTdQME1vUERkU2FVeG5hQWtZQWlJZ0xTUUlNUW9PREF4RENHNWVGaEFzTkNjaEhTY1hFQmNxVTBSZVltVmxEQWttTENJZUZ5RVZEeFlyVkVULy93QXEvL1FDYndOVkFDSUFvd0FBQVFjREZ3SDJBS0FBQ0xFQkFiQ2dzRFVyLy84QUt2N3ZBbThDdWdBaUFLTUFBQUFEQXlRQmtRQUEvLzhBS3Y5S0FtOEN1Z0FpQUtNQUFBQURBeUlCbXdBQUFBRUFRd0FBQXVzQ3VnQXBBREZBTGdvQkF3UUJUQUFFQUFNQ0JBTm5BQVVGQUdFQUFBQTdUUUFDQWdGZkJnRUJBVFFCVGhNa0lTUWhMU0lIQ1IwckV6UTJNeklXRmhVVUJnY1ZGaFlWRkFZR0l5TTFNekkyTlRRbUl5TTFNekkyTlRRbUl5SUdGUkVqUTdXbFdJaE1OQ2M2UXpabFJPUFdLUzQ1TXNLL0l5bElSR3Bxa1FHSGw1d3hXand5VXc4RUQxTThObFl4ZlM0ZklpbDlOQ0FwTUY1aC9vQUFBZ0FxLy9RQ3hnSzZBQlFBR3dBL1FEd0FBZ0VBQVFJQWdBQUFBQVVHQUFWbkFBRUJBMkVBQXdNN1RRZ0JCZ1lFWVFjQkJBUThCRTRWRlFBQUZSc1ZHaGdYQUJRQUV5SVNJaE1KQ1JvckZpWTFOU0VtSmlNaUJoVWpORFl6TWhZVkZBWWpOalkzSVJRV005S29BZ1lGWG1GUllvK3hsYXlxcGFsWVZBcitsR0pXREtld01HZGtSRVI5ZjYrNHM2eDFVRmhYVVFBQUFRQVZBQUFDVGdLdUFBY0FHMEFZQWdFQUFBRmZBQUVCTTAwQUF3TTBBMDRSRVJFUUJBa2FLeE1qTlNFVkl4RWo2ZFFDT2RTUkFqRjlmZjNQQUFBQkFCVUFBQUpPQXE0QUR3QXBRQ1lGQVFFR0FRQUhBUUJuQkFFQ0FnTmZBQU1ETTAwQUJ3YzBCMDRSRVJFUkVSRVJFQWdKSGlzVEl6VXpOU00xSVJVakZUTVZJeEVqNlphVzFBSTUxSmFXa1FFZFo2MTlmYTFuL3VNQS8vOEFGUUFBQWs0RFZRQWlBSzBBQUFFSEF4Z0IyQUNnQUFpeEFRR3dvTEExS3dBQkFCWC9TUUpPQXE0QUd3Qjl0UWtCQVFJQlRFdXdEbEJZUUNzQUFBUURBZ0J5QUFNQ0JBTUNmZ2NCQlFVR1h3QUdCak5OQ1FnQ0JBUTBUUUFDQWdGaUFBRUJRQUZPRzBBc0FBQUVBd1FBQTRBQUF3SUVBd0orQndFRkJRWmZBQVlHTTAwSkNBSUVCRFJOQUFJQ0FXSUFBUUZBQVU1WlFCRUFBQUFiQUJzUkVSRVJKQ0lrRVFvSkhpc2hCeFlXRlJRR0l5SW5OVE15TmpVMEppTWpOeU1SSXpVaEZTTVJBVndGTERaVE5UZ3dXQmNXRXhjcERCN1VBam5VSWdJaUlDMGtDREVLRGd3TVRnSXhmWDM5endELy93QVYvdThDVGdLdUFDSUFyUUFBQUFNREpBRnNBQUQvL3dBVi8wb0NUZ0t1QUNJQXJRQUFBQU1ESWdGMkFBQUFBUUJELy9RQ2p3S3VBQkVBSVVBZUFnRUFBRE5OQUFFQkEyRUVBUU1EUEFOT0FBQUFFUUFRRXlNVEJRa1pLeFltTlJFekVSUVdNekkyTlJFekVSUUdJOTJha1UxSFIwK1JtNHdNaUlNQnIvNVlTazFOU2dHby9sR0RpUC8vQUVQLzlBS1BBMVVBSWdDekFBQUJCd01WQWZBQW9BQUlzUUVCc0tDd05Tdi8vd0JELy9RQ2p3TnBBQ0lBc3dBQUFRY0RHUUlLQUtBQUNMRUJBYkNnc0RVci8vOEFRLy8wQW84RFZRQWlBTE1BQUFFSEF4Z0NEd0NnQUFpeEFRR3dvTEExSy8vL0FFUC85QUtQQTFVQUlnQ3pBQUFCQndNWEFnOEFvQUFJc1FFQnNLQ3dOU3YvL3dCRC8vUUNqd05WQUNJQXN3QUFBUWNESGdIK0FLQUFDTEVCQXJDZ3NEVXIvLzhBUS8vMEFvOERjd0FpQUxNQUFBRUhBeElDRFFDZ0FBaXhBUUt3b0xBMUsvLy9BRVAvOUFLUEJCb0FJZ0N6QUFBQUp3TVNBZzBBb0FFSEF4VUI4QUZsQUJHeEFRS3dvTEExSzdFREFiZ0JaYkExS3dELy93QkQvL1FDandRYUFDSUFzd0FBQUNjREVnSU5BS0FCQndNWUFnOEJaUUFSc1FFQ3NLQ3dOU3V4QXdHNEFXV3dOU3NBLy84QVEvLzBBbzhFR2dBaUFMTUFBQUFuQXhJQ0RRQ2dBUWNERkFHaUFXVUFFYkVCQXJDZ3NEVXJzUU1CdUFGbHNEVXJBUC8vQUVQLzlBS1BCQlVBSWdDekFBQUFKd01TQWcwQW9BRUhBeHdDQVFGbEFCR3hBUUt3b0xBMUs3RURBYmdCWmJBMUt3RC8vd0JELzBvQ2p3S3VBQ0lBc3dBQUFBTURJZ0dyQUFELy93QkQvL1FDandOVkFDSUFzd0FBQVFjREZBR2lBS0FBQ0xFQkFiQ2dzRFVyLy84QVEvLzBBbzhEZndBaUFMTUFBQUVIQXgwQjNnQ2dBQWl4QVFHd29MQTFLd0FCQUVQLzlBTDRBMDRBR1FBdFFDb0VBUUlCQVV3RkFRUUJCSVVEQVFFQk0wMEFBZ0lBWVFBQUFEd0FUZ0FBQUJrQUdTTWpFeWNHQ1JvckFSVVVCZ2NSRkFZaklpWTFFVE1SRkJZek1qWTFFVE15TlRVQytEY3ltNHlMbXBGTlIwZFBaaXNEVG1zdlBRcitrb09JaUlNQnIvNVlTazFOU2dHb05Xdi8vd0JELy9RQytBTlZBQ0lBd1FBQUFRY0RGUUh3QUtBQUNMRUJBYkNnc0RVci8vOEFRLzlLQXZnRFRnQWlBTUVBQUFBREF5SUJxd0FBLy84QVEvLzBBdmdEVlFBaUFNRUFBQUVIQXhRQm9nQ2dBQWl4QVFHd29MQTFLLy8vQUVQLzlBTDRBMzhBSWdEQkFBQUJCd01kQWQ0QW9BQUlzUUVCc0tDd05Tdi8vd0JELy9RQytBTmZBQ0lBd1FBQUFRY0RHd0lJQUtBQUNMRUJBYkNnc0RVci8vOEFRLy8wQW84RFZRQWlBTE1BQUFFSEF4WUNXQUNnQUFpeEFRS3dvTEExSy8vL0FFUC85QUtQQTNNQUlnQ3pBQUFCQndNZkFnc0FvQUFJc1FFQnNLQ3dOU3YvL3dCRC8vUUNqd05RQUNJQXN3QUFBUWNESEFJQkFLQUFDTEVCQWJDZ3NEVXJBQUVBUS85SkFvOENyZ0FpQUROQU1Bd0JBUUFCVEFZRkFnTURNMDBBQkFRQ1lRQUNBanhOQUFBQUFXRUFBUUZBQVU0QUFBQWlBQ0lqRXlVaUtRY0pHeXNCRVJRR0J3WUdGUlFXTXpNVkJpTWlKalUwTmpjaklpWTFFVE1SRkJZek1qWTFFUUtQWTEwV0dCVVdGaUlkTERBYUdSS0xtcEZOUjBkUEFxNytVV2lDRmhRcUVoQVROd3dwSUJnekY0aURBYS8rV0VwTlRVb0JxUC8vQUVQLzlBS1BBNVlBSWdDekFBQUJCd01hQWM4QW9BQUlzUUVDc0tDd05Tdi8vd0JELy9RQ2p3TmZBQ0lBc3dBQUFRY0RHd0lJQUtBQUNMRUJBYkNnc0RVckFBRUFCQUFBQXBZQ3JnQUxBQnRBR0FRQkFnQUJUQUVCQUFBelRRQUNBalFDVGhFWEVBTUpHU3NUTXhNV0Z6TTJOeE16QXlNRW5ZRUxJZ1VnQzRDWCtLSUNydjZJSUc1dUlBRjQvVklBQUFFQUFnQUFBNjRDcmdBYkFDRkFIaFlNQkFNREFBRk1BZ0VDQUFBelRRUUJBd00wQTA0WEVSY1hFQVVKR3lzVE14TVdGek0yTnhNekV4WVhNelkzRXpNREl3TW1KeU1HQndNakFwdGpCd2tGQ1FkbHIyUUdDZ1VJQ0dhR3RwMXhDUWdFQ2dkdm5RS3UvbG9jUkVRY0FhYitXaHBHUUNBQnB2MVNBYlVoUUVVYy9rc0EvLzhBQWdBQUE2NERWUUFpQU00QUFBRUhBeFVDWUFDZ0FBaXhBUUd3b0xBMUsvLy9BQUlBQUFPdUExVUFJZ0RPQUFBQkJ3TVhBbjhBb0FBSXNRRUJzS0N3TlN2Ly93QUNBQUFEcmdOekFDSUF6Z0FBQVFjREVnSjlBS0FBQ0xFQkFyQ2dzRFVyLy84QUFnQUFBNjREVlFBaUFNNEFBQUVIQXhRQ0VnQ2dBQWl4QVFHd29MQTFLd0FCQUFBQUFBS2FBcTRBRFFBZlFCd0tCd01EQWdBQlRBRUJBQUF6VFFNQkFnSTBBazRURWhNUkJBa2FLeE1ETXhjek56TURFeU1ESXdNajdkZXdpd1dLcE5qdXI2SUZvS1FCYUFGRzN0Nyt2UDZXQVFMKy9nQUFBUUFBQUFBQ213S3VBQWtBSFVBYUJ3TUFBd0lBQVV3QkFRQUFNMDBBQWdJMEFrNFNFeEVEQ1JrckFRRXpFek1UTXdFUkl3RUcvdnFscXdXcG5mNzhrUUVWQVpuKzZBRVkvbWYrNndELy93QUFBQUFDbXdOVkFDSUExQUFBQVFjREZRSFpBS0FBQ0xFQkFiQ2dzRFVyLy84QUFBQUFBcHNEVlFBaUFOUUFBQUVIQXhjQitBQ2dBQWl4QVFHd29MQTFLLy8vQUFBQUFBS2JBM01BSWdEVUFBQUJCd01TQWZZQW9BQUlzUUVDc0tDd05Tdi8vd0FBLzBvQ213S3VBQ0lBMUFBQUFBTURJZ0dVQUFELy93QUFBQUFDbXdOVkFDSUExQUFBQVFjREZBR0xBS0FBQ0xFQkFiQ2dzRFVyLy84QUFBQUFBcHNEZndBaUFOUUFBQUVIQXgwQnh3Q2dBQWl4QVFHd29MQTFLLy8vQUFBQUFBS2JBMUFBSWdEVUFBQUJCd01jQWVvQW9BQUlzUUVCc0tDd05Tdi8vd0FBQUFBQ213TmZBQ0lBMUFBQUFRY0RHd0h4QUtBQUNMRUJBYkNnc0RVckFBRUFFUUFBQWtvQ3JnQUpBQ2xBSmdVQkFBRUFBUU1DQWt3QUFBQUJYd0FCQVROTkFBSUNBMThBQXdNMEEwNFJFaEVSQkFrYUt6Y0JJVFVoRlFFaEZTRVJBVnYrdndJVy9xWUJZLzNIUkFIdmUwWCtFbnYvL3dBUkFBQUNTZ05WQUNJQTNRQUFBUWNERlFHOUFLQUFDTEVCQWJDZ3NEVXIvLzhBRVFBQUFrb0RWUUFpQU4wQUFBRUhBeGdCM0FDZ0FBaXhBUUd3b0xBMUsvLy9BQkVBQUFKS0EzTUFJZ0RkQUFBQkJ3TVRBWGdBb0FBSXNRRUJzS0N3TlN2Ly93QVIvMG9DU2dLdUFDSUEzUUFBQUFNRElnRjJBQUFBQVFCRC8vUUNXQUt1QUNBQVo3VUxBUUlFQVV4THNCZFFXRUFoQUFBQ0FRRUFjZ0FFQUFJQUJBSnFCUUVEQXpOTkFBRUJCbUlIQVFZR1BBWk9HMEFpQUFBQ0FRSUFBWUFBQkFBQ0FBUUNhZ1VCQXdNelRRQUJBUVppQndFR0Jqd0dUbGxBRHdBQUFDQUFIeE1qRXlVaUlnZ0pIQ3NXSmpVMU14UVdNekkyTlRVakJpTWlKalUxTXhVVUZqTXlOalUxTXhFVUJpUEpocEU1TlQ5R0JESjNhMnlST0RSQ1JaR1NoQXhZVlFjY0hUNDdPRkI3Y3ZIME5qbGNXYTcrVUlLSUFQLy9BRVAvOUFKWUExVUFJZ0RpQUFBQkJ3TVZBYzRBb0FBSXNRRUJzS0N3TlN2Ly93QkQvL1FDV0FOVkFDSUE0Z0FBQVFjREZ3SHRBS0FBQ0xFQkFiQ2dzRFVyLy84QVEvLzBBbGdEY3dBaUFPSUFBQUVIQXhJQjZ3Q2dBQWl4QVFLd29MQTFLLy8vQUVQLzlBSllBMVVBSWdEaUFBQUJCd01VQVlBQW9BQUlzUUVCc0tDd05Tdi8vd0JELy9RQ1dBTlFBQ0lBNGdBQUFRY0RIQUhmQUtBQUNMRUJBYkNnc0RVci8vOEFRLy8wQWxnRFh3QWlBT0lBQUFFSEF4c0I1Z0NnQUFpeEFRR3dvTEExSy8vL0FDci85QUtwQTVFQUlnQWhBQUFCQndNcEFUWUFvQUFJc1FFQnNLQ3dOU3YvL3dCREFBQUNqd09SQUNJQWJ3QUFBUWNES1FFeUFLQUFDTEVCQWJDZ3NEVXIvLzhBS3YvMEF1RURrUUFpQUhrQUFBRUhBeWtCU0FDZ0FBaXhBZ0d3b0xBMUsvLy9BQ3IvOUFKdkE1RUFJZ0NqQUFBQkJ3TXBBUk1Bb0FBSXNRRUJzS0N3TlN2Ly93QVJBQUFDU2dPUkFDSUEzUUFBQVFjREtRRDVBS0FBQ0xFQkFiQ2dzRFVyQUFJQUhmLzBBaU1DR2dBbEFDNEFmclloSEFJRkJBRk1TN0FVVUZoQUtBQUNBUUFCQW5JQUFBQUhCQUFIYVFBQkFRTmhBQU1EUGswS0NBSUVCQVZoQ1FZQ0JRVThCVTRiUUNrQUFnRUFBUUlBZ0FBQUFBY0VBQWRwQUFFQkEyRUFBd00rVFFvSUFnUUVCV0VKQmdJRkJUd0ZUbGxBRnlZbUFBQW1MaVl0S2lrQUpRQWtJaVVrRXlNVUN3a2NLeFltTlRRMk16VTBKaU1pQmhVVkl5WTFORFl6TWhZVkZSUVdNek1WQmlNaUppY2pCZ1lqTmpZMU5TSVZGQll6ZzJhbW1COHJMaWVFQVhWaGJHc1VEeHdnTHlrM0NnWWRTenhsTnJNaElneEFWR1ZWSlNNbUhCTVBCaEJDVUZoVDZCSVJZQkFrSVNJamJFRTJFRkFaSGdELy93QWQvL1FDSXdMVEFDSUE3Z0FBQUFNQzZ3RzJBQUQvL3dBZC8vUUNJd0xKQUNJQTdnQUFBQU1DOEFHMEFBRC8vd0FkLy9RQ0l3TmpBQ0lBN2dBQUFDTUM4QUcwQUFBQkJ3THJBYllBa0FBSXNRTUJzSkN3TlN2Ly93QWQvMGtDSXdMSkFDSUE3Z0FBQUNNQytnRlZBQUFBQXdMd0FiUUFBUC8vQUIzLzlBSWpBMk1BSWdEdUFBQUFJd0x3QWJRQUFBRUhBdW9CWEFDUUFBaXhBd0d3a0xBMUsvLy9BQjMvOUFJakEyOEFJZ0R1QUFBQUl3THdBYlFBQUFFSEF2UUJpQUNRQUFpeEF3R3drTEExSy8vL0FCMy85QUlqQTJNQUlnRHVBQUFBSXdMd0FiUUFBQUVIQXZJQnZBQ1FBQWl4QXdHd2tMQTFLLy8vQUIzLzlBSWpBdE1BSWdEdUFBQUFBd0x2QWJrQUFQLy9BQjMvOUFJakF0TUFJZ0R1QUFBQUF3THVBYmtBQVAvL0FCMy85QUlqQTRRQUlnRHVBQUFBSXdMdUFia0FBQUVIQXVzQnRnQ3hBQWl4QXdHd3NiQTFLLy8vQUIzL1NRSWpBdE1BSWdEdUFBQUFJd0w2QVZVQUFBQURBdTRCdVFBQS8vOEFIZi8wQWlNRGhBQWlBTzRBQUFBakF1NEJ1UUFBQVFjQzZnRmNBTEVBQ0xFREFiQ3hzRFVyLy84QUhmLzBBaU1Ea0FBaUFPNEFBQUFqQXU0QnVRQUFBUWNDOUFHSUFMRUFDTEVEQWJDeHNEVXIvLzhBSGYvMEFpTURoQUFpQU80QUFBQWpBdTRCdVFBQUFRY0M4Z0c4QUxFQUNMRURBYkN4c0RVci8vOEFHdi8wQWlNQzB3QWlBTzRBQUFBREF2VUJuZ0FBLy84QUhmLzBBaU1DMHdBaUFPNEFBQUFEQXVnQnR3QUEvLzhBSGY5SkFpTUNHZ0FpQU80QUFBQURBdm9CVlFBQS8vOEFIZi8wQWlNQzB3QWlBTzRBQUFBREF1b0JYQUFBLy84QUhmLzBBaU1DM3dBaUFPNEFBQUFEQXZRQmlBQUEvLzhBSGYvMEFpTUMwd0FpQU80QUFBQURBdllCdFFBQS8vOEFIZi8wQWlNQ3NBQWlBTzRBQUFBREF2TUJxd0FBQUFJQUhmOU5BalVDR2dBekFEd0FsVUFRTFF3Q0FRWUJBUUFIQWt3SkFRRUJTMHV3RkZCWVFEQUFCQU1DQXdSeUFBSUFDQVlDQ0drQUF3TUZZUUFGQlQ1TkNRRUdCZ0ZoQUFFQlBFMEtBUWNIQUdJQUFBQkFBRTRiUURFQUJBTUNBd1FDZ0FBQ0FBZ0dBZ2hwQUFNREJXRUFCUVUrVFFrQkJnWUJZUUFCQVR4TkNnRUhCd0JpQUFBQVFBQk9XVUFVQUFBNk9EVTBBRE1BTWlVa0V5TVVLeUlMQ1IwckJSVUdJeUltTlRRMk55WW1KeU1HQmlNaUpqVTBOak0xTkNZaklnWVZGU01tTlRRMk16SVdGUlVVRmpNekZRWUdGUlFXTXdNaUZSUVdNekkyTlFJMUl4d3NNQmNYSkRFSkJoMUxQRDFtcHBnZkt5NG5oQUYxWVd4ckZBOGNGeGdWRnNTeklTSTZObkEzRENrZ0Z6RVdBeU1mSWlOQVZHVlZKU01tSEJNUEJoQkNVRmhUNkJJUllCUXJFaEFUQVZkUUdSNUJOZ0QvL3dBZC8vUUNJd0wyQUNJQTdnQUFBQU1DOFFGNUFBRC8vd0FkLy9RQ0l3T1lBQ0lBN2dBQUFDTUM4UUY1QUFBQkJ3THJBYmNBeFFBSXNRUUJzTVd3TlN2Ly93QWQvL1FDSXdMVEFDSUE3Z0FBQUFNQzhnRzhBQUFBQXdBZC8vUURWZ0lhQUNzQU1RQTZBT1JBQ2hVQkFRTW9BUWdHQWt4THNBNVFXRUEwQUFJQkFBRUNjZ0FIQlFZR0IzSVBDd0lBREFFRkJ3QUZhUW9CQVFFRFlRUUJBd00rVFJBTkFnWUdDR0lPQ1FJSUNEd0lUaHRMc0JSUVdFQTFBQUlCQUFFQ2NnQUhCUVlGQndhQUR3c0NBQXdCQlFjQUJXa0tBUUVCQTJFRUFRTURQazBRRFFJR0JnaGlEZ2tDQ0FnOENFNGJRRFlBQWdFQUFRSUFnQUFIQlFZRkJ3YUFEd3NDQUF3QkJRY0FCV2tLQVFFQkEyRUVBUU1EUGswUURRSUdCZ2hpRGdrQ0NBZzhDRTVaV1VBaU1qSXNMQUFBTWpveU9UWTFMREVzTVM4dEFDc0FLaUlTSWhNaUpCTWpGQkVKSHlzV0pqVTBOak0xTkNZaklnWVZGU01tTlRRMk16SVhOak15RmhVVklSWVdNekkyTlRNVUJpTWlKd1lHSXdFMEl5SUdCd1kyTlRVaUZSUVdNNTJBc2FVa05ETXNoQUY3WlhRN1BtbDFkUDZtQWpROUt6V0hnR21CUGlOZVJRSGdXelExQnNnOXl5WW5ERUJVWlZVbEl5WWNFdzhHRUVKUU16T0hqQ0JHUXpBc1kyTkVJU01CVG0wMk4rSkJOaEJRR1I3Ly93QWQvL1FEVmdMVEFDSUJDQUFBQUFNQzZ3SmhBQUFBQWdCSC8vUUNQZ0xUQUJJQUhnQnNRQW9JQVFRQ0FnRUFCUUpNUzdBVVVGaEFIUUFCQVRWTkFBUUVBbUVBQWdJK1RRY0JCUVVBWVFZREFnQUFOQUJPRzBBaEFBRUJOVTBBQkFRQ1lRQUNBajVOQUFBQU5FMEhBUVVGQTJFR0FRTURQQU5PV1VBVUV4TUFBQk1lRXgwYUdBQVNBQkVrRVJRSUNSa3JCQ1luSXdjakVUTVJNelkyTXpJV0ZSUUdJelkyTlRVMEppTWlGUlVVTXdFNVZCa0hDWFdKQmhkUk5WeHZibVFSTkRROWNIQU1LU2hGQXRQKy9pTW1pb2lMaVhkSlNoSktTWlVRa3dBQkFDYi85QUlIQWhvQUdnQmtTN0FNVUZoQUl3QUJBZ1FDQVhJQUJBTURCSEFBQWdJQVlRQUFBRDVOQUFNREJXSUdBUVVGUEFWT0cwQWxBQUVDQkFJQkJJQUFCQU1DQkFOK0FBSUNBR0VBQUFBK1RRQURBd1ZpQmdFRkJUd0ZUbGxBRGdBQUFCb0FHUklsSWhJa0J3a2JLeFltTlRRMk16SVdGU00wSmlNaUJoVVZGQll6TWpZMU14UUdJNk45Zlg1cGZZb3lMVGcxTnowck00UjhhZ3lHall5SGEyY3dORTlPRUU1UE5TOW5hd0QvL3dBbS8vUUNCd0xUQUNJQkN3QUFBQU1DNndIQkFBRC8vd0FtLy9RQ0J3TFRBQ0lCQ3dBQUFBTUM3d0hFQUFBQUFRQW0vMGtDQndJYUFDMEJLclVQQVFNRUFVeExzQXhRV0VBNkFBY0lBQWdIY2dBQUNRa0FjQUFDQVFVRUFuSUFCUVFCQlhBQUNBZ0dZUUFHQmo1TkNnRUpDUUZpQUFFQlBFMEFCQVFEWWdBREEwQURUaHRMc0E1UVdFQThBQWNJQUFnSEFJQUFBQWtJQUFsK0FBSUJCUVFDY2dBRkJBRUZjQUFJQ0FaaEFBWUdQazBLQVFrSkFXSUFBUUU4VFFBRUJBTmlBQU1EUUFOT0cwdXdFbEJZUUQwQUJ3Z0FDQWNBZ0FBQUNRZ0FDWDRBQWdFRkFRSUZnQUFGQkFFRmNBQUlDQVpoQUFZR1BrMEtBUWtKQVdJQUFRRThUUUFFQkFOaUFBTURRQU5PRzBBK0FBY0lBQWdIQUlBQUFBa0lBQWwrQUFJQkJRRUNCWUFBQlFRQkJRUitBQWdJQm1FQUJnWStUUW9CQ1FrQllnQUJBVHhOQUFRRUEySUFBd05BQTA1WldWbEFFZ0FBQUMwQUxDSVNKaVFpSkJFU0Vnc0pIeXNrTmpVekZBWUhCeFlXRlJRR0l5SW5OVE15TmpVMEppTWpOeVltTlRRMk16SVdGU00wSmlNaUJoVVZGQll6QVZBemhHNWZBeXcyVXpVNE1GZ1hGaE1YS1FwZ1gzMSthWDJLTWkwNE5UYzlZalV2WVdvR0Z3SWlJQzBrQ0RFS0Rnd01SZytGZTR5SGEyY3dORTlPRUU1UC8vOEFKdi8wQWdjQzB3QWlBUXNBQUFBREF1NEJ4QUFBLy84QUp2LzBBZ2NDMHdBaUFRc0FBQUFEQXVrQllnQUFBQUlBSmYvMEFod0Mwd0FTQUI0QWJFQUtDQUVFQUE0QkFnVUNURXV3RkZCWVFCMEFBUUUxVFFBRUJBQmhBQUFBUGswSEFRVUZBbUVHQXdJQ0FqUUNUaHRBSVFBQkFUVk5BQVFFQUdFQUFBQStUUUFDQWpSTkJ3RUZCUU5oQmdFREF6d0RUbGxBRkJNVEFBQVRIaE1kR0JZQUVnQVJFUlFrQ0FrWkt4WW1OVFEyTXpJV0Z6TVJNeEVqSnlNR0JpTTJOVFUwSXlJR0ZSVVVGak9UYm05Y05WRVhCb2wxQ1FjWlZET2NjRDAwTkQwTWlZdUlpaVlqQVFMOUxVVW9LWGVURUpWSlNoSktTUUFBQWdBbS8vUUNQUUxUQUJ3QUtnQlBRRXdVRXc4REFRSVdGUXNLQkFBQkNBY0NCQUFEVEFBQkFnQUNBUUNBQUFJQ05VMEFCQVFBWVFBQUFEWk5Cd0VGQlFOaUJnRURBendEVGgwZEFBQWRLaDBwSkNJQUhBQWJFeFlrQ0FrWkt4WW1OVFEyTXpJWE55WW5CelUzSmljM014WVhOeFVIRmhZVkZBWWpOalkxTlRRbUl5SUdGUlVVRmpPcmhYQnBMeXNGR3lLbVpSUXNCS0VqR1o5Y1BqdUZoME04UEVORE96dERESVdLZm84VEJDa3BERWtIRXlRRkdoY01TUWRLcTJhTGhIQkxUQkJMU2twTEVFeExBUC8vQUNYLzlBTFlBdE1BSWdFUkFBQUFBd0x0QXRnQUFBQUNBQ1gvOUFKV0F0TUFHZ0FtQUhaQUNoRUJDQU1FQVFFSkFreExzQlJRV0VBbEJ3RUZCQUVBQXdVQVp3QUdCalZOQUFnSUEyRUFBd00rVFFBSkNRRmhBZ0VCQVRRQlRodEFLUWNCQlFRQkFBTUZBR2NBQmdZMVRRQUlDQU5oQUFNRFBrMEFBUUUwVFFBSkNRSmhBQUlDUEFKT1dVQU9KU01pRVJFUkZDUWtFUkFLQ1I4ckFTTVJJeWNqQmdZaklpWTFORFl6TWhZWE16VWpOVE0xTXhVekF6UWpJZ1lWRlJRV016STFBbFk2ZFFrSEdWUXpaRzV2WERWUkZ3YWFtb2s2dzNBOU5EUTljQUpML2JWRktDbUppNGlLSmlONlIwRkIvbnlWU1VvU1NrbVRBUC8vQUNYL1NRSWNBdE1BSWdFUkFBQUFBd0w2QVhZQUFQLy9BQ1gvOUFSQkF0TUFJZ0VSQUFBQUF3SEhBbU1BQVAvL0FDWC85QVJCQXRNQUlnRVJBQUFBQXdISkFtTUFBQUFDQUNULzlBSUpBaG9BRkFBYUFIQkxzQTVRV0VBbUFBTUJBZ0lEY2dnQkJnQUJBd1lCWndBRkJRQmhBQUFBUGswQUFnSUVZZ2NCQkFROEJFNGJRQ2NBQXdFQ0FRTUNnQWdCQmdBQkF3WUJad0FGQlFCaEFBQUFQazBBQWdJRVlnY0JCQVE4QkU1WlFCVVZGUUFBRlJvVkdoZ1dBQlFBRXhJaUV5UUpDUm9yRmlZMU5EWXpNaFlWRlNFV0ZqTXlOalV6RkFZakV6UWpJZ1lIb1gxOWYzVjAvcVlDTkQwck5ZZUFhVnRiTkRVR0RJYU5qWWFIakNCR1F6QXNZMk1CVG0wMk53RC8vd0FrLy9RQ0NRTFRBQ0lCR0FBQUFBTUM2d0c5QUFELy93QWsvL1FDQ1FMSkFDSUJHQUFBQUFNQzhBRzdBQUQvL3dBay8vUUNDUUxUQUNJQkdBQUFBQU1DN3dIQUFBRC8vd0FrLy9RQ0NRTFRBQ0lCR0FBQUFBTUM3Z0hBQUFELy93QWsvL1FDQ1FPRUFDSUJHQUFBQUNNQzdnSEFBQUFCQndMckFiMEFzUUFJc1FNQnNMR3dOU3YvL3dBay8wa0NDUUxUQUNJQkdBQUFBQ01DK2dGaUFBQUFBd0x1QWNBQUFQLy9BQ1QvOUFJSkE0UUFJZ0VZQUFBQUl3THVBY0FBQUFFSEF1b0JZd0N4QUFpeEF3R3dzYkExSy8vL0FDVC85QUlKQTVBQUlnRVlBQUFBSXdMdUFjQUFBQUVIQXZRQmp3Q3hBQWl4QXdHd3NiQTFLLy8vQUNULzlBSUpBNFFBSWdFWUFBQUFJd0x1QWNBQUFBRUhBdklCd3dDeEFBaXhBd0d3c2JBMUsvLy9BQ0gvOUFJSkF0TUFJZ0VZQUFBQUF3TDFBYVVBQVAvL0FDVC85QUlKQXRNQUlnRVlBQUFBQXdMb0FiNEFBUC8vQUNULzlBSUpBdE1BSWdFWUFBQUFBd0xwQVY0QUFQLy9BQ1QvU1FJSkFob0FJZ0VZQUFBQUF3TDZBV0lBQVAvL0FDVC85QUlKQXRNQUlnRVlBQUFBQXdMcUFXTUFBUC8vQUNULzlBSUpBdDhBSWdFWUFBQUFBd0wwQVk4QUFQLy9BQ1QvOUFJSkF0TUFJZ0VZQUFBQUF3TDJBYndBQVAvL0FDVC85QUlKQXJBQUlnRVlBQUFBQXdMekFiSUFBQUFDQUNUL1NRSUpBaG9BSlFBckFFcEFSeE1CQkFNQlRBQUNBQUVBQWdHQUNRRUlBQUFDQ0FCbkFBY0hCbUVBQmdZK1RRQUJBUVZoQUFVRlBFMEFBd01FWVFBRUJFQUVUaVltSmlzbUt5UWtKU0lvRWlJUUNna2VLeVVoRmhZek1qWTFNeFFHQndZR0ZSUVdNek1WQmlNaUpqVTBOamNqSWlZMU5EWXpNaFlWSnpRaklnWUhBZ24rcGdJMFBTczFoMHBDRnhnVkZoWWpIQ3d3R2hnR2YzMTlmM1YwamxzME5RYm5Sa013TEV0ZEVoUXJFaEFUTnd3cElCZ3pGNGFOallhSGpEdHROamNBLy84QUpQLzBBZ2tDMHdBaUFSZ0FBQUFEQXZJQnd3QUFBQUlBSS8vMEFnZ0NHZ0FVQUJvQWNFdXdEbEJZUUNZQUF3SUJBZ055QUFFSUFRWUZBUVpuQUFJQ0JHRUhBUVFFUGswQUJRVUFZUUFBQUR3QVRodEFKd0FEQWdFQ0F3R0FBQUVJQVFZRkFRWm5BQUlDQkdFSEFRUUVQazBBQlFVQVlRQUFBRHdBVGxsQUZSVVZBQUFWR2hVYUdCWUFGQUFURWlJVEpBa0pHaXNBRmhVVUJpTWlKalUxSVNZbUl5SUdGU00wTmpNREZETXlOamNCaTMxOWYzVjBBVm9DTkQwck5ZZUFhVnRiTkRVR0FocUdqWTJHaDR3Z1JrTXdMR05qL3JKdE5qY0FBQUVBQ1FBQUFUb0Myd0FVQUM5QUxBb0JBd0lCVEFBREF3SmhBQUlDUFUwRkFRQUFBVjhFQVFFQk5rMEFCZ1kwQms0UkVSSWpJeEVRQndrZEt4TWpOVE0xTkRZek1oWVhGU01pRlJVekZTTVJJMVJMUzBKTUZUSVJNaXRkWFlrQm5uQThQbE1LQm1Bck1uRCtZZ0FBQXdBWS8wb0NXQUptQUN3QU9BQkdBRjVBV3hjUUFnVUFDUUVDQmdRQkNBTURUQUFCQUFHRkNnRUdBQUlEQmdKbkFBVUZBR0VBQUFBK1RRQURBd2hmQUFnSU5FMExBUWNIQkY4SkFRUUVPQVJPT2prdExRQUFRVDQ1UmpwRkxUZ3ROek14QUN3QUtqUTNGQzBNQ1JvckZpWTFORGNtTlRRMk55WTFORFl6TWhjMk5qVXpGQVlIRmhVVUJpTWpJZ1lWRkJZek16SVdGUlFHQmlNakVqWTFOQ1lqSWdZVkZCWXpFekkyTlRRbUl5TWlCaFVVRmpOa1RGRXpOQ2xOZVhBOUxSNGJoanMyTW5WdFVCSVZFZy92T2s0MFdqYjV4REl5TURBeE1UQmpHaUlmRjhFV0h4NFh0a1ExUmlVYU5TRXhDaTlmVTJBUEV6VVROME1NTDBwVFlCQU9EQkZPUHpCS0tBSEhMU2twTFMwcEtTMyttQm9WRmhnYUZCVWEvLzhBR1A5S0FsZ0Mwd0FpQVM0QUFBQURBdXNCMFFBQS8vOEFHUDlLQWxnQ3lRQWlBUzRBQUFBREF2QUJ6d0FBLy84QUdQOUtBbGdDMHdBaUFTNEFBQUFEQXU4QjFBQUFBQVFBR1A5S0FsZ0Mwd0FHQURNQVB3Qk5BSE5BY0FRQkJBQWVGd0lJQXhBQkJRa0xBUXNHQkV3QUJBQUJBQVFCZ0EwQkNRQUZCZ2tGWndJQkFRRUFYd0FBQURWTkFBZ0lBMkVBQXdNK1RRQUdCZ3RmQUFzTE5FME9BUW9LQjE4TUFRY0hPQWRPUVVBME5BY0hTRVZBVFVGTU5EODBQam80QnpNSE1UUTNGQzRTRVJBUENSMHJFek1YSXljSEl3SW1OVFEzSmpVME5qY21OVFEyTXpJWE5qWTFNeFFHQnhZVkZBWWpJeUlHRlJRV016TXlGaFVVQmdZakl4STJOVFFtSXlJR0ZSUVdNeE15TmpVMEppTWpJZ1lWRkJZei9XRlVXQ3d0V1VSTVVUTTBLVTE1Y0QwdEhodUdPell5ZFcxUUVoVVNEKzg2VGpSYU52bkVNakl3TURFeE1HTWFJaDhYd1JZZkhoY0MwNGRGUmZ6K1JEVkdKUm8xSVRFS0wxOVRZQThUTlJNM1F3d3ZTbE5nRUE0TUVVNC9NRW9vQWNjdEtTa3RMU2twTGY2WUdoVVdHQm9VRlJvQS8vOEFHUDlLQWxnREpnQWlBUzRBQUFBREF2Y0JiZ0FBLy84QUdQOUtBbGdDMHdBaUFTNEFBQUFEQXVrQmNnQUFBQUVBUndBQUFoOEMwd0FUQUNkQUpBSUJBd0VCVEFBQUFEVk5BQU1EQVdFQUFRRStUUVFCQWdJMEFrNFRJeE1qRUFVSkd5c1RNeEV6TmpNeUZoVVJJeEUwSmlNaUJoVVJJMGVKQnp4ZVVWMkpMaTB1UFlrQzAvNytTVmhoL3A4QlJERXNRVEQrMEFBQUFRQUFBQUFDSHdMVEFCc0FPMEE0R0FFQkNBRk1CZ0VFQndFRENBUURad0FGQlRWTkFBRUJDR0VKQVFnSVBrMENBUUFBTkFCT0FBQUFHd0FhRVJFUkVSRVRJeE1LQ1I0ckFCWVZFU01STkNZaklnWVZFU01SSXpVek5UTVZNeFVqRlRNMk13SENYWWt1TFM0OWlVZEhpWTJOQnp4ZUFocFlZZjZmQVVReExFRXcvdEFDUzBkQlFVZDZTZi8vLytVQUFBSWZBMVVBSWdFMUFBQUJCd01YQVRJQW9BQUlzUUVCc0tDd05Tdi8vd0JILzBrQ0h3TFRBQ0lCTlFBQUFBTUMrZ0YzQUFBQUFnQkdBQUFBendMVEFBTUFCd0FmUUJ3QUFRRUFYd0FBQURWTkFBSUNOazBBQXdNMEEwNFJFUkVRQkFrYUt4TXpGU01WTXhFalJvbUppWWtDMDRKRC9mSUFBUUJHQUFBQXp3SU9BQU1BRTBBUUFBQUFOazBBQVFFMEFVNFJFQUlKR0NzVE14RWpSb21KQWc3OTh2Ly9BRVlBQUFFc0F0TUFJZ0U2QUFBQUF3THJBU3dBQVAvLy8rY0FBQUVxQXNrQUlnRTZBQUFBQXdMd0FTb0FBUC8vLytJQUFBRXZBdE1BSWdFNkFBQUFBd0x2QVM4QUFQLy8vK0lBQUFFdkF0TUFJZ0U2QUFBQUF3THVBUzhBQVAvLy81QUFBQUVVQXRNQUlnRTZBQUFBQXdMMUFSUUFBUC8vLytRQUFBRXRBdE1BSWdFNkFBQUFBd0xvQVMwQUFQLy9BRVFBQUFEUEF0TUFJZ0U2QUFBQUF3THBBTTBBQVAvL0FFYi9TUURQQXRNQUlnRTVBQUFBQXdMNkFNNEFBUC8vLy8wQUFBRFNBdE1BSWdFNkFBQUFBd0xxQU5JQUFQLy9BRFlBQUFEK0F0OEFJZ0U2QUFBQUF3TDBBUDRBQVAvLy8rZ0FBQUVyQXRNQUlnRTZBQUFBQXdMMkFTc0FBUC8vQUViL1NnSG1BdE1BSWdFNUFBQUFBd0ZLQVJZQUFQLy8vL0FBQUFFaEFyQUFJZ0U2QUFBQUF3THpBU0VBQUFBQ0FDbi9TUURQQXRNQUF3QVlBRDVBT3c4QkJRUUJUQUFBQUFGZkJ3RUJBVFZOQUFJQ05rMEdBUU1ETkUwQUJBUUZZUUFGQlVBRlRnQUFHQmNTRUE0TUJ3WUZCQUFEQUFNUkNBa1hLeE1WSXpVVk14RWpCZ1lWRkJZek14VUdJeUltTlRRMk55UFBpWWtkRnhnVkZoWWpIQ3d3SVNBa0F0T0Nnc1g5OGhRckVoQVROd3dwSUJ3NkdQLy8vK0lBQUFFeUF0TUFJZ0U2QUFBQUF3THlBVElBQUFBQy8rai9TZ0RRQXRNQUF3QVFBREZBTGdZQkJBSUJUQUFCQVFCZkFBQUFOVTBBQXdNMlRRQUNBZ1JpQlFFRUJFQUVUZ1FFQkJBRUR4SWtFUkFHQ1JvckV6TVZJd0ltSnpVek1qVVJNeEVVQmlOSGlZa1hOeEUwSzRsQVNnTFRmUHp6Q2daZ0t3SXAvY2s5VUFBQi8rai9TZ0RRQWc0QURBQWxRQ0lDQVFJQUFVd0FBUUUyVFFBQUFBSmlBd0VDQWtBQ1RnQUFBQXdBQ3hJakJBa1lLeFltSnpVek1qVVJNeEVVQmlNd054RTBLNGxBU3JZS0JtQXJBaW45eVQxUUFQLy9BRWIvU2dKQUF0TUFJZ0U2QUFBQUl3THJBU3dBQUFBakFVc0JGZ0FBQUFNQzZ3SkFBQUQvLy8vZy8wb0JMUUxUQUNJQlN3QUFBQU1DN2dFdEFBQUFBUUJIQUFBQ0pnTFRBQXNBSkVBaENRZ0ZBZ1FDQVFGTUFBQUFOVTBBQVFFMlRRTUJBZ0kwQWs0VEVoSVFCQWthS3hNekVUY3pCeE1qSndjVkkwZUpycDZ1dUoxelJva0MwLzVxMGNyK3ZOOUVtd0QvL3dCSC91OENKZ0xUQUNJQlRnQUFBQU1DL0FGakFBQUFBUUJIQUFBQ0pnSU9BQXNBSUVBZENRZ0ZBZ1FDQUFGTUFRRUFBRFpOQXdFQ0FqUUNUaE1TRWhBRUNSb3JFek1WTnpNSEV5TW5CeFVqUjRtdW5xNjRuWE5HaVFJTzBkSEsvcnpmUkpzQUFRQkhBQUFBMEFMVEFBTUFFMEFRQUFBQU5VMEFBUUUwQVU0UkVBSUpHQ3NUTXhFalI0bUpBdFA5TGYvL0FFY0FBQUVUQTJNQUlnRlJBQUFCQndNVkFSTUFyZ0FJc1FFQnNLNndOU3YvL3dCSEFBQUJqQUxUQUNJQlVRQUFBQU1DN1FHTUFBRC8vd0JIL3U4QTBBTFRBQ0lCVVFBQUFBTUMvQURGQUFELy93QkhBQUFCaWdMVEFDSUJVUUFBQVFjQ1lnRHNBQUlBQ0xFQkFiQUNzRFVyLy84QVIvOUtBZVlDMHdBaUFWRUFBQUFEQVVvQkZnQUFBQUgvL2dBQUFSUUMwd0FMQUNCQUhRc0tCd1lGQkFFQUNBQUJBVXdBQVFFMVRRQUFBRFFBVGhVU0Fna1lLd0VIRVNNUkJ6VTNFVE1STndFVVJJbEpTWWxFQVpNdS9wc0JCekptTWdGbS92Z3VBQUFCQUVjQUFBTTFBaG9BSHdCUHRnY0NBZ1FBQVV4THNCUlFXRUFWQmdFRUJBQmhBZ0VDQUFBMlRRY0ZBZ01ETkFOT0cwQVpBQUFBTmswR0FRUUVBV0VDQVFFQlBrMEhCUUlEQXpRRFRsbEFDeE1pRXlJVEl5TVFDQWtlS3hNekZ6TTJNeklYTXpZek1oWVZFU01STkNNaUJoVVJJeEUwSXlJR0ZSRWpSM1VLQnpwY1pDWUlQR0JMV1lsTktEU0pUU2cxaVFJT1JWRlJVVmhoL3A4QlJGMUJNUDdRQVVSZFFURCswQUFBQVFCSEFBQUNId0lhQUJNQVJMVUNBUU1BQVV4THNCUlFXRUFTQUFNREFHRUJBUUFBTmswRUFRSUNOQUpPRzBBV0FBQUFOazBBQXdNQllRQUJBVDVOQkFFQ0FqUUNUbG0zRXlNVEl4QUZDUnNyRXpNWE16WXpNaFlWRVNNUk5DWWpJZ1lWRVNOSGRRb0hRR1JSWFlrdUxTNDlpUUlPUlZGWVlmNmZBVVF4TEVFdy90RC8vd0JIQUFBQ0h3TFRBQ0lCV1FBQUFBTUM2d0hpQUFELy8vL0pBQUFDSHdLdUFDSUJXUUFBQVFZQzVNbmJBQW14QVFHNC85dXdOU3NBLy84QVJ3QUFBaDhDMHdBaUFWa0FBQUFEQXU4QjVRQUEvLzhBUi83dkFoOENHZ0FpQVZrQUFBQURBdndCZWdBQS8vOEFSd0FBQWg4QzB3QWlBVmtBQUFBREF1a0Jnd0FBQUFFQVIvOUtBaDhDR2dBY0FHUkFDaElCQVFNQ0FRVUFBa3hMc0JSUVdFQWNBQUVCQTJFRUFRTUROazBBQWdJMFRRQUFBQVZoQmdFRkJVQUZUaHRBSUFBREF6Wk5BQUVCQkdFQUJBUStUUUFDQWpSTkFBQUFCV0VHQVFVRlFBVk9XVUFPQUFBQUhBQWJJeEVUSkNNSENSc3JCQ1luTlRNeU5SRTBKaU1pQmhVUkl4RXpGek0yTXpJV0ZSRVVCaU1CZnpjUk5Dc3VMUzQ5aVhVS0IwQmtVVjFBU3JZS0JtQXJBVjh4TEVFdy90QUNEa1ZSV0dIK2RqMVFBQUgvNlA5S0FoOENHZ0FjQUdSQUNna0JCQUVDQVFVQUFreExzQlJRV0VBY0FBUUVBV0VDQVFFQk5rMEFBd00wVFFBQUFBVmlCZ0VGQlVBRlRodEFJQUFCQVRaTkFBUUVBbUVBQWdJK1RRQURBelJOQUFBQUJXSUdBUVVGUUFWT1dVQU9BQUFBSEFBYkl4TWpFaU1IQ1JzckZpWW5OVE15TlJFekZ6TTJNeklXRlJFakVUUW1JeUlHRlJFVUJpTXdOeEUwSzNVS0IwQmtVVjJKTGkwdVBVQkt0Z29HWUNzQ0tVVlJXR0grbndGRU1TeEJNUDZuUFZBQS8vOEFSLzlLQXpNQzB3QWlBVmtBQUFBREFVb0NZd0FBLy84QVJ3QUFBaDhDMHdBaUFWa0FBQUFEQXZJQjZBQUFBQUlBSnYvMEFqMENHZ0FMQUJrQUxFQXBBQUlDQUdFQUFBQStUUVVCQXdNQllRUUJBUUU4QVU0TURBQUFEQmtNR0JNUkFBc0FDaVFHQ1JjckZpWTFORFl6TWhZVkZBWWpOalkxTlRRbUl5SUdGUlVVRmpPcWhJU0hoNFdGaDBNOFBFTkRPenRERElhTmpZYUdqWTJHY0UxT0VFNU5UVTRRVGszLy93QW0vL1FDUFFMVEFDSUJZd0FBQUFNQzZ3SFVBQUQvL3dBbS8vUUNQUUxKQUNJQll3QUFBQU1DOEFIU0FBRC8vd0FtLy9RQ1BRTFRBQ0lCWXdBQUFBTUM3d0hYQUFELy93QW0vL1FDUFFMVEFDSUJZd0FBQUFNQzdnSFhBQUQvL3dBbS8vUUNQUU9FQUNJQll3QUFBQ01DN2dIWEFBQUJCd0xyQWRRQXNRQUlzUU1Cc0xHd05Tdi8vd0FtLzBrQ1BRTFRBQ0lCWXdBQUFDTUMrZ0YzQUFBQUF3THVBZGNBQVAvL0FDYi85QUk5QTRRQUlnRmpBQUFBSXdMdUFkY0FBQUVIQXVvQmVnQ3hBQWl4QXdHd3NiQTFLLy8vQUNiLzlBSTlBNUFBSWdGakFBQUFJd0x1QWRjQUFBRUhBdlFCcGdDeEFBaXhBd0d3c2JBMUsvLy9BQ2IvOUFJOUE0UUFJZ0ZqQUFBQUl3THVBZGNBQUFFSEF2SUIyZ0N4QUFpeEF3R3dzYkExSy8vL0FDYi85QUk5QXRNQUlnRmpBQUFBQXdMMUFid0FBUC8vQUNiLzlBSTlBdE1BSWdGakFBQUFBd0xvQWRVQUFQLy9BQ2IvOUFJOUEzVUFJZ0ZqQUFBQUl3TG9BZFVBQUFFSEF2TUJ5UURGQUFpeEJBR3d4YkExSy8vL0FDYi85QUk5QTNVQUlnRmpBQUFBSXdMcEFYVUFBQUVIQXZNQnlRREZBQWl4QXdHd3hiQTFLLy8vQUNiL1NRSTlBaG9BSWdGakFBQUFBd0w2QVhjQUFQLy9BQ2IvOUFJOUF0TUFJZ0ZqQUFBQUF3THFBWG9BQVAvL0FDYi85QUk5QXQ4QUlnRmpBQUFBQXdMMEFhWUFBQUFDQUNiLzlBSlFBcTRBRlFBakFHWkxzQlJRV0xVQ0FRUUJBVXdidFFJQkJBSUJURmxMc0JSUVdFQWJBQU1ETTAwQUJBUUJZUUlCQVFFK1RRQUZCUUJpQUFBQVBBQk9HMEFmQUFNRE0wMEFBZ0kyVFFBRUJBRmhBQUVCUGswQUJRVUFZZ0FBQUR3QVRsbEFDU1VrRWlFa0pnWUpIQ3NBQmdjV0ZSUUdJeUltTlRRMk16SVhNekkxTlRNVkF6UW1JeUlHRlJVVUZqTXlOalVDVUNvb1A0V0hoNFNFaHpvdEpDdHBvRHhEUXpzN1EwTThBaG82RFVPSmpZYUdqWTJHRERWcmEvN01UazFOVGhCT1RVMU8vLzhBSnYvMEFsQUMwd0FpQVhRQUFBQURBdXNCMUFBQS8vOEFKdjlKQWxBQ3JnQWlBWFFBQUFBREF2b0Jkd0FBLy84QUp2LzBBbEFDMHdBaUFYUUFBQUFEQXVvQmVnQUEvLzhBSnYvMEFsQUMzd0FpQVhRQUFBQURBdlFCcGdBQUFBTUFKdi8wQWxBQzB3QVpBQzhBUFFDZFM3QVVVRmkxSEFFS0J3Rk1HN1VjQVFvSUFVeFpTN0FVVUZoQUxnd0JCUVVCWVFNQkFRRTFUUVFCQUFBQ1lRa0JBZ0l6VFFBS0NnZGhDQUVIQno1TkFBc0xCbUlBQmdZOEJrNGJRRElNQVFVRkFXRURBUUVCTlUwRUFRQUFBbUVKQVFJQ00wMEFDQWcyVFFBS0NnZGhBQWNIUGswQUN3c0dZZ0FHQmp3R1RsbEFHZ0FBT3prME1pNHRLeWtvSmlJZ0FCa0FHQ0lTSkNJU0RRa2JLeElHQnlNME5qTXlGaGNXRmpNeU5qY3pGQVlqSWlZbkppWWpCQVlIRmhVVUJpTWlKalUwTmpNeUZ6TXlOVFV6RlFNMEppTWlCaFVWRkJZek1qWTE3QThEUHlzdERoa1hFeG9ORFJBQ1B5d3REeG9VRkJnTkFWWXFLRCtGaDRlRWhJYzZMU1FyYWFBOFEwTTdPME5EUEFKK0VSUTFSUWtLQ1FrUkZEVkZDUW9KQ1dRNkRVT0pqWWFHalkyR0REVnJhLzdNVGsxTlRoQk9UVTFPLy84QUp2LzBBajBDMHdBaUFXTUFBQUFEQXV3Q0ZnQUEvLzhBSnYvMEFqMEMwd0FpQVdNQUFBQURBdllCMHdBQS8vOEFKdi8wQWowQ3NBQWlBV01BQUFBREF2TUJ5UUFBQUFJQUp2OUpBajBDR2dBYUFDZ0FOVUF5RVFFQkFBa0JBZ0VDVEFBRkJRTmhBQU1EUGswQUJBUUFZUUFBQUR4TkFBRUJBbUVBQWdKQUFrNGxKQ29pSkJFR0NSd3JKQVlIQmhVVUZqTXpGUVlqSWlZMU5EWTNKaVkxTkRZek1oWVZCQll6TWpZMU5UUW1JeUlHRlJVQ1BYUjJJeFVXRmlNY0xEQWFHbk54aEllSGhmNTJPME5EUER4RFF6dUVod2dsSVJBVE53d3BJQmt6RndxR2dvMkdobzFXVFUxT0VFNU5UVTRRQUFBREFDYi96d0k5QWo4QUV3QWNBQ1VBUGtBN0V4QUNCQUlnSHhZVkJBVUVDUVlDQUFVRFRBQURBZ09GQUFFQUFZWUFCQVFDWVFBQ0FqNU5BQVVGQUdFQUFBQThBRTRvSlJJbEVpTUdDUndyQUJVVUJpTWlKd2NqTnlZMU5EWXpNaGMzTXdjQUZ6Y21JeUlHRlJVM05DY0hGak15TmpVQ1BZV0hUellwVlVOTGhJZE9PaXBVUlA3QUQ3QWFKME03L1E2dkdpUkRQQUdhazQyR0ZqdGdRNVdOaGhjOFlmN3BKUG9OVFU0UUVEZ2krUXhOVHYvL0FDYi96d0k5QXRNQUlnRitBQUFBQXdMckFkSUFBUC8vQUNiLzlBSTlBdE1BSWdGakFBQUFBd0x5QWRvQUFQLy9BQ2IvOUFJOUEzVUFJZ0ZqQUFBQUl3THlBZG9BQUFFSEF2TUJ5Z0RGQUFpeEF3R3d4YkExS3dBREFDYi85QU9OQWhvQUhBQWlBREFCR2tBS0J3RUhBQm9CQlFNQ1RFdXdEbEJZUUNzQUJBSURBd1J5REFFSUFBSUVDQUpuQ1FFSEJ3QmhBUUVBQUQ1TkRRb0NBd01GWWdzR0FnVUZQQVZPRzB1d0psQllRQ3dBQkFJREFnUURnQXdCQ0FBQ0JBZ0Nad2tCQndjQVlRRUJBQUErVFEwS0FnTURCV0lMQmdJRkJUd0ZUaHRMc0M1UVdFQTNBQVFDQ2dJRUNvQU1BUWdBQWdRSUFtY0pBUWNIQUdFQkFRQUFQazBOQVFvS0JXRUxCZ0lGQlR4TkFBTURCV0lMQmdJRkJUd0ZUaHRBUVFBRUFnb0NCQXFBREFFSUFBSUVDQUpuQUFjSEFHRUJBUUFBUGswQUNRa0FZUUVCQUFBK1RRMEJDZ29GWVFzR0FnVUZQRTBBQXdNRllnc0dBZ1VGUEFWT1dWbFpRQjhqSXgwZEFBQWpNQ012S2lnZEloMGlJQjRBSEFBYkloSWlFeUlrRGdrY0t4WW1OVFEyTXpJWE5qTXlGaFVWSVJZV016STJOVE1VQmlNaUp3WWpBVFFqSWdZSEJqWTFOVFFtSXlJR0ZSVVVGak9wZzRPRWZrSS9lSFYwL3FZQ05EMHJOWWVBYVhnL1FuNEIwbHMwTlFiSE9qcEJRRG82UUF5R2pZMkdSa2FIakNCR1F6QXNZMk5GUlFGT2JUWTMzazFPRUU1TlRVNFFUazBBQUFJQVIvOVRBajRDR2dBU0FCNEFaRUFLQWdFRUFBOEJBZ1VDVEV1d0ZGQllRQndBQkFRQVlRRUJBQUEyVFFZQkJRVUNZUUFDQWp4TkFBTURPQU5PRzBBZ0FBQUFOazBBQkFRQllRQUJBVDVOQmdFRkJRSmhBQUlDUEUwQUF3TTRBMDVaUUE0VEV4TWVFeDBtRkNRa0VBY0pHeXNUTXhjek5qWXpNaFlWRkFZaklpWW5JeFVqQURZMU5UUW1JeUlWRlJRelIzVUpCeGxVTTJSdWIxdzFVUmNHaVFFMk5EUTljSEFDRGtVb0tZbUxpSW9tSStvQkdFbEtFa3BKa3hDVkFBSUFSLzlUQWo0QzRRQVNBQjRBYUVBS0FnRUVBUThCQWdVQ1RFdXdJMUJZUUNBQUFBQTFUUUFFQkFGaEFBRUJQazBHQVFVRkFtRUFBZ0k4VFFBREF6Z0RUaHRBSUFBRUJBRmhBQUVCUGswR0FRVUZBbUVBQWdJOFRRQUFBQU5mQUFNRE9BTk9XVUFPRXhNVEhoTWRKaFFrSkJBSENSc3JFek1STXpZMk16SVdGUlFHSXlJbUp5TVZJd0EyTlRVMEppTWlGUlVVTTBlSkJoZFJOVjV0YjF3MVVSY0dpUUUyTkRROWNIQUM0Zjd3SXlhSmk0aUtKaVBxQVJoSlNoSktTWk1RbFFBQ0FDWC9Vd0ljQWhvQUVnQWVBSGRMc0JSUVdFQUtEUUVFQVFBQkFBVUNUQnRBQ2cwQkJBSUFBUUFGQWt4WlM3QVVVRmhBSEFBRUJBRmhBZ0VCQVQ1TkJnRUZCUUJoQUFBQVBFMEFBd000QTA0YlFDQUFBZ0kyVFFBRUJBRmhBQUVCUGswR0FRVUZBR0VBQUFBOFRRQURBemdEVGxsQURoTVRFeDRUSFNRUkZDUWpCd2tiS3lVakJnWWpJaVkxTkRZek1oWVhNemN6RVNNUU5UVTBJeUlHRlJVVUZqTUJrd1lYVVRWY2IyNWtNMVFaQndsMWlYQTlORFE5UFNNbWlvaUxpU2tvUmYxRkFSaVZFSk5KU2hKS1NRQUJBRWNBQUFGMUFob0FEd0JaUzdBVVVGaEFDZ0lCQWdBQlRBZ0JBRW9iUUFvSUFRQUJBZ0VDQUFKTVdVdXdGRkJZUUJFQUFnSUFZUUVCQUFBMlRRQURBelFEVGh0QUZRQUFBRFpOQUFJQ0FXRUFBUUUrVFFBREF6UURUbG0yRXlJa0VBUUpHaXNUTXhjek5qWXpNaGNWSXlJR0ZSVWpSM1VMQnhFMkxCMFhKa004aVFJT1ZTMDBDWUJKU3Y3Ly93QkhBQUFCZndMVEFDSUJoZ0FBQUFNQzZ3Ri9BQUQvL3dBMUFBQUJnZ0xUQUNJQmhnQUFBQU1DN3dHQ0FBRC8vd0JIL3U4QmRRSWFBQ0lCaGdBQUFBTUMvQURGQUFELy8vL2pBQUFCZFFMVEFDSUJoZ0FBQUFNQzlRRm5BQUQvL3dCSC8wa0JkUUlhQUNJQmhnQUFBQU1DK2dEUEFBRC8vd0E3QUFBQmZnTFRBQ0lCaGdBQUFBTUM5Z0YrQUFBQUFRQXUvL1FDQ2dJYUFDb0FtTFVDQVFFQUFVeExzQkpRV0VBakFBTUVBQVFEY2dBQUFRRUFjQUFFQkFKaEFBSUNQazBBQVFFRllnWUJCUVU4QlU0YlM3QVdVRmhBSkFBREJBQUVBM0lBQUFFRUFBRitBQVFFQW1FQUFnSStUUUFCQVFWaUJnRUZCVHdGVGh0QUpRQURCQUFFQXdDQUFBQUJCQUFCZmdBRUJBSmhBQUlDUGswQUFRRUZZZ1lCQlFVOEJVNVpXVUFPQUFBQUtnQXBJeE1ySXhNSENSc3JGaVkxTnpNVkZoWXpNalkxTkNZbkxnSTFORFl6TWhZVkJ5TTFOQ1lqSWdZVkZCWVhIZ0lWRkNPcmZRR0ZBVDBzS1RvN1AwRlNQSUZtWDN3QmhURXBLVEEzUFVOVVB2RU1XMHdNQnlNZkZoa2NIQTRQSDBJM1RWTk5RaGNHR2h3V0ZCa1lEQThlUkRxcUFQLy9BQzcvOUFJS0F0TUFJZ0dOQUFBQUF3THJBYlFBQUFBQkFERUJId0N5QXRNQUJBQVpRQllDQVFFQUFVd0FBUUVBWHdBQUFEVUJUaElRQWdrWUt4TXpGUU1qTVlFclZnTFRldjdHQVAvL0FDNy85QUlLQXRNQUlnR05BQUFBQXdMdkFiY0FBQUFCQUM3L1NRSUtBaG9BUFFEWlFBb1hBUVlGQ2dFQ0F3Sk1TN0FPVUZoQU53QUlDUVVKQ0hJQUJRWUpCUVorQUFFQUJBTUJjZ0FHQUFRREJnUnBBQWtKQjJFQUJ3YytUUUFBQURSTkFBTURBbUlBQWdKQUFrNGJTN0FXVUZoQU9BQUlDUVVKQ0hJQUJRWUpCUVorQUFFQUJBQUJCSUFBQmdBRUF3WUVhUUFKQ1FkaEFBY0hQazBBQUFBMFRRQURBd0ppQUFJQ1FBSk9HMEE1QUFnSkJRa0lCWUFBQlFZSkJRWitBQUVBQkFBQkJJQUFCZ0FFQXdZRWFRQUpDUWRoQUFjSFBrMEFBQUEwVFFBREF3SmlBQUlDUUFKT1dWbEFEalF5RXlzakZTUWlKQkVRQ2drZkt3UUhCeFlXRlJRR0l5SW5OVE15TmpVMEppTWpOeVltTlRjekZSWVdNekkyTlRRbUp5NENOVFEyTXpJV0ZRY2pOVFFtSXlJR0ZSUVdGeDRDRlFJSzBBTXNObE0xT0RCWUZ4WVRGeWtLVjJBQmhRRTlMQ2s2T3o5QlVqeUJabDk4QVlVeEtTa3dOejFEVkQ0QkNoY0NJaUF0SkFneENnNE1ERVVLVjBNTUJ5TWZGaGtjSEE0UEgwSTNUVk5OUWhjR0dod1dGQmtZREE4ZVJEb0EvLzhBTHYvMEFnb0Mwd0FpQVkwQUFBQURBdTRCdHdBQS8vOEFMdjd2QWdvQ0dnQWlBWTBBQUFBREF2d0JUQUFBLy84QUx2OUpBZ29DR2dBaUFZMEFBQUFEQXZvQlZnQUFBQUVBUVFBQUFqc0Mzd0FvQURGQUxna0JBd1FCVEFBRUFBTUNCQU5uQUFVRkFHRUFBQUE5VFFBQ0FnRmZCZ0VCQVRRQlRoTWtJU1FoTENJSENSMHJFelEyTXpJV0ZSUUdCeFVXRmhVVUJnWWpJelV6TWpZMU5DWWpJelV6TWpZMU5DWWpJZ1lWRVNOQmluQnVlajR4UWtVMlpVUlhTaTQwTkM1S1J5TXBNVEF5TzRrQi8zSnVZbEU2VkJJRUVXUkVPMTQyYnp3dExUeDVNeWNxTXpneS9ma0FBQUVBQ1FBQUFUb0Myd0FRQUN0QUtBb0JBd0lCVEFBREF3SmhBQUlDUFUwQUFBQUJYd0FCQVRaTkFBUUVOQVJPRWlNakVSQUZDUnNyRXlNMU16VTBOak15RmhjVkl5SVZFU05VUzB0Q1RCVXlFVElyaVFHZWNEdytVd29HWUN2OXdBQUFBUUFMLy9RQkxnS2lBQlFBWHJVUkFRWUZBVXhMc0NwUVdFQWRBQUlDTTAwRUFRQUFBVjhEQVFFQk5rMEFCUVVHWWdjQkJnWThCazRiUUIwQUFnRUNoUVFCQUFBQlh3TUJBUUUyVFFBRkJRWmlCd0VHQmp3R1RsbEFEd0FBQUJRQUV5SVJFUkVSRXdnSkhDc1dKalVSSXpVek56TVZNeFVqRVJRek14VUdCaU9LUUQ5Q0YyOWJXeXN3RVRNV0RGQTlBUjF3bEpSdy92RXJZQVlLQUFBQkFBdi85QUV1QXFJQUhBQjN0UmtCQ2drQlRFdXdLbEJZUUNjSEFRRUlBUUFKQVFCbkFBUUVNMDBHQVFJQ0ExOEZBUU1ETmswQUNRa0tZZ3NCQ2dvOENrNGJRQ2NBQkFNRWhRY0JBUWdCQUFrQkFHY0dBUUlDQTE4RkFRTUROazBBQ1FrS1lnc0JDZ284Q2s1WlFCUUFBQUFjQUJzWUZoRVJFUkVSRVJFUkV3d0pIeXNXSmpVMUl6VXpOU00xTXpjekZUTVZJeFV6RlNNVkZETXpGUVlHSTRwQVB6OC9RaGR2VzF0V1Zpc3dFVE1XREZBOWZVZFpjSlNVY0ZsSGJ5dGdCZ3IvL3dBTC8vUUJnUUxuQUNJQmx3QUFBUWNDN1FHQkFCUUFDTEVCQWJBVXNEVXJBQUVBQy85SkFVa0NvZ0FtQU1aQUN5TVJBZ2tJQndFQUFRSk1TN0FPVUZoQU1BQUlBd2tEQ0FtQUNnRUpBZ0VKY0FjQkF3TUVYd1lCQkFRMlRRQUNBZ1ZmQUFVRk0wMEFBUUVBWWdBQUFFQUFUaHRMc0NwUVdFQXhBQWdEQ1FNSUNZQUtBUWtDQXdrQ2ZnY0JBd01FWHdZQkJBUTJUUUFDQWdWZkFBVUZNMDBBQVFFQVlnQUFBRUFBVGh0QUx3QUlBd2tEQ0FtQUNnRUpBZ01KQW40QUJRQUNBUVVDYVFjQkF3TUVYd1lCQkFRMlRRQUJBUUJpQUFBQVFBQk9XVmxBRWdBQUFDWUFKaUlSRVJFUkZTUWlKQXNKSHlzRUZoVVVCaU1pSnpVek1qWTFOQ1lqSXpjbUpqVVJJelV6TnpNVk14VWpFUlF6TXhVR0J3Y0JFelpUTlRnd1dCY1dFeGNwQ3lna1AwSVhiMXRiS3pBYktRTWtJaUF0SkFneENnNE1ERXdQUnkwQkhYQ1VsSEQrOFN0Z0NnVVgvLzhBQy83dkFTNENvZ0FpQVpjQUFBQURBdndBL0FBQS8vOEFDLzlKQVM0Q29nQWlBWmNBQUFBREF2b0JCZ0FBQUFFQVJQLzBBaHdDRGdBVEFFeTFFQUVEQVFGTVM3QVVVRmhBRXdJQkFBQTJUUUFCQVFOaUJRUUNBd00wQTA0YlFCY0NBUUFBTmswQUF3TTBUUUFCQVFSaUJRRUVCRHdFVGxsQURRQUFBQk1BRWhFVEl4TUdDUm9yRmlZMUVUTVJGQll6TWpZMUVUTVJJeWNqQmlPaFhZa3VMUzQ5aVhVS0IwQmtERmhoQVdIK3ZERXNRVEFCTVAzeVJWSC8vd0JFLy9RQ0hBTFRBQ0lCblFBQUFBTUM2d0hTQUFELy93QkUvL1FDSEFMSkFDSUJuUUFBQUFNQzhBSFFBQUQvL3dCRS8vUUNIQUxUQUNJQm5RQUFBQU1DN3dIVkFBRC8vd0JFLy9RQ0hBTFRBQ0lCblFBQUFBTUM3Z0hWQUFELy93QTIvL1FDSEFMVEFDSUJuUUFBQUFNQzlRRzZBQUQvL3dCRS8vUUNIQUxUQUNJQm5RQUFBQU1DNkFIVEFBRC8vd0JFLy9RQ0hBT1lBQ0lCblFBQUFDTUM2QUhUQUFBQkJ3THJBZElBeFFBSXNRTUJzTVd3TlN2Ly93QkUvL1FDSEFPWUFDSUJuUUFBQUNNQzZBSFRBQUFCQndMdkFkVUF4UUFJc1FNQnNNV3dOU3YvL3dCRS8vUUNIQU9ZQUNJQm5RQUFBQ01DNkFIVEFBQUJCd0xxQVhnQXhRQUlzUU1Cc01Xd05Tdi8vd0JFLy9RQ0hBTjFBQ0lCblFBQUFDTUM2QUhUQUFBQkJ3THpBY2NBeFFBSXNRTUJzTVd3TlN2Ly93QkUvMGtDSEFJT0FDSUJuUUFBQUFNQytnRjFBQUQvL3dCRS8vUUNIQUxUQUNJQm5RQUFBQU1DNmdGNEFBRC8vd0JFLy9RQ0hBTGZBQ0lCblFBQUFBTUM5QUdrQUFBQUFRQkUvL1FDZVFLdUFCc0FYRUFLQkFFREFnY0JBQU1DVEV1d0ZGQllRQmdHQVFVRk0wMEVBUUlDTmswQUF3TUFZZ0VCQUFBMEFFNGJRQndHQVFVRk0wMEVBUUlDTmswQUFBQTBUUUFEQXdGaUFBRUJQQUZPV1VBT0FBQUFHd0FiSXlNVEl4VUhDUnNyQVJVVUJnY1JJeWNqQmlNaUpqVVJNeEVVRmpNeU5qVVJNekkxTlFKNU1DMTFDZ2RBWkZGZGlTNHRMajFTS3dLdWF5dzhDLzR3UlZGWVlRRmgvcnd4TEVFd0FUQTFhLy8vQUVULzlBSjVBdE1BSWdHckFBQUFBd0xyQWRJQUFQLy9BRVQvU1FKNUFxNEFJZ0dyQUFBQUF3TDZBWFVBQVAvL0FFVC85QUo1QXRNQUlnR3JBQUFBQXdMcUFYZ0FBUC8vQUVULzlBSjVBdDhBSWdHckFBQUFBd0wwQWFRQUFQLy9BRVQvOUFKNUF0TUFJZ0dyQUFBQUF3THlBZGdBQVAvL0FFVC85QUljQXRNQUlnR2RBQUFBQXdMc0FoUUFBUC8vQUVULzlBSWNBdE1BSWdHZEFBQUFBd0wyQWRFQUFQLy9BRVQvOUFJY0FyQUFJZ0dkQUFBQUF3THpBY2NBQUFBQkFFVC9TUUl1QWc0QUl3QnNRQThMQVFFRUFRRUFCZ0pNSFFFQkFVdExzQlJRV0VBZEJRRURBelpOQUFRRUFXSUNBUUVCTkUwSEFRWUdBR0VBQUFCQUFFNGJRQ0VGQVFNRE5rMEFBUUUwVFFBRUJBSmlBQUlDUEUwSEFRWUdBR0VBQUFCQUFFNVpRQThBQUFBakFDSVRJeE1qRlNJSUNSd3JCUlVHSXlJbU5UUTJOeU1uSXdZaklpWTFFVE1SRkJZek1qWTFFVE1SQmdZVkZCWXpBaTRpSFN3d0lTQXRDZ2RBWkZGZGlTNHRMajJKRnhnVkZuUTNEQ2tnSERvWVJWRllZUUZoL3J3eExFRXdBVEQ5OGhRckVoQVQvLzhBUlAvMEFod0M5Z0FpQVowQUFBQURBdkVCbFFBQS8vOEFSUC8wQWh3QzB3QWlBWjBBQUFBREF2SUIyQUFBQUFFQUNRQUFBaU1DRGdBTEFCdEFHQVFCQWdBQlRBRUJBQUEyVFFBQ0FqUUNUaEVYRUFNSkdTc1RNeGNXRnpNMk56Y3pBeU1KajFJT0hnVWNFRkdMeFpFQ0R1SW1lSEV0NHYzeUFBQUJBQVFBQUFNR0FnNEFHd0FoUUI0V0RBUURBd0FCVEFJQkFnQUFOazBFQVFNRE5BTk9GeEVYRnhBRkNSc3JFek1YRmhjek5qYzNNeGNXRnpNMk56Y3pBeU1uSmljakJnY0hJd1NOT1FrV0JCWUtObzA1REJVRUV3MDJncHlPUEFzTkJRa01QNDRDRHRnamRHc3IyZG91WjJBMTJ2M3krekJFUXpEOEFQLy9BQVFBQUFNR0F0TUFJZ0c0QUFBQUF3THJBaWtBQVAvL0FBUUFBQU1HQXRNQUlnRzRBQUFBQXdMdUFpd0FBUC8vQUFRQUFBTUdBdE1BSWdHNEFBQUFBd0xvQWlvQUFQLy9BQVFBQUFNR0F0TUFJZ0c0QUFBQUF3THFBYzhBQUFBQkFBWUFBQUlsQWc0QURRQWZRQndLQndNREFnQUJUQUVCQUFBMlRRTUJBZ0kwQWs0VEVoTVJCQWthS3hNbk14Y3pOek1IRXlNbkl3Y2p2NnFsWHdaaG02MjNwRzBHYnBvQkVQNlptZnYrN2E2dUFBQUJBQW4vU2dJakFnNEFGUUFzUUNrTEJnSUFBUUVCQXdBQ1RBSUJBUUUyVFFBQUFBTmlCQUVEQTBBRFRnQUFBQlVBRkJjVElnVUpHU3NXSnpVek1qWTNBek1YRmhjek5qYzNNd01PQWlOZ0owRWpMQTdPajJNUEZnVVlEVTZMc1JnMFV6eTJEV0FpSndJTzl5ZGlYQ3o0L2cxQ1dUYi8vd0FKLzBvQ0l3TFRBQ0lCdmdBQUFBTUM2d0c3QUFELy93QUovMG9DSXdMVEFDSUJ2Z0FBQUFNQzdnRytBQUQvL3dBSi8wb0NJd0xUQUNJQnZnQUFBQU1DNkFHOEFBRC8vd0FKLzBrQ0l3SU9BQ0lCdmdBQUFBTUMrZ0lYQUFELy93QUovMG9DSXdMVEFDSUJ2Z0FBQUFNQzZnRmhBQUQvL3dBSi8wb0NJd0xmQUNJQnZnQUFBQU1DOUFHTkFBRC8vd0FKLzBvQ0l3S3dBQ0lCdmdBQUFBTUM4d0d3QUFELy93QUovMG9DSXdMVEFDSUJ2Z0FBQUFNQzhnSEJBQUFBQVFBVkFBQUIzZ0lPQUFrQUtVQW1CUUVBQVFBQkF3SUNUQUFBQUFGZkFBRUJOazBBQWdJRFh3QURBelFEVGhFU0VSRUVDUm9yTnhNak5TRVZBeUVWSVJYNTZnR3grZ0VEL2pjOUFXRndQUDZlY0FELy93QVZBQUFCM2dMVEFDSUJ4d0FBQUFNQzZ3R2hBQUQvL3dBVkFBQUIzZ0xUQUNJQnh3QUFBQU1DN3dHa0FBRC8vd0FWQUFBQjNnTFRBQ0lCeHdBQUFBTUM2UUZDQUFELy93QVYvMGtCM2dJT0FDSUJ4d0FBQUFNQytnRStBQUFBQVFCRS8wb0NIQUlPQUI4QWFiVUtBUUlFQVV4THNCdFFXRUFqQUFBQ0FRRUFjZ1VCQXdNMlRRQUVCQUppQUFJQ05FMEFBUUVHWWdjQkJnWkFCazRiUUNJQUFBSUJBZ0FCZ0FBRUFBSUFCQUpxQlFFREF6Wk5BQUVCQm1JSEFRWUdRQVpPV1VBUEFBQUFId0FlRXlNVEpTRVRDQWtjS3hZbU5UVXpGRE15TmpjM0l3WWpJaVkxRVRNUkZCWXpNalkxRVRNUkZBWWp1WFNGVVVFOEFRRUVRR1JSWFlrdUxTNDlpWUordGtwSkNpMC9RaWhSV0dFQlEvN2FNU3hCTUFFUy9qRjZld0QvL3dCRS8wb0NIQUxUQUNJQnpBQUFBQU1DNndIVEFBRC8vd0JFLzBvQ0hBTFRBQ0lCekFBQUFBTUM3Z0hXQUFELy93QkUvMG9DSEFMVEFDSUJ6QUFBQUFNQzZBSFVBQUQvL3dCRS8wb0NIQUxUQUNJQnpBQUFBQU1DNmdGNUFBRC8vd0JFLzBvQ0hBS3dBQ0lCekFBQUFBTUM4d0hJQUFELy93QkUvMG9DSEFMVEFDSUJ6QUFBQUFNQzhnSFpBQUQvL3dBbS8vUUNCd0x4QUNJQkN3QUFBQU1ES1FEaEFBRC8vd0JIQUFBQ0h3THhBQ0lCV1FBQUFBTURLUUVDQUFELy93QW0vL1FDUFFMeEFDSUJZd0FBQUFNREtRRDBBQUQvL3dBdS8vUUNDZ0x4QUNJQmpRQUFBQU1ES1FEVUFBRC8vd0FWQUFBQjNnTHhBQ0lCeHdBQUFBTURLUURCQUFBQUFRQUpBQUFDY3dMYkFDVUFQVUE2RndvQ0F3SUJUQVlCQXdNQ1lRVUJBZ0k5VFFvSUFnQUFBVjhIQkFJQkFUWk5Dd0VKQ1RRSlRpVWtJeUloSUJFU0l5TVNJeU1SRUF3Skh5c1RJelV6TlRRMk16SVdGeFVqSWhVVk16VTBOak15RmhjVkl5SVZGVE1WSXhFakVTTVJJMVJMUzBKTUZUSVJNaXV3UWt3Vk1oRXlLMTFkaWJDSkFaNXdQRDVUQ2daZ0t6SThQbE1LQm1Bck1uRCtZZ0dlL21MLy93QUpBQUFEVlFMYkFDSUIyQUFBQUFNQk9RS0dBQUQvL3dBSkFBQURWZ0xiQUNJQjJBQUFBQU1CVVFLR0FBQUFBd0FKQUFBQ0hRTGJBQlFBR0FBY0FLNUxzQjFRV0xVS0FRTUNBVXdidFFvQkF3Y0JURmxMc0F4UVdFQWdDQUVEQXdKaEJ3RUNBajFOQlFFQUFBRmZDUVFDQVFFMlRRb0JCZ1kwQms0YlM3QWRVRmhBS2dBREF3SmhCd0VDQWoxTkFBZ0lBbUVIQVFJQ1BVMEZBUUFBQVY4SkJBSUJBVFpOQ2dFR0JqUUdUaHRBS0FBREF3SmhBQUlDUFUwQUNBZ0hYd0FIQnpWTkJRRUFBQUZmQ1FRQ0FRRTJUUW9CQmdZMEJrNVpXVUFRSEJzYUdSRVJFUkVTSXlNUkVBc0pIeXNUSXpVek5UUTJNeklXRnhVakloVVZNeFVqRVNNQk14VWpGVE1SSTFSTFMwSk1GVElSTWl0ZFhZa0JRSW1KaVlrQm5uQThQbE1LQm1Bck1uRCtZZ0xUZkVuOThnQUNBQWtBQUFJZEF0c0FGQUFZQUc5THNCMVFXTFVLQVFNQ0FVd2J0UW9CQXdjQlRGbExzQjFRV0VBZUFBTURBbUVIQVFJQ1BVMEZBUUFBQVY4RUFRRUJOazBJQVFZR05BWk9HMEFpQUFjSE5VMEFBd01DWVFBQ0FqMU5CUUVBQUFGZkJBRUJBVFpOQ0FFR0JqUUdUbGxBREJFUkVSRVNJeU1SRUFrSkh5c1RJelV6TlRRMk16SVdGeFVqSWhVVk14VWpFU01CTXhFalZFdExRa3dWTWhFeUsxMWRpUUZBaVlrQm5uQThQbE1LQm1Bck1uRCtZZ0xUL1MwQUFBSUFIZ0dVQVZrQzRRQWxBQzhBdkVBTEVBRUNBU0VjQWdVRUFreExzQmhRV0VBbUFBSUJBQUVDY2dBREFBRUNBd0ZwQUFBQUJ3UUFCMmtLQ0FJRUJBVmhDUVlDQlFWTUJVNGJTN0FoVUZoQUxRQUNBUUFCQW5JQUF3QUJBZ01CYVFBQUFBY0VBQWRwQ2dnQ0JBVUZCRmtLQ0FJRUJBVmhDUVlDQlFRRlVSdEFMZ0FDQVFBQkFnQ0FBQU1BQVFJREFXa0FBQUFIQkFBSGFRb0lBZ1FGQlFSWkNnZ0NCQVFGWVFrR0FnVUVCVkZaV1VBWEppWUFBQ1l2Smk0cUtRQWxBQ1FpSlNRVEl4UUxDaHdyRWlZMU5EWXpOVFFtSXlJR0ZSVWpKalUwTmpNeUZoVVZGQll6TXhVR0l5SW1KeU1HQmlNMk5qVTFJZ1lWRkJZelhENW1YQlFhR3hoUUFVYzdRa0FOQ1JFU0hoZ2pCZ1FTTFNROUlqSTdGQlFCbENjelBUUVdGUmNSQ3dvRUNTZ3hOaktNQ3dzNkNSWVRGQlZCS0NFSkZSd09Fd0FBQWdBVkFaUUJXZ0xoQUFzQUdRQlFTN0FZVUZoQUZRQUFBQUlEQUFKcEJRRURBd0ZoQkFFQkFVd0JUaHRBR3dBQUFBSURBQUpwQlFFREFRRURXUVVCQXdNQllRUUJBUU1CVVZsQUVnd01BQUFNR1F3WUV4RUFDd0FLSkFZS0Z5c1NKalUwTmpNeUZoVVVCaU0yTmpVMU5DWWpJZ1lWRlJRV00yVlFVRkpTVVZGU0tTUWtLU2dsSlNnQmxGRldWVkZSVlZaUlJDOHZDUzh2THk4Skx5OEFBQUVBT3dHZUFWWUM0UUFUQUdhMUFnRURBQUZNUzdBY1VGaEFFd0FEQWdBRFdRRUJBQUFDWHdRQkFnSklBazRiUzdBaVVGaEFGUUVCQUFBREFnQURhUUVCQUFBQ1h3UUJBZ0FDVHh0QUdRQUFBd0lBVndBQkFBTUNBUU5wQUFBQUFsOEVBUUlBQWs5WldiY1RJeElrRUFVS0d5c1RNeGN6TmpZek1oVVZJelUwSmlNaUJoVVZJenRIQmdRUU1TRm9VaHdiSENSU0F0b3FGaHR2MU1NZUdTWWR0d0QvL3dBQkFBQUN6d0t1QUFJQ3ZRQUEvLzhBSVFBQUF3RUN1Z0FDQXJ3QUFBQUJBRFQvVXdJTUFnNEFGd0JUdGhNTkFnTUJBVXhMc0NsUVdFQWJBZ0VBQUJsTkFBTURHRTBBQVFFRVlRQUVCQmhOQUFVRkd3Vk9HMEFaQUFFQUJBVUJCR2tDQVFBQUdVMEFBd01ZVFFBRkJSc0ZUbGxBQ1JRa0VSTWpFQVlISENzVE14RVVGak15TmpVUk14RWpKeU1HQmlNaUp4WVZGU00waVM0dExqMkpkUW9IRTBBck54d0lpUUlPL3J3eExFRXdBVEQ5OGtVbktoOURIR0VBQUFFQUlRQUFBdUVDRGdBWUFDbEFKZ1lCQUFFRkFRTUFBa3dFQWdJQUFBRmZBQUVCR1UwRkFRTURHQU5PRXhRVEVTUVNCZ2NjS3pZMk55SUdCeWMyTXlFSEl4RVVGeU1tSmpVUkl3WUdCeU9GTUFNNE9SY1BOSlVCOXdwb0VJWUpDcVlJTGh1SVIvdGNCZ2RmSG5EKy9td3dERTA2QVF0by96Zi8vd0E3LzV3QlZnRGZBUWNCM3dBQS9mNEFDYkVBQWJqOS9yQTFLd0FBQWdBcS8vUUNBZ0s2QUE4QUlRQXNRQ2tBQWdJQVlRQUFBRHROQlFFREF3RmhCQUVCQVR3QlRoQVFBQUFRSVJBZ0dSY0FEd0FPSmdZSkZ5c1dKaVkxTkRZMk16SVdGaFVVQmdZalBnSTFOVFFtSmlNaUJnWVZGUlFXRmpQSVp6YzNaMDVPWnpjM1owNG5LUThQS1NjbktROFBLU2NNUDV5SWlKdy9RSnVJaUp0QWNDdFlUVVpOV0NzcldFMUdUVmdyQUFBQkFGUUFBQUlTQXE0QURBQXFRQ2NFQVFFQ0FVd0FBUUlBQWdFQWdBQUNBak5OQXdFQUFBUmdBQVFFTkFST0VSRVVFUkFGQ1Jzck56TVJJelUyTmpjekVUTVZJVldob2kyRE5FZVQva053QVpoVkJTNGUvY0p3QUFBQkFDc0FBQUlMQXJvQUpBQW9RQ1VBQVFBREFBRURnQUFBQUFKaEFBSUNPMDBBQXdNRVh3QUVCRFFFVGhFYkpCSXJCUWtiS3pjME5qWTNOalkzTmpVMEppTWlGUlVqSmpVME5qTXlGaFlWRkFZR0J3WUhCZ2NoRlNFck1razdNenNVR1M4c1k0Z0VpMnBkWkI4K1ZUOHdHQkVJQVRmK0lDUTVXMFFySnpRZkp6RWdNVjhwRWhab2FFaGFKMFZyU1NzaEZROE9lZ0FCQUNMLzlBSUhBcm9BTHdDQXRTY0JBZ01CVEV1d0NsQllRQzBBQlFRREJBVURnQUFBQWdFQkFISUFBd0FDQUFNQ2FRQUVCQVpoQUFZR08wMEFBUUVIWWdnQkJ3YzhCMDRiUUM0QUJRUURCQVVEZ0FBQUFnRUNBQUdBQUFNQUFnQURBbWtBQkFRR1lRQUdCanROQUFFQkIySUlBUWNIUEFkT1dVQVFBQUFBTHdBdUpCTWtJU1FqRXdrSkhTc1dKalUxTXhVVUZqTXlOalUwSmlNak5UTXlOalUwSmlNaUJoVVZJelUwTmpZek1oWVZGQVlIRlJZV0ZSUUdCaU9pZ0lzMk15NDJQREl6TmlrMExTa3JNSXM2WjBKcGZUa3pPRUk5YkVZTWIxOFNGU3d2THk4M0xIQXhMeXNxS3lvVEhEaFZMMkphT1VrWUJCRldRVHhaTHdBQUFRQVVBQUFDRlFLNkFCVUFXVUFMQ3dFQ0F3Rk1BZ0VDQVV0THNDcFFXRUFhQkFFQ0JRRUFCZ0lBYUFBQkFUTk5BQU1EQmw4QUJnWTBCazRiUUJvQUFRTUJoUVFCQWdVQkFBWUNBR2dBQXdNR1h3QUdCalFHVGxsQUNoRVJFUlFVRXhBSENSMHJKU0UxTmpjekRnSUhNelUyTmpjekVUTVZJeFVqQVRyKzJuczlqUk5QVXhtdkZTa01QMUpTaVpKd3hmTlJ0WklnbHlacUsvNnVjSklBQUFFQUpQLzBBZ1VDcmdBZUFIVkFDeFVCQWdVUUR3SUFBZ0pNUzdBS1VGaEFKUUFBQWdFQkFISUFCUUFDQUFVQ2FRQUVCQU5mQUFNRE0wMEFBUUVHWWdjQkJnWThCazRiUUNZQUFBSUJBZ0FCZ0FBRkFBSUFCUUpwQUFRRUExOEFBd016VFFBQkFRWmlCd0VHQmp3R1RsbEFEd0FBQUI0QUhTTVJGQ1FpRWdnSkhDc1dKalV6RkJZek1qWTFOQ1lqSWdZSEp4TWhGU0VITmpZek1oWVZGQVlqcDRPTk5TOHVOVFlzSGlvUmdoc0JqZjdzQ1JnNEtGaHZnSEFNZVdnMVBEODlPRG9hRmhBQmZIcVlEeE54YlhCOEFBSUFLdi8wQWc0Q3VnQWJBQ2NBZDdVUkFRVURBVXhMc0F4UVdFQW1BQUVDQXdJQmNnQURBQVVHQXdWcEFBSUNBR0VBQUFBN1RRZ0JCZ1lFWVFjQkJBUThCRTRiUUNjQUFRSURBZ0VEZ0FBREFBVUdBd1ZwQUFJQ0FHRUFBQUE3VFFnQkJnWUVZUWNCQkFROEJFNVpRQlVjSEFBQUhDY2NKaUlnQUJzQUdpVWlFaVVKQ1JvckZpWTFORFkyTXpJV0ZTTTBKaU1pQmdZSE5qWXpNaFlWRkFZR0l6WTJOVFFtSXlJR0ZSUVdNNnFBT214UmJHdUxKaXNyS3c0QkdFa3JabVU4YVVJcU1EQXdNREl5TUF5WnRvdW1SblpoTXpVdlZFY1hIM3BuUkdjM2NEOHpOajQrTmpNL0FBRUFJd0FBQWhBQ3JnQU1BQjlBSEFZQkFBRUJUQUFBQUFGZkFBRUJNMDBBQWdJMEFrNFdFUklEQ1Jrck5oSTNJVFVoRlFZQ0ZSUVhJNGFIWi82dkFlMXFqUUdVbWdFbGRYcGJoUDd4alJzWUFBQURBQ0gvOUFJTEFyb0FHQUFrQURBQVJFQkJFd1VDQkFNQlRBY0JBd0FFQlFNRWFRQUNBZ0JoQUFBQU8wMElBUVVGQVdFR0FRRUJQQUZPSlNVWkdRQUFKVEFsTHlzcEdTUVpJeDhkQUJnQUZ5c0pDUmNyRmlZMU5EWTNKaVkxTkRZMk16SVdGaFVVQmdjV0ZSUUdJeEkyTlRRbUl5SUdGUlFXTXhJMk5UUW1JeUlHRlJRV001cDVOamN0THpSblNVbG5OQzh1Ym5sOEt5OHZLeXN1TGlzeU5qWXlNalkyTWd4dldUbFVGeGhSTWpaV016TldOakpSR0N4NFdXOEJvUzhzTERBd0xDd3YvczAwTHk4ME5DOHZOQUFDQUI3LzlBSUNBcm9BR3dBbkFIZTFDZ0VDQmdGTVM3QU1VRmhBSmdBQUFnRUJBSElJQVFZQUFnQUdBbWtBQlFVRFlRQURBenROQUFFQkJHSUhBUVFFUEFST0cwQW5BQUFDQVFJQUFZQUlBUVlBQWdBR0Fta0FCUVVEWVFBREF6dE5BQUVCQkdJSEFRUUVQQVJPV1VBVkhCd0FBQnduSENZaUlBQWJBQm9sSlNJU0NRa2FLeFltTlRNVUZqTXlOalkzQmdZaklpWTFORFkyTXpJV0ZSUUdCaU1TTmpVMEppTWlCaFVVRmpPZmE0c21LeXNyRGdFWVNTdG1aVHhwUW4yQU9teFJNREl5TURBd01EQU1kbUV6TlM5VVJ4Y2ZlbWRFWnplWnRvdW1SZ0Z3UGpZelB6OHpOajRBLy84QUt2LzBBZ0lDdWdBQ0FlVUFBUC8vQUZRQUFBSVNBcTRBQWdIbUFBRC8vd0FyQUFBQ0N3SzZBQUlCNXdBQS8vOEFJdi8wQWdjQ3VnQUNBZWdBQVAvL0FCUUFBQUlWQXJvQUFnSHBBQUQvL3dBay8vUUNCUUt1QUFJQjZnQUEvLzhBS3YvMEFnNEN1Z0FDQWVzQUFQLy9BQ01BQUFJUUFxNEFBZ0hzQUFELy93QWgvL1FDQ3dLNkFBSUI3UUFBLy84QUh2LzBBZ0lDdWdBQ0FlNEFBUC8vQUNyLzlBSUNBcm9BQWdJYkFBQUFBZ0E1Ly9ZQjlBSmdBQXdBR2dBcVFDY0FBQUFDQXdBQ2FRVUJBd01CWVFRQkFRRThBVTRORFFBQURSb05HUlFTQUF3QUN5VUdDUmNyRmlZbU5UUTJNeklXRlJRR0l6WTJOVFUwSmlNaUJoVVZGQll6eW1JdmFuUnphbXB6TWlBZ01qTWdJVElLUG9kd3BaQ1FwYVdRYUZGWlJWbFNWVlpGV1ZFQUFBRUFZQUFBQWZrQ1ZnQU1BQ2RBSkFRQkFRSUJUQUFDQVFLRkFBRUFBWVVEQVFBQUJHQUFCQVEwQkU0UkVSUVJFQVVKR3lzM014RWpOVFkyTnpNUk14VWhZWXlOTG53d1BJUCthRzRCUjFJRUxoMytHRzRBQVFBMkFBQUI4UUpnQUNJQVNrdXdDbEJZUUJvQUFRQURBQUZ5QUFJQUFBRUNBR2tBQXdNRVh3QUVCRFFFVGh0QUd3QUJBQU1BQVFPQUFBSUFBQUVDQUdrQUF3TUVYd0FFQkRRRVRsbTNFUm9rRXlrRkNSc3JOelEyTmpjMk5qVTBKaU1pQmhVVkl5WTFORFl6TWhZV0ZSUUdCZ2NHQmhVekZTRTJMa0kyUkVNb0ppZ3Rnd0o4WjAxY0pqaElOQjhaOFA1Rkl5OVBQQ28wU2kwYktTb29IZ3dTWEdBNVVTZEFZajhqRlJVSmVBQUJBQzMvOWdIdkFtQUFMZ0I4dFNjQkFnTUJURXV3RGxCWVFDc0FCUVFEQkFVRGdBQUFBZ0VCQUhJQUJnQUVCUVlFYVFBREFBSUFBd0pwQUFFQkIySUlBUWNIUEFkT0cwQXNBQVVFQXdRRkE0QUFBQUlCQWdBQmdBQUdBQVFGQmdScEFBTUFBZ0FEQW1rQUFRRUhZZ2dCQndjOEIwNVpRQkFBQUFBdUFDMGtFeVFoSkNNVENRa2RLeFltTlRVekZSUVdNekkyTlRRbUl5TTFNekkyTlRRbUl5SUdGUlVqTlRRMk5qTXlGaFVVQmdjVkZoWVZGQVlqbzNhRUx5d3FMaThsTXpBZ0tpZ2pKQ3lCTldBL1lISXlLVEE1ZDJjS1lGQVJFaUlsS2ljcUpXUW9KU01sSkNBT0Z6QktLbGhMTDBVU0F4QkxPRTFlQUFFQUlRQUFBZjRDWUFBVkFDNUFLd3NDQWdJREFVd0FBUU1CaFFRQkFnVUJBQVlDQUdnQUF3TTJUUUFHQmpRR1RoRVJFUlFVRXhBSENSMHJKU0UxTmpjekRnSUhNelUyTmpjekVUTVZJeFVqQVMzKzlHMDFpdzFIVVJ1ZkZpb0pQVXRMaG41c3JjayttSUlmZ1NkZUl2N1lhMzRBQVFBdi8vWUI4QUpWQUI0QWNVQUxGUUVDQlJBUEFnQUNBa3hMc0E1UVdFQWpBQUFDQVFFQWNnQURBQVFGQXdSbkFBVUFBZ0FGQW1rQUFRRUdZZ2NCQmdZOEJrNGJRQ1FBQUFJQkFnQUJnQUFEQUFRRkF3Um5BQVVBQWdBRkFta0FBUUVHWWdjQkJnWThCazVaUUE4QUFBQWVBQjBqRVJRa0loSUlDUndyRmlZMU14UVdNekkyTlRRbUl5SUdCeWNUSVJVaEJ6WTJNeklXRlJRR0k2bDZoUzhxS1M4dktCMGxEbmtZQVhEL0FRY1VOQ2hUWm5kbUNtcGNLek0yTUM0eUdCSVBBVXh6ZXcwVVpsOWVid0FDQURULzlnSDRBbUFBRndBakFITzFEZ0VGQXdGTVM3QU9VRmhBSkFBQkFnTUNBWElBQUFBQ0FRQUNhUUFEQUFVR0F3VnBDQUVHQmdSaEJ3RUVCRHdFVGh0QUpRQUJBZ01DQVFPQUFBQUFBZ0VBQW1rQUF3QUZCZ01GYVFnQkJnWUVZUWNCQkFROEJFNVpRQlVZR0FBQUdDTVlJaDRjQUJjQUZpUWhFaVFKQ1JvckZpWTFORFl6TWhZVkl6UWpJZ1lITmpZek1oWVZGQVlqTmpZMU5DWWpJZ1lWRkJZenFYVnlkR0pxaEVzMElnRVNRQ2xaWkhsaUppc3JLU2tzTENrS2lKeXdsbWhZV0U5WkR4OW9XRnhzYURNckxUTXpMU3N6QUFFQU1nQUFBZmdDVlFBTEFCMUFHZ1lCQUFFQlRBQUJBQUFDQVFCbkFBSUNOQUpPRlJFU0F3a1pLelkyTnlFMUlSVUdCaFVWSTR4d1dmN2RBY1plZUphQTkyWjRUM1ByZVM4QUF3QXovL1lCK1FKZ0FCVUFJUUF0QUVKQVB4QUVBZ1FEQVV3QUFBQUNBd0FDYVFjQkF3QUVCUU1FYVFnQkJRVUJZUVlCQVFFOEFVNGlJaFlXQUFBaUxTSXNLQ1lXSVJZZ0hCb0FGUUFVS1FrSkZ5c1dKalUwTnlZMU5EWTJNeklXRmhVVUJ4WVZGQVlqRWpZMU5DWWpJZ1lWRkJZekVqWTFOQ1lqSWdZVkZCWXpwbk5mVGpOZVFFQmZNMDVnZFc4bEt5c2xKU2twSlNrdk1DZ29MeTRwQ2w5UFlpc3hWREpOS3l0T01WVXdLbU5QWHdGdEppVWtKeWNrSlNiKytTc25KaXNySmljckFBQUNBRFAvOWdIM0FtQUFHQUFrQUhPMUNRRUNCZ0ZNUzdBT1VGaEFKQUFBQWdFQkFISUFBd0FGQmdNRmFRZ0JCZ0FDQUFZQ2FRQUJBUVJpQndFRUJEd0VUaHRBSlFBQUFnRUNBQUdBQUFNQUJRWURCV2tJQVFZQUFnQUdBbWtBQVFFRVlnY0JCQVE4QkU1WlFCVVpHUUFBR1NRWkl4OGRBQmdBRnlRbElSSUpDUm9yRmlZMU14UXpNalkyTndZR0l5SW1OVFEyTXpJV0ZSUUdJeEkyTlRRbUl5SUdGUlFXTTY1cGhFb2xKUTBCRUVNcFdXTjVZWFYxY25RcExDd3BLU3NxS1FwbldGZ21SajBQSUdoWVhXeUpuSytXQVVNekxTczBNeXd0TXdBREFEbi85Z0gwQW1BQURBQVZBQjRBTFVBcUdSZ1BBd01DQVV3RUFRRUFBZ01CQW1rQUF3TUFZUUFBQUR3QVRnQUFIQm9URVFBTUFBc2tCUWtYS3dBV0ZSUUdJeUltSmpVME5qTURGQmNUSmlNaUJoVXpOQ2NERmpNeU5qVUJpbXBxYzAxaUwycDBVd2xzRFJVeklLVUtiUkFWTWlBQ1lKQ2xwWkEraDNDbGtQNm9TU1FCVmdkVlZrMGovcWtJVVZrQS8vOEFLdi8wQWdJQ3VnQUNBZVVBQVAvL0FGUUFBQUlTQXE0QUFnSG1BQUQvL3dBckFBQUNDd0s2QUFJQjV3QUEvLzhBSXYvMEFnY0N1Z0FDQWVnQUFQLy9BQlFBQUFJVkFyb0FBZ0hwQUFELy93QWsvL1FDQlFLdUFBSUI2Z0FBLy84QUt2LzBBZzRDdWdBQ0Flc0FBUC8vQUNNQUFBSVFBcTRBQWdIc0FBRC8vd0FoLy9RQ0N3SzZBQUlCN1FBQS8vOEFIdi8wQWdJQ3VnQUNBZTRBQVAvL0FDci85QUlDQXJvQUFnSWJBQUQvL3dBNS8vWUI5QUpnQUFJQitnQUEvLzhBWUFBQUFma0NWZ0FDQWZzQUFQLy9BRFlBQUFIeEFtQUFBZ0g4QUFELy93QXQvL1lCN3dKZ0FBSUIvUUFBLy84QUlRQUFBZjRDWUFBQ0FmNEFBUC8vQUMvLzlnSHdBbFVBQWdIL0FBRC8vd0EwLy9ZQitBSmdBQUlDQUFBQS8vOEFNZ0FBQWZnQ1ZRQUNBZ0VBQVAvL0FEUC85Z0g1QW1BQUFnSUNBQUQvL3dBei8vWUI5d0pnQUFJQ0F3QUEvLzhBT2YvMkFmUUNZQUFDQWdRQUFBQURBQ3IvOUFJQ0Fyb0FEd0FaQUNNQU1FQXRIUndURWdRREFnRk1BQUlDQVdFRUFRRUJPMDBBQXdNQVlRQUFBRHdBVGdBQUlCNFdGQUFQQUE0bUJRa1hLd0FXRmhVVUJnWWpJaVltTlRRMk5qTURGQmNUSmlNaUJnWVZNelFuQXhZek1qWTJOUUZrWnpjM1owNU9aemMzWjA1ZkJvMFVJQ2NwRDc0S2toUXBKeWtQQXJwQW00aUltMEEvbklpSW5ELytla1F2QVhvUEsxaE5YaW4rZWhjcldFMEEvLzhBSWY5UkFTMEF4Z0VIQWpvQUFQMm9BQW14QUFLNC9haXdOU3NBLy84QU4vOVlBU1lBdWdFSEFqc0FBUDJvQUFteEFBRzQvYWl3TlNzQS8vOEFLZjlZQVNrQXhnRUhBandBQVAyb0FBbXhBQUc0L2Fpd05Tc0EvLzhBSmY5UkFTZ0F4Z0VIQWowQUFQMm9BQW14QUFHNC9haXdOU3NBLy84QUhmOVlBUzRBeHdFSEFqNEFBUDJvQUFteEFBRzQvYWl3TlNzQS8vOEFKLzlSQVNnQXVnRUhBajhBQVAyb0FBbXhBQUc0L2Fpd05Tc0EvLzhBSGY5UkFUQUF4Z0VIQWtBQUFQMm9BQW14QUFLNC9haXdOU3NBLy84QUpmOVlBU3dBdWdFSEFrRUFBUDJvQUFteEFBRzQvYWl3TlNzQS8vOEFJLzlSQVNrQXh3RUhBa0lBQVAyb0FBbXhBQU80L2Fpd05Tc0EvLzhBSGY5UkFUQUF4Z0VIQWtNQUFQMm9BQW14QUFLNC9haXdOU3NBLy84QUlmL3dBUzBCWlFFSEFqb0FBUDVIQUFteEFBSzQva2V3TlNzQS8vOEFOLy85QVNZQlh3RUhBanNBQVA1TkFBbXhBQUc0L2syd05Tc0EvLzhBS2YvOUFTa0Jhd0VIQWp3QUFQNU5BQW14QUFHNC9rMndOU3NBLy84QUpmL3dBU2dCWlFFSEFqMEFBUDVIQUFteEFBRzQva2V3TlNzQS8vOEFIZi8rQVM0QmJRRUhBajRBQVA1T0FBbXhBQUc0L2s2d05Tc0EvLzhBSi8vd0FTZ0JXUUVIQWo4QUFQNUhBQW14QUFHNC9rZXdOU3NBLy84QUhmL3lBVEFCWndFSEFrQUFBUDVKQUFteEFBSzQva213TlNzQS8vOEFKZi85QVN3Qlh3RUhBa0VBQVA1TkFBbXhBQUc0L2syd05Tc0EvLzhBSS8vdkFTa0JaUUVIQWtJQUFQNUdBQW14QUFPNC9rYXdOU3NBLy84QUhmL3lBVEFCWndFSEFrTUFBUDVKQUFteEFBSzQva213TlNzQS8vOEFJUUZFQVMwQ3VRRUdBam9BbXdBSnNRQUN1UCtic0RVckFQLy9BRGNCVEFFbUFxNEJCZ0k3QUp3QUNiRUFBYmovbkxBMUt3RC8vd0FwQVV3QktRSzZBUVlDUEFDY0FBbXhBQUc0LzV5d05Tc0EvLzhBSlFGRkFTZ0N1Z0VHQWowQW5BQUpzUUFCdVArY3NEVXJBUC8vQUIwQlRBRXVBcnNCQmdJK0FKd0FDYkVBQWJqL25MQTFLd0QvL3dBbkFVVUJLQUt1QVFZQ1B3Q2NBQW14QUFHNC81eXdOU3NBLy84QUhRRkZBVEFDdWdFR0FrQUFuQUFKc1FBQ3VQK2NzRFVyQVAvL0FDVUJUQUVzQXE0QkJnSkJBSndBQ2JFQUFiai9uTEExS3dELy93QWpBVVVCS1FLN0FRWUNRZ0NjQUFteEFBTzQvNXl3TlNzQS8vOEFIUUZGQVRBQ3VnRUdBa01BbkFBSnNRQUN1UCtjc0RVckFBQUNBQ0VCcVFFdEF4NEFDd0FaQUN4QUtRQUNBZ0JoQUFBQVMwMEZBUU1EQVdFRUFRRUJUQUZPREF3QUFBd1pEQmdURVFBTEFBb2tCZ29YS3hJbU5UUTJNeklXRlJRR0l6WTJOVFUwSmlNaUJoVVZGQll6WlVSRFFFTkdSVUViRWhJYkd4SVNHd0dwVldWbFZsUm5aVlZLS0RZbE5pZ29OaVUyS0FBQUFRQTNBYkFCSmdNU0FBd0FLa0FuQkFFQkFnRk1BQUVDQUFJQkFJQUFBZ0pIVFFNQkFBQUVZQUFFQkVnRVRoRVJGQkVRQlFvYkt4TXpOU00xTmpZM014RXpGU00zVWxJWlJ4b3JTdThCKzdjM0FoZ1AvdWxMQUFFQUtRR3dBU2tESGdBaUFFNUxzQlZRV0VBY0FBRUFBd0FCY2dBQUFBSmhBQUlDUzAwQUF3TUVYd0FFQkVnRVRodEFIUUFCQUFNQUFRT0FBQUFBQW1FQUFnSkxUUUFEQXdSZkFBUUVTQVJPV2JjUkdTUVRLZ1VLR3lzVE5EWTNOalkzTmpVMEppTWlCaFVWSXlZMU5EWXpNaFlWRkFZR0J3WUdCek1WSVNrdkx4b2VDZ3dWRkJZWFVBTktPVWN4SVNzakJ4d0dtdjhBQWNrck9TTVRHZzRRR2c0V0ZCY1NEUTh6TTBjbUpEZ2xHQVVTQmtzQUFRQWxBYWtCS0FNZUFDc0FQMEE4R2hnQ0FnTWtBUUVDQkFJQ0FBRURUQUFDQUFFQUFnRnBBQU1EQkdFQUJBUkxUUUFBQUFWaEJnRUZCVXdGVGdBQUFDc0FLaWNqSVNNbkJ3b2JLeEltTlRVekZSUVdNekkyTlRRakl6VXpNalkxTkNNaUJoVVZJelUwTmpNeUZoVVVCZ2NWRmhZVkZBWWphVVJUR1JZVkdESWdJaE1XSmhJV1UwVTFPRU1iR3gwZ1J6a0JxVHN6QndnVUZSVVZMVVVWRmlZVUVnZ01MamcxTVJza0RnUUxLeDh4T0FBQUFRQWRBYkFCTGdNZkFCTUFXRUFLQ2dFQ0F3SUJBQUlDVEV1d0psQllRQm9FQVFJRkFRQUdBZ0JvQUFFQlIwMEFBd01HWHdBR0JrZ0dUaHRBR2dBQkF3R0ZCQUVDQlFFQUJnSUFhQUFEQXdaZkFBWUdTQVpPV1VBS0VSRVJFeE1URUFjS0hTc1RJelUyTnpNR0JnY3pOVFkzTXhVekZTTVZJN09XTWloWkRqOFlTQmNRTENnb1V3SDJRRkNaUElZaU1DdzRsRVZHQUFBQkFDY0JxUUVvQXhJQUhBQjFRQXNVQVFJRkR3NENBQUlDVEV1d0dsQllRQ1VBQUFJQkFRQnlBQVVBQWdBRkFta0FCQVFEWHdBREEwZE5BQUVCQm1JSEFRWUdUQVpPRzBBbUFBQUNBUUlBQVlBQUJRQUNBQVVDYVFBRUJBTmZBQU1EUjAwQUFRRUdZZ2NCQmdaTUJrNVpRQThBQUFBY0FCc2lFUk1rSWhJSUNod3JFaVkxTXhRV016STJOVFFtSXlJSEp6Y3pGU01ITmpNeUZoVVVCaU50UmxRWEZoUVlHQlFZRWt3TzFvOEVHQ0V3UEVROEFhaytOaGNaSGh3YUdoa0t4a280RGowNlBFSUFBZ0FkQWFrQk1BTWVBQmdBSXdCM3RROEJCUU1CVEV1d0hWQllRQ1lBQVFJREFnRnlBQU1BQlFZREJXa0FBZ0lBWVFBQUFFdE5DQUVHQmdSaEJ3RUVCRXdFVGh0QUp3QUJBZ01DQVFPQUFBTUFCUVlEQldrQUFnSUFZUUFBQUV0TkNBRUdCZ1JoQndFRUJFd0VUbGxBRlJrWkFBQVpJeGtpSGh3QUdBQVhKU0VTSkFrS0dpc1NKalUwTmpNeUZoVWpOQ01pQmdZSE5qWXpNaFlWRkFZak5qWTFOQ01pQmhVVUZqTmhSRVZIUHp4VEt4WVVCUUVMSlJjN09FczhGUmt1RmhrYUZRR3BUMkZzV1Q0ekt4Y2xJdzBRUHpVM1FrY2NGVEVaR0JVY0FBQUJBQ1VCc0FFc0F4SUFDd0FmUUJ3RkFRQUJBVXdBQUFBQlh3QUJBVWROQUFJQ1NBSk9GaEVSQXdvWkt4STNJelVoRlFZR0ZSUVhJMWh5cFFFSE9FWUJWd0pFaEVvNFJJQkZGQTBBQXdBakFha0JLUU1mQUJRQUhnQXFBRVJBUVE4RUFnUURBVXdIQVFNQUJBVURCR2tBQWdJQVlRQUFBRXROQ0FFRkJRRmhCZ0VCQVV3QlRoOGZGUlVBQUI4cUh5a2xJeFVlRlIwYkdRQVVBQk1wQ1FvWEt4SW1OVFEzSmlZMU5EWXpNaFlWRkFjV0ZSUUdJelkyTlRRbUl5SVZGRE1XTmpVMEppTWlCaFVVRmpOa1FUWVdGMEE2T2tBdU4wRkNFeFVWRXljbkZoa1pGaGNZR0JjQnFUd3dQQmtPS0Jnc096c3NNaHdhT3pBODRCWVRGQlVwS1p3WUZSVVhGeFVWR0FBQUFnQWRBYWtCTUFNZUFCZ0FJd0IzdFFrQkFnWUJURXV3SFZCWVFDWUFBQUlCQVFCeUNBRUdBQUlBQmdKcEFBVUZBMkVBQXdOTFRRQUJBUVJpQndFRUJFd0VUaHRBSndBQUFnRUNBQUdBQ0FFR0FBSUFCZ0pwQUFVRkEyRUFBd05MVFFBQkFRUmlCd0VFQkV3RVRsbEFGUmtaQUFBWkl4a2lIeDBBR0FBWEpDVWhFZ2tLR2lzU0pqVXpGRE15TmpZM0JnWWpJaVkxTkRZek1oWVZGQVlqTmpZMU5DWWpJZ1lWRkRObFBGTXJGaFFGQVFzbkZ6azRTenhJUkVWSEZoa2FGUlVaTGdHcFBqTXJGeVVqRFJBOU5EZEZUMkZzV2N3WkdCVWNIQlV4QUFBQi94Yi85QUdRQXJvQUF3QW1TN0FxVUZoQUN3QUFBRE5OQUFFQk5BRk9HMEFKQUFBQkFJVUFBUUYyV2JRUkVBSUpHQ3NCTXdFakFUaFkvZDVZQXJyOU9nQURBQzcvOUFNUEFyb0FBd0FRQURFQTg3RUdaRVJMc0JSUVdMVUlBUU1BQVV3YnRRZ0JBd1FCVEZsTHNCUlFXRUEwQkFFQUF3Q0ZBQU1DQTRVQUNBY0tCd2h5QlFFQ0FBWUhBZ1pvQUFrQUJ3Z0pCMm9BQ2dFQkNsY0FDZ29CWHdzQkFRb0JUeHRMc0JWUVdFQThBQUFFQUlVQUJBTUVoUUFEQWdPRkFBZ0hDZ2NJY2dBQkN3R0dCUUVDQUFZSEFnWm9BQWtBQndnSkIyb0FDZ3NMQ2xjQUNnb0xYd0FMQ2d0UEcwQTlBQUFFQUlVQUJBTUVoUUFEQWdPRkFBZ0hDZ2NJQ29BQUFRc0JoZ1VCQWdBR0J3SUdhQUFKQUFjSUNRZHFBQW9MQ3dwWEFBb0tDMThBQ3dvTFQxbFpRQkl4TUM4dUp5VVRLeEVSRkJFUkVSQU1DUjhyc1FZQVJBRXpBU01ETXpVak5UWTJOek1STXhVakFUUTJOelkyTnpZMU5DWWpJZ1lWRlNNbU5UUTJNeklXRlJRR0J3WUhNeFVoQW9aWS9kNVlObEpTR1VjYUswcnZBZUV2THhvZUNnd1ZGQllYVUFOS09VY3hQRE1kREpyL0FBSzYvVG9Cb0xvM0FoZ1AvdVpML3RBck9pVVRHZzRRR2c0V0ZCY1NEZzR6TTBjbU5FTWlGQXhMLy84QU4vL3dBeHdDdWdBaUFqRUFBQUFqQWtRQlRRQUFBQU1DS1FIMEFBRC8vd0FwLy9BREhBSzZBQ0lDTWdBQUFDTUNSQUZOQUFBQUF3SXBBZlFBQUFBREFDNy85QU1QQXJvQUF3QVFBQ1FCRGJFR1pFUkxzQlJRV0VBT0NBRURBQnNCQ1FvVEFRY0pBMHdiUUE0SUFRTUVHd0VKQ2hNQkJ3a0RURmxMc0JKUVdFQTNCQUVBQXdDRkFBTUNBNFVBQ0FJR0FnZ0dnQVVCQWdBR0NnSUdhQUFLQ1FFS1Z3c0JDUXdCQndFSkIyZ0FDZ29CWHcwQkFRb0JUeHRMc0JSUVdFQTdCQUVBQXdDRkFBTUNBNFVBQ0FJR0FnZ0dnQUFCRFFHR0JRRUNBQVlLQWdab0FBb0pEUXBYQ3dFSkRBRUhEUWtIYUFBS0NnMWZBQTBLRFU4YlFEOEFBQVFBaFFBRUF3U0ZBQU1DQTRVQUNBSUdBZ2dHZ0FBQkRRR0dCUUVDQUFZS0FnWm9BQW9KRFFwWEN3RUpEQUVIRFFrSGFBQUtDZzFmQUEwS0RVOVpXVUFXSkNNaUlTQWZIaDBhR1JNUkVSRVVFUkVSRUE0Skh5dXhCZ0JFQVRNQkl3TXpOU00xTmpZM014RXpGU01CSXpVMk56TUdCZ2N6TlRZM014VXpGU01WSXdLR1dQM2VXRFpTVWhsSEdpdEs3d0ptbGpFcFdRNC9HRWdYRUN3b0tGTUN1djA2QWFDNk53SVlELzdtUy83K1FGQ2FQSWNpTUN3NGxFVkdBQUFEQUNiLzlBTVBBcm9BS3dBdkFFTUF6ckVHWkVSQUdCb1lBZ0lESkFFQkFnUUNBZ0FCT2dFS0N6SUJDQW9GVEV1d0VsQllRRDBBQ1FBRkFBa0ZnQVlCQkFBREFnUURhUUFDQUFFQUFnRnBBQUFQQVFVTEFBVnBBQXNLQnd0WERBRUtEUUVJQndvSWFBQUxDd2RmRGdFSEN3ZFBHMEJCQUFrQUJRQUpCWUFBQnc0SGhnWUJCQUFEQWdRRGFRQUNBQUVBQWdGcEFBQVBBUVVMQUFWcEFBc0tEZ3RYREFFS0RRRUlEZ29JYUFBTEN3NWZBQTRMRGs5WlFDQUFBRU5DUVVBL1BqMDhPVGcxTkRFd0x5NHRMQUFyQUNvbkl5RWpKeEFKR3l1eEJnQkVFaVkxTlRNVkZCWXpNalkxTkNNak5UTXlOalUwSXlJR0ZSVWpOVFEyTXpJV0ZSUUdCeFVXRmhVVUJpTUJNd0VqSlNNMU5qY3pCZ1lITXpVMk56TVZNeFVqRlNOcVJGTVpGaFVZTWlBaUV4WW1FaFpUUlRVNFF4c2JIU0JIT1FIZFdQM2VXQUl3bGpFcFdRNC9HRWdYRUN3b0tGTUJSVHN6QndnVUZSVVZMVVVWRmlZVUVnZ01MamcxTVJza0RnUUxLeDh4T0FGMS9UcFRRRkNhUEljaU1DdzRsRVZHQVAvL0FEZi83d01kQXJvQUlnSXhBQUFBSXdKRUFVMEFBQUFEQWk0QjlBQUEvLzhBSmYvdkF4MEN1Z0FpQWpNQUFBQWpBa1FCVFFBQUFBTUNMZ0gwQUFELy93QW4vKzhESFFLNkFDSUNOUUFBQUNNQ1JBRk5BQUFBQXdJdUFmUUFBUC8vQUNYLzd3TDFBcm9BSWdJM0FBQUFJd0pFQVNVQUFBQURBaTRCekFBQUFBRUFSZ0FBQU5BQWlRQURBQk5BRUFBQUFBRmZBQUVCTkFGT0VSQUNDUmdyTnpNVkkwYUtpb21KQUFFQVJ2OWtBTkFBaVFBR0FEcTFCQUVBQVFGTVM3QWRVRmhBRUFBQkFRQmZBQUFBTkUwQUFnSTRBazRiUUJBQUFnQUNoZ0FCQVFCZkFBQUFOQUJPV2JVU0VSQURDUmtyTXlNMU14VUhJMzAzaWtKSWlYMm9BQUFDQUdFQUFBRHJBZzRBQXdBSEFCOUFIQUFCQVFCZkFBQUFOazBBQWdJRFh3QURBelFEVGhFUkVSQUVDUm9yRXpNVkl4VXpGU05oaW9xS2lnSU9pZnlKQUFBQ0FHSC9aQURyQWc0QUF3QUtBRkMxQ0FFQ0F3Rk1TN0FkVUZoQUdnQUJBUUJmQUFBQU5rMEFBd01DWHdBQ0FqUk5BQVFFT0FST0cwQWFBQVFDQklZQUFRRUFYd0FBQURaTkFBTURBbDhBQWdJMEFrNVp0eElSRVJFUUJRa2JLeE16RlNNVEl6VXpGUWNqWVlxS056ZUtRa2dDRG9uK2U0bDlxQUFBQXdCaUFBQURoZ0NKQUFNQUJ3QUxBQnRBR0FRQ0FnQUFBVjhGQXdJQkFUUUJUaEVSRVJFUkVBWUpIQ3MzTXhVakpUTVZJeVV6RlNOaWlvb0JUWXFLQVUyS2lvbUppWW1KaVFBQ0FGb0FBQUR6QXE0QUF3QUhBQjlBSEFBQkFRQmZBQUFBTTAwQUFnSURYd0FEQXpRRFRoRVJFUkFFQ1JvckV6TURJd2N6RlNOYW1TUlNHNHFLQXE3K0Z6eUpBQUlBV3Y5ZkFQTUNEUUFEQUFjQU8wdXdLbEJZUUJVQUFRRUFYd0FBQURaTkFBSUNBMThBQXdNNEEwNGJRQklBQWdBREFnTmpBQUVCQUY4QUFBQTJBVTVadGhFUkVSQUVDUm9yRXpNVkl4Y3pFeU5paW9vYlVpU1pBZzJKUFA0WEFBSUFPUUFBQWlBQ3VnQWdBQ1FBTUVBdEFBRUFBd0FCQTRBQUF3UUFBd1IrQUFBQUFtRUFBZ0k3VFFBRUJBVmZBQVVGTkFWT0VSRWFKUk1vQmdrY0t6YzBOalkzTmpZMU5DTWlCaFVYSXlZMU5EWTJNeklXRlJRR0JnY0dCaFVWSXdjekZTUHJIQ1lmSUI5aE9Tb0Jpd1E1Y1ZGdmZSMHBJaWtuZlFhS2l2QXVRU2NYRnlZY1N6a2lHeEVTT1YwMlcxY3RRU2thSVRBbEhEeUpBQUlBU3Y5VUFqRUNEZ0FEQUNRQU5rQXpBQUlCQkFFQ0JJQUFCQU1CQkFOK0FBRUJBRjhBQUFBMlRRQURBd1ZpQmdFRkJUZ0ZUZ1FFQkNRRUl4TXBHeEVRQndrYkt4TXpGU01DSmpVME5qWTNOalkxTlRNVkZBWUdCd1lHRlJRek1qWTFKek1XRlJRR0JpUDdpb28wZlIwcElpa25mUndtSHlBZllUa3FBWXNFT1hGUkFnNkovYzliVnkxQktSb2hNQ1VjS3k1Qkp4Y1hKaHhMT1NJYkVSSTVYVFlBQVFCZ0FTRUE2Z0dxQUFNQUdFQVZBQUFCQVFCWEFBQUFBVjhBQVFBQlR4RVFBZ2tZS3hNekZTTmdpb29CcW9rQUFRQW9BTkFCTndIZkFBOEFIa0FiQUFBQkFRQlpBQUFBQVdFQ0FRRUFBVkVBQUFBUEFBNG1Bd2tYS3pZbUpqVTBOall6TWhZV0ZSUUdCaU9LUGlRa1BpVWxQaVVsUGlYUUpENGxKVDRsSlQ0bEpUNGtBQUFCQUI4QmFnRmlBcTRBRVFBbFFDSVBEZzBNQ3dvSkJnVUVBd0lCRFFFQUFVd0FBUUVBWHdBQUFETUJUaGdYQWdrWUt4TUhKemNuTnhjbk13YzNGd2NYQnljWEk2aGdLWEJ3S1dBUlV4RmdLWEJ3S1dBUlV3SGhTa2N1TDBaS2QzWkpSaTh1UjBwMy8vOEFXZ0FBQWJNQ3JnQWpBbE1Bd0FBQUFBSUNVd0FBQUFJQUNmLzBBaUFDdWdBYkFCOEFzMHV3RmxCWVFDZ1FEd2tEQVF3S0FnQUxBUUJuQmdFRUJETk5EZ2dDQWdJRFh3Y0ZBZ01ETmswTkFRc0xOQXRPRzB1d0tsQllRQ1lIQlFJRERnZ0NBZ0VEQW1nUUR3a0RBUXdLQWdBTEFRQm5CZ0VFQkROTkRRRUxDelFMVGh0QU1BWUJCQU1FaFEwQkN3QUxoZ2NGQWdNT0NBSUNBUU1DYUJBUENRTUJBQUFCVnhBUENRTUJBUUJmREFvQ0FBRUFUMWxaUUI0Y0hCd2ZIQjhlSFJzYUdSZ1hGaFVVRXhJUkVSRVJFUkVSRVJBUkNSOHJOeU0xTXpjak5UTTNNd2N6TnpNSE14VWpCek1WSXdjak55TUhJd0UzSXdkSVAxVVpRRllwYUNsNEtXZ3BTMkVaVEdJamFDTjRJMmdCR1JsNEdhTnNlMnpFeE1URWJIdHNyNit2QVJ0N2V3QUJBQUgvendFVkF0OEFBd0FtUzdBcVVGaEFDd0FCQUFHR0FBQUFOUUJPRzBBSkFBQUJBSVVBQVFGMldiUVJFQUlKR0NzVE13TWp0bCswWUFMZi9QQUFBUUFCLzg4QkZRTGZBQU1BSmt1d0tsQllRQXNBQVFBQmhnQUFBRFVBVGh0QUNRQUFBUUNGQUFFQmRsbTBFUkFDQ1JnckV6TVRJd0ZmdFdBQzMvendBQUgvOFFNV0FWMERlQUFEQUNDeEJtUkVRQlVBQUFFQkFGY0FBQUFCWHdBQkFBRlBFUkFDQ1JncnNRWUFSQU1oRlNFUEFXeitsQU40WXYvL0FGb0FBQUR6QXE0QkJ3SlVBQUFBb1FBSXNRQUNzS0d3TlN2Ly93QksvL0lDTVFLc0FRY0NWZ0FBQUo0QUNMRUFBckNlc0RVckFBRUFGQUZKQUo0QjBnQURBQmhBRlFBQUFRRUFWd0FBQUFGZkFBRUFBVThSRUFJSkdDc1RNeFVqRklxS0FkS0pBQUVBRkFFaEFKNEJxZ0FEQUJoQUZRQUFBUUVBVndBQUFBRmZBQUVBQVU4UkVBSUpHQ3NUTXhVakZJcUtBYXFKQUFFQU0vOWpBVEVDNEFBTkFFRkxzQjlRV0VBTEFBQUFOVTBBQVFFNEFVNGJTN0FtVUZoQUN3QUJBUUJmQUFBQU5RRk9HMEFRQUFBQkFRQlhBQUFBQVY4QUFRQUJUMWxadEJZVkFna1lLeFltTlRRMk56TUdCaFVVRmhjamlWWldVRmc2U1VrNldFSG1lM3pvWEdEdGNISHZZQUFBQVFBYy8yTUJHZ0xnQUEwQVFVdXdIMUJZUUFzQUFBQTFUUUFCQVRnQlRodExzQ1pRV0VBTEFBRUJBRjhBQUFBMUFVNGJRQkFBQUFFQkFGY0FBQUFCWHdBQkFBRlBXVm0wRmhVQ0NSZ3JGalkxTkNZbk14WVdGUlFHQnlOV1NVazZXRkJXVmxCWVBlOXhjTzFnWE9oOGUrWmNBQUFCQUIzL1lRRlhBdDhBSkFCMVM3QWpVRmhBTFFBRUFRVUJCQVdBQUFVQUFRVUFmZ0FCQUFBR0FRQnBBQU1EQW1FQUFnSTlUUUFHQmdkaENBRUhCemdIVGh0QUtnQUVBUVVCQkFXQUFBVUFBUVVBZmdBQkFBQUdBUUJwQUFZSUFRY0dCMlVBQXdNQ1lRQUNBajBEVGxsQUVBQUFBQ1FBSkJZUkZ4RVdFUllKQ1IwckJDWW1OVFUwSmlNMU1qWTFOVFEyTmpNVklnWVZGQWNIQmdZakZUSVdGeGNXRlJRekZRRU5YRE01S0NnNU0xeEtLVG9FQXdJN1EwSThBZ01FWTU4WFFEM0JIeDFjSFIvQlBVQVhUUnNpS0ZCTU5UY0tOalpNVUNnOVRRQUJBQzcvWVFGb0F0OEFKQUJ1UzdBalVGaEFMQUFDQlFFRkFnR0FBQUVHQlFFR2ZnQUZBQVlBQlFacEFBTURCR0VBQkFROVRRQUFBQWRoQUFjSE9BZE9HMEFwQUFJRkFRVUNBWUFBQVFZRkFRWitBQVVBQmdBRkJta0FBQUFIQUFkbEFBTURCR0VBQkFROUEwNVpRQXNXRVJZUkZ4RVdFQWdKSGlzWE1qVTBOemMyTmpNMUlpWW5KeVkxTkNZak5USVdGaFVWRkJZekZTSUdGUlVVQmdZakxtTUVBd0k4UWtNN0FnTUVPaWxLWERNNUtDZzVNMXhLVWowb1VFdzJOZ28zTlV4UUtDSWJUUmRBUGNFZkhWd2RIOEU5UUJjQUFRQkgvMThCSHdMZkFBY0FRVXV3S2xCWVFCVUFBUUVBWHdBQUFEVk5BQUlDQTE4QUF3TTRBMDRiUUJnQUFBQUJBZ0FCWndBQ0F3TUNWd0FDQWdOZkFBTUNBMDladGhFUkVSQUVDUm9yRXpNVkl4RXpGU05IMkdSazJBTGZYLzArWHdBQkFDNy9Yd0VHQXQ4QUJ3QkJTN0FxVUZoQUZRQUJBUUpmQUFJQ05VMEFBQUFEWHdBREF6Z0RUaHRBR0FBQ0FBRUFBZ0ZuQUFBREF3QlhBQUFBQTE4QUF3QURUMW0yRVJFUkVBUUpHaXNYTXhFak5UTVJJeTVrWk5qWVFnTENYL3lBQUFFQUxnRFRBUjhCU1FBREFCaEFGUUFBQVFFQVZ3QUFBQUZmQUFFQUFVOFJFQUlKR0NzVE14VWpMdkh4QVVsMkFBRUFMZ0RUQVI4QlNRQURBQmhBRlFBQUFRRUFWd0FBQUFGZkFBRUFBVThSRUFJSkdDc1RNeFVqTHZIeEFVbDJBQUVBQUFEZEFpd0JQd0FEQUJoQUZRQUFBUUVBVndBQUFBRmZBQUVBQVU4UkVBSUpHQ3NSSVJVaEFpejkxQUUvWWdBQUFRQUFBTjBENkFFL0FBTUFHRUFWQUFBQkFRQlhBQUFBQVY4QUFRQUJUeEVRQWdrWUt4RWhGU0VENlB3WUFUOWlBQUFCQUdRQTNRT0VBVDhBQXdBWVFCVUFBQUVCQUZjQUFBQUJYd0FCQUFGUEVSQUNDUmdyRXlFVklXUURJUHpnQVQ5aS8vOEFMZ0RUQVI4QlNRQUNBbWtBQVAvL0FDNEEwd0VmQVVrQUFnSnBBQUFBQVFBQS8yQUNMUC9DQUFNQUlMRUdaRVJBRlFBQUFRRUFWd0FBQUFGZkFBRUFBVThSRUFJSkdDdXhCZ0JFRlNFVklRSXMvZFErWWdBQ0FBRCt5QUlvLzhJQUF3QUhBQ3F4Qm1SRVFCOEFBQUFCQWdBQlp3QUNBd01DVndBQ0FnTmZBQU1DQTA4UkVSRVFCQWthSzdFR0FFUVZJUlVoRlNFVklRSW8vZGdDS1AzWVBsdEVXLy8vQUM0Qkl3RWZBWmtCQmdKcEFGQUFDTEVBQWJCUXNEVXIvLzhBTGdFakFSOEJtUUFDQW5JQUFQLy9BQUFCTFFJc0FZOEJCZ0pyQUZBQUNMRUFBYkJRc0RVci8vOEFBQUV0QStnQmp3RUdBbXdBVUFBSXNRQUJzRkN3TlN2Ly93QXVBU01CSHdHWkFBSUNjZ0FBQUFFQVJ2OWtBTkFBaVFBR0FEcTFCQUVBQVFGTVM3QWRVRmhBRUFBQkFRQmZBQUFBTkUwQUFnSTRBazRiUUJBQUFnQUNoZ0FCQVFCZkFBQUFOQUJPV2JVU0VSQURDUmtyTXlNMU14VUhJMzAzaWtKSWlYMm9BQUFDQUViL1pBR3VBSWtBQmdBTkFFVzJDd1FDQUFFQlRFdXdIVkJZUUJNRUFRRUJBRjhEQVFBQU5FMEZBUUlDT0FKT0cwQVRCUUVDQUFLR0JBRUJBUUJmQXdFQUFEUUFUbGxBQ1JJUkVSSVJFQVlKSENzekl6VXpGUWNqSlNNMU14VUhJMzAzaWtKSUFSVTNpa0pJaVgyb25JbDlxQUFBQWdCR0FZa0JyZ0t1QUFZQURRQW1RQ01IQUFJQ0FRRk1Bd0VBQUROTkJRRUNBZ0ZmQkFFQkFUWUNUaEVSRWhFUkVRWUpIQ3NUTnpNSE14VWpOemN6QnpNVkkwWkNTRGMzaXQ1Q1NEYzNpZ0lHcUp5SmZhaWNpUUFBQWdCR0FZa0JyZ0t1QUFZQURRQW1RQ01MQkFJQUFRRk1CUUVDQUFLR0F3RUFBQUZmQkFFQkFUTUFUaElSRVJJUkVBWUpIQ3NUSXpVekZRY2pKU00xTXhVSEkzMDNpa0pJQVJVM2lrSklBaVdKZmFpY2lYMm9BQUVBUmdHSkFOQUNyZ0FHQUI5QUhBQUJBZ0VCVEFBQUFETk5BQUlDQVY4QUFRRTJBazRSRVJFRENSa3JFemN6QnpNVkkwWkNTRGMzaWdJR3FKeUpBQUFCQUVZQmlRRFFBcTRBQmdBZlFCd0VBUUFCQVV3QUFnQUNoZ0FBQUFGZkFBRUJNd0JPRWhFUUF3a1pLeE1qTlRNVkJ5TjlONHBDU0FJbGlYMm9BQUVBUmdHSkFOQUNyZ0FHQUI5QUhBQUJBUUFCVEFBQ0FRS0dBQUVCQUY4QUFBQXpBVTRSRVJFRENSa3JFelV6RlNNWEkwYUtOemRJQWpGOWlad0FBZ0E3QUg0Q0JRSU9BQVVBQ3dBZVFCc0pBd0lCQUFGTUF3RUJBUUJmQWdFQUFEWUJUaElTRWhFRUNSb3JFemN6Qnhjak56Y3pCeGNqTzRoamJHeGpWNGhqYkd4akFVYkl5TWpJeU1qSUFBQUNBQ2NBZmdIeEFnNEFCUUFMQUI1QUd3a0RBZ0VBQVV3REFRRUJBRjhDQVFBQU5nRk9FaElTRVFRSkdpc1RKek1YQnlNbEp6TVhCeU9UYkdPSWlHTUJTMnhqaUloakFVYkl5TWpJeU1qSUFBRUFPd0IrQVNZQ0RnQUZBQmxBRmdNQkFRQUJUQUFCQVFCZkFBQUFOZ0ZPRWhFQ0NSZ3JFemN6Qnhjak80aGpiR3hqQVViSXlNZ0FBUUFuQUg0QkVnSU9BQVVBR1VBV0F3RUJBQUZNQUFFQkFGOEFBQUEyQVU0U0VRSUpHQ3NUSnpNWEJ5T1RiR09JaUdNQlJzakl5QUFDQURVQmx3R21BcTRBQlFBTEFDQkFIUWtHQXdBRUFRQUJUQU1CQVFFQVh3SUJBQUF6QVU0U0VoSVJCQWthS3hNMU14VUhJemMxTXhVSEl6V1ZGV3JHbFJWcUFodVRrNFNFazVPRUFBQUJBREVCbHdER0FxNEFCUUFhUUJjREFBSUJBQUZNQUFFQkFGOEFBQUF6QVU0U0VRSUpHQ3NUTlRNVkJ5TXhsUlZxQWh1VGs0UUFBQUVBTi8rSUFlc0NUUUFGQUJkQUZBTUJBUUFCVEFBQUFRQ0ZBQUVCZGhJUkFnWVlLemNCTXdFQkl6Y0JLWXIrMVFFc2l1c0JZdjZlL3AwQUFBRUFOLytJQWVzQ1RRQUZBQmRBRkFNQkFRQUJUQUFBQVFDRkFBRUJkaElSQWdZWUt5VUJNd0VCSXdGai90U0tBU3IrMTRycUFXUCtuZjZlQUFJQVB2K29BcFVEQkFBZkFDa0FWRUJSRmhNQ0J3TWNBUVVISWgwQ0JnQUxDQUlCQmdSTUFBQUZCZ1VBQm9BQUFnRUNoZ0FFQUFVQUJBVm5BQWNIQTJFQUF3TTdUUWdCQmdZQllRQUJBVHdCVGdBQUppUUFId0FlRkJJbUVpSVNDUWtjS3lRMk5UTVVCaU1pSndjak55WW1OVFEyTXpJWE56TUhGaFlWSXpRbkF4WXpKaFlYRXlZaklnWVZGUUhBUlpDWmhrSTFJallwU1VtY25Da3FIellrU2xHVk5LQWVMNllWR1p3UUZGeEtiMGxHaElZUFcyMGtub0MwcndoU1lCdDdYMVVsL2xNTm1sWWFBYU1EYld3ZUFBSUFKdi9QQWdjQzB3QWFBQ0lBTzBBNEJnRUJBQnNRQWdJQkloRUNCQU1BQVFVRUJFd0FBUUFDQXdFQ1p3QURBQVFGQXdScEFBVUZBRjhBQUFBMUJVNFJFaGNTRVJjR0NSd3JKU1ltTlRRMk56VXpGUllXRlNNMEppY1JOalkxTXhRR0J4VWpFUVlHRlJVVUZoY0JBMjl1Ym04ellIR0tKU0lrS1lSd1lUTXJKeWdxUlFpR2hJU0dDR3BxQld0aEtUSUgvcmtGTXl0aWF3VjFBaW9KVFVRUVFrNEtBQUFEQUQ3L3FBS1ZBd1FBSmdBdEFETUFYRUJaSUIwYkF3a0VNakFsQXdjSk15Z0NDQUFRRFFzREFRZ0VUQUFBQndnSEFBaUFBd0VDQVFLR0JnRUZBQWNBQlFkbkFBa0pCR0VBQkFRN1RRb0JDQWdCWWdBQkFUd0JUZ0FBS2lrQUpnQW1FeFFTSmhRU0loSUxDUjRySkRZMU14UUdJeUluQnlNM0ppY0hJemNtSmpVME5qTXlGemN6QnhZWE56TUhGaFVqTkNjREpoY1RCZ1lWRlJZWEV5WW5Bd0hBUlpDWmhoQWFIVFlnSmg0b05qSTJOWnljR2d3Y05oOGtIeWcyTWxlVkFvV21FWXBWUmt3bW5CWW9ubTlKUm9TR0FrNVZDQTFxaFNxVGJiU3ZBVXRUQnhCcWhrYUpEaFQrbm9zdkFYUUViR2tleXdrQm9ob0wvbG9BQUFJQUhBQmpBaEFDV3dBakFETUFTMEJJRWhBS0NBUUNBQmtUQndFRUF3SWlIQm9EQVFNRFRCRUpBZ0JLSXhzQ0FVa0FBQUFDQXdBQ2FRUUJBd0VCQTFrRUFRTURBV0VBQVFNQlVTUWtKRE1rTWl3cUlCNHNCUWtYS3pjM0ppWTFORFkzSnpjWE5qWXpNaFlYTnhjSEZoWVZGQVlIRndjbkJnWWpJaVluQno0Q05UUW1KaU1pQmdZVkZCWVdNeDAyR1JrWkdUY3dPUnhOS0NoTkhEa3dOeGtaR1JrMkxUY2RUaW9xVGgwMytFc3NMRXNzTEVzc0xFc3NrRGdmVGlvclR4dzJNRGdZR3hzWU9EQTJIRThyS2s0Zk9DMDZHeHdjR3pwU0wwNHRMRTB2TDAwc0xVNHZBQUFEQUNqL3p3SUVBdE1BSndBdUFEVUFQMEE4S0I0Q0JRSTBMaDhMQkFFRk5Rb0RBd0FCQTB3RUFRSUFCUUVDQldjQUFRWUJBQWNCQUdvQUJ3Y0RYd0FEQXpVSFRoRWFFeEVSR3hRUUNBa2VLemNtSmpVME56TVZGaFlYTlM0Q05UUTJOelV6RlJZV0ZRY2pOVFFtSnhVZUFoVVVCeFVqRVFZR0ZSUVdGeFkyTlRRbUp4WDlaWEFCZ0FFdkpEOVNPbkJiTTFadUFZQWtIMEpWUGRReklTWWtJMVl0S1NkRUJWcElCd1VISHlJRWZROGdQelJJVWdWcWFnVk1QUmNHRnh3RmJnOGZRamFnQ25VQ05BTVlFaFFZQ2ZNWEdCWWNDMjhBQUFNQVN2KzVBbFlDMHdBYUFDZ0FMQUNIUUFvUkFRZ0RCQUVCQ1FKTVM3QVVVRmhBTFFjQkJRUUJBQU1GQUdjQUNRRUJDVmtBQ2dBTENndGpBZ0VCQVFaZkFBWUdOVTBBQ0FnRFlRQURBellJVGh0QUxnY0JCUVFCQUFNRkFHY0FDUUFDQ2drQ2FRQUtBQXNLQzJNQUNBZ0RZUUFEQXpaTkFBRUJCbDhBQmdZMUFVNVpRQklzS3lvcEppUWpFUkVSRkNRa0VSQU1DUjhyQVNNUkl5Y2pCZ1lqSWlZMU5EWXpNaFlYTXpVak5UTTFNeFV6QXpRbUl5SUdGUlVVRmpNeU5qVUJJUlVoQWxaQmJna0hHRTRtV21kalZ5aExGZ2FhbW9KQnd6Y3ZMVEF3TFRFMS9yY0J5LzQxQWt2OTdFVW5Lb0Z4Y1lBb0lZWkhRVUgra1Q1RVFqNFNQVUpCUHY3dFJ3QUFBUUFLLy9RQ0NnSzZBQ2tBVlVCU0VRRUZCQklCQXdVbUFRb0FKd0VMQ2dSTUJnRURCd0VDQVFNQ1p3Z0JBUWtCQUFvQkFHY0FCUVVFWVFBRUJEdE5BQW9LQzJFTUFRc0xQQXRPQUFBQUtRQW9KU01oSUJRUkVpTWlFUlFSRWcwSkh5c0VKaWNqTlRNbU5UUTNJelV6TmpZek1oY1ZKaU1pQmdjekZTTUdGUlFYTXhVakZoWXpNamNWQmlNQkhhc2dTRG9CQVRwSUlLdDJPajB1TUVWcEd0N3pBZ0x6M2hwcFJUUXFOMEFNZ0c5UkN4Z1hERkZ1Z1JKdUVFTThVUlFQRFJaUlBFTVFiaElBQUFFQUYvOUpBaFFDMndBZEFEMUFPaEVCQkFNQ0FRY0FBa3dGQVFJR0FRRUFBZ0ZuQUFRRUEyRUFBd005VFFBQUFBZGhDQUVIQjBBSFRnQUFBQjBBSEJFU0l5TVJFaU1KQ1IwckZpWW5Oek15TnhNak56TTNOall6TWhZWEJ5TWlCd2N6QnlNREJnWWpWakFQRkRJcUNWZExGMHNWRFZSTUZUQVBGRElyQ1JOZEYxMVpEVlJMdHdvR1lDc0JsbkJnUGxNS0JtQXJWbkQrWUQ1VEFBRUFDZ0FBQWlBQ3JnQVJBRGRBTkFBQUFBRUNBQUZuQmdFQ0JRRURCQUlEWndrQkNBZ0hYd0FIQnpOTkFBUUVOQVJPQUFBQUVRQVJFUkVSRVJFUkVSRUtDUjRyRXhVaEZTRVZNeFVqRlNNMUl6VXpFU0VWMUFFbi90bTR1SkU1T1FIZEFqT3BlMVZCZVhsQkFmUjdBQUFEQUNyL3NRS2xBdkVBR2dBaUFDY0FxMHV3RmxCWVFCUWVHZ0lIQkFRQkFRZ0hBUUlCQTB3a0FRZ0JTeHRBRkI0YUFnY0VCQUVCQ0FjQkF3RURUQ1FCQ0FGTFdVdXdGbEJZUUNvQUJ3UUFCQWNBZ0FBQUNnRUpDQUFKYUFBRkFBSUZBbU1HQVFRRU8wMEFDQWdCWWdNQkFRRTBBVTRiUUM0QUJ3UUFCQWNBZ0FBQUNnRUpDQUFKYUFBRkFBSUZBbU1HQVFRRU8wMEFBUUUwVFFBSUNBTmlBQU1EUEFOT1dVQVNJeU1qSnlNbkZSSVJFUlFSRlJFUUN3a2ZLd0VoRVNNbkJnWUhGU00xSmlZMU5EWTNOVE1WRmhZVkl6UW1Kd0lXRnhFR0JoVVZGeFUyTmpjQmxnRVBaQTBxUkRBOW1KZVlsejE2bFpaQ045ZEZWVk5IMXp0Q0FRRjEvb3RNS0NjR1JrTUNyTFdzcmdnNE9BZDljVE5BQnY2ZmFBUUJ6UWxyWXg1S2pBcElPZ0FBQVFBUUFBQUNyUUt1QUJNQUwwQXNDQVlDQkFvSkF3TUJBQVFCYUFjQkJRVXpUUUlCQUFBMEFFNEFBQUFUQUJNUkVSRVJFUkVSRVJFTENSOHJBUUVqQVNNUkl4RWpOVE1STXhFekFUTUJJUlVCZXdFeXNQN3dHWkV6TTVFWkFSQ3cvczRCRXdFdS90SUJMdjdTQVM1U0FTNyswZ0V1L3RKU0FBQUJBQXNBQUFJTUFyb0FKUUNIUzdBT1VGaEFNUUFHQndRSEJuSUlBUVFKQVFNQ0JBTm5DZ0VDQ3dFQkFBSUJad0FIQndWaEFBVUZPMDBNQVFBQURWOEFEUTAwRFU0YlFESUFCZ2NFQndZRWdBZ0JCQWtCQXdJRUEyY0tBUUlMQVFFQUFnRm5BQWNIQldFQUJRVTdUUXdCQUFBTlh3QU5EVFFOVGxsQUZpVWtJeUloSUI4ZUhSd1RJeE1qRVJFUkVSQU9DUjhyTnpNMUl6VXpOU00xTXpVME5qTXlGaFVWSXpVMEppTWlCaFVWTXhVakZUTVZJd2NoRlNFWVBrdExTMHR5YVdaMWlDMG1KU3ljbnA2ZURBRXkvaFJ3VWx3MVhFUmlaV05mRFJFbEtTa2hVVncxWEZKd0FBQUJBQW9BQUFJZUFxNEFIUUJBUUQwV0ZSUVRFaEVRRFF3TENnc0RBUmNKQ0FjR0JRSURBa3dFQVFNQkFnRURBb0FBQVFFelRRQUNBZ0JnQUFBQU5BQk9BQUFBSFFBZEtSa2pCUWtaS3dFVkZBWWpJelVITlRjMUJ6VTNFVE1WTnhVSEZUY1ZCeFV6TWpZMU5RSWVoWHZiT1RrNU9aR3VycTZ1U2pjNUFTUS9iM2JNSGswZU9CNU5IZ0VRdzExTlhUaGRUVjJiTmpNOUFBRUFOUUFBQXNVREJRQVhBQzVBS3dzSUFnRURBVXdBQkFBQkFBUUJad1lGQWdNRE8wMENBUUFBTkFCT0FBQUFGd0FYRVJNVkZSTUhDUnNyQUJZVkVTTVJOQ1luRVNNUkJnWVZFU01STkRZM05UTVZBaTJZbFVWUVBVOUZsWmVTUFFLeHJabitsUUZjYkc0SS9qc0J4QWh1YS82a0FXeVlyUWhNVEFBQkFCQUFBQUxHQXE0QUlnQkZRRUlKQVFZSEd3RUJBQUpNQ2dFSERBc0NCZ0FIQm1jRkFRQUVBUUVDQUFGbkNRRUlDRE5OQXdFQ0FqUUNUZ0FBQUNJQUlpRWdIeDRSRVJFUkVSY1JFUkVOQ1I4ckFSVXpGU01WSXdNbUp3Y1dGUkVqTlNNMU16VWpOVE0xTXhNV0Z6Y25FVE1WTXhVQ2cwTkRqZlVSRmdVRGpUczdPenVOOUFzZEJRT05Rd0dBVEVqc0FYZ2JKd01yRWY2RjdFaE1TT2IraXhFeUF6b0JlK1pJQUFNQUNnQUFBcVFDcmdBUkFCY0FIUUE4UURrSEJnSUVDUU1DQUFvRUFHY0xBUW9BQVFJS0FXY0FDQWdGWHdBRkJUTk5BQUlDTkFKT0dCZ1lIUmdjR3hvaUVSSWhFUkVSSWhBTUNSOHJBU01HQmlNakZTTVJJelV6TlNFeUZoY3pJVE1tSmlNakZqWTNJeFV6QXFSSkNYbHRtSkU1T1FFemFuUUlTUDR3OHdjd0o1VzdMd2p5bFFHclcyVHNBYXRCd21WZElpWE1JeUZFQUFBQ0FBb0FBQUtrQXE0QUdnQWpBSUpMc0IxUVdFQXZCZ0VCQlFFQ0RBRUNadzBCREFBREJBd0Rad0FMQ3dsZkFBa0pNMDBIQVFBQUNGOEtBUWdJTmswQUJBUTBCRTRiUUMwS0FRZ0hBUUFCQ0FCbkJnRUJCUUVDREFFQ1p3MEJEQUFEQkF3RFp3QUxDd2xmQUFrSk0wMEFCQVEwQkU1WlFCZ2JHeHNqR3lJaEh4b1pGeFVSRVJFUkVTSVJFaEFPQ1I4ckFTTVZGVE1WSXdZR0l5TVZJeEVqTlRNMUl6VXpOU0V5RmhjekJEWTFOQ1lqSXhVekFxUkhSMUlVZEY2WWtUazVPVGtCTTFwdkZGSCs5REl5TDVXVkFkNFFFRUZHUyt3QmZVRWdRWTlLUmJnMk1UQTF6QUFBQWdBS0FBQUNYUUt1QUJZQUh3QTlRRG9KQVFZTENBSUZBQVlGWndRQkFBTUJBUUlBQVdjQUNnb0hYd0FIQnpOTkFBSUNOQUpPQUFBZkhSa1hBQllBRlNFUkVSRVJFUkVSREFrZUt6Y1ZNeFVqRlNNMUl6VXpOU00xTXhFaE1oWVZGQVlqSnpNeU5qVTBKaU1qMUxpNGtUazVPVGtCTTNOMGVYaVlsUzh5TWkrVjdFUkJaMmRCUkhzQlIzVnJhM2Q3TmpFd05RQUFBUUEyQUFBQ1VnS3VBQm9BaGJRTUFRSUJTMHV3R1ZCWVFDOEFCd2tBQ1FkeUFBTUNBNFlBQ0FvQkNRY0lDV2NHQVFBRkFRRUVBQUZuQUFRQ0FnUlhBQVFFQW1FQUFnUUNVUnRBTUFBSENRQUpCd0NBQUFNQ0E0WUFDQW9CQ1FjSUNXY0dBUUFGQVFFRUFBRm5BQVFDQWdSWEFBUUVBbUVBQWdRQ1VWbEFFZ0FBQUJvQUdoRWhFUklpRVNJUkVnc0dIeXNCRmhjekZTTUdCaU16RnlNbk5UTXlOamNoTlNFbUl5TTFJUlVCcFNFSmc0QUZlWElaK2NuMXFTa3lCZjczQVFBVlFxa0NIQUptS1R0SVltenM3SHNyS0VneGUwZ0FBUUFMQUFBQ0RBSzZBQjBBYTB1d0RsQllRQ2NBQkFVQ0JRUnlCZ0VDQndFQkFBSUJad0FGQlFOaEFBTURPMDBJQVFBQUNWOEFDUWswQ1U0YlFDZ0FCQVVDQlFRQ2dBWUJBZ2NCQVFBQ0FXY0FCUVVEWVFBREF6dE5DQUVBQUFsZkFBa0pOQWxPV1VBT0hSd1JFUk1qRXlNUkVSQUtDUjhyTnpNMUl6VXpOVFEyTXpJV0ZSVWpOVFFtSXlJR0ZSVXpGU01ISVJVaEdENUxTM0pwWm5XSUxTWWxMSnllREFFeS9oUndxbkJwWW1Walh3MFJKU2twSVhad3FuQUFBQVFBRUFBQUE2QUNyZ0FYQUI4QUp3QXZBRWxBUmhzQkJRWXNKQUlCQUFKTUR3d0xDUWNGQlE0TkJBSUVBQUVGQUdnS0NBSUdCak5OQXdFQkFUUUJUaGdZS1NnaElCZ2ZHQjhYRmhVVUV4SVJFUkVSRVJFUkVSQVFDUjhyQVNNREl3TWpBeU1ESXpVekF6TVRNeE16RXpNVE13TXpJU2NtSnlNR0R3SWpGeFlYTXpZM0pTTVhGaGN6TmpjRG9HZExuVWRtUloxTFoxVlBtMEpUUks5RFZFU0dUMVgrV1E4SUNRUUtCdzkrTlFnR0NnVUtCZ0dSTlFnR0NnVUpCd0VzL3RRQkxQN1VBU3hJQVRyK3hnRTYvc1lCT3Y3R1FTRkFSUnhCU0NRY1JFUWNKQ1FhUmtBZ0FBQUJBQUFBQUFJdEFxNEFHd0E1UURZTUFRTUVBVXdHQVFNSEFRSUJBd0pvQ0FFQkNRRUFDZ0VBWndVQkJBUXpUUUFLQ2pRS1Roc2FHUmdSRVJJVkVoRVJFUkFMQ1I4ck55TTFNelVqTlRNbkp6TVhGek0zTnpNSEJ6TVZJeFV6RlNNVkk5Tzl2YjJSSG9tZFd5RUZJRnFWZ1NXU3ZiMjlpWTVSUmxFNS84TkZSc0x6UlZGR1VZNEFBUUJrQUxzQTdBRkRBQXNBSGtBYkFBQUJBUUJaQUFBQUFXRUNBUUVBQVZFQUFBQUxBQW9rQXdZWEt6WW1OVFEyTXpJV0ZSUUdJNHdvS0J3Y0tDZ2N1eWdjSENnb0hCd29BUC8vQURILzlBS3JBcm9BSXdLbEFSc0FBQUFuQWs0QUp3SWxBUU1DVGdHZkFBQUFDYkVCQWJnQ0piQTFLd0FBQWY4Vy8vUUJrQUs2QUFNQUprdXdLbEJZUUFzQUFBQXpUUUFCQVRRQlRodEFDUUFBQVFDRkFBRUJkbG0wRVJBQ0NSZ3JBVE1CSXdFNFdQM2VXQUs2L1RvQUF3QTRBQkVDRVFJaUFBTUFCd0FMQUN4QUtRQUFBQUVDQUFGbkFBSUFBd1FDQTJjQUJBVUZCRmNBQkFRRlh3QUZCQVZQRVJFUkVSRVFCZ1ljS3hNaEZTRVZJUlVoRlNFVklUZ0IyZjRuQWRuK0p3SFovaWNDSW1odGFHMW5BQUVBc2Y4R0FXMERXd0FKQUI1QUd3QUJBQUdGQUFBQ0FnQlpBQUFBQW1FQUFnQUNVUlFTRUFNR0dTc1hNalVETXhJVkZBWWpzVTBSY2c1a1dMVTVBOWY4a0hWQkx3QUJBTy8vQmdHckExc0FDUUFlUUJzQUFnRUNoZ0FBQVFFQVdRQUFBQUZoQUFFQUFWRVNFUk1EQmhrckVqVTBOak1WSWhVVEkrOWtXRTBSY2dKMmRVRXZSVG44S1FBQUFRQTRBQUFDRUFIL0FBc0FRVXV3SVZCWVFCVURBUUVFQVFBRkFRQm5BQUlDTmswQUJRVTBCVTRiUUJVREFRRUVBUUFGQVFCbkFBSUNCVjhBQlFVMEJVNVpRQWtSRVJFUkVSQUdDUndyTnlNMU16VXpGVE1WSXhVajhMaTRaN201Wjh0b3pNeG95d0FCQURnQXpBSVFBVFFBQXdBWVFCVUFBQUVCQUZjQUFBQUJYd0FCQUFGUEVSQUNCaGdyRXlFVklUZ0IyUDRvQVRSb0FBRUFTd0FsQWY0QjJRQUxBQWF6Q3dVQk1pczNOeWMzRnpjWEJ4Y0hKd2RMa0pCSWtaRkprWkJKa0pCdmtKQkprSkZLa1k5SmtKRUFBd0FuQUFFQi93SUFBQU1BQndBTEFFOUxzQ05RV0VBZEFBSUFBd1FDQTJjQUFRRUFYd0FBQURaTkFBUUVCVjhBQlFVMEJVNGJRQnNBQUFBQkFnQUJad0FDQUFNRUFnTm5BQVFFQlY4QUJRVTBCVTVaUUFrUkVSRVJFUkFHQ1J3ckV6TVZJd2NoRlNFWE14VWoxbmg0cndIWS9paXZlSGdDQUc1ZWFWeHVBQUFDQURnQVlBSVFBWndBQXdBSEFDSkFId0FBQUFFQ0FBRm5BQUlEQXdKWEFBSUNBMThBQXdJRFR4RVJFUkFFQ1JvckV5RVZJUlVoRlNFNEFkaitLQUhZL2lnQm5HaHRad0FCQUNZQUdRSCtBZVFBRXdCc1M3QVNVRmhBS1FBRUF3TUVjQUFKQUFBSmNRVUJBd1lCQWdFREFtZ0hBUUVBQUFGWEJ3RUJBUUJmQ0FFQUFRQlBHMEFuQUFRREJJVUFDUUFKaGdVQkF3WUJBZ0VEQW1nSEFRRUFBQUZYQndFQkFRQmZDQUVBQVFCUFdVQU9FeElSRVJFUkVSRVJFUkFLQmg4ck55TTFNemNqTlNFM013Y3pGU01ITXhVaEJ5T1RiYVE2M2dFVkoxWW5iYVE2M3Y3ckpsWmdaMjFvU0Vob2JXZEhBQUVBT0FBQ0FoSUNDZ0FHQUFhekJnTUJNaXMzSlNVMUJSVUZPQUYxL29zQjJ2NG1lSTZPZHNWL3hBQUFBUUEyQUFJQ0VBSUtBQVlBQnJNR0FnRXlLemMxSlJVRkJSVTJBZHIraXdGMXhuL0ZkbzZPZGdBQUFnQW1BQUFDQUFLREFBWUFDZ0FpUUI4R0JRUURBZ0VBQndCS0FBQUJBUUJYQUFBQUFWOEFBUUFCVHhFWEFnWVlLemNsSlRVRkZRVVZJUlVoSmdGMS9vc0IydjRtQWRuK0ovR09qbmJGZjhRVGFBQUFBZ0FtQUFBQ0FBS0RBQVlBQ2dBaVFCOEdCUVFEQWdFQUJ3QktBQUFCQVFCWEFBQUFBVjhBQVFBQlR4RVhBZ1lZS3hNMUpSVUZCUlVGSVJVaEpnSGEvb3NCZGY0bkFkbitKd0UvZjhWMmpvNTJFMmdBQWdBbkFBQUIvd0tVQUFzQUR3QXJRQ2dEQVFFRUFRQUZBUUJuQUFJQUJRWUNCV2NBQmdZSFh3QUhCelFIVGhFUkVSRVJFUkVRQ0FrZUt4TWpOVE0xTXhVekZTTVZJd2NoRlNIZnVMaG51YmxudUFIWS9pZ0JZR2pNekdqTExXZ0FBZ0FiQUNrQ0NBSEpBQmtBTXdCUFFFd05BQUlEQVNZWkFnUUNKeG9DQndVRFRBd0JBRW96QVFaSkFBQUFBd0lBQTJrQUFRQUNCQUVDYVFBRkJ3WUZXUUFFQUFjR0JBZHBBQVVGQm1FQUJnVUdVU1FsSkNVa0pTUWlDQVllS3hNMk5qTXlGaGNXRmpNeU5qY1ZCZ1lqSWlZbkppWWpJZ1lIRlRZMk16SVdGeFlXTXpJMk54VUdCaU1pSmljbUppTWlCZ2NiRmtvdkdTc2lIekFhS1V3YUZrb3ZHU3NpSHpBYUtVd2FGa292R1NzaUh6QWFLVXdhRmtvdkdTc2lIekFhS1V3YUFYUWZLZzhQRHhBcUgzZ2ZLZzhQRHhBcUgxc2ZLZzhQRHhBcUgzZ2ZLZzhQRHhBcUh3QUFBUUFwQU1jQ0h3R1NBQmtBT2JFR1pFUkFMZzBBQWdNQkFVd01BUUJLR1FFQ1NRQUJBd0lCV1FBQUFBTUNBQU5wQUFFQkFtRUFBZ0VDVVNRbEpDSUVDUm9yc1FZQVJCTTJOak15RmhjV0ZqTXlOamNWQmdZaklpWW5KaVlqSWdZSEtSWkxNQmt0SXlJdkdpcE1HeFpMTUJrdEl5SXZHaXBNR3dFK0hpb1BEdzhQS2g1M0hpb1BEdzhQS2g0QUFBRUFLZ0RCQWg0Qnh3QUZBQjVBR3dBQ0FBS0dBQUVBQUFGWEFBRUJBRjhBQUFFQVR4RVJFQU1KR1NzQklUVWhFU01CdlA1dUFmUmlBV1ZpL3ZvQUFRQVpBU1lCdlFLdUFBWUFJYkVHWkVSQUZnUUJBUUFCVEFBQUFRQ0ZBZ0VCQVhZU0VSQURDUmtyc1FZQVJCTXpFeU1EQXlPMWE1MXVaV051QXE3K2VBRU8vdklBQUFNQUx3Q0tBcGdCeVFBY0FDY0FNd0JLUUVjd0hoa0tCQVVFQVV3QkFRQUdBUVFGQUFScENnY0pBd1VDQWdWWkNnY0pBd1VGQW1FSUF3SUNCUUpSS0NnZEhRQUFLRE1vTWk0c0hTY2RKaUlnQUJ3QUd5WWxKZ3NHR1NzMkppWTFORFkyTXpJV0Z6NENNeklXRmhVVUJnWWpJaVluQmdZak5qY21KaU1pQmhVVUZqTWdOalUwSmlNaUJnY1dGak9kUlNrcFNDd3hUQ0VGTHo0a0tVWXBLa1lvS0U4bkpVa3dRREVnS0I4Y0pTY2RBVWNpSlI0WktDTWhMUnVLSjBndkwwa3BMUzBHTkNBbVJpOHlTeWNtT0M4dlUwZ3hJU2tsSHkwd0d5SXRJQzB1SHdBREFCMEFZd0lRQWxzQUdRQWlBQ3NBUkVCQkRRc0NBZ0FwS0NJT0FRVURBaGdCQVFNRFRBd0JBRW9aQVFGSkFBQUFBZ01BQW1rRUFRTUJBUU5aQkFFREF3RmhBQUVEQVZFakl5TXJJeW9sS3ljRkJoa3JOemNtSmpVME5qWXpNaFlYTnhjSEZoWVZGQVlHSXlJbUp3Y0JKaU1pQmdZVkZCY1dOalkxTkNjSEZqTWROaGtaUkhGQUtFMGNPVEEzR1JsRGNVRXFUaDAzQVNNb0x5eExMQmkzU3l3YzVpczBrRGdmVGlwRGNrSWJHRGd3Tmh4UEswVnlRaHdiT2dHSkd5OU5MQzRyVVM5T0xURXM1eUFBQUFFQVhnQUFBbklDcEFBVkFDQkFIUU1CQVFJQmhnQUFBZ0lBV1FBQUFBSmhBQUlBQWxFVUpCUWpCQVlhS3hNME5qWXpNaFlXRlJFakVUUW1KaU1pQmdZVkVTTmVSM3BKU1hwSFhDNVBNREJRTDF3Qm1rdDZSVVY2Uy81bUFab3pVaTR1VWpQK1pnQUFBUUFYLzNNQkF3TmJBQThBSWtBZkFBRUFBZ0FCQW1rQUFBTURBRmtBQUFBRFlRQURBQU5SRlJFVkVBUUdHaXNYTWpVQ05UUTJNeFVpRlJJVkZBWWpGMHNiWkZoTkhHTllSem9DYW81QkwwVTUvWlNPUVM4QUFBRUFJUUFBQXdFQ3VnQXBBQ3hBS1NjYkV3VUVBd0FCVEFBRUJBRmhBQUVCTzAwQ0FRQUFBMThGQVFNRE5BTk9GaVlSS1NvUUJna2NLemN6TWhjV0Z5WW1OVFEyTmpNeUZoWVZGQVlITmpjMk16TVZJVFUyTmpVMU5DTWlGUlVVRmhjVklTRXpCeVlmR0Q1RlZKeHNiSnhVUmo0WklTSUpNLzYwVUZQSHgxTlEvclI3QmdVREtZQlZhWmRQVDVkcFZYOHFBd1VHZTI0T2ExVWc0K01nVkdvUGJ3QUFBZ0FCQUFBQ3p3S3VBQU1BRHdCQ3RRa0JBZ0FCVEV1d0tWQllRQkVBQUFBWFRRTUJBZ0lCWHdBQkFSZ0JUaHRBRVFBQUFnQ0ZBd0VDQWdGZkFBRUJHQUZPV1VBTEJBUUVEd1FQRVJBRUJ4Z3JBVE1CSVNVbUp5Y21KeU1HQndjR0J3RU50Z0VNL1RJQ0J4Z1JUZ3dmQlI4TVRCSVlBcTc5VW5zekxzNGdaMmNnemk4eUFBQUJBQ24vZ0FNT0F0TUFDd0FrUUNFRkFRTUFBNFlBQVFBQUFWY0FBUUVBWHdRQ0FnQUJBRThSRVJFUkVSQUdCaHdyRXlNMUlSVWpFU01SSVJFamdsa0M1VnVRL3ZDUkFsWjlmZjBxQXRiOUtnQUFBUUE3LzRBQ3NnTFRBQTBBTVVBdUFnRUJBQWdCQWdJQkFBRURBZ05NQUFBQUFRSUFBV2NBQWdNREFsY0FBZ0lEWHdBREFnTlBFU01SRXdRR0dpc1hBUUUxSVJVaEZSTUJGU0VWSVRzQkpQN21BbHIrYS83KzZ3Ry8vWWtjQVVjQk5uSjlCUDdwL3NZRWZRQUFBUUFlLzJ3Q0pBTlpBQWtBR2tBWEJRTUNBUVFCQUFGTUFBQUJBSVVBQVFGMkVSWUNCaGdyRXdjbk54TVhFek1ESTNVOEc2eG5Jb0pQb200QkNoZFFTUDduWEFORC9CTUFBZ0FqLy9RQnh3TGZBQjBBS2dCTVFFa1VBUUVDRXdFQUFRb0JCQUFnQVFVRUJFd0FBZ0FCQUFJQmFRQUFBQVFGQUFScEJ3RUZBd01GV1FjQkJRVURZUVlCQXdVRFVSNGVBQUFlS2g0cEpDSUFIUUFjSXlnbUNBWVpLeFltSmpVME5qWXpNaFlYTXpZMU5DWW1JeUlITlRZek1oWVdGUlFHSXpZMk55WW1JeUlHQmhVVUZqT2VVaWsxVmpJbk9Bd0VBU00rSmowdk9FZythMEY5Y2pFNUJnZ3JIaGdvRnlFZUREcGpPMGx3UENvWEJodzhaRG9pYUIxTG5uZTYwV1p3VFIwc0tVVXBNajBBLy84QU5QOVRBZ3dDRGdBQ0FlSUFBQUFCQUxFQUFBTWlBbkVBQlFBZVFCc0FBQUVBaFFBQkFnSUJWd0FCQVFKZkFBSUJBazhSRVJBREJoa3JFek1SSVJVaHNWa0NHUDJQQW5IOTZGa0FBQVVBTHYvMEEwd0N1Z0FMQUE4QUhRQXBBRGNBa2t1d0ZGQllRQ3NMQVFVS0FRRUlCUUZwQUFZQUNBa0dDR29BQkFRQVlRSUJBQUE3VFEwQkNRa0RZUXdIQWdNRE5BTk9HMEF6Q3dFRkNnRUJDQVVCYVFBR0FBZ0pCZ2hxQUFJQ00wMEFCQVFBWVFBQUFEdE5BQU1ETkUwTkFRa0pCMkVNQVFjSFBBZE9XVUFtS2lvZUhoQVFBQUFxTnlvMk1TOGVLUjRvSkNJUUhSQWNGeFVQRGcwTUFBc0FDaVFPQ1JjckVpWTFORFl6TWhZVkZBWWpBVE1CSXhJMk5UVTBKaU1pQmhVVkZCWXpBQ1kxTkRZek1oWVZGQVlqTmpZMU5UUW1JeUlHRlJVVUZqT0NWRlJUVTFSVVV3R3lhUDRGWm1zYkd5UWtHeHNrQVgxVVZGTlRWRlJUSkJzYkpDUWJHeVFCVVZGalkxSlNZMk5SQVYzOVVnR2lMeTBQTFM4dUxnOHVMdjVTVVdOalVsSmpZMUZSTHkwUExTOHZMUTh0THdBSEFCTC85UVBVQXJvQUN3QVBBQjBBS1FBMUFFTUFVUURzUzdBVVVGaEFNUThCQlE0QkFRb0ZBV2tJQVFZTUFRb0xCZ3BxQUFRRUFHRUNBUUFBTzAwVERSSURDd3NEWVJFSkVBY0VBd00wQTA0YlM3QVdVRmhBTlE4QkJRNEJBUW9GQVdrSUFRWU1BUW9MQmdwcUFBSUNNMDBBQkFRQVlRQUFBRHRORXcwU0F3c0xBMkVSQ1JBSEJBTUROQU5PRzBBNUR3RUZEZ0VCQ2dVQmFRZ0JCZ3dCQ2dzR0Ntb0FBZ0l6VFFBRUJBQmhBQUFBTzAwQUF3TTBUUk1ORWdNTEN3ZGhFUWtRQXdjSFBBZE9XVmxBTmtSRU5qWXFLaDRlRUJBQUFFUlJSRkJMU1RaRE5rSTlPeW8xS2pRd0xoNHBIaWdrSWhBZEVCd1hGUThPRFF3QUN3QUtKQlFKRnlzU0pqVTBOak15RmhVVUJpTUJNd0VqRWpZMU5UUW1JeUlHRlJVVUZqTUFKalUwTmpNeUZoVVVCaU15SmpVME5qTXlGaFVVQmlNa05qVTFOQ1lqSWdZVkZSUVdNeUEyTlRVMEppTWlCaFVWRkJZeldraElSMGRJU0VjQlFscitobGhNRVJFV0ZoRVJGZ0VmU0VoSFIwaElSL2RJU0VkSFNFaEgvdGdSRVJZV0VSRVdBVlFSRVJZV0VSRVdBVkZSWTJOU1VtTmpVUUZkL1ZJQm9pNHVEeTR1TGk0UExpNytVMUZqWTFKU1kyTlJVV05qVWxKalkxRlJMaTRQTGk0dUxnOHVMaTR1RHk0dUxpNFBMaTRBQVFBcUFNRUNIZ0hIQUFVQUhrQWJBQUlCQW9ZQUFBRUJBRmNBQUFBQlh3QUJBQUZQRVJFUUF3WVpLeE1oRlNFVkl5b0I5UDV1WWdISFlxUUFBUUJFL3pFQnN3TEhBQWtBSEVBWkJ3WUZBZ0VBQmdFQUFVd0FBQUVBaFFBQkFYWVVFd0lHR0NzVEJ6VTNNeGNWSnhFanhZR3RGYTJCYlFJRE5UVEZ4VFExL1M0QUFBRUFLZ0JFQThBQnRBQUpBRksyQndZQ0FBRUJURXV3Q2xCWVFCd0FBZ0VCQW5BQUF3QUFBM0VBQVFBQUFWY0FBUUVBWUFBQUFRQlFHMEFhQUFJQkFvVUFBd0FEaGdBQkFBQUJWd0FCQVFCZ0FBQUJBRkJadGhNUkVSQUVCaG9ySlNFMUlTY3pGeFVISXdMOC9TNEMwalUweGNVMHhteUNyaFd0QUFBQkFFVC9NUUcwQXNjQUNRQWNRQmtIQmdVQ0FRQUdBUUFCVEFBQUFRQ0ZBQUVCZGhRVEFnWVlLeGMxRnhFekVUY1ZCeU5FZ215Q3JoVUtORFVDMHYwdU5UVEZBQUVBS2dCRUE4QUJ0QUFKQUZLMkFRQUNBZ0VCVEV1d0NsQllRQndBQUFFQkFIQUFBd0lDQTNFQUFRSUNBVmNBQVFFQ1lBQUNBUUpRRzBBYUFBQUJBSVVBQXdJRGhnQUJBZ0lCVndBQkFRSmdBQUlCQWxCWnRoRVJFUklFQmhvck56VTNNd2NoRlNFWEl5ckZORFVDMHYwdU5UVHlGYTJDYklJQUFRQXFBRVVEd0FHMEFBOEFYRUFKQ1FnQkFBUUVBUUZNUzdBS1VGaEFIZ0lCQUFFQkFIQUZBUU1FQkFOeEFBRUVCQUZYQUFFQkJHQUFCQUVFVUJ0QUhBSUJBQUVBaFFVQkF3UURoZ0FCQkFRQlZ3QUJBUVJnQUFRQkJGQlpRQWtSRVJNUkVSSUdCaHdyTnpVM013Y2hKek1YRlFjak55RVhJeXJGTkRVQ0RqVTB4Y1UwTmYzeU5UVHlGYTJCZ2EwVnJZR0JBQUVBUWY4eEFiRUN4d0FQQUNKQUh3ME1Dd29KQ0FVRUF3SUJBQXdCQUFGTUFBQUJBSVVBQVFGMkZ4WUNCaGdyRnpVWEVRYzFOek1YRlNjUk54VUhJMEdDZ3E0VnJZS0NyUlVLTkRVQ0RqVTB4Y1UwTmYzeU5UVEZBQUlBUWY4WEFiRUN4d0FQQUJNQU5VQXlEUXdMQ2drSUJRUURBZ0VBREFFQUFVd0FBQUVBaFFBQkFnR0ZBQUlEQXdKWEFBSUNBMThBQXdJRFR4RVJGeFlFQmhvck56VVhFUWMxTnpNWEZTY1JOeFVISXdjaEZTRkJnb0t1RmEyQ2dxMFZyUUZ2L3BGaE5EVUJvelUweGNVME5mNWROVFRGTDFZQUFnQXEvM3NDRGdMWUFBVUFDUUFhUUJjSkNBY0RCQUVBQVV3QUFBRUFoUUFCQVhZU0VRSUdHQ3NURXpNVEF5TVRBd01US3JOL3NySi9zM1IwZEFFcUFhNytVdjVSQWE4QksvN1YvdFFBQWdBbi8yY0R0UUs2QUVJQVN3RitRQTRRQVFFSFBnRUpBVDhCQ2drRFRFdXdGbEJZUUR3QUJRUURCQVZ5QUFNQUN3Y0RDMmtBQ0FnQVlRQUFBRHROQUFRRUJtRUFCZ1kyVFE0TUFnY0hBV0VDQVFFQk5FMEFDUWtLWVEwQkNnbzRDazRiUzdBWFVGaEFQUUFGQkFNRUJRT0FBQU1BQ3djREMya0FDQWdBWVFBQUFEdE5BQVFFQm1FQUJnWTJUUTRNQWdjSEFXRUNBUUVCTkUwQUNRa0tZUTBCQ2dvNENrNGJTN0FaVUZoQU93QUZCQU1FQlFPQUFBTUFDd2NEQzJrT0RBSUhBZ0VCQ1FjQmFRQUlDQUJoQUFBQU8wMEFCQVFHWVFBR0JqWk5BQWtKQ21FTkFRb0tPQXBPRzB1d0xsQllRRGdBQlFRREJBVURnQUFEQUFzSEF3dHBEZ3dDQndJQkFRa0hBV2tBQ1EwQkNna0taUUFJQ0FCaEFBQUFPMDBBQkFRR1lRQUdCallFVGh0QVBRQUZCQU1FQlFPQUFBTUFDd3dEQzJrT0FRd0hBUXhaQUFjQ0FRRUpCd0ZwQUFrTkFRb0pDbVVBQ0FnQVlRQUFBRHROQUFRRUJtRUFCZ1kyQkU1WldWbFpRQnhEUXdBQVEwdERTa2RHQUVJQVFUdzZKQ1VrRXlNVUpTVWxEd2tmS3dRbU5UUTJOak15RmhVVUJnWWpJaVluSXdZR0l5SW1OVFEyTXpVMEppTWlCaFVWSXlZMU5EWXpNaFlWRlJRV016STJOVFFtSXlJR0ZSUVdNekkyTnhVR0JpTVNOalUxSWhVVUZqTUJDT0Y5MG9iSjhFbHNOeTgrREFZWlJUYzRYSmVLSENjcEpIZ0JhbGhqWVJRVE1FYTlwTFRJcUs0cmVCOGtkU2s4TWFNZkhwbk0wNW5EV0xuQWFvWTdKQm9mSURsTlhFNGhJQ01hRVE0R0RqeEpVRXZURnhKa2JKaVR0cktwcUJNTlVnc1FBUkE3TVE5SkZod0FBd0E5Ly9JQ3ZnSzZBQjRBS1FBeUFIeEFFeWtHQWdFRUxDc1pGQk1GQlFFY0FRSUZBMHhMc0JKUVdFQWtBQVFFQUdFQUFBQTdUUUFCQVFKaEJnTUNBZ0kwVFFjQkJRVUNZUVlEQWdJQ05BSk9HMEFoQUFRRUFHRUFBQUE3VFFBQkFRSmZBQUlDTkUwSEFRVUZBMkVHQVFNRFBBTk9XVUFVS2lvQUFDb3lLakVsSXdBZUFCMFRHU3NJQ1JrckZpWW1OVFEyTnlZMU5EWTJNeklXRmhVVUJnY1hOamN6QmdjWEl5Y0dJeEkyTlRRbUl5SUdGUlFYRWpjbkJnWVZGQll6N25CQlN6MHhOMXMxTVZNelNVSnRHZ0YvQkVCMHB5VlVhVGtuSlJzY0pTOHpNSndpSVVZMURpOWJQMEJmSEQxSVBWWXNKVWswT0d3Z2R6aE5obDEvS1RjQnZEa2hJaVVvSlRjdi9zTWVyQTR4S0N3M0FBQUJBQkwvV0FJUUFxNEFFQUFtUUNNQUFBSURBZ0FEZ0FRQkFnSUJYd0FCQVROTkJRRURBemdEVGhFUkVSRWxFQVlKSENzM0lpWW1OVFEyTXlFVkl4RWpFU01SSStrNVlqeUZid0VLUFZSQ1ZQMHdZa1Z4YVQzODV3TVovT2NBQWdBcC8wb0NBd0s2QURVQVFnQnlRQWxDUERBVkJBQURBVXhMc0JaUVdFQWpBQU1FQUFRRGNnQUFBUUVBY0FBRUJBSmhBQUlDTzAwQUFRRUZZZ1lCQlFWQUJVNGJRQ1VBQXdRQUJBTUFnQUFBQVFRQUFYNEFCQVFDWVFBQ0FqdE5BQUVCQldJR0FRVUZRQVZPV1VBUkFBQUFOUUEwSkNJZkhoc1pJeE1IQ1JnckZpWTFOek1WRkJZek1qWTFOQ1luTGdJMU5EWTNKalUwTmpNeUZoVUhJelUwSmlNaUJoVVVGaGNlQWhVVUJnY1dGUlFHSXhJMU5DWW1KeWNHRlJRV0ZoZXplUUdMS2lVbExUaytQbEE1S3loQ2ZXVmRlUUdMS3lRbExUaytQbEE1S3loQ2ZXVnRKamt5SENFdlFqdTJUVUlYQWgwZEh4a2JKeHdiTDB3MEpVWWFNVkJPVWsxQ0Z3TWFIUjBaR3ljY0d5OU1OQ1pGR2pOT1RsSUJiUjRoTUI4V0RCMGJKVFVoR0FBQUF3QU4vL1FDMHdLNkFBOEFId0E1QUdpeEJtUkVRRjBBQlFZSUJnVUlnQUFJQndZSUIzNEFBQUFDQkFBQ2FRQUVBQVlGQkFacEFBY01BUWtEQndscEN3RURBUUVEV1FzQkF3TUJZZ29CQVFNQlVpQWdFQkFBQUNBNUlEZzJOVE14TFNzcEtDWWtFQjhRSGhnV0FBOEFEaVlOQ1JjcnNRWUFSQVFtSmpVME5qWXpNaFlXRlJRR0JpTStBalUwSmlZaklnWUdGUlFXRmpNbUpqVTBOak15RmhVak5DWWpJZ1lWRkJZek1qWTFNeFFHSXdFUW8yQmdvMkJnbzJCZ28yQlBoazVPaGs5UGhrNU9oazljVjFkY1UwMU9KQzQwTUM4MUxTbEtUMUVNWUtOZ1lLTmdZS05nWUtOZ1BrK0dVRStIVDArSFQxQ0dUMUZtYkcxbVUxTTFMME5PVFVNeU1raGVBQUFFQUEzLzlBTFRBcm9BRHdBZkFDMEFOZ0Jvc1Faa1JFQmRKd0VHQ0FGTUJ3RUZCZ01HQlFPQUFBQUFBZ1FBQW1rQUJBQUpDQVFKWnd3QkNBQUdCUWdHWndzQkF3RUJBMWtMQVFNREFXRUtBUUVEQVZFdkxoQVFBQUExTXk0Mkx6WXRMQ3NxS1NnaUlCQWZFQjRZRmdBUEFBNG1EUWtYSzdFR0FFUUVKaVkxTkRZMk16SVdGaFVVQmdZalBnSTFOQ1ltSXlJR0JoVVVGaFl6QXpNeUZoVVVCZ2NYSXljakZTTTNNalkxTkNZakl4VUJFS05nWUtOZ1lLTmdZS05nVDRaT1RvWlBUNFpPVG9aUGxNQS9RaUlqVjFST1kwNjJHeUVmSFdnTVlLTmdZS05nWUtOZ1lLTmdQaytHVUUrSFQwK0hUMUNHVHdIMVJEb3BQUStxbkp6ZkloNGRIM3dBQkFBTi8vUUMwd0s2QUE4QUh3QXFBRE1BVjBCVUFBWUZBd1VHQTRBQUFBQUNCQUFDYVFBRUFBZ0hCQWhuQ3dFSEFBVUdCd1ZuQ2dFREFRRURXUW9CQXdNQllRa0JBUU1CVVN3ckVCQUFBREl3S3pNc015b3BLQ1lpSUJBZkVCNFlGZ0FQQUE0bURBWVhLd1FtSmpVME5qWXpNaFlXRlJRR0JpTStBalUwSmlZaklnWUdGUlFXRmpNRE16SVdGUlFHSXlNVkl6Y3lOalUwSmlNakZRRVFvMkJnbzJCZ28yQmdvMkJQaGs1T2hrOVBoazVPaGsrQXdEOUNTa3RlVHJZYklSOGRhQXhnbzJCZ28yQmdvMkJnbzJBK1Q0WlFUNGRQVDRkUFVJWlBBZlZFT2tZOW5OOGlIaDBmZkFBQ0FFNEJGd09GQXE0QUJ3QVhBRFJBTVJRUUNnTURBQUZNQ0FjR0F3TUFBNFlGQkFJQkFBQUJWd1VFQWdFQkFGOENBUUFCQUU4VEV4RVRFUkVSRVJBSkJoOHJFeU0xSVJVakVTTUJNeE16RXpNUkl4RWpBeU1ESXhFajJZc0JZb3BOQVFGeVlRUmtjRTBHWWtobEFrY0NaVWxKL3JNQmx2N1JBUy8rYVFFbS90b0JMZjdUQUFRQUtmLzBBMDRDdWdBWEFCc0FKd0ExQUdKQVh3QUJBZ1FDQVFTQUFBUURBZ1FEZmdZQkFBQUNBUUFDYVFBRERBRUZDZ01GYVFBSUFBb0xDQXBwRGdFTEJ3Y0xXUTRCQ3dzSFlRMEpBZ2NMQjFFb0tCd2NBQUFvTlNnMEx5MGNKeHdtSWlBYkdoa1lBQmNBRmhJakloSWpEd1liS3hJMU5EWXpNaFlWSXpRbUl5SVZGUlF6TWpZMU14UUdJd0V6QVNNZ0pqVTBOak15RmhVVUJpTTJOalUxTkNZaklnWVZGUlFXTXlsYlZFZGNXQ2tnV1ZraUtWWmFTUUd5VlA0QVZBRzJZR0JYVjJCZ1Z5OHdNQzh2TURBdkFVUzdYVjVNU0NJb2FSQm9KaU5KU3dGMi9UcGVYVjFlWGwxZFhrczJNaEF5TnpjeUVESTJBQUFDQUN3QmdnRmtBcm9BRHdBYkFEaXhCbVJFUUMwQUFBQUNBd0FDYVFVQkF3RUJBMWtGQVFNREFXRUVBUUVEQVZFUUVBQUFFQnNRR2hZVUFBOEFEaVlHQ1JjcnNRWUFSQkltSmpVME5qWXpNaFlXRlJRR0JpTTJOalUwSmlNaUJoVVVGak9kUnlvcVJ5c3JSeW9xUnlzZktpb2ZIeXNySHdHQ0trY3JLMGNxS2tjckswY3FVaXNmSHlvcUh4OHJBQUFCQURNQitnRFpBcTRBQkFBVFFCQUFBUUVBWHdBQUFETUJUaElRQWdrWUt4TXpGd2NqVm9JQk9XMENyZ094QUFBQ0FETUIrZ0dpQXE0QUJBQUpBQmRBRkFNQkFRRUFYd0lCQUFBekFVNFNFUklRQkFrYUt4TXpGd2NqTnpNWEJ5TldnZ0U1YmV5Q0FUbHRBcTREc2JRRHNRQUJBRnIvVXdDK0F0TUFBd0FUUUJBQUFBQTFUUUFCQVRnQlRoRVFBZ2tZS3hNekVTTmFaR1FDMC95QUFBSUFXdjlUQUw0QzB3QURBQWNBSDBBY0FBRUJBRjhBQUFBMVRRQUNBZ05mQUFNRE9BTk9FUkVSRUFRSkdpc1RNeEVqRlRNUkkxcGtaR1JrQXRQK2txVCtrZ0FBQVFBai8xTUNDQUt1QUFzQUlFQWRDUWdIQmdNQ0FRQUlBUUFCVEFBQUFETk5BQUVCT0FGT0ZSUUNDUmdyRXdjMUZ5Y3pCemNWSnhNajhNM05FV3dSenM0VWNnR3BFbkVSdDdjUmNSTDlxZ0FDQURmLzlBR2pBdDhBR1FBaEFEbEFOaUVXRUFZRUF3SUhBUU1YQVFJQkFrd0FBQUFEQVFBRGFRQUJBZ0lCV1FBQkFRSmhCQUVDQVFKUkFBQWVIQUFaQUJnb0tRVUdHQ3NXSmljSE5UWTNOVFEyTXpJV0ZSUUdCeFVVRmpNeU54VUdJeEkxTkNNaUJoVVZ4MW9CTlIwWVgwaEVUR2hYS3lJMEx6UThKaW9aSXd4a1VTVlpGUlgxZDJ4UFNrR2lVMG81Tmg1bkdnSC9WRVJGU244QUFBRUFKUDlUQWdnQ3JnQVZBQ2xBSmhNU0VSQVBEZzBNQ3dnSEJnVUVBd0lCRVFFQUFVd0FBQUF6VFFBQkFUZ0JUaG9aQWdrWUt6Y0hOUmNuTndjMUZ5Y3pCemNWSnhjSE54VW5GeVB4emMwVUZNM05FV3dSemMwVUZNM05FV3dORVhFU3FhVVNjUkczdHhGeEVxV3BFbkVSdWdBQUJBQkRBQUFFSWdLNkFBc0FIZ0FzQURBQWhrQUtHUUVIQmhBQkNRZ0NURXV3RkZCWVFDVUxBUWNLQVFFSUJ3RnBBQWdBQ1FRSUNXY0FCZ1lBWHdNQ0FnQUFNMDBGQVFRRU5BUk9HMEFwQ3dFSENnRUJDQWNCYVFBSUFBa0VDQWxuQXdFQ0FqTk5BQVlHQUdFQUFBQTdUUVVCQkFRMEJFNVpRQjRmSHdBQU1DOHVMUjhzSHlzbUpCNGRGaFVVRXcwTUFBc0FDaVFNQ1JjckFDWTFORFl6TWhZVkZBWWpBVE1CRmhjM0p4RXpFU01CSmljSEZoVVJJd0EyTlRVMEppTWlCaFVWRkJZekJ5RVZJUU1mVlZWWFYxVlZWL3pOalFFSURCd0ZBNDJOL3ZjVEZBVURqUU5ZSWlJbEpTTWpKWndCT2Y3SEFUQmdaV1ZnWUdWbFlBRisvbzRSTWdNNkFYajlVZ0YxR3ljREt4SCtpQUdBT0RnS09EZzVOd28zT1hsWkFBQUNBQzMvOUFJdkFob0FGd0FlQUVaQVF4MFpBZ1VFRkJNT0F3SUJBa3dBQUFBRUJRQUVhUWNCQlFBQkFnVUJad0FDQXdNQ1dRQUNBZ05oQmdFREFnTlJHQmdBQUJnZUdCNGNHZ0FYQUJZaUl5WUlCaGtyRmlZbU5UUTJOak15RmhZVkZTRVZGak15TmpjWEJnWWpFelVtSXlJSEZlQjFQajUxVGs1MFAvNXFPbHRCWXhvaUlITk5sVHhaV2pzTVIzeFFVSHhIU1lKU0JhVTFPak1WUFVVQkxwYzNOcGdBQWdCTkFBQUNEd0l6QUFRQUNRQW9RQ1VJQndZQ0FRQUdBVW9DQVFFQUFBRlhBZ0VCQVFCZkFBQUJBRThGQlFVSkJRa1RBd1lYS3hNM0Z4RWhKVFVuQnhWTjRlSCtQZ0Y5bkp3Qk52Mzkvc3BHMWJLeTFRQUJBQ3YvOUFLekFyb0FMd0JDUUQ4R0FRUURBVXdBQVFJREFnRURnQVlCQXdjQkJBVURCR2tBQWdJQVlRQUFBRHROQUFVRkNHRUpBUWdJUEFoT0FBQUFMd0F1RVJNaklTUWlGQ3dLQ1I0ckZpWW1OVFEyTnpVbUpqVTBOak15RmhZVkZTTTFOQ01pQmhVVUZqTXpGU01pQmhVVU16STJOVFV6RlNNVkZBWWo4WDlIUzBFOFA1UitUWGRDaVg5Q1F6OHRSVUk1Ull4RVEraGZqb1FNTDFrOFJGSVNCQmhHUEZwaUwxVTRIQk5XTWkwcEwzQXFOV0kwTXN0d1dHUjBBQUFCQUFBQjN3Q0tBdE1BQmdCTnNRWmtSTFVFQVFBQkFVeExzQXBRV0VBV0FBSUFBQUp4QUFFQUFBRlhBQUVCQUY4QUFBRUFUeHRBRlFBQ0FBS0dBQUVBQUFGWEFBRUJBRjhBQUFFQVQxbTFFaEVRQXdrWks3RUdBRVFUSXpVekZRY2pOemVLUWtnQ1ZIOXpnZi8vQUFBQ0dBRnZBc3dCQmdMYXpSNEFDTEVBQXJBZXNEVXIvLzhBQUFJWUFLWUN6QUVHQXRuTkhnQUlzUUFCc0I2d05Tc0FBUUFBQWxnQk1RS3dBQU1BSUxFR1pFUkFGUUFBQVFFQVZ3QUFBQUZmQUFFQUFVOFJFQUlKR0N1eEJnQkVFU0VWSVFFeC9zOENzRmdBQUFMK3R3SmRBQUFDMHdBREFBY0FKYkVHWkVSQUdnSUJBQUVCQUZjQ0FRQUFBVjhEQVFFQUFVOFJFUkVRQkFrYUs3RUdBRVFCTXhVak56TVZJLzYzZG5iU2QzY0MwM1oyZGdBQUFmOTNBbEVBQUFMVEFBTUFJTEVHWkVSQUZRQUFBUUVBVndBQUFBRmZBQUVBQVU4UkVBSUpHQ3V4QmdCRUF6TVZJNG1KaVFMVGdnQUIveXNDVHdBQUF0TUFCQUFnc1Faa1JFQVZBQUFCQVFCWEFBQUFBVjhBQVFBQlR4RWdBZ2tZSzdFR0FFUUROek1YSTlVQmhVOXBBdEFEaEFBQi95c0NUd0FBQXRNQUJBQWdzUVprUkVBVkFBQUJBUUJYQUFBQUFWOEFBUUFCVHhJUUFna1lLN0VHQUVRRE14Y0hJNGFGQVd4cEF0TURnUUFDL253Q1R3QUFBdE1BQkFBSkFDV3hCbVJFUUJvQ0FRQUJBUUJYQWdFQUFBRmZBd0VCQUFGUEVoRVNFQVFKR2l1eEJnQkVBVE1YQnlNM014Y0hJLzdMaFFGc2FmNkZBV3hwQXRNRGdZUURnUUFBQWY5MkFpSUFBQUxUQUFNQUUwQVFBQUVCQUY4QUFBQTFBVTRSRUFJSkdDc0RNd2NqZG5aQ1NBTFRzUUFCL3JNQ1RBQUFBdE1BQmdBb3NRWmtSRUFkQkFFQkFBRk1BQUFCQVFCWEFBQUFBVjhDQVFFQUFVOFNFUkFEQ1JrcnNRWUFSQU16RnlNbkJ5UGplbWx2TnpodkF0T0hSVVVBQUFIK3N3Sk1BQUFDMHdBR0FDbXhCbVJFUUI0Q0FRSUFBVXdCQVFBQ0FnQlhBUUVBQUFKZkFBSUFBazhSRWhBRENSa3JzUVlBUkFFekZ6Y3pCeVArczI4NE4yOXBlZ0xUUlVXSEFBQUIvcjBDUUFBQUFza0FEd0F1c1Faa1JFQWpBZ0VBQVFDRkFBRURBd0ZaQUFFQkEyRUVBUU1CQTFFQUFBQVBBQTRTSWhNRkNSa3JzUVlBUkFJbUpqVXpGaFl6TWpZM014UUdCaVBaU0NKYUF5UWdJQ1lDV2lKSk53SkFLRDhpRWg0ZUVpSS9LQUFDL3pZQ0xBQUFBdllBQ3dBWEFEaXhCbVJFUUMwQUFBQUNBd0FDYVFVQkF3RUJBMWtGQVFNREFXRUVBUUVEQVZFTURBQUFEQmNNRmhJUUFBc0FDaVFHQ1JjcnNRWUFSQUltTlRRMk16SVdGUlFHSXpZMk5UUW1JeUlHRlJRV001TTNOeTR1TnpjdUV4a1pFeFFZR0JRQ0xEb3JLem82S3lzNk9Sa1RFeGtaRXhNWkFBQUIvckFDV1FBQUF0TUFHQUF1c1Faa1JFQWpBQUVFQXdGWkFnRUFBQVFEQUFScEFBRUJBMklGQVFNQkExSVJKQ0lTSkNFR0NSd3JzUVlBUkFBMk16SVdGeFlXTXpJMk56TVVCaU1pSmljbUppTWlCeVArc0RFeEVCd1pGUndQRHhFRFJqRXlFQnNaRlJ3UEhnVkdBbzVGQ1FvSkNSRVVOVVVKQ2drSkpRQUIvczhDV0FBQUFyQUFBd0Fnc1Faa1JFQVZBQUFCQVFCWEFBQUFBVjhBQVFBQlR4RVFBZ2tZSzdFR0FFUUJJUlVoL3M4Qk1mN1BBckJZQUFBQi96Z0NUd0FBQXQ4QUV3Q2JzUVprUkxVSkFRRUNBVXhMc0E1UVdFQWpBQUVDQUFRQmNnQUFBd0lBY0FBREJBUURjQUFDQVFRQ1dnQUNBZ1JmQUFRQ0JFOGJTN0F3VUZoQUpRQUJBZ0FDQVFDQUFBQURBZ0FEZmdBREJBUURjQUFDQVFRQ1dnQUNBZ1JmQUFRQ0JFOGJRQ1lBQVFJQUFnRUFnQUFBQXdJQUEzNEFBd1FDQXdSK0FBSUJCQUphQUFJQ0JGOEFCQUlFVDFsWnR4RVVJaVFnQlFrYks3RUdBRVFETXpJMk5UUW1JeU0xTmpNeUZoVVVCZ2NWSTVrT0VnNFJFam9tTFM1SE1DVkVBb1VKQ2dzSUxBZ2JJaHNkQWhrQUFBTCtmQUpQQUFBQzB3QUVBQWtBSmJFR1pFUkFHZ0lCQUFFQkFGY0NBUUFBQVY4REFRRUFBVThSSVJFZ0JBa2FLN0VHQUVRQk56TVhJemMzTXhjai9ud0JoVTlwUXdHRlQya0MwQU9FZ1FPRUFBQUIvcjBDU2dBQUF0TUFEd0Fvc1Faa1JFQWRBd0VCQWdHR0FBQUNBZ0JaQUFBQUFtRUFBZ0FDVVJJaUV5SUVDUm9yc1FZQVJBQTJOak15RmhZVkl5WW1JeUlHQnlQK3ZTSkpOemRJSWxvREpDQWdKZ0phQW13L0tDZy9JaEllSGhJQUFBSC9qUUpRQUFBREpnQUdBRTJ4Qm1SRXRRQUJBZ0VCVEV1d0RGQllRQllBQUFFQkFIQUFBUUlDQVZjQUFRRUNZQUFDQVFKUUcwQVZBQUFCQUlVQUFRSUNBVmNBQVFFQ1lBQUNBUUpRV2JVUkVSRURDUmtyc1FZQVJBTTNNd2N6RlNOek5EOHVMbk1DdUc1a2NnQUFBZitOQWxBQUFBTkVBQVlBVGJFR1pFUzFCQUVBQVFGTVM3QUtVRmhBRmdBQ0FBQUNjUUFCQUFBQlZ3QUJBUUJmQUFBQkFFOGJRQlVBQWdBQ2hnQUJBQUFCVndBQkFRQmZBQUFCQUU5WnRSSVJFQU1KR1N1eEJnQkVBeU0xTXhVSEkwVXVjemM4QXRKeWFJd0FBZjhrQWNvQUFBS3VBQW9BSnJFR1pFUkFHd0FCQUFHRkFBQUNBZ0JYQUFBQUFtQUFBZ0FDVUNNU0lBTUpHU3V4QmdCRUF6TXlOVFV6RlJRR0l5UGNTQ3RwVFVWS0FnNDFhMnM0UVFBQUFmOTUvMGtBQVAvTEFBTUFJTEVHWkVSQUZRQUFBUUVBVndBQUFBRmZBQUVBQVU4UkVBSUpHQ3V4QmdCRUJ6TVZJNGVIaHpXQ0FBQUMvcmIvU1FBQS84c0FBd0FIQUNXeEJtUkVRQm9DQVFBQkFRQlhBZ0VBQUFGZkF3RUJBQUZQRVJFUkVBUUpHaXV4QmdCRUJUTVZJemN6RlNQK3RuWjIwM2QzTllLQ2dnQUIvNDMrN3dBQS84c0FCZ0JOc1Faa1JMVUVBUUFCQVV4THNBNVFXRUFXQUFJQUFBSnhBQUVBQUFGWEFBRUJBRjhBQUFFQVR4dEFGUUFDQUFLR0FBRUFBQUZYQUFFQkFGOEFBQUVBVDFtMUVoRVFBd2taSzdFR0FFUUhJelV6RlFjalJTNXpOenkzZ25oa0FBQUIveEQvU1FBQUFBb0FFd0Jyc1Faa1JMVUJBUVFBQVV4THNBNVFXRUFnQUFNQ0FRQURjZ0FDQUFFQUFnRnBBQUFFQkFCWEFBQUFCR0lGQVFRQUJGSWJRQ0VBQXdJQkFnTUJnQUFDQUFFQUFnRnBBQUFFQkFCWEFBQUFCR0lGQVFRQUJGSlpRQTBBQUFBVEFCSVJFU1FpQmdrYUs3RUdBRVFHSnpVek1qWTFOQ1lqSXpjekJ4WVdGUlFHSThBd1dCY1dFeGNwRFZVR0xEWlROYmNJTVFvT0RBeFlMQUlpSUMwa0FBSC9aZjlKQUFBQUJBQVJBRm14Qm1SRXRROEJBZ0VCVEV1d0NsQllRQmdBQVFBQ0FBRnlBQUFCQWdCWEFBQUFBbUVEQVFJQUFsRWJRQmtBQVFBQ0FBRUNnQUFBQVFJQVZ3QUFBQUpoQXdFQ0FBSlJXVUFMQUFBQUVRQVFKaFVFQ1JncnNRWUFSQVltTlRRMk56TVZCZ1lWRkJZek14VUdJMnN3SkNKREZ4Z1ZGaFlqSExjcElCMDhHUVFVS3hJUUV6Y01BQUFCL3IzL1BBQUEvOFVBRHdBdXNRWmtSRUFqQWdFQUFRQ0ZBQUVEQXdGWkFBRUJBMkVFQVFNQkExRUFBQUFQQUE0U0loTUZDUmtyc1FZQVJBWW1KalV6RmhZek1qWTNNeFFHQmlQWlNDSmFBeVFnSUNZQ1dpSkpOOFFvUHlJU0hoNFNJajhvQUFBQi9zLy9XZ0FBLzdJQUF3QWdzUVprUkVBVkFBQUJBUUJYQUFBQUFWOEFBUUFCVHhFUUFna1lLN0VHQUVRRklSVWgvczhCTWY3UFRsZ0FBZjZuQVR3QUFBR29BQU1BSUxFR1pFUkFGUUFBQVFFQVZ3QUFBQUZmQUFFQUFVOFJFQUlKR0N1eEJnQkVBU0VWSWY2bkFWbitwd0dvYkFBQUFmMDZBVHdBQUFHb0FBTUFJTEVHWkVSQUZRQUFBUUVBVndBQUFBRmZBQUVBQVU4UkVBSUpHQ3V4QmdCRUFTRVZJZjA2QXNiOU9nR29iQUFBQWY3cUFNb0FBQUh1QUFNQUJyTURBUUV5S3dFbEZRWCs2Z0VXL3VvQk1MNW12Z0FBQWYzMy84OEFBQUkvQUFNQUdiRUdaRVJBRGdBQUFRQ0ZBQUVCZGhFUUFna1lLN0VHQUVRRE13RWpWRlQrVEZVQ1AvMlFBQUVBU3dKUEFTQUMwd0FFQUNDeEJtUkVRQlVBQUFFQkFGY0FBQUFCWHdBQkFBRlBFaEFDQ1JncnNRWUFSQk16Rndjam1vVUJiR2tDMHdPQkFBRUFCUUpLQVVnQzB3QVBBQzZ4Qm1SRVFDTUNBUUFCQUlVQUFRTURBVmtBQVFFRFlRUUJBd0VEVVFBQUFBOEFEaElpRXdVSkdTdXhCZ0JFRWlZbU5UTVdGak15TmpjekZBWUdJMjlJSWxvREpDQWdKZ0phSWtrM0Frb29QeUlTSGg0U0lqOG9BQUVBQUFKTUFVMEMwd0FHQUNteEJtUkVRQjRDQVFJQUFVd0JBUUFDQWdCWEFRRUFBQUpmQUFJQUFrOFJFaEFEQ1JrcnNRWUFSQkV6RnpjekJ5TnZPRGR2YVhvQzAwVkZod0FBQVFBdC8wb0JIUUFMQUJNQWE3RUdaRVMxQVFFRUFBRk1TN0FPVUZoQUlBQURBZ0VBQTNJQUFnQUJBQUlCYVFBQUJBUUFWd0FBQUFSaUJRRUVBQVJTRzBBaEFBTUNBUUlEQVlBQUFnQUJBQUlCYVFBQUJBUUFWd0FBQUFSaUJRRUVBQVJTV1VBTkFBQUFFd0FTRVJFa0lnWUpHaXV4QmdCRUZpYzFNekkyTlRRbUl5TTNNd2NXRmhVVUJpTmRNRmdYRmhNWEtRMVZCaXcyVXpXMkNERUtEZ3dNV0N3Q0lpQXRKQUFCQUFBQ1RBRk5BdE1BQmdBb3NRWmtSRUFkQkFFQkFBRk1BQUFCQVFCWEFBQUFBVjhDQVFFQUFVOFNFUkFEQ1JrcnNRWUFSQk16RnlNbkJ5TnFlbWx2TnpodkF0T0hSVVVBQUFJQUFnSmRBVXNDMHdBREFBY0FKYkVHWkVSQUdnSUJBQUVCQUZjQ0FRQUFBVjhEQVFFQUFVOFJFUkVRQkFrYUs3RUdBRVFUTXhVak56TVZJd0oyZHRKM2R3TFRkbloyQUFFQVpBSlNBT3NDMUFBREFDQ3hCbVJFUUJVQUFBRUJBRmNBQUFBQlh3QUJBQUZQRVJBQ0NSZ3JzUVlBUkJNekZTTmtoNGNDMUlJQUFRQkxBazhCSUFMVEFBUUFJTEVHWkVSQUZRQUFBUUVBVndBQUFBRmZBQUVBQVU4UklBSUpHQ3V4QmdCRUV6Y3pGeU5MQVlWUGFRTFFBNFFBQWdBSEFrOEJpd0xUQUFRQUNRQWxzUVprUkVBYUFnRUFBUUVBVndJQkFBQUJYd01CQVFBQlR4SVJFaEFFQ1JvcnNRWUFSQk16Rndjak56TVhCeU5XaFFGc2FmNkZBV3hwQXRNRGdZUURnUUFCQUE0Q1dBRS9BckFBQXdBZ3NRWmtSRUFWQUFBQkFRQlhBQUFBQVY4QUFRQUJUeEVRQWdrWUs3RUdBRVFUSVJVaERnRXgvczhDc0ZnQUFRQkovMG9CREFBTUFCSUFOYkVHWkVSQUtnOEJBZ0VCVEFBQkFBSUFBUUtBQUFBQkFnQlhBQUFBQW1FREFRSUFBbEVBQUFBU0FCRW1GUVFKR0N1eEJnQkVGaVkxTkRZM014VUdCaFVVRmpNekZRWUdJNGMrR3hoV0RCUVlHQ29TTXhTMktpNGlNQmdFRFNZVEZoMDNCZ2dBQWdCQ0Fpd0JEQUwyQUFzQUZ3QTRzUVprUkVBdEFBQUFBZ01BQW1rRkFRTUJBUU5aQlFFREF3RmhCQUVCQXdGUkRBd0FBQXdYREJZU0VBQUxBQW9rQmdrWEs3RUdBRVFTSmpVME5qTXlGaFVVQmlNMk5qVTBKaU1pQmhVVUZqTjVOemN1TGpjM0xoTVpHUk1VR0JnVUFpdzZLeXM2T2lzck9qa1pFeE1aR1JNVEdRQUFBZi8vQWxrQlR3TFRBQmdBTHJFR1pFUkFJd0FCQkFNQldRSUJBQUFFQXdBRWFRQUJBUU5pQlFFREFRTlNFU1FpRWlRaEJna2NLN0VHQUVRQ05qTXlGaGNXRmpNeU5qY3pGQVlqSWlZbkppWWpJZ2NqQVRFeEVCd1pGUndQRHhFRFJqRXlFQnNaRlJ3UEhnVkdBbzVGQ1FvSkNSRVVOVVVKQ2drSkpRRC8vLzYzQWwwQUFBTFRBQUlDNkFBQS8vLy9lUUpSQUFJQzB3QUNBdWtDQUFBQi8wQUNUd0FBQXJVQUJBQVRRQkFBQVFFQVh3QUFBRE1CVGhFZ0Fna1lLd00zTXhjandBR0NQV3dDc2dObUFBQUIvMEFDVHdBQUFyVUFCQUFUUUJBQUFRRUFYd0FBQURNQlRoSVFBZ2tZS3dNekZ3Y2pnNElCVkd3Q3RRTmpBQUFDL253Q1R3QUFBclVBQkFBSkFCZEFGQU1CQVFFQVh3SUJBQUF6QVU0U0VSSVFCQWthS3dFekZ3Y2pOek1YQnlQK3k0VUJiR24raFFGc2FRSzFBMk5tQTJNQUFBSCtzd0pNQUFBQ3RRQUdBQnRBR0FRQkFRQUJUQUlCQVFFQVh3QUFBRE1CVGhJUkVBTUpHU3NETXhjakp3Y2o0M3BwYnpjNGJ3SzFhU2NuQUFIK3N3Sk1BQUFDdFFBR0FCdEFHQUlCQWdBQlRBQUNBZ0JmQVFFQUFETUNUaEVTRUFNSkdTc0JNeGMzTXdjai9yTnZPRGR2YVhvQ3RTY25hUUQvLy82OUFrQUFBQUxKQUFJQzhBQUEvLy8vTmdJc0FBQUM5Z0FDQXZFQUFBQUIvc1FDUlFBQUFyOEFHQUJDUzdBWlVGaEFGd0FFQkFCaEFnRUFBRHROQlFFREF3RmhBQUVCTXdOT0cwQVVBQUVGQVFNQkEyWUFCQVFBWVFJQkFBQTdCRTVaUUFrUkpDSVNKQ0VHQ1J3ckFEWXpNaFlYRmhZek1qWTNNeFFHSXlJbUp5WW1JeUlISS83RU1pc1VJeFlFR3dvUEVRTkdNaXdUSXhZTEZnZ2VCVVlDZUVjTUN3SU1FUlF6Und3TEJRa2wvLy8rendKWUFBQUNzQUFDQXZNQUFQLy8vemdDVHdBQUF0OEFBZ0wwQUFBQUF2NThBazhBQUFLMUFBUUFDUUFYUUJRREFRRUJBRjhDQVFBQU13Rk9FU0VSSUFRSkdpc0JOek1YSXpjM014Y2ovbndCaFU5dVNBR0ZUMjRDc2dObVl3Tm1BUC8vL3IwQ1NnQUFBdE1BQWdMMkFBRC8vLytOQWxBQUFBTW1BQUlDOXdBQS8vLy9KQUhLQUFBQ3JnQUNBdmtBQUFBQi8zbi9TZ0FBLzZnQUF3QVRRQkFBQUFBQlh3QUJBVGdCVGhFUUFna1lLd2N6RlNPSGg0ZFlYdi8vL3JmL1NRQUIvOHNBQWdMN0FRQUFBZitOL3U4QUFQL0xBQVlBV2JVRUFRQUJBVXhMc0E1UVdFQVJBQUlBQUFKeEFBRUJBRjhBQUFBNEFFNGJTN0F5VUZoQUVBQUNBQUtHQUFFQkFGOEFBQUE0QUU0YlFCVUFBZ0FDaGdBQkFBQUJWd0FCQVFCZkFBQUJBRTlaV2JVU0VSQURDUmtyQnlNMU14VUhJMFV1Y3pjOHQ0SjRaQUFBQWY4US8wa0FBQUFLQUJNQVdiVUJBUVFBQVV4THNBNVFXRUFiQUFNQ0FRQURjZ0FDQUFFQUFnRnBBQUFBQkdJRkFRUUVRQVJPRzBBY0FBTUNBUUlEQVlBQUFnQUJBQUlCYVFBQUFBUmlCUUVFQkVBRVRsbEFEUUFBQUJNQUVoRVJKQ0lHQ1JvckJpYzFNekkyTlRRbUl5TTNNd2NXRmhVVUJpUEFNRmdYRmhNWEtRMVZCaXcyVXpXM0NERUtEZ3dNV0N3Q0lpQXRKUC8vL3ozL1NmL1lBQVFBQWdMKzJBRC8vLzY5L3p3QUFQL0ZBQUlDL3dBQS8vLyt6LzlhQUFEL3NnQUNBd0FBQUFBQkFBQUNUd0NYQXZFQUJBQVlRQlVBQUFFQkFGY0FBQUFCWHdBQkFBRlBFaEFDQ1JnckV6TVhCeU1kZVFFdWFRTHhBNThBQUFBQkFBQURMZ0JTQUFjQVd3QUZBQUlBS0FCVUFJMEFBQUNORGhVQUJBQURBQUFBUUFCQUFFQUFRQUIyQUljQW1BQ3lBTWNBNFFEN0FSVUJKZ0UzQVZFQlpnR0FBWm9CdEFIRkFkWUI0Z0h6QWdRQ0ZRSW1Bb0FDa1FLckFyd0RBZ01UQTJnRHFnTzdBOHdFZmdTUEJLQUUxQVRnQk93Rk1BVkJCVWtGVlFWaEJXMEZtUVdxQmJzRnpBWGRCZmNHREFZbUJrQUdXZ1pyQm53R2pRYVpCcW9HdXdiTUJ0MEhLd2M4QjJJSG5BZ0hDQmdJS1FnNkNFc0lWd2hvQ0pBSTBRamlDTzRKQkFrUUNTRUpNZ2xEQ1ZRSlpRbDJDWWNKa3dta0NiVUp4Z25YQ2dzS0hBcGVDbnNLakFxM0NzTUszd3JyQ3Z3TENBc1VDeVlMTWd0ZkM1c0x6Z3ZhQytzTC9Bd0lEQmtNWkF5ckRMY015QTBGRFJZTkp3MDREVWtOWXcxNERaSU5yQTNHRGRjTjZBNENEaHdPS0E0NURrb09zUTdDRHM0TzN3N3dEd0VQRWc4akR6UVBpUS9tRC9jUUNCQWlFS01RMlJFU0VWa1JtQkdwRWJvUnhoSFhFZU1SOUJKUUVtRVNmQktORXlrVE9oTkdFMUlUcEJQdkZBNFVQQlJORkxVVXdSVE5GUHNWREJVZEZTNFZQeFZRRldFVmV4V1ZGYThWeVJYVkZlWVY5eFkxRmtZV1VoWmpGblFXaFJhV0ZxY1d1QmNGRnhZWEp4ZE9GNUFYb1JleUY4TVgxQmdBR0NjWU9CaEpHRm9ZWmhoM0dJZ1ltUmlxR05VWTVoajNHUWdaRkJsMUdZWVpseG1vR2JrWnlobmJHZXdaL1JvT0doOGFNQnF2R3JzYXh4cmNHdXdiQVJzV0d5c2JOeHRERzFnYmFCdDlHNUlicHh1ekc3OGJ5eHZYRytNYjd4djdISmdjcEJ5NUhNVWRpQjJVSGZnZVVSNWRIbWtmUFI5SkgxVWZ1U0FnSUN3Z25pQ3FJTFlnd2lFa0lUQWhQQ0ZJSVZRaGFTRjVJWTRob3lHNEljUWgwQ0hjSWVnaDlDSUFJZ3dpR0NKOElvZ2k2eU1pSTdFanZTUEpJOVVrZWlTR0pKSWt4aVVNSlIwbEtTVktKV0FsYkNWNEpZUWxrQ1djSmFnbHRDWEFKY3dsMkNYa0pmQWwvQ1pCSmswbWd5YXRKc0VtelNiM0p3TW5LaWRBSjFFblhTZHBKM29uaGlldktBVW9SeWhUS0dRb2NDaDhLSWdvNVNsQ0tVNHBXaW1YS2FNcHJ5bTdLY2NwM0Nuc0tnRXFGaW9yS2pjcVF5cFlLbTBxZVNxRktwRXErQ3NFS3hBckhDc29LODByMlN2bEsvRXNSeXloTEswc3VTek9MYUV1QVM1akxzd3ZFeThmTHlzdk55OURMMDh2V3kvakwrOHdDakFXTU5jdzR6RHZNUHN4VERGOU1jd3lMakkvTXRneTVETHdNell6UWpOT00xb3paak55TTM0emt6T29NNzB6MGpQZU0rb3o5alJPTkZvMFpqUnlOSDQwaWpTV05LSTByalVZTlNRMU1EVldOWlUxb1RXdE5iazF4VFh2TmlvMk5qWkNOazQyV2pabU5uSTJmamFLTnJRMndEYk1OdGcyNURkSE4xTTNYemRyTjNjM2d6ZVBONXMzcHplek43ODN5emdjT0NnNE5EaTJPUlE1dERvRU9sWTZYanBtT3JVNjhqc0JPMG83ZHp2Q1BFSThrano3UFhBOW1UNENQbmcrZ0Q2SVBwQSttRDZnUHFnK3NENjRQc0EreUQ3UVB3NC9PVCtSUUExQVIwQ3VRUnRCUUVHa1FoTkNYRUprUW14Q2RFSjhRb1JDakVLVVFweENwRUtzUXJSQ3ZFTEVRc3hDMUVMY1F1UkM3RUwwUXZ4REJFTU1RMTVEYlVOOFE0dERta09wUTdoRHgwUFdRK1ZEOUVRRFJCSkVJVVF3UkQ5RVRrUmRSR3hFZTBTS1JKaEVwa1MwUk1KRTBFVGVST3hFK2tVSVJSWkZWRVdBUmR0R05VYUJSdVpIVmtkOFI5eElURWh0U1RGSlFVbFJTaEZLMUVya1N2UkxCRXNVU3lsTFZVdDJTN1JMMlV2N1RDdE1lVXpMVE9OTkRrMUNUVTVOMTAzM1RoZE9ORTVDVGxCT2FFNkFUcnBPOUU5alQ4NVAvMUF3VUVoUVlGQjVVSkpRcTFDelVMdFExMUQrVVF0UkUxRWdVUzFSTlZGaFVaeFJ5VkgxVWhWU05GSlRVbnRTbzFLL1V0dFRBbE1lVXp4VFdsTmFVMXBUV2xOYVUxcFRXbE5hVThOVUZsU1ZWUWxWZGxYN1ZtQldybGJtVjN0WHVGZ3RXSGxZdDFrTVdWbFp6Vm9ZV29SYTQxdFhXNXRid0Z2WFcvaGNKMXhLWEcxY29WeTZYTlpkRmwwNlhZOWRwVjI2WGVSZURsNCtYck5lK2w4Wlh6eGZyV0FVWUVoZ2RHREdZUWxoTW1Gb1lZeGg4V0g1WWhoaXMyT2NZN3BqM1dRYlpEMWtlbVRFWlBGbExtVlZabmhuQTJjeVo4aG9UV2pRYVVacGlXb0dhazVxWm1xSGFwMXF2MnJuYXpacmNHd0JiRlJzZjJ6ZmJSVnRJbTB2YlV4dGNXMk5iYXR0eVczeWJnaHVMVzVUYm9adXlHOEhieVZ2a20rN2IreHdJM0JaY0lCd25IREFjUFp4UzNHVmNjaHg1WElEY2lGeU0zSk5jbXR5bm5MRGN4aHpQWE5oYzMxem0zUERjK0IwR1hSYmRKcDBvblNxZE1KMDJuVDhkUnAxT1hWQmRVbDFrbldhZGFKMXhIWE1kZFIxM0hYeGRmbDJOWGFCZG9sMmtYYVpkck4yczNhemRyTjJzd0FBQUFFQUFBQUJBUWFGbHNCR1h3ODg5UUFQQStnQUFBQUEyVXd3SXdBQUFBRFpUSmlnL1RyK3lBVWNCRGdBQVFBSEFBSUFBQUFBQUFBQjlRQUFBQUFBQUFFV0FBQUJGZ0FBQXRJQUFnTFNBQUlDMGdBQ0F0SUFBZ0xTQUFJQzBnQUNBdElBQWdMU0FBSUMwZ0FDQXRJQUFnTFNBQUlDMGdBQ0F0SUFBZ0xTQUFJQzBnQUNBdElBQWdMU0FBSUMwZ0FDQXRJQUFnTFNBQUlDMGdBQ0F0SUFBZ0xTQUFJQzBnQUNBdElBQWdMU0FBSUQ2UC83QStqLyt3TFNBRU1DMGdBcUF0SUFLZ0xTQUNvQzBnQXFBdElBS2dMU0FDb0MwZ0JEQlRVQVF3VTFBRU1DMHYvNEF0SUFRd0xTLy9nQzBnQkRCTVlBUXdUR0FFTUNtd0JEQXBzQVF3S2JBRU1DbXdCREFwc0FRd0tiQUVNQ213QkRBcHNBUXdLYkFFTUNtd0JEQXBzQVF3S2JBRU1DbXdCREFwc0FRd0tiQUVNQ213QkRBcHNBUXdLYkFFTUNtd0JEQXBzQVF3SmpBRU1DWS8va0F3b0FLZ01LQUNvRENnQXFBd29BS2dNS0FDb0RDZ0FxQXdvQUtnTFNBRU1DMGdBSEF0SUFRd0xTQUVNQkZnQkRBMElBUXdFV0FFTUJGdi9xQVJiLzVRRVcvK1VCRnYrZEFSYi81d0VXQUVNQkZnQkRBUllBQlFFV0FEa0JGdi9yQVJiLzh3RVdBQ3dCRnYvdkFpd0FHUU5DQUVNQ0xBQVpBdElBUXdMU0FFTUNZd0JEQkk4QVF3SmpBRU1DWXdCREFtTUFRd0pqQUVNRGVRQkRBbU1BQUFOQkFFTUMwZ0JEQlA0QVF3TFNBRU1DMGdCREF0SUFRd0xTQUVNQzBnQkRBdEwvNUFQb0FFTUMwZ0JEQXdvQUtnTUtBQ29EQ2dBcUF3b0FLZ01LQUNvRENnQXFBd29BS2dNS0FDb0RDZ0FxQXdvQUtnTUtBQ29EQ2dBcUF3b0FLZ01LQUNvRENnQXFBd29BS2dNS0FDb0RDZ0FxQXdvQUtnTUtBQ29EQ2dBcUF3b0FLZ01LQUNvRENnQXFBd29BS2dNS0FDb0RDZ0FxQXdvQUtnTUtBQ29EQ2dBcUF3b0FLZ1BvQUNvQ213QkRBcHNBUXdNS0FDb0MwZ0JEQXRJQVF3TFNBRU1DMGdCREF0SUFRd0xTQUVNQzBnQkRBcHNBS2dLYkFDb0Ezd0F4QXBzQUtnS2JBQ29DbXdBcUFwc0FLZ0tiQUNvREhnQkRBdThBS2dKakFCVUNZd0FWQW1NQUZRSmpBQlVDWXdBVkFtTUFGUUxTQUVNQzBnQkRBdElBUXdMU0FFTUMwZ0JEQXRJQVF3TFNBRU1DMGdCREF0SUFRd0xTQUVNQzBnQkRBdElBUXdMU0FFTUMwZ0JEQXRJQVF3TFNBRU1DMGdCREF0SUFRd0xTQUVNQzBnQkRBdElBUXdMU0FFTUMwZ0JEQXRJQVF3TFNBRU1DMGdCREFwc0FCQU93QUFJRHNBQUNBN0FBQWdPd0FBSURzQUFDQXBzQUFBS2JBQUFDbXdBQUFwc0FBQUtiQUFBQ213QUFBcHNBQUFLYkFBQUNtd0FBQXBzQUFBSmpBQkVDWXdBUkFtTUFFUUpqQUJFQ1l3QVJBcHNBUXdLYkFFTUNtd0JEQXBzQVF3S2JBRU1DbXdCREFwc0FRd0xTQUNvQzBnQkRBd29BS2dLYkFDb0NZd0FSQWl3QUhRSXNBQjBDTEFBZEFpd0FIUUlzQUIwQ0xBQWRBaXdBSFFJc0FCMENMQUFkQWl3QUhRSXNBQjBDTEFBZEFpd0FIUUlzQUIwQ0xBQWRBaXdBR2dJc0FCMENMQUFkQWl3QUhRSXNBQjBDTEFBZEFpd0FIUUlzQUIwQ0xBQWRBaXdBSFFJc0FCMERlUUFkQTNrQUhRSmpBRWNDTEFBbUFpd0FKZ0lzQUNZQ0xBQW1BaXdBSmdJc0FDWUNZd0FsQW1NQUpnSmpBQ1VDWXdBbEFtTUFKUVJYQUNVRVZ3QWxBaXdBSkFJc0FDUUNMQUFrQWl3QUpBSXNBQ1FDTEFBa0Fpd0FKQUlzQUNRQ0xBQWtBaXdBSkFJc0FDRUNMQUFrQWl3QUpBSXNBQ1FDTEFBa0Fpd0FKQUlzQUNRQ0xBQWtBaXdBSkFJc0FDUUNMQUFqQVUwQUNRSmpBQmdDWXdBWUFtTUFHQUpqQUJnQ1l3QVlBbU1BR0FKakFCZ0NZd0JIQW1NQUFBSmovK1VDWXdCSEFSWUFSZ0VXQUVZQkZnQkdBUmIvNXdFVy8rSUJGdi9pQVJiL2tBRVcvK1FCRmdCRUFSWUFSZ0VXLy8wQkZnQTJBUmIvNkFJc0FFWUJGdi93QVJZQUtRRVcvK0lCRnYvb0FSYi82QUlzQUVZQkZ2L2dBaXdBUndJc0FFY0NMQUJIQVJZQVJ3RVdBRWNCRmdCSEFSWUFSd0VXQUVjQ0xBQkhBUmIvL2dONUFFY0NZd0JIQW1NQVJ3SmovOGtDWXdCSEFtTUFSd0pqQUVjQ1l3QkhBbVAvNkFONUFFY0NZd0JIQW1NQUpnSmpBQ1lDWXdBbUFtTUFKZ0pqQUNZQ1l3QW1BbU1BSmdKakFDWUNZd0FtQW1NQUpnSmpBQ1lDWXdBbUFtTUFKZ0pqQUNZQ1l3QW1BbU1BSmdKakFDWUNZd0FtQW1NQUpnSmpBQ1lDWXdBbUFtTUFKZ0pqQUNZQ1l3QW1BbU1BSmdKakFDWUNZd0FtQW1NQUpnSmpBQ1lDWXdBbUFtTUFKZ093QUNZQ1l3QkhBbU1BUndKakFDVUJoUUJIQVlVQVJ3R0ZBRFVCaFFCSEFZWC80d0dGQUVjQmhRQTdBaXdBTGdJc0FDNEF4Z0F4QWl3QUxnSXNBQzRDTEFBdUFpd0FMZ0lzQUM0Q1l3QkJBUllBQ1FGTkFBc0JUUUFMQVUwQUN3Rk5BQXNCVFFBTEFVMEFDd0pqQUVRQ1l3QkVBbU1BUkFKakFFUUNZd0JFQW1NQU5nSmpBRVFDWXdCRUFtTUFSQUpqQUVRQ1l3QkVBbU1BUkFKakFFUUNZd0JFQW1NQVJBSmpBRVFDWXdCRUFtTUFSQUpqQUVRQ1l3QkVBbU1BUkFKakFFUUNZd0JFQW1NQVJBSmpBRVFDWXdCRUFpd0FDUU1LQUFRRENnQUVBd29BQkFNS0FBUURDZ0FFQWl3QUJnSXNBQWtDTEFBSkFpd0FDUUlzQUFrQ0xBQUpBaXdBQ1FJc0FBa0NMQUFKQWl3QUNRSDBBQlVCOUFBVkFmUUFGUUgwQUJVQjlBQVZBbU1BUkFKakFFUUNZd0JFQW1NQVJBSmpBRVFDWXdCRUFtTUFSQUlzQUNZQ1l3QkhBbU1BSmdJc0FDNEI5QUFWQW9ZQUNRT2NBQWtEbkFBSkFtUUFDUUpqQUFrQmNnQWVBVzBBRlFHTUFEc0N6d0FCQXlJQUlRSkFBRFFDL2dBaEFZd0FPd0lzQUNvQ0xBQlVBaXdBS3dJc0FDSUNMQUFVQWl3QUpBSXNBQ29DTEFBakFpd0FJUUlzQUI0Q0xBQXFBaXdBVkFJc0FDc0NMQUFpQWl3QUZBSXNBQ1FDTEFBcUFpd0FJd0lzQUNFQ0xBQWVBaXdBS2dJc0FEa0NMQUJnQWl3QU5nSXNBQzBDTEFBaEFpd0FMd0lzQURRQ0xBQXlBaXdBTXdJc0FETUNMQUE1QWl3QUtnSXNBRlFDTEFBckFpd0FJZ0lzQUJRQ0xBQWtBaXdBS2dJc0FDTUNMQUFoQWl3QUhnSXNBQ29DTEFBNUFpd0FZQUlzQURZQ0xBQXRBaXdBSVFJc0FDOENMQUEwQWl3QU1nSXNBRE1DTEFBekFpd0FPUUlzQUNvQlRRQWhBVTBBTndGTkFDa0JUUUFsQVUwQUhRRk5BQ2NCVFFBZEFVMEFKUUZOQUNNQlRRQWRBVTBBSVFGTkFEY0JUUUFwQVUwQUpRRk5BQjBCVFFBbkFVMEFIUUZOQUNVQlRRQWpBVTBBSFFGTkFDRUJUUUEzQVUwQUtRRk5BQ1VCVFFBZEFVMEFKd0ZOQUIwQlRRQWxBVTBBSXdGTkFCMEJUUUFoQVUwQU53Rk5BQ2tCVFFBbEFVMEFIUUZOQUNjQlRRQWRBVTBBSlFGTkFDTUJUUUFkQUtmL0ZnTkNBQzREUVFBM0EwRUFLUU5DQUM0RFFnQW1BMEVBTndOQkFDVURRUUFuQXhZQUpRRVdBRVlCRmdCR0FVMEFZUUZOQUdFRDZBQmlBVTBBV2dGTkFGb0NZd0E1QW1NQVNnRk5BR0FCWGdBb0FZVUFId0lOQUZvQ0xBQUpBUllBQVFFV0FBRUJUZi94QVUwQVdnSmpBRW9Bc2dBVUFMSUFGQUZOQURNQlRRQWNBWVVBSFFHRkFDNEJUUUJIQVUwQUxnRk5BQzRCVFFBdUFpd0FBQVBvQUFBRDZBQmtBbGdBTGdGTkFDNENMQUFBQWlnQUFBRk5BQzRCVFFBdUFpd0FBQVBvQUFBQlRRQXVBUllBUmdIMEFFWUI5QUJHQWZRQVJnRVdBRVlCRmdCR0FSWUFSZ0lzQURzQ0xBQW5BVTBBT3dGTkFDY0IyZ0ExQU80QU1RSWlBRGNDSWdBM0ErZ0FBQUpZQUFBQStnQUFBUllBQUFDeUFBQUJUUUFBQUFBQUFBTFNBRDRDTEFBbUF0SUFQZ0lzQUJ3Q0xBQW9BbU1BU2dJc0FBb0NMQUFYQWs4QUNnTGlBQ29DdmdBUUFpd0FDd0k3QUFvQytnQTFBdFlBRUFLcEFBb0NxUUFLQXFrQUNnSmVBRFlDTEFBTEE3QUFFQUlzQUFBQlhnQmtBdHdBTVFDbi94WUNSd0E0QWx3QXNRSmNBTzhDU0FBNEFrZ0FPQUpJQUVzQ0pRQW5Ba2dBT0FJbEFDWUNTQUE0QWtnQU5nSWxBQ1lDSlFBbUFpVUFKd0lsQUJzQ1NBQXBBa2dBS2dIVkFCa0N5UUF2QWl3QUhRTFNBRjRCRWdBWEF5SUFJUUxQQUFFRE53QXBBc2tBT3dJbEFCNEI3Z0FqQWtBQU5BUFRBTEVEZVFBdUErZ0FFZ0pJQUNvQjlBQkVBK2dBS2dIMEFFUUQ2QUFxQStnQUtnSDBBRUVCOUFCQkFsZ0FLZ1BQQUNjQzBnQTlBaXdBRWdJc0FDa0M0UUFOQXVFQURRTGhBQTBENkFCT0EzVUFLUUdRQUN3QThBQXpBZDhBTXdFWUFGb0JHQUJhQWl3QUl3SHBBRGNDTEFBa0JGc0FRd0pZQUMwQ1hBQk5BdElBS3dDS0FBQUJid0FBQUtZQUFBRXhBQUFBQVA2M0FBRC9kd0FBL3lzQUFQOHJBQUQrZkFBQS8zWUFBUDZ6QUFEK3N3QUEvcjBBQVA4MkFBRCtzQUFBL3M4QUFQODRBQUQrZkFBQS9yMEFBUCtOQUFEL2pRQUEveVFBQVA5NUFBRCt0Z0FBLzQwQUFQOFFBQUQvWlFBQS9yMEFBUDdQQUFEK3B3QUEvVG9BQVA3cUFBRDk5d0ZOQUVzQlRRQUZBVTBBQUFGTkFDMEJUUUFBQVUwQUFnRk5BR1FCVFFCTEFVMEFCd0ZOQUE0QlRRQkpBVTBBUWdGTi8vOEFBUDYzQUFEL2VRQUEvMEFBQVA5QUFBRCtmQUFBL3JNQUFQNnpBQUQrdlFBQS96WUFBUDdFQUFEK3p3QUEvemdBQVA1OEFBRCt2UUFBLzQwQUFQOGtBQUQvZVFBQS9yY0FBUCtOQUFEL0VBQUEvejBBQVA2OUFBRCt6d0NYQUFBQ1dBQUFBQUFBQUFBQUFBQUFBUUFBQTI3L0xnQUFCVFg5T3Y4WEJSd0FBUUFBQUFBQUFBQUFBQUFBQUFBQUF5c0FCQUpJQXJ3QUJRQUFBb29DV0FBQUFFc0NpZ0pZQUFBQlhnQXlBVHNBQUFJTENBTUNBZ0lDQ3dRZ0FBQVBBQUFBQVFBQUFBQUFBQUFBVDAxT1NRQ2dBQUQrL3dOdS95NEFBQVE0QVRnZ0FBR1RBQUFBQUFJT0FxNEFBQUFnQUE0QUFBQUNBQUFBQXdBQUFCUUFBd0FCQUFBQUZBQUVDQW9BQUFEZ0FJQUFCZ0JnQUFBQURRQXZBRGtBZmdGL0FZOEJrZ0dkQWFFQnNBSGNBZWNCNndIMUFoc0NMUUl6QWpjQ1dRSnlBcm9DdkFMSEFza0MzUU1FQXd3RER3TVRBeHNESkFNb0F5NERNUU00QTVRRHFRTzhBOEFlRFI0bEhrVWVXeDVqSG0wZWhSNlRIcDRlK1NBRklBa2dFU0FWSUI0Z0lpQW1JREFnTXlBNklEd2dQaUJFSUZJZ2NDQjVJSDhnaVNDWklLRWdwQ0NuSUtrZ3JTQ3lJTFVndWlDOUlRVWhFeUVYSVNJaEppRXVJVlFoWGlHVklhZ2lBaUlHSWc4aUVpSVZJaG9pSHlJcElpc2lTQ0poSW1VakFpTVFJeUVseWlmcHA0emcvKy85OEFEN0F2Ny8vLzhBQUFBQUFBMEFJQUF3QURvQW9BR1BBWkVCblFHZ0FhOEJ4QUhtQWVvQjhRSDZBaW9DTUFJM0Fsa0NjZ0s1QXJ3Q3hnTEpBdGdEQUFNR0F3OERFUU1iQXlNREpnTXVBekVETlFPVUE2a0R2QVBBSGd3ZUpCNUVIbG9lWWg1c0hvQWVraDZlSHFBZ0FpQUpJQkFnRXlBWElDQWdKaUF3SURJZ09TQThJRDRnUkNCU0lIQWdkQ0IvSUlBZ21TQ2hJS01ncGlDcElLc2dzU0MxSUxrZ3ZDRUZJUk1oRmlFaUlTWWhMaUZUSVZzaGtDR29JZ0lpQlNJUEloRWlGU0laSWg0aUtTSXJJa2dpWUNKa0l3SWpFQ01nSmNvbjZLZUw0UC92L2ZBQSt3SCsvLy8vQXlyLzlRQUFBYlVBQUFBQS94MEFBUDdaQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBL3hUKzAvN3VBQUFBS0FBQUFCNEFBQUFBQUFELzV2L2wvOTcvMS8vVy85SC96Ly9NL2t6K09QNG0vaU1BQUFBQUFBQUFBQUFBQUFBQUFBQUE0ZzBBQUFBQTRvSGlYdUpZQUFBQUFPSXM0cFhpcCtKSDRoN2lJT0lBNGxMaHl1SEs0V0Robk9GTDRlNEFBT0gxNGZnQUFBQUE0ZGdBQUFBQTRkTGh5d0FBNGJUaGx1R3o0UFBnN3dBQTRTWGd2d0FBNEs4QUFPQ1FBQUFBQU9DUjRKRGdiQUFBQUFEZjROKzJBQURkQk5xY0FBQWlMQk12RXkwRzJnT05BQUVBQUFBQUFOd0FBQUQ0QVlBQUFBTThBQUFEUEFNK0EwQURjQU55QTNRRGZBTytBOFFBQUFBQUFBQUR4QUFBQThRQUFBUEVBODREMWdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVBLQTh3RHpnUFFBOUlEMUFQV0ErQUFBQVBnQkpJQUFBQUFBQUFFa2dTZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBU0lBQUFBQUFTR0JJb0FBQVNLQkl3QUFBQUFCSW9BQUFBQUFBQUFBQUFBQklJQUFBQUFCSWdBQUFTSUFBQUVpQVNLQUFBQUFBQUFCSVlFaUFBQUFBQUVoZ0FBQUFBRWhBQUFBQUFBQUFBQUFBQUFBQUFEQWxNQ2dnSmJBcEVDeEFMUUFvTUNZd0prQWxrQ3FRSlBBbWtDVGdKY0FsQUNVUUt3QXEwQ3J3SlZBczhBQkFBZ0FDRUFKd0F3QUVRQVJnQk5BRkVBWVFCa0FHWUFiZ0J2QUhrQW1RQ2JBSndBb3dDdEFMTUF6UURPQU5NQTFBRGRBbWNDWFFKb0FyY0NjQU1NQU80QkNnRUxBUkVCR0FFdEFTNEJOUUU1QVVvQlRnRlJBVmdCV1FGakFZTUJoUUdHQVkwQmx3R2RBYmNCdUFHOUFiNEJ4d0psQXRzQ1pnSzFBb2tDVkFLT0FxQUNrQUtpQXR3QzBnTUtBdE1CM1FKK0FyWUNhZ0xVQXc0QzJBS3pBandDUFFNRkFzSUMwUUpYQXdnQ093SGVBbjhDU0FKRkFra0NWZ0FXQUFVQURRQWRBQlFBR3dBZUFDUUFQZ0F4QURRQU93QmJBRk1BVmdCWUFDb0FlQUNJQUhvQWZRQ1dBSVFDcXdDVUFMOEF0QUMzQUxrQTFRQ2FBWlVCQUFEdkFQY0JCd0QrQVFVQkNBRU9BU1lCR1FFY0FTTUJRd0U3QVQ0QlFBRVNBV0lCY2dGa0FXY0JnQUZ1QXF3QmZnR3BBWjRCb1FHakFiOEJoQUhCQUJrQkF3QUdBUEFBR2dFRUFDSUJEQUFsQVE4QUpnRVFBQ01CRFFBckFSTUFMQUVVQUVFQktRQXlBUm9BUEFFa0FFSUJLZ0F6QVJzQVNnRXlBRWdCTUFCTUFUUUFTd0V6QUU4Qk53Qk9BVFlBWUFGSkFGNEJSd0JVQVR3QVh3RklBRmtCT2dCU0FVWUFZd0ZOQUdVQlR3RlFBR2dCVWdCcUFWUUFhUUZUQUdzQlZRQnRBVmNBY1FGYUFITUJYUUJ5QVZ3Qld3QjFBVjhBa2dGOEFIc0JaUUNRQVhvQW1BR0NBSjBCaHdDZkFZa0FuZ0dJQUtRQmpnQ29BWklBcHdHUkFLWUJrQUN3QVpvQXJ3R1pBSzRCbUFETUFiWUF5UUd6QUxVQm53RExBYlVBeHdHeEFNb0J0QURRQWJvQTFnSEFBTmNBM2dISUFPQUJ5Z0RmQWNrQmxnQkZBcFFBaWdGMEFNRUJxd0FwQUM4QkZ3Qm5BR3dCVmdCd0FIY0JZUUFNQVBZQVZRRTlBSHdCWmdDMkFhQUF2UUduQUxvQnBBQzdBYVVBdkFHbUFFa0JNUUNUQVgwQUtBQXVBUllBUndFdkFCd0JCZ0FmQVFrQWxRRi9BQk1BL1FBWUFRSUFPZ0VpQUVBQktBQlhBVDhBWFFGRkFJTUJiUUNSQVhzQW9BR0tBS0lCakFDNEFhSUF5QUd5QUtrQmt3Q3hBWnNBaFFGdkFKY0JnUUNHQVhBQTJ3SEZBdVlDNVFNSkF3Y0RCZ01MQXhBRER3TVJBdzBDNmdMckF1NEM4Z0x6QXZBQzZRTG9BdlFDOFFMc0F1OEFMUUVWQUZBQk9BQjBBVjRBb1FHTEFLb0JsQUN5QVp3QTBnRzhBTThCdVFEUkFic0E0UUhMQUJVQS93QVhBUUVBRGdENEFCQUErZ0FSQVBzQUVnRDhBQThBK1FBSEFQRUFDUUR6QUFvQTlBQUxBUFVBQ0FEeUFEMEJKUUEvQVNjQVF3RXJBRFVCSFFBM0FSOEFPQUVnQURrQklRQTJBUjRBWEFGRUFGb0JRZ0NIQVhFQWlRRnpBSDRCYUFDQUFXb0FnUUZyQUlJQmJBQi9BV2tBaXdGMUFJMEJkd0NPQVhnQWp3RjVBSXdCZGdDK0FhZ0F3QUdxQU1JQnJBREVBYTRBeFFHdkFNWUJzQUREQWEwQTJRSERBTmdCd2dEYUFjUUEzQUhHQW9jQ2hnS0xBb2dDY1FKN0Fud0Nkd0o5QW5rQ2VnSjRBdDBDM3dKWUFwVUNtQUtTQXBNQ2x3S2RBcFlDbndLWkFwb0NuZ0xnQXRVQ3lnTEhBc2dDeVFMTEFzd0N1UUs5QXI4Q3FnS2pBc0FDdUFMREFxNENwZ0t5QXJFQ3FBS25BS1VCandBQXNBQXNJTEFBVlZoRldTQWdTN2dBRGxGTHNBWlRXbGl3TkJ1d0tGbGdaaUNLVlZpd0FpVmh1UWdBQ0FCall5TmlHeUVoc0FCWnNBQkRJMFN5QUFFQVEyQkNMYkFCTExBZ1lHWXRzQUlzSXlFaklTMndBeXdnWkxNREZCVUFRa093RTBNZ1lHQkNzUUlVUTBLeEpRTkRzQUpEVkhnZ3NBd2pzQUpEUTJGa3NBUlFlTElDQWdKRFlFS3dJV1VjSWJBQ1EwT3lEaFVCUWh3Z3NBSkRJMEt5RXdFVFEyQkNJN0FBVUZobFdiSVdBUUpEWUVJdHNBUXNzQU1yc0JWRFdDTWhJeUd3RmtOREk3QUFVRmhsV1JzZ1pDQ3d3RkN3QkNaYXNpZ0JEVU5GWTBXd0JrVllJYkFESlZsU1cxZ2hJeUViaWxnZ3NGQlFXQ0d3UUZrYklMQTRVRmdoc0RoWldTQ3hBUTFEUldORllXU3dLRkJZSWJFQkRVTkZZMFVnc0RCUVdDR3dNRmtiSUxEQVVGZ2daaUNLaW1FZ3NBcFFXR0FiSUxBZ1VGZ2hzQXBnR3lDd05sQllJYkEyWUJ0Z1dWbFpHN0FDSmJBTVEyT3dBRkpZc0FCTHNBcFFXQ0d3REVNYlM3QWVVRmdoc0I1TFliZ1FBR093REVOanVBVUFZbGxaWkdGWnNBRXJXVmtqc0FCUVdHVlpXU0Jrc0JaREkwSlpMYkFGTENCRklMQUVKV0ZrSUxBSFExQllzQWNqUXJBSUkwSWJJU0Zac0FGZ0xiQUdMQ01oSXlHd0F5c2daTEVIWWtJZ3NBZ2pRckFHUlZnYnNRRU5RMFZqc1FFTlE3QUVZRVZqc0FVcUlTQ3dDRU1naWlDS3NBRXJzVEFGSmJBRUpsRllZRkFiWVZKWldDTlpJVmtnc0VCVFdMQUJLeHNoc0VCWkk3QUFVRmhsV1Myd0J5eXdDVU1yc2dBQ0FFTmdRaTJ3Q0N5d0NTTkNJeUN3QUNOQ1liQUNZbWF3QVdPd0FXQ3dCeW90c0Frc0lDQkZJTEFPUTJPNEJBQmlJTEFBVUZpd1FHQlpackFCWTJCRXNBRmdMYkFLTExJSkRnQkRSVUlxSWJJQUFRQkRZRUl0c0Fzc3NBQkRJMFN5QUFFQVEyQkNMYkFNTENBZ1JTQ3dBU3Nqc0FCRHNBUWxZQ0JGaWlOaElHUWdzQ0JRV0NHd0FCdXdNRkJZc0NBYnNFQlpXU093QUZCWVpWbXdBeVVqWVVSRXNBRmdMYkFOTENBZ1JTQ3dBU3Nqc0FCRHNBUWxZQ0JGaWlOaElHU3dKRkJZc0FBYnNFQlpJN0FBVUZobFdiQURKU05oUkVTd0FXQXRzQTRzSUxBQUkwS3pEUXdBQTBWUVdDRWJJeUZaS2lFdHNBOHNzUUlDUmJCa1lVUXRzQkFzc0FGZ0lDQ3dEME5Lc0FCUVdDQ3dEeU5DV2JBUVEwcXdBRkpZSUxBUUkwSlpMYkFSTENDd0VHSm1zQUZqSUxnRUFHT0tJMkd3RVVOZ0lJcGdJTEFSSTBJakxiQVNMRXRVV0xFRVpFUlpKTEFOWlNONExiQVRMRXRSV0V0VFdMRUVaRVJaR3lGWkpMQVRaU040TGJBVUxMRUFFa05WV0xFU0VrT3dBV0ZDc0JFcldiQUFRN0FDSlVLeER3SWxRckVRQWlWQ3NBRVdJeUN3QXlWUVdMRUJBRU5nc0FRbFFvcUtJSW9qWWJBUUtpRWpzQUZoSUlvalliQVFLaUVic1FFQVEyQ3dBaVZDc0FJbFliQVFLaUZac0E5RFI3QVFRMGRnc0FKaUlMQUFVRml3UUdCWlpyQUJZeUN3RGtOanVBUUFZaUN3QUZCWXNFQmdXV2F3QVdOZ3NRQUFFeU5Fc0FGRHNBQStzZ0VCQVVOZ1FpMndGU3dBc1FBQ1JWUllzQklqUWlCRnNBNGpRckFOSTdBRVlFSWdzQlFqUWlCZ3NBRmh0eGdZQVFBUkFCTUFRa0pDaW1BZ3NCUkRZTEFVSTBLeEZBZ3JzSXNyR3lKWkxiQVdMTEVBRlNzdHNCY3NzUUVWS3kyd0dDeXhBaFVyTGJBWkxMRURGU3N0c0Jvc3NRUVZLeTJ3R3l5eEJSVXJMYkFjTExFR0ZTc3RzQjBzc1FjVkt5MndIaXl4Q0JVckxiQWZMTEVKRlNzdHNDc3NJeUN3RUdKbXNBRmpzQVpnUzFSWUl5QXVzQUZkR3lFaFdTMndMQ3dqSUxBUVltYXdBV093Rm1CTFZGZ2pJQzZ3QVhFYklTRlpMYkF0TENNZ3NCQmlackFCWTdBbVlFdFVXQ01nTHJBQmNoc2hJVmt0c0NBc0FMQVBLN0VBQWtWVVdMQVNJMElnUmJBT0kwS3dEU093QkdCQ0lHQ3dBV0cxR0JnQkFCRUFRa0tLWUxFVUNDdXdpeXNiSWxrdHNDRXNzUUFnS3kyd0lpeXhBU0FyTGJBakxMRUNJQ3N0c0NRc3NRTWdLeTJ3SlN5eEJDQXJMYkFtTExFRklDc3RzQ2Nzc1FZZ0t5MndLQ3l4QnlBckxiQXBMTEVJSUNzdHNDb3NzUWtnS3kyd0xpd2dQTEFCWUMyd0x5d2dZTEFZWUNCREk3QUJZRU93QWlWaHNBRmdzQzRxSVMyd01DeXdMeXV3THlvdHNERXNJQ0JISUNDd0RrTmp1QVFBWWlDd0FGQllzRUJnV1dhd0FXTmdJMkU0SXlDS1ZWZ2dSeUFnc0E1RFk3Z0VBR0lnc0FCUVdMQkFZRmxtc0FGallDTmhPQnNoV1Myd01pd0FzUUFDUlZSWXNRNEdSVUt3QVJhd01TcXhCUUVWUlZnd1dSc2lXUzJ3TXl3QXNBOHJzUUFDUlZSWXNRNEdSVUt3QVJhd01TcXhCUUVWUlZnd1dSc2lXUzJ3TkN3Z05iQUJZQzJ3TlN3QXNRNEdSVUt3QVVWanVBUUFZaUN3QUZCWXNFQmdXV2F3QVdPd0FTdXdEa05qdUFRQVlpQ3dBRkJZc0VCZ1dXYXdBV093QVN1d0FCYTBBQUFBQUFCRVBpTTRzVFFCRlNvaExiQTJMQ0E4SUVjZ3NBNURZN2dFQUdJZ3NBQlFXTEJBWUZsbXNBRmpZTEFBUTJFNExiQTNMQzRYUEMyd09Dd2dQQ0JISUxBT1EyTzRCQUJpSUxBQVVGaXdRR0JaWnJBQlkyQ3dBRU5oc0FGRFl6Z3RzRGtzc1FJQUZpVWdMaUJIc0FBalFyQUNKVW1LaWtjalJ5TmhJRmhpR3lGWnNBRWpRckk0QVFFVkZDb3RzRG9zc0FBV3NCY2pRckFFSmJBRUpVY2pSeU5oc1F3QVFyQUxReXRsaWk0aklDQThpamd0c0Rzc3NBQVdzQmNqUXJBRUpiQUVKU0F1UnlOSEkyRWdzQVlqUXJFTUFFS3dDME1ySUxCZ1VGZ2dzRUJSV0xNRUlBVWdHN01FSmdVYVdVSkNJeUN3Q2tNZ2lpTkhJMGNqWVNOR1lMQUdRN0FDWWlDd0FGQllzRUJnV1dhd0FXTmdJTEFCS3lDS2ltRWdzQVJEWUdRanNBVkRZV1JRV0xBRVEyRWJzQVZEWUZtd0F5V3dBbUlnc0FCUVdMQkFZRmxtc0FGallTTWdJTEFFSmlOR1lUZ2JJN0FLUTBhd0FpV3dDa05ISTBjallXQWdzQVpEc0FKaUlMQUFVRml3UUdCWlpyQUJZMkFqSUxBQkt5T3dCa05nc0FFcnNBVWxZYkFGSmJBQ1lpQ3dBRkJZc0VCZ1dXYXdBV093QkNaaElMQUVKV0JrSTdBREpXQmtVRmdoR3lNaFdTTWdJTEFFSmlOR1lUaFpMYkE4TExBQUZyQVhJMElnSUNDd0JTWWdMa2NqUnlOaEl6dzRMYkE5TExBQUZyQVhJMElnc0FvalFpQWdJRVlqUjdBQkt5TmhPQzJ3UGl5d0FCYXdGeU5Dc0FNbHNBSWxSeU5ISTJHd0FGUllMaUE4SXlFYnNBSWxzQUlsUnlOSEkyRWdzQVVsc0FRbFJ5TkhJMkd3QmlXd0JTVkpzQUlsWWJrSUFBZ0FZMk1qSUZoaUd5RlpZN2dFQUdJZ3NBQlFXTEJBWUZsbXNBRmpZQ011SXlBZ1BJbzRJeUZaTGJBL0xMQUFGckFYSTBJZ3NBcERJQzVISTBjallTQmdzQ0JnWnJBQ1lpQ3dBRkJZc0VCZ1dXYXdBV01qSUNBOGlqZ3RzRUFzSXlBdVJyQUNKVWF3RjBOWVVCdFNXVmdnUEZrdXNUQUJGQ3N0c0VFc0l5QXVSckFDSlVhd0YwTllVaHRRV1ZnZ1BGa3VzVEFCRkNzdHNFSXNJeUF1UnJBQ0pVYXdGME5ZVUJ0U1dWZ2dQRmtqSUM1R3NBSWxSckFYUTFoU0cxQlpXQ0E4V1M2eE1BRVVLeTJ3UXl5d09pc2pJQzVHc0FJbFJyQVhRMWhRRzFKWldDQThXUzZ4TUFFVUt5MndSQ3l3T3l1S0lDQThzQVlqUW9vNEl5QXVSckFDSlVhd0YwTllVQnRTV1ZnZ1BGa3VzVEFCRkN1d0JrTXVzREFyTGJCRkxMQUFGckFFSmJBRUppQWdJRVlqUjJHd0RDTkNMa2NqUnlOaHNBdERLeU1nUENBdUl6aXhNQUVVS3kyd1JpeXhDZ1FsUXJBQUZyQUVKYkFFSlNBdVJ5TkhJMkVnc0FZalFyRU1BRUt3QzBNcklMQmdVRmdnc0VCUldMTUVJQVVnRzdNRUpnVWFXVUpDSXlCSHNBWkRzQUppSUxBQVVGaXdRR0JaWnJBQlkyQWdzQUVySUlxS1lTQ3dCRU5nWkNPd0JVTmhaRkJZc0FSRFlSdXdCVU5nV2JBREpiQUNZaUN3QUZCWXNFQmdXV2F3QVdOaHNBSWxSbUU0SXlBOEl6Z2JJU0FnUmlOSHNBRXJJMkU0SVZteE1BRVVLeTJ3Unl5eEFEb3JMckV3QVJRckxiQklMTEVBT3lzaEl5QWdQTEFHSTBJak9MRXdBUlFyc0FaRExyQXdLeTJ3U1N5d0FCVWdSN0FBSTBLeUFBRUJGUlFUTHJBMktpMndTaXl3QUJVZ1I3QUFJMEt5QUFFQkZSUVRMckEyS2kyd1N5eXhBQUVVRTdBM0tpMndUQ3l3T1NvdHNFMHNzQUFXUlNNZ0xpQkdpaU5oT0xFd0FSUXJMYkJPTExBS0kwS3dUU3N0c0U4c3NnQUFSaXN0c0ZBc3NnQUJSaXN0c0ZFc3NnRUFSaXN0c0ZJc3NnRUJSaXN0c0ZNc3NnQUFSeXN0c0ZRc3NnQUJSeXN0c0ZVc3NnRUFSeXN0c0ZZc3NnRUJSeXN0c0Zjc3N3QUFBRU1yTGJCWUxMTUFBUUJES3kyd1dTeXpBUUFBUXlzdHNGb3Nzd0VCQUVNckxiQmJMTE1BQUFGREt5MndYQ3l6QUFFQlF5c3RzRjBzc3dFQUFVTXJMYkJlTExNQkFRRkRLeTJ3WHl5eUFBQkZLeTJ3WUN5eUFBRkZLeTJ3WVN5eUFRQkZLeTJ3WWl5eUFRRkZLeTJ3WXl5eUFBQklLeTJ3WkN5eUFBRklLeTJ3WlN5eUFRQklLeTJ3Wml5eUFRRklLeTJ3Wnl5ekFBQUFSQ3N0c0dnc3N3QUJBRVFyTGJCcExMTUJBQUJFS3kyd2FpeXpBUUVBUkNzdHNHc3Nzd0FBQVVRckxiQnNMTE1BQVFGRUt5MndiU3l6QVFBQlJDc3RzRzRzc3dFQkFVUXJMYkJ2TExFQVBDc3VzVEFCRkNzdHNIQXNzUUE4SzdCQUt5MndjU3l4QUR3cnNFRXJMYkJ5TExBQUZyRUFQQ3V3UWlzdHNITXNzUUU4SzdCQUt5MndkQ3l4QVR3cnNFRXJMYkIxTExBQUZyRUJQQ3V3UWlzdHNIWXNzUUE5S3k2eE1BRVVLeTJ3ZHl5eEFEMHJzRUFyTGJCNExMRUFQU3V3UVNzdHNIa3NzUUE5SzdCQ0t5MndlaXl4QVQwcnNFQXJMYkI3TExFQlBTdXdRU3N0c0h3c3NRRTlLN0JDS3kyd2ZTeXhBRDRyTHJFd0FSUXJMYkIrTExFQVBpdXdRQ3N0c0g4c3NRQStLN0JCS3kyd2dDeXhBRDRyc0VJckxiQ0JMTEVCUGl1d1FDc3RzSUlzc1FFK0s3QkJLeTJ3Z3l5eEFUNHJzRUlyTGJDRUxMRUFQeXN1c1RBQkZDc3RzSVVzc1FBL0s3QkFLeTJ3aGl5eEFEOHJzRUVyTGJDSExMRUFQeXV3UWlzdHNJZ3NzUUUvSzdCQUt5MndpU3l4QVQ4cnNFRXJMYkNLTExFQlB5dXdRaXN0c0lzc3Nnc0FBMFZRV0xBR0c3SUVBZ05GV0NNaEd5RlpXVUlyc0FobHNBTWtVSGl4QlFFVlJWZ3dXUzBBQUFBQVM3Z0F5RkpZc1FFQmpsbXdBYmtJQUFnQVkzQ3hBQWRDdFFBK0FDQUVBQ3F4QUFkQ1FBcEZCREVJSndNVkJ3UUtLckVBQjBKQUNrc0NPd1lzQVI0RkJBb3FzUUFMUXIwUmdBeUFDZ0FGZ0FBRUFBc3FzUUFQUXIwQVFBQkFBRUFBUUFBRUFBc3F1UUFEQUFCRXNTUUJpRkZZc0VDSVdMa0FBd0JrUkxFb0FZaFJXTGdJQUloWXVRQURBQUJFV1J1eEp3R0lVVmk2Q0lBQUFRUkFpR05VV0xrQUF3QUFSRmxaV1ZsWlFBcEhCRE1JS1FNWEJ3UU9LcmdCLzRXd0JJMnhBZ0JFc3dWa0JnQkVSQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBWUFCZ0FHQUFZQXJvQUFBSU9BQUQvVXdRNC9zZ0N1Z0FBQWc0QUFQOVRCRGoreUFCWkFGa0FTZ0JLLzV3RU9QN0kvNXdFT1A3SUFJMEFqUUJ3QUhBQ3JnQUFBdE1DRGdBQS8xTUVPUDdJQXJyLzlBTGJBaHIvOVA5S0JEait5QUJaQUZrQVNnQktBeElCc0FRNC9zZ0RIZ0dwQkRqK3lBQUFBQUFBRHdDNkFBTUFBUVFKQUFBQXFBQUFBQU1BQVFRSkFBRUFEZ0NvQUFNQUFRUUpBQUlBQ0FDMkFBTUFBUVFKQUFNQUxnQytBQU1BQVFRSkFBUUFHQURzQUFNQUFRUUpBQVVBUWdFRUFBTUFBUVFKQUFZQUdBRkdBQU1BQVFRSkFBY0FUZ0ZlQUFNQUFRUUpBQWdBR0FHc0FBTUFBUVFKQUFrQUdBSEVBQU1BQVFRSkFBb0JqZ0hjQUFNQUFRUUpBQXNBTGdOcUFBTUFBUVFKQUF3QU5nT1lBQU1BQVFRSkFBMEJJQVBPQUFNQUFRUUpBQTRBTkFUdUFFTUFid0J3QUhrQWNnQnBBR2NBYUFCMEFDQUFNZ0F3QURFQU9RQWdBRlFBYUFCbEFDQUFRUUJ5QUdNQWFBQnBBSFlBYndBZ0FGQUFjZ0J2QUdvQVpRQmpBSFFBSUFCQkFIVUFkQUJvQUc4QWNnQnpBQ0FBS0FCb0FIUUFkQUJ3QUhNQU9nQXZBQzhBWndCcEFIUUFhQUIxQUdJQUxnQmpBRzhBYlFBdkFFOEFiUUJ1QUdrQVlnQjFBSE1BTFFCVUFIa0FjQUJsQUM4QVFRQnlBR01BYUFCcEFIWUFid0FwQUVFQWNnQmpBR2dBYVFCMkFHOEFRZ0J2QUd3QVpBQXhBQzRBTUFBd0FEUUFPd0JQQUUwQVRnQkpBRHNBUVFCeUFHTUFhQUJwQUhZQWJ3QXRBRUlBYndCc0FHUUFRUUJ5QUdNQWFBQnBBSFlBYndBZ0FFSUFid0JzQUdRQVZnQmxBSElBY3dCcEFHOEFiZ0FnQURFQUxnQXdBREFBTkFBN0FDQUFkQUIwQUdZQVlRQjFBSFFBYndCb0FHa0FiZ0IwQUNBQUtBQjJBREVBTGdBNEFDa0FRUUJ5QUdNQWFBQnBBSFlBYndBdEFFSUFid0JzQUdRQVFRQnlBR01BYUFCcEFIWUFid0FnQUdrQWN3QWdBR0VBSUFCMEFISUFZUUJrQUdVQWJRQmhBSElBYXdBZ0FHOEFaZ0FnQUU4QWJRQnVBR2tBWWdCMUFITUFMUUJVQUhrQWNBQmxBQzRBVHdCdEFHNEFhUUJpQUhVQWN3QXRBRlFBZVFCd0FHVUFTQUJsQUdNQWRBQnZBSElBSUFCSEFHRUFkQUIwQUdrQVFRQnlBR01BYUFCcEFIWUFid0FnQUdrQWN3QWdBR0VBSUFCbkFISUFid0IwQUdVQWN3QnhBSFVBWlFBZ0FITUFZUUJ1QUhNQUlBQnpBR1VBY2dCcEFHWUFJQUIwQUhrQWNBQmxBR1lBWVFCakFHVUFJQUJtQUdFQWJRQnBBR3dBZVFBZ0FHWUFjZ0J2QUcwQUlBQlBBRzBBYmdCcEFHSUFkUUJ6QUMwQVZBQjVBSEFBWlFBdUFDQUFTUUIwQUNBQWR3QmhBSE1BSUFCdkFISUFhUUJuQUdrQWJnQmhBR3dBYkFCNUFDQUFaQUJsQUhNQWFRQm5BRzRBWlFCa0FDQUFaZ0J2QUhJQUlBQm9BR2tBWndCb0FHd0FhUUJuQUdnQWRBQnpBQ0FBWVFCdUFHUUFJQUJvQUdVQVlRQmtBR3dBYVFCdUFHVUFjd0F1QUNBQVZBQm9BR2tBY3dBZ0FHWUFZUUJ0QUdrQWJBQjVBQ0FBYVFCekFDQUFjZ0JsQUcwQWFRQnVBR2tBY3dCakFHVUFiZ0IwQUNBQWJ3Qm1BQ0FBYkFCaEFIUUFaUUFnQUc0QWFRQnVBR1VBZEFCbEFHVUFiZ0IwQUdnQUlBQmpBR1VBYmdCMEFIVUFjZ0I1QUNBQVFRQnRBR1VBY2dCcEFHTUFZUUJ1QUNBQWRBQjVBSEFBWlFCbUFHRUFZd0JsQUhNQUxnQm9BSFFBZEFCd0FEb0FMd0F2QUc4QWJRQnVBR2tBWWdCMUFITUFMUUIwQUhrQWNBQmxBQzRBWXdCdkFHMEFhQUIwQUhRQWNBQTZBQzhBTHdCM0FIY0Fkd0F1QUc4QWJRQnVBR2tBWWdCMUFITUFMUUIwQUhrQWNBQmxBQzRBWXdCdkFHMEFWQUJvQUdrQWN3QWdBRVlBYndCdUFIUUFJQUJUQUc4QVpnQjBBSGNBWVFCeUFHVUFJQUJwQUhNQUlBQnNBR2tBWXdCbEFHNEFjd0JsQUdRQUlBQjFBRzRBWkFCbEFISUFJQUIwQUdnQVpRQWdBRk1BU1FCTUFDQUFUd0J3QUdVQWJnQWdBRVlBYndCdUFIUUFJQUJNQUdrQVl3QmxBRzRBY3dCbEFDd0FJQUJXQUdVQWNnQnpBR2tBYndCdUFDQUFNUUF1QURFQUxnQWdBRlFBYUFCcEFITUFJQUJzQUdrQVl3QmxBRzRBY3dCbEFDQUFhUUJ6QUNBQVlRQjJBR0VBYVFCc0FHRUFZZ0JzQUdVQUlBQjNBR2tBZEFCb0FDQUFZUUFnQUVZQVFRQlJBQ0FBWVFCMEFEb0FJQUJvQUhRQWRBQndBRG9BTHdBdkFITUFZd0J5QUdrQWNBQjBBSE1BTGdCekFHa0FiQUF1QUc4QWNnQm5BQzhBVHdCR0FFd0FhQUIwQUhRQWNBQTZBQzhBTHdCekFHTUFjZ0JwQUhBQWRBQnpBQzRBY3dCcEFHd0FMZ0J2QUhJQVp3QXZBRThBUmdCTUFBSUFBQUFBQUFEL3RRQXlBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFETGdBQUFRSUFBZ0FEQUNRQXlRRURBUVFCQlFFR0FRY0JDQUVKQU1jQkNnRUxBUXdCRFFFT0FROEFZZ0VRQUswQkVRRVNBUk1CRkFCakFSVUFyZ0NRQVJZQUpRQW1BUDBBL3dCa0FSY0JHQUFuQVJrQkdnRHBBUnNCSEFFZEFSNEJId0FvQUdVQklBRWhBTWdCSWdFakFTUUJKUUVtQVNjQXlnRW9BU2tBeXdFcUFTc0JMQUV0QVM0QUtRRXZBQ29CTUFENEFURUJNZ0V6QVRRQUt3RTFBVFlCTndBc0FUZ0F6QUU1QVRvQXpRRTdBTTRBK2dFOEFNOEJQUUUrQVQ4QlFBRkJBQzBCUWdGREFDNEJSQUF2QVVVQlJnRkhBVWdCU1FGS0FPSUFNQUF4QVVzQlRBRk5BVTRCVHdGUUFWRUJVZ0JtQURJQTBBRlRBVlFBMFFGVkFWWUJWd0ZZQVZrQldnQm5BVnNCWEFGZEFOTUJYZ0ZmQVdBQllRRmlBV01CWkFGbEFXWUJad0ZvQUpFQmFRQ3ZBV29Bc0FBekFPMEFOQUExQVdzQmJBRnRBVzRCYndGd0FEWUJjUUZ5QU9RQSt3RnpBWFFCZFFGMkFYY0FOd0Y0QVhrQmVnRjdBWHdBT0FEVUFYMEJmZ0RWQVg4QWFBR0FBWUVCZ2dHREFZUUExZ0dGQVlZQmh3R0lBWWtCaWdHTEFZd0JqUUdPQVk4QmtBR1JBRGtBT2dHU0FaTUJsQUdWQURzQVBBRHJBWllBdXdHWEFaZ0JtUUdhQVpzQVBRR2NBT1lCblFHZUFaOEJvQUdoQWFJQm93R2tBYVVCcGdHbkFhZ0JxUUdxQUVRQWFRR3JBYXdCclFHdUFhOEJzQUd4QUdzQnNnR3pBYlFCdFFHMkFiY0FiQUc0QUdvQnVRRzZBYnNCdkFCdUFiMEFiUUNnQWI0QVJRQkdBUDRCQUFCdkFiOEJ3QUJIQU9vQndRRUJBY0lCd3dIRUFFZ0FjQUhGQWNZQWNnSEhBY2dCeVFIS0Fjc0J6QUJ6QWMwQnpnQnhBYzhCMEFIUkFkSUIwd0hVQUVrQVNnSFZBUGtCMWdIWEFkZ0IyUUJMQWRvQjJ3SGNBRXdBMXdCMEFkMEIzZ0IyQWQ4QWR3SGdBZUVBZFFIaUFlTUI1QUhsQWVZQjV3Qk5BZWdCNlFIcUFFNEI2d0hzQUU4QjdRSHVBZThCOEFIeEFPTUFVQUJSQWZJQjh3SDBBZlVCOWdIM0FmZ0IrUUI0QUZJQWVRSDZBZnNBZXdIOEFmMEIvZ0gvQWdBQ0FRQjhBZ0lDQXdJRUFIb0NCUUlHQWdjQ0NBSUpBZ29DQ3dJTUFnMENEZ0lQQUtFQ0VBQjlBaEVBc1FCVEFPNEFWQUJWQWhJQ0V3SVVBaFVDRmdJWEFGWUNHQUlaQU9VQS9BSWFBaHNDSEFDSkFoMEFWd0llQWg4Q0lBSWhBaUlBV0FCK0FpTUNKQUNBQWlVQWdRSW1BaWNDS0FJcEFpb0Fmd0lyQWl3Q0xRSXVBaThDTUFJeEFqSUNNd0kwQWpVQ05nSTNBRmtBV2dJNEFqa0NPZ0k3QUZzQVhBRHNBandBdWdJOUFqNENQd0pBQWtFQVhRSkNBT2NDUXdKRUFrVUNSZ0pIQWtnQ1NRSktBa3NDVEFKTkFrNENUd0pRQWxFQ1VnSlRBTUFBd1FDZEFKNENWQUpWQWxZQ1Z3Q2JBbGdBRXdBVUFCVUFGZ0FYQUJnQUdRQWFBQnNBSEFKWkFsb0NXd0pjQWwwQ1hnSmZBbUFDWVFKaUFtTUNaQUpsQW1ZQ1p3Sm9BbWtDYWdKckFtd0NiUUp1QW04Q2NBSnhBbklDY3dKMEFuVUNkZ0ozQW5nQ2VRSjZBbnNDZkFKOUFuNENmd0tBQW9FQ2dnS0RBb1FDaFFLR0FvY0NpQUtKQW9vQ2l3S01BbzBDamdLUEFwQUNrUUtTQXBNQ2xBS1ZBcFlDbHdLWUFwa0NtZ0tiQXB3Q25RS2VBcDhDb0FLaEFxSUNvd0trQXFVQ3BnS25BcWdDcVFLcUFxc0NyQUt0QUx3QTlBS3VBcThBOVFEMkFyQUNzUUt5QXJNQUVRQVBBQjBBSGdDckFBUUFvd0FpQUtJQXd3Q0hBQTBDdEFBR0FCSUFQd0sxQXJZQ3R3SzRBcmtBQ3dBTUFGNEFZQUErQUVBQUVBSzZBTElBc3dLN0Fyd0N2UUJDQXI0Q3Z3TEFBc0VDd2dMREFNUUF4UUMwQUxVQXRnQzNBc1FBcVFDcUFMNEF2d0FGQUFvQ3hRTEdBc2NDeUFMSkFzb0N5d0xNQXMwQ3pnQ0VBczhBdlFBSEF0QUMwUUNtQVBjQzBnTFRBdFFDMVFMV0F0Y0MyQUxaQXRvQzJ3Q0ZBdHdBbGdMZEF0NEMzd0xnQXVFQzRnQU9BTzhBOEFDNEFDQUFqd0FoQUI4QWxRQ1VBSk1BcHdCaEFLUUFRUUNTQXVNQzVBQ2NBdVVDNWdDYUFKa0FwUUNZQXVjQzZBQUlBTVlDNlFMcUF1c0M3QUx0QXU0Qzd3THdBTGtBSXdBSkFJZ0FoZ0NMQUlvQzhRQ01BdklBZ3dMekF2UUFYd0RvQUlJQzlRRENBdllDOXdMNEF2a0MrZ0w3QXZ3Qy9RTCtBdjhEQUFNQkF3SURBd01FQXdVREJnTUhBd2dEQ1FNS0F3c0REQU1OQXc0RER3TVFBeEVERWdNVEF4UURGUU1XQXhjREdBTVpBeG9BalFEYkFPRUEzZ0RZQUk0QTNBQkRBTjhBMmdEZ0FOMEEyUU1iQXh3REhRTWVBeDhESUFNaEF5SURJd01rQXlVREpnTW5BeWdES1FNcUF5c0RMQU10QXk0REx3TXdBekVETWdNekF6UUROUU0yQkU1VlRFd0dRV0p5WlhabEIzVnVhVEZGUVVVSGRXNXBNVVZDTmdkMWJta3hSVUl3QjNWdWFURkZRaklIZFc1cE1VVkNOQWQxYm1rd01VTkVCM1Z1YVRGRlFUUUhkVzVwTVVWQlF3ZDFibWt4UlVFMkIzVnVhVEZGUVRnSGRXNXBNVVZCUVFkMWJta3dNakF3QjNWdWFURkZRVEFIZFc1cE1VVkJNZ2QxYm1rd01qQXlCMEZ0WVdOeWIyNEhRVzluYjI1bGF3cEJjbWx1WjJGamRYUmxCMEZGWVdOMWRHVUxRMk5wY21OMWJXWnNaWGdLUTJSdmRHRmpZMlZ1ZEFkMWJta3dNVVl4QjNWdWFUQXhRelFHUkdOaGNtOXVCa1JqY205aGRBZDFibWt4UlRCREIzVnVhVEF4UmpJSGRXNXBNREZETlFaRlluSmxkbVVHUldOaGNtOXVCM1Z1YVRGRlFrVUhkVzVwTVVWRE5nZDFibWt4UlVNd0IzVnVhVEZGUXpJSGRXNXBNVVZETkFkMWJta3dNakEwQ2tWa2IzUmhZMk5sYm5RSGRXNXBNVVZDT0FkMWJta3hSVUpCQjNWdWFUQXlNRFlIUlcxaFkzSnZiZ2RGYjJkdmJtVnJCM1Z1YVRGRlFrTUhkVzVwTURFNU1RZDFibWt3TVVZMEJrZGpZWEp2Ymd0SFkybHlZM1Z0Wm14bGVBZDFibWt3TVRJeUNrZGtiM1JoWTJObGJuUUVTR0poY2d0SVkybHlZM1Z0Wm14bGVBZDFibWt4UlRJMEFrbEtCa2xpY21WMlpRZDFibWt3TVVOR0IzVnVhVEF5TURnSGRXNXBNVVZEUVFkMWJta3hSVU00QjNWdWFUQXlNRUVIU1cxaFkzSnZiZ2RKYjJkdmJtVnJCa2wwYVd4a1pRdDFibWt3TUVFME1ETXdNUXRLWTJseVkzVnRabXhsZUFkMWJta3dNVE0yQjNWdWFUQXhRemNHVEdGamRYUmxCa3hqWVhKdmJnZDFibWt3TVROQ0JFeGtiM1FIZFc1cE1ERkRPQWQxYm1rd01VTkJCazVoWTNWMFpRWk9ZMkZ5YjI0SGRXNXBNREUwTlFkMWJta3hSVFEwQTBWdVp3ZDFibWt3TVRsRUIzVnVhVEF4UTBJR1QySnlaWFpsQjNWdWFUQXhSREVIZFc1cE1VVkVNQWQxYm1reFJVUTRCM1Z1YVRGRlJESUhkVzVwTVVWRU5BZDFibWt4UlVRMkIzVnVhVEF5TUVNSGRXNXBNREl5UVFkMWJta3dNak13QjNWdWFURkZRME1IZFc1cE1VVkRSUVZQYUc5eWJnZDFibWt4UlVSQkIzVnVhVEZGUlRJSGRXNXBNVVZFUXdkMWJta3hSVVJGQjNWdWFURkZSVEFOVDJoMWJtZGhjblZ0YkdGMWRBZDFibWt3TWpCRkIwOXRZV055YjI0SGRXNXBNREZGUVF0UGMyeGhjMmhoWTNWMFpRZDFibWt3TWpKREJsSmhZM1YwWlFaU1kyRnliMjRIZFc1cE1ERTFOZ2QxYm1rd01qRXdCM1Z1YVRGRk5VRUhkVzVwTURJeE1nWlRZV04xZEdVSGRXNXBRVGM0UWd0VFkybHlZM1Z0Wm14bGVBZDFibWt3TWpFNEIzVnVhVEZGTmpJSGRXNXBNVVU1UlFkMWJta3dNVGhHQkZSaVlYSUdWR05oY205dUIzVnVhVEF4TmpJSGRXNXBNREl4UVFkMWJta3hSVFpEQmxWaWNtVjJaUWQxYm1rd01VUXpCM1Z1YVRBeU1UUUhkVzVwTURGRU53ZDFibWt3TVVRNUIzVnVhVEF4UkVJSGRXNXBNREZFTlFkMWJta3hSVVUwQjNWdWFURkZSVFlGVldodmNtNEhkVzVwTVVWRk9BZDFibWt4UlVZd0IzVnVhVEZGUlVFSGRXNXBNVVZGUXdkMWJta3hSVVZGRFZWb2RXNW5ZWEoxYld4aGRYUUhkVzVwTURJeE5nZFZiV0ZqY205dUIxVnZaMjl1WldzRlZYSnBibWNHVlhScGJHUmxCbGRoWTNWMFpRdFhZMmx5WTNWdFpteGxlQWxYWkdsbGNtVnphWE1HVjJkeVlYWmxDMWxqYVhKamRXMW1iR1Y0QjNWdWFURkZSalFHV1dkeVlYWmxCM1Z1YVRGRlJqWUhkVzVwTURJek1nZDFibWt4UlVZNEJscGhZM1YwWlFwYVpHOTBZV05qWlc1MEIzVnVhVEZGT1RJSldTNXNiMk5zUjFWQkRsbGhZM1YwWlM1c2IyTnNSMVZCRTFsamFYSmpkVzFtYkdWNExteHZZMnhIVlVFUldXUnBaWEpsYzJsekxteHZZMnhIVlVFT1dXZHlZWFpsTG14dlkyeEhWVUVQZFc1cE1ESXpNaTVzYjJOc1IxVkJEM1Z1YVRGRlJqZ3ViRzlqYkVkVlFRNURZV04xZEdVdWJHOWpiRkJNU3c1T1lXTjFkR1V1Ykc5amJGQk1TdzVQWVdOMWRHVXViRzlqYkZCTVN3NVRZV04xZEdVdWJHOWpiRkJNU3c1YVlXTjFkR1V1Ykc5amJGQk1Td1poWW5KbGRtVUhkVzVwTVVWQlJnZDFibWt4UlVJM0IzVnVhVEZGUWpFSGRXNXBNVVZDTXdkMWJta3hSVUkxQjNWdWFUQXhRMFVIZFc1cE1VVkJOUWQxYm1reFJVRkVCM1Z1YVRGRlFUY0hkVzVwTVVWQk9RZDFibWt4UlVGQ0IzVnVhVEF5TURFSGRXNXBNVVZCTVFkMWJta3hSVUV6QjNWdWFUQXlNRE1IWVcxaFkzSnZiZ2RoYjJkdmJtVnJDbUZ5YVc1bllXTjFkR1VIWVdWaFkzVjBaUXRqWTJseVkzVnRabXhsZUFwalpHOTBZV05qWlc1MEJtUmpZWEp2YmdkMWJta3hSVEJFQjNWdWFUQXhSak1IZFc1cE1ERkROZ1psWW5KbGRtVUdaV05oY205dUIzVnVhVEZGUWtZSGRXNXBNVVZETndkMWJta3hSVU14QjNWdWFURkZRek1IZFc1cE1VVkROUWQxYm1rd01qQTFDbVZrYjNSaFkyTmxiblFIZFc1cE1VVkNPUWQxYm1reFJVSkNCM1Z1YVRBeU1EY0haVzFoWTNKdmJnZGxiMmR2Ym1WckIzVnVhVEZGUWtRSGRXNXBNREkxT1FkMWJta3dNVVkxQm1kallYSnZiZ3RuWTJseVkzVnRabXhsZUFkMWJta3dNVEl6Q21ka2IzUmhZMk5sYm5RRWFHSmhjZ3RvWTJseVkzVnRabXhsZUFkMWJta3hSVEkxQm1saWNtVjJaUWQxYm1rd01VUXdCM1Z1YVRBeU1Ea0phUzVzYjJOc1ZGSkxCM1Z1YVRGRlEwSUhkVzVwTVVWRE9RZDFibWt3TWpCQ0FtbHFCMmx0WVdOeWIyNEhhVzluYjI1bGF3WnBkR2xzWkdVSGRXNXBNREl6Tnd0MWJta3dNRFpCTURNd01RdHFZMmx5WTNWdFpteGxlQWQxYm1rd01UTTNER3RuY21WbGJteGhibVJwWXdac1lXTjFkR1VHYkdOaGNtOXVCM1Z1YVRBeE0wTUViR1J2ZEFkMWJta3dNVU01Qm01aFkzVjBaUXR1WVhCdmMzUnliM0JvWlFadVkyRnliMjRIZFc1cE1ERTBOZ2QxYm1reFJUUTFBMlZ1WndkMWJta3dNamN5QjNWdWFUQXhRME1HYjJKeVpYWmxCM1Z1YVRBeFJESUhkVzVwTVVWRU1RZDFibWt4UlVRNUIzVnVhVEZGUkRNSGRXNXBNVVZFTlFkMWJta3hSVVEzQjNWdWFUQXlNRVFIZFc1cE1ESXlRZ2QxYm1rd01qTXhCM1Z1YVRGRlEwUUhkVzVwTVVWRFJnVnZhRzl5YmdkMWJta3hSVVJDQjNWdWFURkZSVE1IZFc1cE1VVkVSQWQxYm1reFJVUkdCM1Z1YVRGRlJURU5iMmgxYm1kaGNuVnRiR0YxZEFkMWJta3dNakJHQjI5dFlXTnliMjRIZFc1cE1ERkZRZ3R2YzJ4aGMyaGhZM1YwWlFkMWJta3dNakpFQm5KaFkzVjBaUVp5WTJGeWIyNEhkVzVwTURFMU53ZDFibWt3TWpFeEIzVnVhVEZGTlVJSGRXNXBNREl4TXdaellXTjFkR1VIZFc1cFFUYzRRd3R6WTJseVkzVnRabXhsZUFkMWJta3dNakU1QjNWdWFURkZOak1GYkc5dVozTUVkR0poY2daMFkyRnliMjRIZFc1cE1ERTJNd2QxYm1rd01qRkNCM1Z1YVRGRk5rUUdkV0p5WlhabEIzVnVhVEF4UkRRSGRXNXBNREl4TlFkMWJta3dNVVE0QjNWdWFUQXhSRUVIZFc1cE1ERkVRd2QxYm1rd01VUTJCM1Z1YVRGRlJUVUhkVzVwTVVWRk53VjFhRzl5YmdkMWJta3hSVVU1QjNWdWFURkZSakVIZFc1cE1VVkZRZ2QxYm1reFJVVkVCM1Z1YVRGRlJVWU5kV2gxYm1kaGNuVnRiR0YxZEFkMWJta3dNakUzQjNWdFlXTnliMjRIZFc5bmIyNWxhd1YxY21sdVp3WjFkR2xzWkdVR2QyRmpkWFJsQzNkamFYSmpkVzFtYkdWNENYZGthV1Z5WlhOcGN3WjNaM0poZG1VTGVXTnBjbU4xYldac1pYZ0hkVzVwTVVWR05RWjVaM0poZG1VSGRXNXBNVVZHTndkMWJta3dNak16QjNWdWFURkZSamtHZW1GamRYUmxDbnBrYjNSaFkyTmxiblFIZFc1cE1VVTVNd2w1TG14dlkyeEhWVUVPZVdGamRYUmxMbXh2WTJ4SFZVRVRlV05wY21OMWJXWnNaWGd1Ykc5amJFZFZRUkY1WkdsbGNtVnphWE11Ykc5amJFZFZRUTU1WjNKaGRtVXViRzlqYkVkVlFROTFibWt3TWpNekxteHZZMnhIVlVFUGRXNXBNVVZHT1M1c2IyTnNSMVZCRG1OaFkzVjBaUzVzYjJOc1VFeExEbTVoWTNWMFpTNXNiMk5zVUV4TERtOWhZM1YwWlM1c2IyTnNVRXhMRG5OaFkzVjBaUzVzYjJOc1VFeExEbnBoWTNWMFpTNXNiMk5zVUV4TEEyWmZaZ1ZtWDJaZmFRVm1YMlpmYkFkMWJta3lNRGRHQjNWdWFUQXpPVFFIZFc1cE1ETkJPUWQxYm1rd00wSkRCM1Z1YVRJd09Ua0hlbVZ5Ynk1c1pnWnZibVV1YkdZR2RIZHZMbXhtQ0hSb2NtVmxMbXhtQjJadmRYSXViR1lIWm1sMlpTNXNaZ1p6YVhndWJHWUljMlYyWlc0dWJHWUlaV2xuYUhRdWJHWUhibWx1WlM1c1pneDZaWEp2TG14bUxucGxjbThJZW1WeWJ5NXZjMllIYjI1bExtOXpaZ2QwZDI4dWIzTm1DWFJvY21WbExtOXpaZ2htYjNWeUxtOXpaZ2htYVhabExtOXpaZ2R6YVhndWIzTm1DWE5sZG1WdUxtOXpaZ2xsYVdkb2RDNXZjMllJYm1sdVpTNXZjMllOZW1WeWJ5NXZjMll1ZW1WeWJ3ZDZaWEp2TG5SbUJtOXVaUzUwWmdaMGQyOHVkR1lJZEdoeVpXVXVkR1lIWm05MWNpNTBaZ2RtYVhabExuUm1Cbk5wZUM1MFpnaHpaWFpsYmk1MFpnaGxhV2RvZEM1MFpnZHVhVzVsTG5SbURIcGxjbTh1ZEdZdWVtVnlid2w2WlhKdkxuUnZjMllJYjI1bExuUnZjMllJZEhkdkxuUnZjMllLZEdoeVpXVXVkRzl6WmdsbWIzVnlMblJ2YzJZSlptbDJaUzUwYjNObUNITnBlQzUwYjNObUNuTmxkbVZ1TG5SdmMyWUtaV2xuYUhRdWRHOXpaZ2x1YVc1bExuUnZjMllPZW1WeWJ5NTBiM05tTG5wbGNtOEplbVZ5Ynk1NlpYSnZCM1Z1YVRJd09EQUhkVzVwTWpBNE1RZDFibWt5TURneUIzVnVhVEl3T0RNSGRXNXBNakE0TkFkMWJta3lNRGcxQjNWdWFUSXdPRFlIZFc1cE1qQTROd2QxYm1reU1EZzRCM1Z1YVRJd09Ea0plbVZ5Ynk1a2JtOXRDRzl1WlM1a2JtOXRDSFIzYnk1a2JtOXRDblJvY21WbExtUnViMjBKWm05MWNpNWtibTl0Q1dacGRtVXVaRzV2YlFoemFYZ3VaRzV2YlFwelpYWmxiaTVrYm05dENtVnBaMmgwTG1SdWIyMEpibWx1WlM1a2JtOXRDWHBsY204dWJuVnRjZ2h2Ym1VdWJuVnRjZ2gwZDI4dWJuVnRjZ3AwYUhKbFpTNXVkVzF5Q1dadmRYSXViblZ0Y2dsbWFYWmxMbTUxYlhJSWMybDRMbTUxYlhJS2MyVjJaVzR1Ym5WdGNncGxhV2RvZEM1dWRXMXlDVzVwYm1VdWJuVnRjZ2QxYm1reU1EY3dCM1Z1YVRBd1Fqa0hkVzVwTURCQ01nZDFibWt3TUVJekIzVnVhVEl3TnpRSGRXNXBNakEzTlFkMWJta3lNRGMyQjNWdWFUSXdOemNIZFc1cE1qQTNPQWQxYm1reU1EYzVCM1Z1YVRJeE5UTUhkVzVwTWpFMU5BbHZibVZsYVdkb2RHZ01kR2h5WldWbGFXZG9kR2h6QzJacGRtVmxhV2RvZEdoekRITmxkbVZ1WldsbmFIUm9jd2xsZUdOc1lXMWtZbXdIZFc1cE1qQXpSUTlsZUdOc1lXMWtiM2R1TG1OaGMyVVJjWFZsYzNScGIyNWtiM2R1TG1OaGMyVWJjR1Z5YVc5a1kyVnVkR1Z5WldRdWJHOWpiRU5CVkM1allYTmxGbkJsY21sdlpHTmxiblJsY21Wa0xteHZZMnhEUVZRSGRXNXBNREJCUkFkMWJta3lNREUxQjNWdWFUSXdNVEFIZFc1cE1qQXhNUTExYm1SbGNuTmpiM0psWkdKc0MyaDVjR2hsYmk1allYTmxESFZ1YVRBd1FVUXVZMkZ6WlF0bGJtUmhjMmd1WTJGelpRdGxiV1JoYzJndVkyRnpaUXgxYm1reU1ERXhMbU5oYzJVTmNYVnZkR1Z5WlhabGNuTmxaQWQxYm1reU4wVTRCM1Z1YVRJM1JUa0hkVzVwTWpBd013ZDFibWt5TURBeUIzVnVhVEl3TURVSGRXNXBNREJCTUFkMWJta3lNREE1QjNWdWFUSXdNRFFIZFc1cFJrVkdSZ2QxYm1reU1FSTFEV052Ykc5dWJXOXVaWFJoY25rRVpHOXVad1JGZFhKdkIzVnVhVEl3UWpJSGRXNXBNakJCUkFSc2FYSmhCM1Z1YVRJd1FrRUhkVzVwTWpCQ1F3ZDFibWt5TUVFMkJuQmxjMlYwWVFkMWJta3lNRUl4QjNWdWFUSXdRa1FIZFc1cE1qQkNPUWQxYm1reU1FRTVCM1Z1YVRJeU1Ua0hkVzVwTWpBMU1nZDFibWt5TWpFMUMyVnhkV2wyWVd4bGJtTmxDbWx1ZEdWbmNtRnNZblFLYVc1MFpXZHlZV3gwY0FobGJYQjBlWE5sZEF4cGJuUmxjbk5sWTNScGIyNEhkVzVwTWpFeU5nZDFibWt5TWpBMkIzVnVhVEF3UWpVS2IzSjBhRzluYjI1aGJBMXlaWFpzYjJkcFkyRnNibTkwQjJGeWNtOTNkWEFLWVhKeWIzZHlhV2RvZEFsaGNuSnZkMlJ2ZDI0SllYSnliM2RzWldaMENXRnljbTkzWW05MGFBbGhjbkp2ZDNWd1pHNE1ZWEp5YjNkMWNHUnVZbk5sQjNWdWFUSXhNVGNIZFc1cE1qRXdOUVp0YVc1MWRHVUdjMlZqYjI1a0IzVnVhVEl4TVRNSGRXNXBNakV4TmdsbGMzUnBiV0YwWldRRmFHOTFjMlVOWVcxd1pYSnpZVzVrTG1Gc2RBZDFibWt3TWtKREIzVnVhVEF5UWtFSGRXNXBNREpDT1FkMWJta3dNa001QjNWdWFUQXpNRGdIZFc1cE1ETXdOd2xuY21GMlpXTnZiV0lKWVdOMWRHVmpiMjFpQjNWdWFUQXpNRUlMZFc1cE1ETXdReTVoYkhRSGRXNXBNRE13TWdkMWJta3dNekJEQjNWdWFUQXpNRFlIZFc1cE1ETXdRUWwwYVd4a1pXTnZiV0lIZFc1cE1ETXdOQTFvYjI5cllXSnZkbVZqYjIxaUIzVnVhVEF6TUVZSGRXNXBNRE14TVFkMWJta3dNekV5QjNWdWFUQXpNVE1IZFc1cE1ETXhRZ3hrYjNSaVpXeHZkMk52YldJSGRXNXBNRE15TkFkMWJta3dNekkyQjNWdWFUQXpNamNIZFc1cE1ETXlPQWQxYm1rd016SkZCM1Z1YVRBek16RUhkVzVwTURNek5RZDFibWt3TXpNMkIzVnVhVEF6TXpjSGRXNXBNRE16T0F4MWJta3dNekE0TG1OaGMyVU1kVzVwTURNd055NWpZWE5sRG1keVlYWmxZMjl0WWk1allYTmxEbUZqZFhSbFkyOXRZaTVqWVhObERIVnVhVEF6TUVJdVkyRnpaUXgxYm1rd016QXlMbU5oYzJVTWRXNXBNRE13UXk1allYTmxESFZ1YVRBek1EWXVZMkZ6WlF4MWJta3dNekJCTG1OaGMyVU9kR2xzWkdWamIyMWlMbU5oYzJVTWRXNXBNRE13TkM1allYTmxFbWh2YjJ0aFltOTJaV052YldJdVkyRnpaUXgxYm1rd016QkdMbU5oYzJVTWRXNXBNRE14TVM1allYTmxESFZ1YVRBek1USXVZMkZ6WlF4MWJta3dNekZDTG1OaGMyVVJaRzkwWW1Wc2IzZGpiMjFpTG1OaGMyVU1kVzVwTURNeU5DNWpZWE5sREhWdWFUQXpNall1WTJGelpReDFibWt3TXpJM0xtTmhjMlVNZFc1cE1ETXlPQzVqWVhObERIVnVhVEF6TWtVdVkyRnpaUXgxYm1rd016TXhMbU5oYzJVTllXTjFkR1V1Ykc5amJGQk1Td2QxYm1rd01EQXdCM1Z1YVVVd1JrWUhkVzVwUlVaR1JBZDFibWxHTURBd0FBQUJBQUgvL3dBUEFBRUFBQUFNQUFBQUFBREVBQUlBSGdBRUFCOEFBUUFoQUNrQUFRQXJBQ3NBQVFBdEFFTUFBUUJHQUd3QUFRQnZBSFFBQVFCM0FKY0FBUUNjQUtRQUFRQ21BS29BQVFDdEFLMEFBUUN2QU13QUFRRE9BTklBQVFEVUFRa0FBUUVMQVJFQUFRRVRBU3dBQVFFdUFVa0FBUUZMQVU4QUFRRlJBVmNBQVFGWkFWNEFBUUZoQVlFQUFRR0dBWTRBQVFHUUFaUUFBUUdYQVpjQUFRR1pBYllBQVFHNEFid0FBUUcrQWRjQUFRSFlBZHdBQWdMb0F1d0FBd0x1QXdRQUF3TVNBeWdBQXdBQ0FBa0M2QUxzQUFJQzdnTDRBQUlDK1FMNUFBTUMrZ0w5QUFFQy93TUFBQUVERWdNZ0FBSURJUU1oQUFNRElnTWxBQUVESndNb0FBRUFBQUFCQUFBQUNnQThBSTRBQWtSR1RGUUFEbXhoZEc0QUlBQUVBQUFBQVAvL0FBUUFBQUFDQUFRQUJnQUVBQUFBQVAvL0FBUUFBUUFEQUFVQUJ3QUlZM0J6Y0FBeVkzQnpjQUF5YTJWeWJnQTZhMlZ5YmdBNmJXRnlhd0JDYldGeWF3QkNiV3R0YXdCSWJXdHRhd0JJQUFBQUFnQUFBQUVBQUFBQ0FBSUFBd0FBQUFFQUJBQUFBQU1BQlFBR0FBY0FDQUFTQUJJQU5BQmdDSUFpbWlOd0pXQUFBUUFBQUFFQUNBQUJBQW9BQlFBRkFBb0FBZ0FDQUFRQTdRQUFBZUFCNFFEcUFBSUFDQUFCQUFnQUFnZm9BQVFBQUFna0FCUUFBUUFDQUFEL3lRQUNBQUlBQXdBREFBRUNpUUtKQUFFQUFnQUlBQVVBRUFFR0JkSUhzQWZpQUFFQWVnQUVBQUFBT0FEc0FPd0E3QURzQU93QTdBRHNBT3dBN0FEc0FPd0E3QURzQU93QTdBRHNBT3dBN0FEc0FPd0E3QURzQU93QTdBRHNBT3dBeWdES0FNb0F5Z0RLQU5BQTBBRFFBTkFBMEFEUUFPSUE0Z0RpQU9JQTRnRGlBT0lBNGdEaUFNQUF3QURBQU1BQXdBREFBTW9BMEFEaUFPd0FBZ0FMQUFRQUhRQUFBR1lBWmdBYUFHZ0FhQUFiQUdvQWF3QWNBRzBBYlFBZUFNMEEwZ0FmQU5RQTNBQWxBYmNCdkFBdUFwa0NtUUEwQXFFQ29nQTFBcjBDdlFBM0FBSUNUdi9iQWsvLzJ3QUJBTTcveVFBRUFBVC95UUVZLys0QlkvL3VBWDcvdGdBQ0FXUC90Z0dGLzdZQUFnRE8vOGtCdVAvdUFBSUNMQUFFQUFBQ25BTVlBQW9BR3dBQS83Yi90ditrLzhuLzIvL2IvOXNBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUQveWYvWS81SC96ditSQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBLytJQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQS83Yi90ditrLzhuLzdnQUEvOXNBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFELzdnQUFBQUQvdGdBQS8zOEFBUDkvQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRC83di9iQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFQKzIvN2IvdHYrMi81SC90ditSQUFELzd2KzIvNUgveWYvdS84bi90ditSLzdiL3lmL0UvOFFBQUFBQUFBQUFBQUFBQUFBQUFBQUEvOXYvdHYvSi82VC95ZitrQUFBQUFQKzIvOG4veWYvdS84a0FBUC9KLzl2L3lRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVAvMkFBRC83QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFELzd2L0pBQUQvcFAvSi81SC95ZitSLzdBQUFBQUEvN2IveWYvYkFBRC9zUCsyLzhuL3lRQUFBQUQvN0FBQ0FCSUFCQUFkQUFBQVJBQkZBQm9BWkFCbUFCd0FhQUJvQUI4QWFnQnJBQ0FBYlFCdEFDSUFtUUNhQUNNQW5BQ2dBQ1VBb2dDaUFDb0FyUUN1QUNzQXNBQ3hBQzBBelFEY0FDOENsUUtWQUQ4Q2x3S1hBRUFDbVFLWkFFRUNuUUtlQUVJQ29RS2lBRVFDdlFLOUFFWUFBZ0FVQUVRQVJRQUJBR1FBWlFBQ0FHWUFaZ0FEQUdnQWFBQURBR29BYXdBREFHMEFiUUFEQUprQW1nQUVBSndBb0FBRkFLSUFvZ0FGQUswQXJnQUdBTEFBc1FBR0FNMEEwZ0FIQU5NQTB3QUlBTlFBM0FBSkFwVUNsUUFCQXBjQ2x3QUNBcGtDbVFBREFwMENuZ0FFQXFFQ29RQUhBcUlDb2dBSkFBSUFTQUFEQUFNQUJRQUVBQjBBQ0FCR0FFWUFEZ0JJQUV3QURnQjVBSmdBRGdDYkFKc0FEZ0NzQUt3QURnQ3RBSzRBQVFDd0FMRUFBUUROQU5JQUFnRFVBTndBQXdEcEFPa0FEZ0RyQU9zQURnRHVBUWtBQ1FFTEFRc0FDd0VNQVJBQUR3RVJBUlFBQ3dFWEFTd0FDd0V1QVM0QURRRXdBVFFBRFFFNUFVa0FFZ0ZNQVV3QUVnRlFBVkFBRXdGWUFWMEFFd0ZmQVY4QUV3RmhBV0lBRXdGakFZSUFDd0dEQVlNQUV3R0ZBWVVBQ3dHR0FZb0FFd0dNQVl3QUV3R05BWTRBRkFHUUFaTUFGQUdYQVpzQUdnR2RBYllBRmdHM0Fid0FCZ0c5QWIwQUdBRytBY1lBQndISEFjb0FHUUhUQWRNQUN3SFVBZFFBRXdIVkFkVUFDd0hXQWRZQUZBSFhBZGNBR1FKT0FrNEFEQUpQQWs4QUNnSlFBbEFBRUFKUkFsRUFGUUpTQWxJQURBSlhBbGdBRVFKaUFtSUFEQUpwQW1rQUVRSnFBbW9BRndKckFtd0FFUUp1QW04QUVRSndBbkFBREFKeUFuSUFFUUozQW5nQURBSjZBbm9BQkFKOEFud0FCQUtKQW9rQUJRS05BbzBBRGdLT0FvNEFDd0tQQW84QURnS1NBcElBQ3dLVEFwTUFEZ0tXQXBZQURnS2hBcUVBQWdLaUFxSUFBd0tqQXFNQUVRSzlBcjBBQ0FMVEF0UUFEZ0FDQUt3QUJBQUFBT1lCR2dBR0FBMEFBQUE4QUZvQVVBQkxBQW9BV2dBeUFGQUFQQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQklBQUFBQUFBQUFBQUFBQUFBQVdnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQWwvOG4veVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRC90disyQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFQKzIvN1lBQVFBYkFSTUJMUUZUQVZVQmhnR0hBWWdCaVFHS0FZd0JsZ0czQWJnQnVRRzZBYnNCdkFHK0FiOEJ3QUhCQWNJQnd3SEVBY1VCeGdIWUFBSUFDQUV0QVMwQUFRRlZBVlVBQWdHR0FZb0FBd0dNQVl3QUF3R1dBWllBQVFHM0Fid0FCQUcrQWNZQUJRSFlBZGdBQVFBQ0FDQUFSUUJGQUFNQkNnRUtBQVFCTFFFdEFBRUJOUUUxQUFRQk9RRkpBQUlCU2dGTEFBTUJUQUZNQUFJQlRRRk5BQU1CVGdGUEFBUUJVUUZTQUFRQlZBRlVBQVFCVndGWEFBUUJZQUZnQUFNQmxRR1dBQUVCbHdHYkFBa0IyQUhjQUFFQ1RnSk9BQXdDVHdKUEFBc0NVZ0pTQUF3Q1ZRSlZBQWNDWWdKaUFBd0NZd0pqQUFVQ1pBSmtBQVlDWlFKbEFBVUNaZ0ptQUFZQ1p3Sm5BQVVDYUFKb0FBWUNjQUp3QUF3Q2R3SjRBQXdDZWdKNkFBb0NmQUo4QUFvQ2dnS0RBQWdBQWdBVUFBUUFBQUJRQUJ3QUFRQUNBQUQvMndBQkFBSUNlZ0o4QUFJQUF3R05BWTRBQVFHUUFaTUFBUUhXQWRZQUFRQUNBQllBQkFBQUFCNEFJZ0FCQUFNQUFQL2IvKzRBQVFBQ0FBTUNpUUFDQUFBQUFnQUVBQVFBSFFBQkFOUUEzQUFDQXFJQ29nQUNBcjBDdlFBQkFBUUFBQUFCQUFnQUFRQU1BQ0lBQlFEQ0FhNEFBZ0FEQXVnQzdBQUFBdTREQkFBRkF4SURLQUFjQUFJQUdnQUVBQjhBQUFBaEFDa0FIQUFyQUNzQUpRQXRBRU1BSmdCR0FHd0FQUUJ2QUhRQVpBQjNBSmNBYWdDY0FLUUFpd0NtQUtvQWxBQ3RBSzBBbVFDdkFNd0FtZ0RPQU5JQXVBRFVBUWtBdlFFTEFSRUE4d0VUQVN3QStnRXVBVWtCRkFGTEFVOEJNQUZSQVZjQk5RRlpBVjRCUEFGaEFZRUJRZ0dHQVk0Qll3R1FBWlFCYkFHWEFaY0JjUUdaQWJZQmNnRzRBYndCa0FHK0FkY0JsUUF6QUFJYThnQUNHczRBQWhyVUFBSWEyZ0FDR3VBQUFoc1FBQUliRUFBQ0d4WUFBaHNjQUFJYTVnQUNHeWdBQWhzdUFBSWE3QUFDR3pvQUFodEFBQUliUUFBRUhEd0FBQm00QUFBWnNnQUFHY1FBQUJuS0FBRUF6Z0FBR2RBQUFCbldBQU1BMUFBREFOb0FBd0RnQUFNQTVnQUNHdklBQWhyNEFBSWEvZ0FDR3dRQUFoc0tBQUliRUFBQ0d4QUFBaHNXQUFJYkhBQUNHeUlBQWhzb0FBSWJMZ0FDR3pRQUFoczZBQUliUUFBRUhEd0FBQm00QUFBWnZnQUFHY1FBQUJuS0FBRVp4QUFBR2RBQUFCbldBQUgvN2dBQUFBSC9Vd0Z5QUFIK25BRnlBQUgvZFFGY0FBSCsrd0VIQWE4UlJCRktFVElBQUFBQUVVUVJTaEVzQUFBQUFCRkVFVW9RM2dBQUFBQVJSQkZLRU5nQUFBQUFFUm9SU2hEZUFBQUFBQkZFRVVvUTVBQUFBQUFSUkJGS0VPb0FBQUFBRVVRUlNoRHdBQUFBQUJGRUVVb1JGQUFBQUFBUlJCRktFUHdBQUFBQUVVUVJTaEQyQUFBQUFCRWFFVW9RL0FBQUFBQVJSQkZLRVFJQUFBQUFFVVFSU2hFSUFBQUFBQkZFRVVvUkRnQUFBQUFSUkJGS0VSUUFBQUFBRVVRUlNoRW1BQUFBQUJFYUVVb1JNZ0FBQUFBUlJCRktFU0FBQUFBQUVVUVJTaEVtQUFBQUFCRkVFVW9ST0FBQUFBQVJSQkZLRVN3QUFBQUFFVVFSU2hFeUFBQUFBQkZFRVVvUk9BQUFBQUFSUkJGS0VUNEFBQUFBRVVRUlNoRlFBQUFBQUFBQUFBQVJWZ0FBQUFBQUFBQUFFVndBQUFBQUZPQUFBQlRtQUFBQUFCVGdBQUFSWWdBQUFBQVU0QUFBRVdnQUFBQUFFVzRBQUFBQUFBQUFBQlRnQUFBUmRBQUFBQUFVNEFBQUVYb0FBQUFBRVpnQUFCR3FFYkFBQUJHR0FBQVJnQkdTQUFBUmhnQUFFWXdSa2dBQUVaZ0FBQkdlRWJBQUFCR2tBQUFScWhHd0FBQVJ2QUFBRWJZUnlBQUFFYndBQUJIQ0VjZ0FBQkljRWlJU0ZnQUFBQUFTSEJJaUVoQUFBQUFBRWh3U0loSE9BQUFBQUJJY0VpSVI4Z0FBQUFBU0hCSWlFZG9BQUFBQUVod1NJaEhVQUFBQUFCSDRFaUlSMmdBQUFBQVNIQklpRWVBQUFBQUFFaHdTSWhIbUFBQUFBQkljRWlJUjdBQUFBQUFTSEJJaUVmSUFBQUFBRWh3U0loSUVBQUFBQUJJY0VpSVNCQUFBQUFBUitCSWlFaFlBQUFBQUVod1NJaEgrQUFBQUFCSWNFaUlTQkFBQUFBQVNIQklpRWdvQUFBQUFFaHdTSWhJUUFBQUFBQkljRWlJU0ZnQUFBQUFTSEJJaUVpZ0FBQUFBRWtZQUFCTnNBQUFBQUJKR0FBQVRlQUFBQUFBU1JnQUFFaTRBQUFBQUVrWUFBQkkwQUFBQUFCSkdBQUFTT2dBQUFBQVNRQUFBRTJ3QUFBQUFFa1lBQUJKTUFBQUFBQkpTQUFBU1pCSnFBQUFTVWdBQUVtUVNhZ0FBRWxJQUFCSllFbW9BQUJKZUFBQVNaQkpxQUFBWEZCS3NGallBQUFBQUZ4UVNyQkp3QUFBQUFCY1VFcXdTbWdBQUFBQVhGQktzRW5ZQUFBQUFGeFFTckJKOEFBQUFBQmNVRXF3V01BQUFBQUFYRkJLc0Vud0FBQUFBRnhRU3JCS09BQUFBQUJjVUVxd1NqZ0FBQUFBU2doS3NGallBQUFBQUZ4UVNyQktJQUFBQUFCY1VFcXdTamdBQUFBQVhGQktzRXBRQUFBQUFGeFFTckJLYUFBQUFBQmNVRXF3V05nQUFBQUFYRkJLc0VxQUFBQUFBQUFBQUFCS21BQUFBQUJjVUVxd1NzZ0FBQUFBQUFBQUFFcmdBQUFBQUVyNEFBQUFBQUFBQUFCTEVBQUFBQUFBQUFBQVMzQUFBRXVJUzZCTHVFdHdBQUJMS0V1Z1M3aExjQUFBUzBCTG9FdTRTM0FBQUV1SVM2Qkx1RXRZQUFCTGlFdWdTN2hMY0FBQVM0aExvRXU0UzNBQUFFdUlTNkJMdUZPd0FBQlR5QUFBQUFCVHNBQUFTOUFBQUFBQVU3QUFBRXZvQUFBQUFGT3dBQUJNQUFBQUFBQk1HQUFBVThnQUFBQUFVN0FBQUV3d0FBQUFBRk93QUFCVHlBQUFBQUJUc0FBQVRFZ0FBQUFBVStCVCtGUVFWQ2hVUUZQZ1UvaE5tRlFvVkVCVDRGUDRUR0JVS0ZSQVUrQlQrRTFvVkNoVVFGUGdVL2hNa0ZRb1ZFQlQ0RlA0VEhoVUtGUkFUUWhUK0V5UVZDaFVRRlBnVS9oTXFGUW9WRUJUNEZQNFRNQlVLRlJBVStCVCtFellWQ2hVUUZQZ1UvaE5hRlFvVkVCVDRGUDRUVGhVS0ZSQVUrQlQrRXp3VkNoVVFGUGdVL2hNOEZRb1ZFQk5DRlA0VkJCVUtGUkFVK0JUK0UwZ1ZDaFVRRlBnVS9oTk9GUW9WRUJUNEZQNFZCQlVLRTFRVStCVCtFMllWQ2hOVUUwSVUvaFVFRlFvVFZCVDRGUDRUU0JVS0UxUVUrQlQrRTA0VkNoTlVGUGdVL2hOK0ZRb1RWQlQ0RlA0VFdoVUtGUkFVK0JUK0UyQVZDaFVRRlBnVS9oTm1GUW9WRUJUNEZQNFZCQlVLRlJBVGNoVCtFMndWQ2hVUUUzSVUvaE40RlFvVkVCVDRGUDRUZmhVS0ZSQVUrQlQrRTRRVkNoVVFFNmdBQUJPaUFBQUFBQk9vQUFBVGlnQUFBQUFUcUFBQUU1WUFBQUFBRTVBQUFCT2lBQUFBQUJPb0FBQVRsZ0FBQUFBVG5BQUFFNklBQUFBQUU2Z0FBQk91QUFBQUFCVVdBQUFWSEFBQUFBQVZGZ0FBRTdRQUFBQUFGUllBQUJPNkFBQUFBQlBBQUFBQUFBQUFBQUFWRmdBQUU4WUFBQUFBRTh3QUFCVWNBQUFBQUJQU0FBQVZIQUFBQUFBVmxBQUFFK1FUNmdBQUZaUUFBQlBZRStvQUFCZDZBQUFBQUJQcUFBQVQzZ0FBRStRVDZnQUFGTFlBQUJQa0Urb0FBQlErRkVRVU1nQUFGRkFVUGhSRUZDd0FBQlJRRkQ0VVJCUHdBQUFVVUJRK0ZFUVVKZ0FBRkZBVVBoUkVFL1lBQUJSUUZENFVSQlFtQUFBVVVCUStGRVFVR2dBQUZGQVVQaFJFRkFnQUFCUlFGRDRVUkJQOEFBQVVVQlErRkVRVUFnQUFGRkFVUGhSRUZBZ0FBQlJRRkE0VVJCUXlBQUFVVUJRK0ZFUVVGQUFBRkZBVVBoUkVGQm9BQUJSUUZENFVSQlF5QUFBVUlCUStGRVFVTEFBQUZDQVVEaFJFRkRJQUFCUWdGRDRVUkJRVUFBQVVJQlErRkVRVUdnQUFGQ0FVUGhSRUZFb0FBQlFnRkQ0VVJCUW1BQUFVVUJRK0ZFUVVPQUFBRkZBVVBoUkVGQ3dBQUJSUUZENFVSQlF5QUFBVVVCUStGRVFVT0FBQUZGQVVQaFJFRkVvQUFCUlFBQUFBQUJSV0FBQUFBQUFBQUFBVVhBQUFBQUFBQUFBQUZHSUFBQUFBQUFBQUFCUm9BQUFBQUFBQUFBQVViZ0FBQUFBVW1BQUFGSUFBQUFBQUZKZ0FBQlNTQUFBQUFCU1lBQUFVZEFBQUFBQVVtQUFBRkl3QUFBQUFGSG9BQUJTQUFBQUFBQlNZQUFBVWhnQUFBQUFVbUFBQUZJd0FBQUFBRkpnQUFCU1NBQUFBQUJTWUFBQVVuZ0FBQUFBVmxBQUFGU0lWS0FBQUZaUUFBQlNrRlNnQUFCV1VBQUFVcWhVb0FBQVZsQUFBRkxBVktBQUFGTFlBQUJVaUZTZ0FBQUFBQUFBVXZBQUFBQUFBQUFBQUZOUUFBQUFBQUFBQUFCVENBQUFBQUFBQUFBQVV5QUFBQUFBQUFBQUFGTTRBQUFBQUFBQUFBQlRVQUFBQUFBQUFBQUFVMmdBQUFBQVU0QUFBRk9ZQUFBQUFGT3dBQUJUeUFBQUFBQlQ0RlA0VkJCVUtGUkFWRmdBQUZSd0FBQUFBRlpRQUFCVWlGU2dBQUJWcUZYQVZYZ0FBQUFBVmFoVndGVklBQUFBQUZXb1ZjQlV1QUFBQUFCVnFGWEFWTkFBQUFBQVhKaFZ3RlM0QUFBQUFGV29WY0JVMEFBQUFBQlZxRlhBVk5BQUFBQUFWYWhWd0ZUb0FBQUFBRldvVmNCVlNBQUFBQUJWcUZYQVZRQUFBQUFBVmFoVndGVVlBQUFBQUZ5WVZjQlZBQUFBQUFCVnFGWEFWUmdBQUFBQVZhaFZ3RlVZQUFBQUFGV29WY0JWTUFBQUFBQlZxRlhBVlVnQUFBQUFWYWhWd0ZWSUFBQUFBRnlZVmNCVmVBQUFBQUJWcUZYQVZVZ0FBQUFBVmFoVndGVklBQUFBQUZXb1ZjQlYyQUFBQUFCVnFGWEFWV0FBQUFBQVZhaFZ3RlY0QUFBQUFGV29WY0JWMkFBQUFBQlZxRlhBVlpBQUFBQUFWYWhWd0ZYWUFBQUFBQUFBQUFCVjhBQUFBQUFBQUFBQVZnZ0FBQUFBWVJnQUFHQkFBQUFBQUdFWUFBQldPQUFBQUFCaEdBQUFWamdBQUFBQVhKZ0FBQUFBQUFBQUFHRVlBQUJXSUFBQUFBQmhHQUFBVmpnQUFBQUFWbEFBQUZ2QVZvQlcrRlpRQUFCYndGYUFWdmhXVUFBQVc4QldnRmI0Vm1nQUFGdkFWb0JXK0Zhd0FBQldtRmJnVnZoV3NBQUFWc2hXNEZiNFY5Qlg2RmU0QUFBQUFGZlFWK2hYaUFBQUFBQlgwRmZvVnhBQUFBQUFWOUJYNkZlSUFBQUFBRmZRVitoWEtBQUFBQUJYMEZmb1YwQUFBQUFBVjNCWDZGY29BQUFBQUZmUVYraFhRQUFBQUFCWDBGZm9WMEFBQUFBQVY5Qlg2RmRZQUFBQUFGZlFWK2hYaUFBQUFBQlgwRmZvVjRnQUFBQUFWOUJYNkZlSUFBQUFBRmR3VitoWHVBQUFBQUJYMEZmb1Y0Z0FBQUFBVjlCWDZGZUlBQUFBQUZmUVYraFlBQUFBQUFCWDBGZm9WNkFBQUFBQVY5Qlg2RmU0QUFBQUFGZlFWK2hZQUFBQUFBQmhHRmdZV0RBQUFBQUFBQUFBQUZoSUFBQUFBQUFBQUFCWXFBQUFBQUFBQUFBQVdHQUFBQUFBQUFBQUFGaW9BQUFBQUFBQUFBQlllQUFBQUFBQUFBQUFXSkFBQUFBQUFBQUFBRmlvQUFBQUFHQ2dBQUJZMkZqd0FBQmdvQUFBV05oWThBQUFZS0FBQUZqQVdQQUFBRnQ0QUFCWTJGandBQUJaeUZuZ1dZQUFBQUFBV2NoWjRGbUFBQUFBQUZuSVdlQlpVQUFBQUFCWnlGbmdXUWdBQUFBQVdjaFo0RmxRQUFBQUFGbklXZUJaSUFBQUFBQlp5Rm5nV1ZBQUFBQUFXY2haNEZsUUFBQUFBRm5JV2VCWlVBQUFBQUJaT0ZuZ1dZQUFBQUFBV2NoWjRGbFFBQUFBQUZuSVdlQlpVQUFBQUFCWnlGbmdXWmdBQUFBQVdjaFo0Rm1BQUFBQUFGbklXZUJaYUFBQUFBQlp5Rm5nV1lBQUFBQUFXY2haNEZtWUFBQUFBQUFBQUFCWnNBQUFBQUJaeUZuZ1dmZ0FBQUFBQUFBQUFGb1FBQUFBQUZvb0FBQUFBQUFBQUFCYVFBQUFBQUFBQUFBQVhGQUFBRnB3V29oYW9GeFFBQUJhV0ZxSVdxQmNVQUFBV25CYWlGcWdXL0FBQUZwd1dvaGFvRnhRQUFCYWNGcUlXcUJjVUFBQVduQmFpRnFnWEZBQUFGcHdXb2hhb0dCWUFBQmdjQUFBWUloZ1dBQUFXdEFBQUdDSVlGZ0FBR0J3QUFCZ2lHQllBQUJhMEFBQVlJaGF1QUFBWUhBQUFHQ0lZRmdBQUZyUUFBQmdpR0JZQUFCZ2NBQUFZSWhnV0FBQVd1Z0FBR0NJWUtCZ3VHRFFZT2hoQUdDZ1lMaGdLR0RvWVFCZ29HQzRXd0JnNkdFQVlLQmd1R0FvWU9oaEFHQ2dZTGhiR0dEb1lRQmdvR0M0V3pCZzZHRUFXM2hndUZzWVlPaGhBR0NnWUxoYk1HRG9ZUUJnb0dDNFd6Qmc2R0VBWUtCZ3VGdElZT2hoQUdDZ1lMaGdLR0RvWVFCZ29HQzRZQ2hnNkdFQVlLQmd1RnRnWU9oaEFHQ2dZTGhiWUdEb1lRQmJlR0M0WU5CZzZHRUFZS0JndUdBb1lPaGhBR0NnWUxoZ0tHRG9ZUUJnb0dDNFlOQmc2RnVRWUtCZ3VHQW9ZT2hia0Z0NFlMaGcwR0RvVzVCZ29HQzRZQ2hnNkZ1UVlLQmd1R0FvWU9oYmtHQ2dZTGhid0dEb1c1QmdvR0M0WUNoZzZHRUFZS0JndUZ2QVlPaGhBR0NnWUxoYnFHRG9ZUUJnb0dDNFlOQmc2R0VBWUtCZ3VGNUlZT2hoQUdDZ1lMaGVHR0RvWVFCZ29HQzRXOEJnNkdFQVlLQmd1RnZZWU9oaEFGeFFBQUJjT0FBQUFBQmNVQUFBWEFnQUFBQUFYRkFBQUZ3SUFBQUFBRnZ3QUFCY09BQUFBQUJjVUFBQVhBZ0FBQUFBWENBQUFGdzRBQUFBQUZ4UUFBQmNhQUFBQUFCaEdBQUFZVEFBQUFBQVlSZ0FBRnlBQUFBQUFHRVlBQUJjZ0FBQUFBQmNtQUFBQUFBQUFBQUFZUmdBQUZ5d0FBQUFBRnpJQUFCaE1BQUFBQUJjNEFBQVlUQUFBQUFBWFBnQUFBQUFYVmhkY0Z6NEFBQUFBRjFZWFhCZEVBQUFBQUJkV0Yxd1hTZ0FBQUFBWFZoZGNGMUFBQUFBQUYxWVhYQmVZRjU0WGtnQUFGNlFYbUJlZUY0WUFBQmVrRjVnWG5oZGlBQUFYcEJlWUY1NFhoZ0FBRjZRWG1CZWVGMmdBQUJla0Y1Z1huaGVHQUFBWHBCZVlGNTRYaGdBQUY2UVhtQmVlRjI0QUFCZWtGNWdYbmhkdUFBQVhwQmVZRjU0WGJnQUFGNlFYbUJlZUYzUUFBQmVrRjNvWG5oZVNBQUFYcEJlWUY1NFhoZ0FBRjZRWG1CZWVGNFlBQUJla0Y1Z1huaGVTQUFBWGdCZVlGNTRYaGdBQUY0QVhlaGVlRjVJQUFCZUFGNWdYbmhlR0FBQVhnQmVZRjU0WGhnQUFGNEFYbUJlZUYvNEFBQmVBRjVnWG5oZUdBQUFYcEJlWUY1NFgvZ0FBRjZRWG1CZWVGNHdBQUJla0Y1Z1huaGVTQUFBWHBCZVlGNTRYL2dBQUY2UVhtQmVlRi80QUFCZWtBQUFBQUJlcUFBQUFBQUFBQUFBWHRnQUFBQUFBQUFBQUY3QUFBQUFBQUFBQUFCZTJBQUFBQUFBQUFBQVh0Z0FBQUFBWDJnQUFGOGdBQUFBQUY5b0FBQmZPQUFBQUFCZmFBQUFYdkFBQUFBQVgyZ0FBRjg0QUFBQUFGOElBQUJmSUFBQUFBQmZhQUFBWHpnQUFBQUFYMmdBQUY4NEFBQUFBRjlvQUFCZlVBQUFBQUJmYUFBQVg0QUFBQUFBWVVnQUFHRmdZWGdBQUdGSUFBQmZtR0Y0QUFCaFNBQUFYNWhoZUFBQVlVZ0FBRitZWVhnQUFGK3dBQUJoWUdGNEFBQUFBQUFBWDhnQUFBQUFBQUFBQUYvNEFBQUFBQUFBQUFCZjRBQUFBQUFBQUFBQVgvZ0FBQUFBQUFBQUFGLzRBQUFBQUFBQUFBQmdFQUFBQUFBQUFBQUFZQ2dBQUFBQVlSZ0FBR0JBQUFBQUFHQllBQUJnY0FBQVlJaGdvR0M0WU5CZzZHRUFZUmdBQUdFd0FBQUFBR0ZJQUFCaFlHRjRBQUFBQkFXVUQzZ0FCQVdVRFBnQUJBV1VENWdBQkFXVUVBd0FCQVdZRDNnQUJBV1VEelFBQkFXVURMUUFCQVdVRDFRQUJBV1VEOGdBQkFXWUR6UUFCQVdVRFZRQUJBV2IvU2dBQkFXVURWZ0FCQVdVRGN3QUJBV1VEVGdBQkFXVUNyZ0FCQVdZRGN3QUJBV1lFT0FBQkFXVUFBQUFCQXRBQUFBQUJBV1lEVGdBQkFrNENyZ0FCQWs0RFRnQUJBWE1EVGdBQkFYTURWUUFCQVcvL1NRQUJBWE1ETFFBQkFYTURjd0FCQkFnQ3JnQUJCQVFBQUFBQkJBZ0RWUUFCQkFRQlZ3QUJBV2tBQUFBQkFWWURWUUFCQVdyL1NnQUJBVllDcmdBQkFLUUJYQUFCQTlBQ0RnQUJBOHdBQUFBQkE5QUMwd0FCQTh3QkJ3QUJBVlVEUGdBQkFWVUR6UUFCQVZVRExRQUJBVlVEMVFBQkFWVUQ4Z0FCQVZZRHpRQUJBVlVEVlFBQkFWYi9TZ0FCQVZVRFZnQUJBVlVEY3dBQkFWWURjd0FCQVZVRFRnQUJBVlVDcmdBQkFWVUFBQUFCQW1RQUFBQUJBVllEVGdBQkFZRURQZ0FCQVlFRFZRQUJBWUVETFFBQkFYYisvQUFCQVhVQUFBQUJBWUVEY3dBQkFXWUFBQUFCQVdnRExRQUJBV2YvU2dBQkFXZ0NyZ0FCQVdrQ0hBQUJBcmtDcmdBQkFJd0RQZ0FCQUl3RFZRQUJBSXovU2dBQkFJd0RWZ0FCQUl3RGN3QUJBSTBEY3dBQkFJd0RUZ0FCQUkwRFRnQUJBYU1DcmdBQkFMVUFBQUFCQXJrRFRnQUJBYU1ETFFBQkFXUUFBQUFCQVdYKy9BQUJCQVlDcmdBQkFJc0RUZ0FCQVUzKy9BQUJBVXdBQUFBQkFJc0NyZ0FCQWJzQmNnQUJBVGdDRGdBQkJIVUNyZ0FCQVc4RFRnQUJBVzhEVlFBQkFXeisvQUFCQVc4RGN3QUJBWEFEVGdBQkFZVURQZ0FCQVlVRHpRQUJBWVVETFFBQkFZVUQxUUFCQVlVRDhnQUJBWVlEelFBQkFZVUVFd0FCQVpUL1NnQUJBWVVEVmdBQkFZVURjd0FCQWZRRFRnQUJBWVVEVlFBQkFZWURjd0FCQVlVRFRnQUJBWUVDcmdBQkFZVUFBQUFCQVlFRFRnQUJBWVlEVGdBQkFZWUQ3Z0FCQVV3RFRnQUJBV24rL0FBQkFVd0RWUUFCQVduL1NnQUJBVXdDcmdBQkFXZ0FBQUFCQVUwRGN3QUJBVkFEVGdBQkFWQURWUUFCQVZmL1NRQUJBVkFETFFBQkFWaisvQUFCQVZqL1NnQUJBVElEVlFBQkFUUCsvQUFCQVRJQ3JnQUJBVElCVGdBQkFXa0RQZ0FCQVdrRExRQUJBV2tFR2dBQkFXa0VHd0FCQVdrRUV3QUJBV2ovU2dBQkFXa0RWZ0FCQVdrRGN3QUJBaHdEVGdBQkFXa0RWUUFCQVdrRFRnQUJBV2tDcmdBQkFXb0Rjd0FCQVdjQUFBQUJBZEFBQUFBQkFXb0RUZ0FCQWh3Q3JnQUJBZGtDcmdBQkFka0RUZ0FCQWRrRExRQUJBZGtEY3dBQkFka0RWZ0FCQVZJRExRQUJBVkgvU2dBQkFWSUNyZ0FCQVZJRFZnQUJBVklEY3dBQkFWSURUZ0FCQVZBQUFBQUJBVk1EVGdBQkFUWURUZ0FCQVRZRFZRQUJBVFlEY3dBQkFUUC9TZ0FCQVVjQ3JnQUJBVWNETFFBQkFVY0Rjd0FCQVVjRFZnQUJBVWNEVGdBQkFVZ0RUZ0FCQVc4QUFBQUJBWE1DcmdBQkFXc0FBQUFCQVc4Q3JnQUJBWk1BQUFBQkFiUUFBQUFCQVlVQ3JnQUJBWVVCVndBQkFmUUNyZ0FCQVZjQUFBQUJBVkFDcmdBQkFUWUNyZ0FCQVRJQlZ3QUJBUk1DbmdBQkFSTURZd0FCQVJRRFl3QUJBUk1DdndBQkFSTURoQUFCQVJRRGhBQUJBUk1DMHdBQkFSTUNyZ0FCQVJNQ0RnQUJBUlFEbUFBQkFSRUFBQUFCQWlNQUJBQUJBUlFDMHdBQkFiNENEZ0FCQWI0QzB3QUJBUjRDdndBQkFSNEMwd0FCQVRJQUFBQUJBVFAvU1FBQkFiY0NhZ0FCQTJFQ0RnQUJBMTBBQUFBQkEyRUMwd0FCQTEwQkJ3QUJBazRDRGdBQkFSb0NuZ0FCQVJvQ3Z3QUJBUm9EaEFBQkFSc0RoQUFCQVIvL1NRQUJBUm9DMHdBQkFSb0NyZ0FCQVJvQ0RnQUJBUjRBQUFBQkFYMEFBQUFCQVJzQzB3QUJBSzhDRGdBQkFRNENEZ0FCQVM0Q0RnQUJBUzRDbmdBQkFTNEN2d0FCQVM0REpnQUJBUzRDMHdBQkFJd0RMUUFCQUl3Q3JnQUJBTFlDY3dBQkFJa0NuZ0FCQUlrQ3Z3QUJBSXYvU1FBQkFJa0Mwd0FCQUlrQ3JnQUJBSWtDRGdBQkFJb0Mwd0FCQUljQ0RnQUJBSW9BQUFBQkFMSUFBQUFCQVowQzB3QUJBSWNDdndBQkFTa0FBQUFCQVNyKy9BQUJBSXdEWEFBQkFJd0N2QUFCQVVVQmFBQUJBUUlDRGdBQkFVSCsvQUFCQVQ4QzB3QUJBVUFDMHdBQkFURUNuZ0FCQVRFQ3Z3QUJBVEVEaEFBQkFUSURoQUFCQVRFRGN3QUJBVFQvU1FBQkFYUUNyZ0FCQVRFQ3JnQUJBVElDMHdBQkFUSURjd0FCQUl6Ky9BQUJBTndDMHdBQkFJei9TUUFCQU53Q0RnQUJBSXNBQUFBQkFOMEMwd0FCQVJFQzB3QUJBUkwvU1FBQkFSRUN2d0FCQVJQKy9BQUJBUlAvU1FBQkFNSUFBQUFCQU1ML1NRQUJBTVArL0FBQkFNUC9TUUFCQUpFQkZnQUJBUGNDSWdBQkFTOENuZ0FCQVM4Q3Z3QUJBUzhEbUFBQkFTOERjd0FCQVRML1NRQUJBWjBDcmdBQkFTOEMwd0FCQVM4Q3JnQUJBUzhDRGdBQkFURUFBQUFCQWh3QUFBQUJBWjBDRGdBQkFZWUNEZ0FCQVlZQ3Z3QUJBWVlDMHdBQkFSZ0N2d0FCQWRUL1NRQUJBUmdDRGdBQkFSZ0Mwd0FCQVJnQ3JnQUJBZE1BQUFBQkFSa0Mwd0FCQVA0QzB3QUJBUHYvU1FBQkFUQUNEZ0FCQVRBQ3Z3QUJBVEFDMHdBQkFUQUNyZ0FCQVRFQzB3QUJBUjRDRGdBQkFVQUFBQUFCQVQ4Q0RnQUJBSVFDRGdBQkFUTUFBQUFCQVY4QUFBQUJBVEVDRGdBQkFUSUJCd0FCQVhRQ0RnQUJBUklBQUFBQkFSRUNEZ0FCQVBvQUFBQUJBUDRDRGdBQkFQb0JCd0FHQVFBQUFRQUlBQUVBREFBTUFBRUFLQUNFQUFFQURBTDZBdnNDL0FMOUF2OERBQU1pQXlNREpBTWxBeWNES0FBTUFBQUFPQUFBQURJQUFBQkVBQUFBU2dBQUFGQUFBQUJXQUFBQU9BQUFBRDRBQUFCRUFBQUFTZ0FBQUZBQUFBQldBQUgvWEFBQUFBSC92QUFBQUFIL1hRQUFBQUgveGdBQUFBSC9lUUFBQUFIL1h3QUFBQUgvYUFBQUFBd0FHZ0FnQURJQU9BQStBRVFBSmdBc0FESUFPQUErQUVRQUFmKzkvMGtBQWY5Yi8wa0FBZis5LzBvQUFmOWMvMGtBQWYvSC92d0FBZjk1LzBrQUFmOWUvMGtBQWY5by8wa0FCZ0lBQUFFQUNBQUJBQXdBREFBQkFDSUJHQUFDQUFNQzZBTHNBQUFDN2dMNEFBVURFZ01nQUJBQUh3QUFBS0lBQUFCK0FBQUFoQUFBQUlvQUFBQ1FBQUFBd0FBQUFNQUFBQURHQUFBQXpBQUFBSllBQUFEWUFBQUEzZ0FBQUp3QUFBRHFBQUFBOEFBQUFQQUFBQUNpQUFBQXFBQUFBSzRBQUFDMEFBQUF1Z0FBQU1BQUFBREFBQUFBeGdBQUFNd0FBQURTQUFBQTJBQUFBTjRBQUFEa0FBQUE2Z0FBQVBBQUFmKzhBZzRBQWYrM0FnNEFBZjlkQWc0QUFmOGJBZzRBQWY5WEFnNEFBZjkxQWc0QUFmOWNBZzRBQWYrK0FnNEFBZi9IQWc0QUFmOTVBZzRBQWY4UkFnNEFBZjlhQWc0QUFmOWZBZzRBQWYrYUFnNEFBZjloQWc0QUFmOW9BZzRBQWYrTEFnNEFBZjlyQWc0QUFmOWVBZzRBQWYvQUFnNEFId0IyQUVBQVJnQk1BRklBV0FCZUFLQUFwZ0JrQUxJQXVBQnFBTVFBeWdCd0FIWUFmQUNDQUlnQWpnQ1VBSm9Bb0FDbUFLd0FzZ0M0QUw0QXhBREtBQUgvdkFMVEFBSC90d0xUQUFIL1hRTFRBQUgvR3dMVEFBSC9XZ0svQUFIL1dnTFRBQUgvV0FMVEFBSC9kUUxUQUFIL3dBTkVBQUgvWEFMVEFBSC92Z0xUQUFIL3h3SzJBQUgvZVFLdUFBSC9FUUsxQUFIL1dnS05BQUgvV2dLMUFBSC9Yd0tlQUFIL213TFRBQUgvWWdLdUFBSC9hQUt1QUFIL2l3TFRBQUgvYXdLMUFBSC9Yd0xUQUFIL3dBTW1BQVlEQUFBQkFBZ0FBUUFNQUF3QUFRQVVBQ1FBQVFBQ0F2a0RJUUFDQUFBQUNnQUFBQW9BQWY4a0FnNEFBZ0FHQUFZQUFmOGtBcTRBQUFBQkFBQUFDZ0tDQ01RQUFrUkdURlFBRG14aGRHNEFPZ0FFQUFBQUFQLy9BQkVBQUFBTkFCc0FLQUExQUVJQVdnQm5BSFFBZ1FDT0FKc0FxQUMxQU1JQXp3RGNBRVlBQzBGYVJTQUFjRU5CVkNBQW1rTlNWQ0FBeEVkVlFTQUE3a3RCV2lBQkdFMVBUQ0FCUWs1TVJDQUJiRkJNU3lBQmxsSlBUU0FCd0ZSQlZDQUI2bFJTU3lBQ0ZBQUEvLzhBRWdBQkFBNEFHZ0FjQUNrQU5nQkRBRnNBYUFCMUFJSUFqd0NjQUtrQXRnRERBTkFBM1FBQS8vOEFFZ0FDQUE4QUhRQXFBRGNBUkFCUEFGd0FhUUIyQUlNQWtBQ2RBS29BdHdERUFORUEzZ0FBLy84QUVnQURBQkFBSGdBckFEZ0FSUUJRQUYwQWFnQjNBSVFBa1FDZUFLc0F1QURGQU5JQTN3QUEvLzhBRWdBRUFCRUFId0FzQURrQVJnQlJBRjRBYXdCNEFJVUFrZ0NmQUt3QXVRREdBTk1BNEFBQS8vOEFFZ0FGQUJJQUlBQXRBRG9BUndCU0FGOEFiQUI1QUlZQWt3Q2dBSzBBdWdESEFOUUE0UUFBLy84QUVnQUdBQk1BSVFBdUFEc0FTQUJUQUdBQWJRQjZBSWNBbEFDaEFLNEF1d0RJQU5VQTRnQUEvLzhBRWdBSEFCUUFJZ0F2QUR3QVNRQlVBR0VBYmdCN0FJZ0FsUUNpQUs4QXZBREpBTllBNHdBQS8vOEFFZ0FJQUJVQUl3QXdBRDBBU2dCVkFHSUFid0I4QUlrQWxnQ2pBTEFBdlFES0FOY0E1QUFBLy84QUVnQUpBQllBSkFBeEFENEFTd0JXQUdNQWNBQjlBSW9BbHdDa0FMRUF2Z0RMQU5nQTVRQUEvLzhBRWdBS0FCY0FKUUF5QUQ4QVRBQlhBR1FBY1FCK0FJc0FtQUNsQUxJQXZ3RE1BTmtBNWdBQS8vOEFFZ0FMQUJnQUpnQXpBRUFBVFFCWUFHVUFjZ0IvQUl3QW1RQ21BTE1Bd0FETkFOb0E1d0FBLy84QUVnQU1BQmtBSndBMEFFRUFUZ0JaQUdZQWN3Q0FBSTBBbWdDbkFMUUF3UURPQU5zQTZBRHBZV0ZzZEFWNFlXRnNkQVY0WVdGc2RBVjRZV0ZzZEFWNFlXRnNkQVY0WVdGc2RBVjRZV0ZzZEFWNFlXRnNkQVY0WVdGc2RBVjRZV0ZzZEFWNFlXRnNkQVY0WVdGc2RBVjRZV0ZzZEFWNFkyRnpaUVdBWTJGelpRV0FZMkZ6WlFXQVkyRnpaUVdBWTJGelpRV0FZMkZ6WlFXQVkyRnpaUVdBWTJGelpRV0FZMkZ6WlFXQVkyRnpaUVdBWTJGelpRV0FZMkZ6WlFXQVkyRnpaUVdBWTJOdGNBV0daRzV2YlFXTVpHNXZiUVdNWkc1dmJRV01aRzV2YlFXTVpHNXZiUVdNWkc1dmJRV01aRzV2YlFXTVpHNXZiUVdNWkc1dmJRV01aRzV2YlFXTVpHNXZiUVdNWkc1dmJRV01aRzV2YlFXTVpuSmhZd1dTWm5KaFl3V1NabkpoWXdXU1puSmhZd1dTWm5KaFl3V1NabkpoWXdXU1puSmhZd1dTWm5KaFl3V1NabkpoWXdXU1puSmhZd1dTWm5KaFl3V1NabkpoWXdXU1puSmhZd1dTYkdsbllRV3diR2xuWVFXd2JHbG5ZUVd3YkdsbllRV3diR2xuWVFXd2JHbG5ZUVd3YkdsbllRV3diR2xuWVFXd2JHbG5ZUVd3YkdsbllRV3diR2xuWVFXd2JHbG5ZUVd3YkdsbllRV3diRzUxYlFXMmJHNTFiUVcyYkc1MWJRVzJiRzUxYlFXMmJHNTFiUVcyYkc1MWJRVzJiRzUxYlFXMmJHNTFiUVcyYkc1MWJRVzJiRzUxYlFXMmJHNTFiUVcyYkc1MWJRVzJiRzUxYlFXMmJHOWpiQVc4Ykc5amJBWENiRzlqYkFYSWJHOWpiQVhPYkc5amJBWFViRzlqYkFYYWJHOWpiQVhnYkc5amJBWG1iRzlqYkFYc2JHOWpiQVh5Ykc5amJBWDRiV2R5YXdYK2JXZHlhd1grYldkeWF3WCtiV2R5YXdYK2JXZHlhd1grYldkeWF3WCtiV2R5YXdYK2JXZHlhd1grYldkeWF3WCtiV2R5YXdYK2JXZHlhd1grYldkeWF3WCtiV2R5YXdYK2JuVnRjZ1lFYm5WdGNnWUViblZ0Y2dZRWJuVnRjZ1lFYm5WdGNnWUViblZ0Y2dZRWJuVnRjZ1lFYm5WdGNnWUViblZ0Y2dZRWJuVnRjZ1lFYm5WdGNnWUViblZ0Y2dZRWJuVnRjZ1lFYjI1MWJRWUtiMjUxYlFZS2IyNTFiUVlLYjI1MWJRWUtiMjUxYlFZS2IyNTFiUVlLYjI1MWJRWUtiMjUxYlFZS2IyNTFiUVlLYjI1MWJRWUtiMjUxYlFZS2IyNTFiUVlLYjI1MWJRWUtiM0prYmdZUWIzSmtiZ1lRYjNKa2JnWVFiM0prYmdZUWIzSmtiZ1lRYjNKa2JnWVFiM0prYmdZUWIzSmtiZ1lRYjNKa2JnWVFiM0prYmdZUWIzSmtiZ1lRYjNKa2JnWVFiM0prYmdZUWNHNTFiUVlZY0c1MWJRWVljRzUxYlFZWWNHNTFiUVlZY0c1MWJRWVljRzUxYlFZWWNHNTFiUVlZY0c1MWJRWVljRzUxYlFZWWNHNTFiUVlZY0c1MWJRWVljRzUxYlFZWWNHNTFiUVlZYzJGc2RBWWVjMkZzZEFZZWMyRnNkQVllYzJGc2RBWWVjMkZzZEFZZWMyRnNkQVllYzJGc2RBWWVjMkZzZEFZZWMyRnNkQVllYzJGc2RBWWVjMkZzZEFZZWMyRnNkQVllYzJGc2RBWWVjMmx1WmdZa2MybHVaZ1lrYzJsdVpnWWtjMmx1WmdZa2MybHVaZ1lrYzJsdVpnWWtjMmx1WmdZa2MybHVaZ1lrYzJsdVpnWWtjMmx1WmdZa2MybHVaZ1lrYzJsdVpnWWtjMmx1WmdZa2MzVmljd1lxYzNWaWN3WXFjM1ZpY3dZcWMzVmljd1lxYzNWaWN3WXFjM1ZpY3dZcWMzVmljd1lxYzNWaWN3WXFjM1ZpY3dZcWMzVmljd1lxYzNWaWN3WXFjM1ZpY3dZcWMzVmljd1lxYzNWd2N3WXdjM1Z3Y3dZd2MzVndjd1l3YzNWd2N3WXdjM1Z3Y3dZd2MzVndjd1l3YzNWd2N3WXdjM1Z3Y3dZd2MzVndjd1l3YzNWd2N3WXdjM1Z3Y3dZd2MzVndjd1l3YzNWd2N3WXdkRzUxYlFZMmRHNTFiUVkyZEc1MWJRWTJkRzUxYlFZMmRHNTFiUVkyZEc1MWJRWTJkRzUxYlFZMmRHNTFiUVkyZEc1MWJRWTJkRzUxYlFZMmRHNTFiUVkyZEc1MWJRWTJkRzUxYlFZMmVtVnlid1k4ZW1WeWJ3WThlbVZ5YndZOGVtVnlid1k4ZW1WeWJ3WThlbVZ5YndZOGVtVnlid1k4ZW1WeWJ3WThlbVZ5YndZOGVtVnlid1k4ZW1WeWJ3WThlbVZ5YndZOGVtVnlid1k4QUFBQUFnQUFBQUVBQUFBQkFDY0FBQUFCQUFNQUFBQUJBQ0FBQUFBTkFBUUFCUUFHQUFjQUNBQUpBQW9BQ3dBTUFBMEFEZ0FQQUJBQUFBQUJBQ2dBQUFBQkFDTUFBQUFCQUJJQUFBQUJBQmNBQUFBQkFCUUFBQUFCQUJNQUFBQUJBQmdBQUFBQkFCa0FBQUFCQUJVQUFBQUJBQnNBQUFBQkFCb0FBQUFCQUJZQUFBQUJBQkVBQUFBQkFCd0FBQUFCQUI4QUFBQUJBQ1lBQUFBQ0FDRUFJZ0FBQUFFQUpBQUFBQUVBS2dBQUFBRUFLd0FBQUFFQUhRQUFBQUVBSGdBQUFBRUFKUUFBQUFFQUtRQXhBR1FCbWdPOEE4b0VGZ2J3QndvSEpnZEVCMlFIaGdlcUI5QUgrQWdpQ0ZRSWZnbDRDWGdJcWdsNENQUUplQWs2Q1hnSmpBbU1DYTRKN0F6NENnWUtGQW9pQ2pBS2VBcWFDcklLK0F0U0M1SU1lZ3krRE9RTStBMHNEV0FObEEyeURjWUFBUUFBQUFFQUNBQUNBSmdBU1FLS0FkMEE2UUJpQU9vQjNnRHJBT3dBcVFDeEFPSUE0d0RrQU9VQTVnRG5BT2dBN1FIZEFkTUJRUUZNQWVRQjFBSGVBZFVCMWdHVEFac0J6QUhOQWM0Qnp3SFFBZEVCMGdIWEFyd0N3Z0pmQW1BQ1JBSmhBbklDY3dKMEFuVUNkZ0xqQXhJREV3TVVBeFVERmdNWEF4Z0RHUU1hQXhzREhBTWRBeDRESHdNZ0F5RURJZ01qQXlRREpRTW1BeWNES0FNcEFBRUFTUUFEQUFRQUlnQmhBSEVBZVFCNkFLUUFwd0N3QU5RQTFRRFdBTmNBMlFEYkFOd0EzZ0R1QVF3Qk9RRktBVmtCV2dGakFXUUJqZ0dSQVpvQnZnRy9BY0FCd1FIREFjVUJ4Z0hJQWVFQjRnSlVBbFlDWEFKaUFta0NhZ0pyQW13Q2J3TFFBdWdDNlFMcUF1c0M3QUx1QXU4QzhBTHhBdklDOHdMMEF2VUM5Z0wzQXZrQytnTDdBdndDL1FMK0F2OERBQU1GQUFNQUFBQUJBQWdBQVFINEFETUFiQUIrQUk0QW5nQ3VBTDRBemdEZUFPNEEvZ0VPQVJZQkhBRWlBU2dCTGdFMEFUb0JRQUZHQVV3QlZBRmFBV0FCWmdGc0FYSUJlQUYrQVlRQmlnR1FBWlFCbUFHY0FhQUJwQUdvQWF3QnNBRzBBYndCd2dISUFjNEIxQUhhQWVBQjVnSHNBZklBQ0FJd0FpWUNIQUk2QWU4Q0JRSVFBaHNBQndJeEFpY0NIUUk3QWZBQ0JnSVJBQWNDTWdJb0FoNENQQUh4QWdjQ0VnQUhBak1DS1FJZkFqMEI4Z0lJQWhNQUJ3STBBaW9DSUFJK0FmTUNDUUlVQUFjQ05RSXJBaUVDUHdIMEFnb0NGUUFIQWpZQ0xBSWlBa0FCOVFJTEFoWUFCd0kzQWkwQ0l3SkJBZllDREFJWEFBY0NPQUl1QWlRQ1FnSDNBZzBDR0FBSEFqa0NMd0lsQWtNQitBSU9BaGtBQXdIbEFmb0IrUUFDQWVZQit3QUNBZWNCL0FBQ0FlZ0IvUUFDQWVrQi9nQUNBZW9CL3dBQ0Flc0NBQUFDQWV3Q0FRQUNBZTBDQWdBQ0FlNENBd0FEQWU4Q0VBSUVBQUlCOEFJUkFBSUI4UUlTQUFJQjhnSVRBQUlCOHdJVUFBSUI5QUlWQUFJQjlRSVdBQUlCOWdJWEFBSUI5d0lZQUFJQitBSVpBQUlCN3dJUEFBRUI4QUFCQWZFQUFRSHlBQUVCOHdBQkFmUUFBUUgxQUFFQjlnQUJBZmNBQVFINEFBTUIrZ0h2QWhvQUFnSDdBZkFBQWdIOEFmRUFBZ0g5QWZJQUFnSCtBZk1BQWdIL0FmUUFBZ0lBQWZVQUFnSUJBZllBQWdJQ0FmY0FBZ0lEQWZnQUFnSmlBbUVBQWdBRkFlVUIrQUFBQWZvQ0F3QVVBZ1VDRGdBZUFoQUNHUUFvQWxjQ1Z3QXlBQUVBQUFBQkFBZ0FBUUEyQUFFQUJnQUFBQUlBQ2dBY0FBTUFBQUFCQUNZQUFRQTRBQUVBQUFBQ0FBTUFBQUFCQUJRQUFnQWNBQ1lBQVFBQUFBSUFBUUFDQVRrQlNnQUJBQU1DK1FMNkF2d0FBUUFEQXZRQzlRTDJBQVlBQUFBWkFEZ0FYZ0NFQUtnQXpBRHVBUkFCTUFGUUFXNEJqQUdvQWNRQjNnSDRBaEFDS0FJK0FsUUNhQUo4QW80Q29BS3dBc0FBQXdBTkJoZ0dHQVlZQmhnR0dBWVlCaGdHR0FZWUJoZ0dHQVlZQXB3QUFRS2NBQUFBQUFBREFBQUFBUUoyQUEwRjhnWHlCZklGOGdYeUJmSUY4Z1h5QmZJRjhnWHlCZklDZGdBQUFBTUFEQVhNQmN3RnpBWE1CY3dGekFYTUJjd0Z6QVhNQmN3Q1VBQUJBbEFBQUFBQUFBTUFBQUFCQWl3QURBV29CYWdGcUFXb0JhZ0ZxQVdvQmFnRnFBV29CYWdDTEFBQUFBTUFDd1dFQllRRmhBV0VCWVFGaEFXRUJZUUZoQVdFQWdnQUFRSUlBQUFBQUFBREFBQUFBUUhtQUFzRllnVmlCV0lGWWdWaUJXSUZZZ1ZpQldJRllnSG1BQUFBQXdBS0JVQUZRQVZBQlVBRlFBVkFCVUFGUUFWQUFjUUFBUUhFQUFBQUFBQURBQUFBQVFHa0FBb0ZJQVVnQlNBRklBVWdCU0FGSUFVZ0JTQUJwQUFBQUFNQUNRVUFCUUFGQUFVQUJRQUZBQVVBQlFBQmhBQUJBWVFBQUFBQUFBTUFBQUFCQVdZQUNRVGlCT0lFNGdUaUJPSUU0Z1RpQk9JQlpnQUFBQU1BQ0FURUJNUUV4QVRFQk1RRXhBVEVBVWdBQVFGSUFBQUFBQUFEQUFBQUFRRXNBQWdFcUFTb0JLZ0VxQVNvQktnRXFBRXNBQUFBQXdBSEJJd0VqQVNNQkl3RWpBU01BUkFBQVFFUUFBQUFBQUFEQUFBQUFRRDJBQWNFY2dSeUJISUVjZ1J5QkhJQTlnQUFBQU1BQmdSWUJGZ0VXQVJZQkZnQTNBQUJBTndBQUFBQUFBTUFBQUFCQU1RQUJnUkFCRUFFUUFSQUJFQUF4QUFBQUFNQUJRUW9CQ2dFS0FRb0FLd0FBUUNzQUFBQUFBQURBQUFBQVFDV0FBVUVFZ1FTQkJJRUVnQ1dBQUFBQXdBRUEvd0QvQVA4QUlBQUFRQ0FBQUFBQUFBREFBQUFBUUJzQUFRRDZBUG9BK2dBYkFBQUFBTUFBd1BVQTlRQVdBQUJBRmdBQUFBQUFBTUFBQUFCQUVZQUF3UENBOElBUmdBQUFBTUFBZ093QURRQUFRQTBBQUFBQUFBREFBQUFBUUFrQUFJRG9BQWtBQUFBQXdBQkE1QUFBUUFVQUFFRGtBQUJBQUFBTEFBQkFBRUNYQUFHQUFBQUFRQUlBQU1BQUFBQkEyNEFBUUZXQUFFQUFBQXNBQVlBQUFBQkFBZ0FBd0FBQUFFRFZBQUNBWTRCUEFBQkFBQUFMQUFHQUFBQUFRQUlBQU1BQUFBQkF6Z0FBd0Z5QVhJQklBQUJBQUFBTEFBR0FBQUFBUUFJQUFNQUFBQUJBeG9BQkFGVUFWUUJWQUVDQUFFQUFBQXNBQVlBQUFBQkFBZ0FBd0FBQUFFQytnQUZBVFFCTkFFMEFUUUE0Z0FCQUFBQUxBQUdBQUFBQVFBSUFBTUFBQUFCQXRnQUJnRVNBUklCRWdFU0FSSUF3QUFCQUFBQUxBQUdBQUFBQVFBSUFBTUFBQUFCQXJRQUJ3RHVBTzRBN2dEdUFPNEE3Z0NjQUFFQUFBQXNBQVlBQUFBQkFBZ0FBd0FBQUFFQ2pnQUlBTWdBeUFESUFNZ0F5QURJQU1nQWRnQUJBQUFBTEFBR0FBQUFBUUFJQUFNQUFBQUJBbVlBQ1FDZ0FLQUFvQUNnQUtBQW9BQ2dBS0FBVGdBQkFBQUFMQUFHQUFBQUFRQUlBQU1BQUFBQkFqd0FDZ0IyQUhZQWRnQjJBSFlBZGdCMkFIWUFkZ0FrQUFFQUFBQXNBQUVBQVFKRUFBWUFBQUFCQUFnQUF3QUJBQklBQVFJS0FBQUFBUUFBQUMwQUFnQUNBaVlDTHdBQUFrUUNSQUFLQUFZQUFBQUJBQWdBQXdBQkFlQUFBUUFVQUFFQUdnQUJBQUFBTFFBQkFBRUFBd0FDQUFFQ01BSTVBQUFBQVFBQUFBRUFDQUFDQUNJQURnRGlBT01BNUFEbEFPWUE1d0RvQWN3QnpRSE9BYzhCMEFIUkFkSUFBUUFPQU5RQTFRRFdBTmNBMlFEYkFOd0J2Z0cvQWNBQndRSERBY1VCeGdBR0FBQUFBZ0FLQUNnQUF3QUJBQklBQVFBWUFBQUFBUUFBQUM0QUFRQUJBVHNBQVFBQkFVb0FBd0FCQUJJQUFRQVlBQUFBQVFBQUFDNEFBUUFCQUZNQUFRQUJBR0VBQmdBQUFBSUFDZ0FrQUFNQUFRQVVBQUVFZkFBQkFCUUFBUUFBQUM0QUFRQUJBVkVBQXdBQkFCUUFBUVJpQUFFQUZBQUJBQUFBTHdBQkFBRUFaZ0FCQUFBQUFRQUlBQUVBQmdBSUFBRUFBUUU1QUFFQUFBQUJBQWdBQWdBT0FBUUFxUUN4QVpNQm13QUJBQVFBcHdDd0FaRUJtZ0FCQUFBQUFRQUlBQUlBSEFBTEFPa0E2Z0RyQU93QTdRSFRBZFFCMVFIV0FkY0RLUUFCQUFzQUlnQnhBSG9BcEFEZUFRd0JXZ0ZrQVk0QnlBTUZBQUVBQUFBQkFBZ0FBZ0FLQUFJQ3ZBTENBQUVBQWdIaEFlSUFBUUFBQUFFQUNBQUJBRmdBVlFBQkFBQUFBUUFJQUFFQVNnQkxBQUVBQUFBQkFBZ0FBUUE4QUVFQUJnQUFBQUlBQ2dBa0FBTUFBUUFzQUFFQUVnQUFBQUVBQUFBd0FBRUFBZ0FFQU80QUF3QUJBQklBQVFBY0FBQUFBUUFBQURBQUFnQUJBZVVCN2dBQUFBRUFBZ0I1QVdNQUJBQUFBQUVBQ0FBQkFCUUFBUUFJQUFFQUJBTGdBQU1CWXdKT0FBRUFBUUJ2QUFFQUFBQUJBQWdBQVFBRy8vVUFBZ0FCQWZvQ0F3QUFBQUVBQUFBQkFBZ0FBZ0F1QUJRQjd3SHdBZkVCOGdIekFmUUI5UUgyQWZjQitBSDZBZnNCL0FIOUFmNEIvd0lBQWdFQ0FnSURBQUlBQWdIbEFlNEFBQUlRQWhrQUNnQUJBQUFBQVFBSUFBSUFRZ0FlQWdVQ0JnSUhBZ2dDQ1FJS0Fnc0NEQUlOQWc0QjVRSG1BZWNCNkFIcEFlb0I2d0hzQWUwQjdnSVFBaEVDRWdJVEFoUUNGUUlXQWhjQ0dBSVpBQUlBQWdIbEFmZ0FBQUg2QWdNQUZBQUJBQUFBQVFBSUFBSUFMZ0FVQWhBQ0VRSVNBaE1DRkFJVkFoWUNGd0lZQWhrQitnSDdBZndCL1FIK0FmOENBQUlCQWdJQ0F3QUNBQUVCNVFINEFBQUFBUUFBQUFFQUNBQUNBSlFBUndIdkFmQUI4UUh5QWZNQjlBSDFBZllCOXdINEFlOEI4QUh4QWZJQjh3SDBBZlVCOWdIM0FmZ0I3d0h3QWZFQjhnSHpBZlFCOVFIMkFmY0IrQUh2QWZBQjhRSHlBZk1COUFIMUFmWUI5d0g0QWw4Q1lBSmhBbklDY3dKMEFuVUNkZ01TQXhNREZBTVZBeFlERndNWUF4a0RHZ01iQXh3REhRTWVBeDhESUFNaEF5SURJd01rQXlVREpnTW5BeWdBQWdBTUFlVUI3Z0FBQWZvQ0F3QUtBZ1VDRGdBVUFoQUNHUUFlQWxRQ1ZBQW9BbFlDVmdBcEFtSUNZZ0FxQW1rQ2JBQXJBbThDYndBdkF1Z0M3QUF3QXU0Qzl3QTFBdmtEQUFBL0FBUUFBQUFCQUFnQUFRQTJBQUVBQ0FBRkFBd0FGQUFjQUNJQUtBSFpBQU1CTFFFNUFkb0FBd0V0QVZFQjJBQUNBUzBCMndBQ0FUa0IzQUFDQVZFQUFRQUJBUzBBQVFBQUFBRUFDQUFDQUJBQUJRSWJBZmtDQkFJUEFob0FBUUFGQWVVQjd3SDZBZ1VDRUFBQkFBQUFBUUFJQUFFQUJnQVRBQUVBQVFMUUFBRUFBQUFCQUFnQUFnQWNBQXNCNUFJY0FoMENIZ0lmQWlBQ0lRSWlBaU1DSkFJbEFBSUFBZ0ZaQVZrQUFBSGxBZTRBQVFBQkFBQUFBUUFJQUFJQUhBQUxBakFDTVFJeUFqTUNOQUkxQWpZQ053STRBamtDUkFBQ0FBSUI1UUh1QUFBQ1hBSmNBQW9BQVFBQUFBRUFDQUFDQUJ3QUN3S0tBaVlDSndJb0Fpa0NLZ0lyQWl3Q0xRSXVBaThBQWdBQ0FBTUFBd0FBQWVVQjdnQUJBQUVBQUFBQkFBZ0FBZ0FNQUFNQVlnRk1BbUlBQVFBREFHRUJTZ0pYQUFFQUFBQUJBQWdBQVFBR0FBb0FBUUFCQWxjQUFRQUFBQUVBQ0FBQ0FBNEFCQUhkQWQ0QjNRSGVBQUVBQkFBRUFIa0E3Z0ZqXCIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./src/css/main.scss\nvar main = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./node_modules/gsap/gsap-core.js\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\n/*!\n * GSAP 3.4.2\n * https://greensock.com\n *\n * @license Copyright 2008-2020, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n\n/* eslint-disable */\nvar _config = {\n  autoSleep: 120,\n  force3D: "auto",\n  nullTargetWarn: 1,\n  units: {\n    lineHeight: ""\n  }\n},\n    _defaults = {\n  duration: .5,\n  overwrite: false,\n  delay: 0\n},\n    _bigNum = 1e8,\n    _tinyNum = 1 / _bigNum,\n    _2PI = Math.PI * 2,\n    _HALF_PI = _2PI / 4,\n    _gsID = 0,\n    _sqrt = Math.sqrt,\n    _cos = Math.cos,\n    _sin = Math.sin,\n    _isString = function _isString(value) {\n  return typeof value === "string";\n},\n    _isFunction = function _isFunction(value) {\n  return typeof value === "function";\n},\n    _isNumber = function _isNumber(value) {\n  return typeof value === "number";\n},\n    _isUndefined = function _isUndefined(value) {\n  return typeof value === "undefined";\n},\n    _isObject = function _isObject(value) {\n  return typeof value === "object";\n},\n    _isNotFalse = function _isNotFalse(value) {\n  return value !== false;\n},\n    _windowExists = function _windowExists() {\n  return typeof window !== "undefined";\n},\n    _isFuncOrString = function _isFuncOrString(value) {\n  return _isFunction(value) || _isString(value);\n},\n    _isArray = Array.isArray,\n    _strictNumExp = /(?:-?\\.?\\d|\\.)+/gi,\n    //only numbers (including negatives and decimals) but NOT relative values.\n_numExp = /[-+=.]*\\d+[.e\\-+]*\\d*[e\\-\\+]*\\d*/g,\n    //finds any numbers, including ones that start with += or -=, negative numbers, and ones in scientific notation like 1e-8.\n_numWithUnitExp = /[-+=.]*\\d+[.e-]*\\d*[a-z%]*/g,\n    _complexStringNumExp = /[-+=.]*\\d+(?:\\.|e-|e)*\\d*/gi,\n    //duplicate so that while we\'re looping through matches from exec(), it doesn\'t contaminate the lastIndex of _numExp which we use to search for colors too.\n_parenthesesExp = /\\(([^()]+)\\)/i,\n    //finds the string between parentheses.\n_relExp = /[+-]=-?[\\.\\d]+/,\n    _delimitedValueExp = /[#\\-+.]*\\b[a-z\\d-=+%.]+/gi,\n    _globalTimeline,\n    _win,\n    _coreInitted,\n    _doc,\n    _globals = {},\n    _installScope = {},\n    _coreReady,\n    _install = function _install(scope) {\n  return (_installScope = _merge(scope, _globals)) && gsap;\n},\n    _missingPlugin = function _missingPlugin(property, value) {\n  return console.warn("Invalid property", property, "set to", value, "Missing plugin? gsap.registerPlugin()");\n},\n    _warn = function _warn(message, suppress) {\n  return !suppress && console.warn(message);\n},\n    _addGlobal = function _addGlobal(name, obj) {\n  return name && (_globals[name] = obj) && _installScope && (_installScope[name] = obj) || _globals;\n},\n    _emptyFunc = function _emptyFunc() {\n  return 0;\n},\n    _reservedProps = {},\n    _lazyTweens = [],\n    _lazyLookup = {},\n    _lastRenderedFrame,\n    _plugins = {},\n    _effects = {},\n    _nextGCFrame = 30,\n    _harnessPlugins = [],\n    _callbackNames = "",\n    _harness = function _harness(targets) {\n  var target = targets[0],\n      harnessPlugin,\n      i;\n\n  if (!_isObject(target) && !_isFunction(target)) {\n    targets = [targets];\n  }\n\n  if (!(harnessPlugin = (target._gsap || {}).harness)) {\n    i = _harnessPlugins.length;\n\n    while (i-- && !_harnessPlugins[i].targetTest(target)) {}\n\n    harnessPlugin = _harnessPlugins[i];\n  }\n\n  i = targets.length;\n\n  while (i--) {\n    targets[i] && (targets[i]._gsap || (targets[i]._gsap = new GSCache(targets[i], harnessPlugin))) || targets.splice(i, 1);\n  }\n\n  return targets;\n},\n    _getCache = function _getCache(target) {\n  return target._gsap || _harness(toArray(target))[0]._gsap;\n},\n    _getProperty = function _getProperty(target, property) {\n  var currentValue = target[property];\n  return _isFunction(currentValue) ? target[property]() : _isUndefined(currentValue) && target.getAttribute(property) || currentValue;\n},\n    _forEachName = function _forEachName(names, func) {\n  return (names = names.split(",")).forEach(func) || names;\n},\n    //split a comma-delimited list of names into an array, then run a forEach() function and return the split array (this is just a way to consolidate/shorten some code).\n_round = function _round(value) {\n  return Math.round(value * 100000) / 100000 || 0;\n},\n    _arrayContainsAny = function _arrayContainsAny(toSearch, toFind) {\n  //searches one array to find matches for any of the items in the toFind array. As soon as one is found, it returns true. It does NOT return all the matches; it\'s simply a boolean search.\n  var l = toFind.length,\n      i = 0;\n\n  for (; toSearch.indexOf(toFind[i]) < 0 && ++i < l;) {}\n\n  return i < l;\n},\n    _parseVars = function _parseVars(params, type, parent) {\n  //reads the arguments passed to one of the key methods and figures out if the user is defining things with the OLD/legacy syntax where the duration is the 2nd parameter, and then it adjusts things accordingly and spits back the corrected vars object (with the duration added if necessary, as well as runBackwards or startAt or immediateRender). type 0 = to()/staggerTo(), 1 = from()/staggerFrom(), 2 = fromTo()/staggerFromTo()\n  var isLegacy = _isNumber(params[1]),\n      varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1),\n      vars = params[varsIndex],\n      irVars;\n\n  if (isLegacy) {\n    vars.duration = params[1];\n  }\n\n  vars.parent = parent;\n\n  if (type) {\n    irVars = vars;\n\n    while (parent && !("immediateRender" in irVars)) {\n      // inheritance hasn\'t happened yet, but someone may have set a default in an ancestor timeline. We could do vars.immediateRender = _isNotFalse(_inheritDefaults(vars).immediateRender) but that\'d exact a slight performance penalty because _inheritDefaults() also runs in the Tween constructor. We\'re paying a small kb price here to gain speed.\n      irVars = parent.vars.defaults || {};\n      parent = _isNotFalse(parent.vars.inherit) && parent.parent;\n    }\n\n    vars.immediateRender = _isNotFalse(irVars.immediateRender);\n\n    if (type < 2) {\n      vars.runBackwards = 1;\n    } else {\n      vars.startAt = params[varsIndex - 1]; // "from" vars\n    }\n  }\n\n  return vars;\n},\n    _lazyRender = function _lazyRender() {\n  var l = _lazyTweens.length,\n      a = _lazyTweens.slice(0),\n      i,\n      tween;\n\n  _lazyLookup = {};\n  _lazyTweens.length = 0;\n\n  for (i = 0; i < l; i++) {\n    tween = a[i];\n    tween && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0);\n  }\n},\n    _lazySafeRender = function _lazySafeRender(animation, time, suppressEvents, force) {\n  _lazyTweens.length && _lazyRender();\n  animation.render(time, suppressEvents, force);\n  _lazyTweens.length && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when someone calls seek() or time() or progress(), they expect an immediate render.\n},\n    _numericIfPossible = function _numericIfPossible(value) {\n  var n = parseFloat(value);\n  return (n || n === 0) && (value + "").match(_delimitedValueExp).length < 2 ? n : value;\n},\n    _passThrough = function _passThrough(p) {\n  return p;\n},\n    _setDefaults = function _setDefaults(obj, defaults) {\n  for (var p in defaults) {\n    p in obj || (obj[p] = defaults[p]);\n  }\n\n  return obj;\n},\n    _setKeyframeDefaults = function _setKeyframeDefaults(obj, defaults) {\n  for (var p in defaults) {\n    if (!(p in obj) && p !== "duration" && p !== "ease") {\n      obj[p] = defaults[p];\n    }\n  }\n},\n    _merge = function _merge(base, toMerge) {\n  for (var p in toMerge) {\n    base[p] = toMerge[p];\n  }\n\n  return base;\n},\n    _mergeDeep = function _mergeDeep(base, toMerge) {\n  for (var p in toMerge) {\n    base[p] = _isObject(toMerge[p]) ? _mergeDeep(base[p] || (base[p] = {}), toMerge[p]) : toMerge[p];\n  }\n\n  return base;\n},\n    _copyExcluding = function _copyExcluding(obj, excluding) {\n  var copy = {},\n      p;\n\n  for (p in obj) {\n    p in excluding || (copy[p] = obj[p]);\n  }\n\n  return copy;\n},\n    _inheritDefaults = function _inheritDefaults(vars) {\n  var parent = vars.parent || _globalTimeline,\n      func = vars.keyframes ? _setKeyframeDefaults : _setDefaults;\n\n  if (_isNotFalse(vars.inherit)) {\n    while (parent) {\n      func(vars, parent.vars.defaults);\n      parent = parent.parent || parent._dp;\n    }\n  }\n\n  return vars;\n},\n    _arraysMatch = function _arraysMatch(a1, a2) {\n  var i = a1.length,\n      match = i === a2.length;\n\n  while (match && i-- && a1[i] === a2[i]) {}\n\n  return i < 0;\n},\n    _addLinkedListItem = function _addLinkedListItem(parent, child, firstProp, lastProp, sortBy) {\n  if (firstProp === void 0) {\n    firstProp = "_first";\n  }\n\n  if (lastProp === void 0) {\n    lastProp = "_last";\n  }\n\n  var prev = parent[lastProp],\n      t;\n\n  if (sortBy) {\n    t = child[sortBy];\n\n    while (prev && prev[sortBy] > t) {\n      prev = prev._prev;\n    }\n  }\n\n  if (prev) {\n    child._next = prev._next;\n    prev._next = child;\n  } else {\n    child._next = parent[firstProp];\n    parent[firstProp] = child;\n  }\n\n  if (child._next) {\n    child._next._prev = child;\n  } else {\n    parent[lastProp] = child;\n  }\n\n  child._prev = prev;\n  child.parent = child._dp = parent;\n  return child;\n},\n    _removeLinkedListItem = function _removeLinkedListItem(parent, child, firstProp, lastProp) {\n  if (firstProp === void 0) {\n    firstProp = "_first";\n  }\n\n  if (lastProp === void 0) {\n    lastProp = "_last";\n  }\n\n  var prev = child._prev,\n      next = child._next;\n\n  if (prev) {\n    prev._next = next;\n  } else if (parent[firstProp] === child) {\n    parent[firstProp] = next;\n  }\n\n  if (next) {\n    next._prev = prev;\n  } else if (parent[lastProp] === child) {\n    parent[lastProp] = prev;\n  }\n\n  child._next = child._prev = child.parent = null; // don\'t delete the _dp just so we can revert if necessary. But parent should be null to indicate the item isn\'t in a linked list.\n},\n    _removeFromParent = function _removeFromParent(child, onlyIfParentHasAutoRemove) {\n  child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) && child.parent.remove(child);\n  child._act = 0;\n},\n    _uncache = function _uncache(animation) {\n  var a = animation;\n\n  while (a) {\n    a._dirty = 1;\n    a = a.parent;\n  }\n\n  return animation;\n},\n    _recacheAncestors = function _recacheAncestors(animation) {\n  var parent = animation.parent;\n\n  while (parent && parent.parent) {\n    //sometimes we must force a re-sort of all children and update the duration/totalDuration of all ancestor timelines immediately in case, for example, in the middle of a render loop, one tween alters another tween\'s timeScale which shoves its startTime before 0, forcing the parent timeline to shift around and shiftChildren() which could affect that next tween\'s render (startTime). Doesn\'t matter for the root timeline though.\n    parent._dirty = 1;\n    parent.totalDuration();\n    parent = parent.parent;\n  }\n\n  return animation;\n},\n    _hasNoPausedAncestors = function _hasNoPausedAncestors(animation) {\n  return !animation || animation._ts && _hasNoPausedAncestors(animation.parent);\n},\n    _elapsedCycleDuration = function _elapsedCycleDuration(animation) {\n  return animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration() + animation._rDelay) * animation : 0;\n},\n    // feed in the totalTime and cycleDuration and it\'ll return the cycle (iteration minus 1) and if the playhead is exactly at the very END, it will NOT bump up to the next cycle.\n_animationCycle = function _animationCycle(tTime, cycleDuration) {\n  return (tTime /= cycleDuration) && ~~tTime === tTime ? ~~tTime - 1 : ~~tTime;\n},\n    _parentToChildTotalTime = function _parentToChildTotalTime(parentTime, child) {\n  return (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur);\n},\n    _setEnd = function _setEnd(animation) {\n  return animation._end = _round(animation._start + (animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum) || 0));\n},\n    _alignPlayhead = function _alignPlayhead(animation, totalTime) {\n  // adjusts the animation\'s _start and _end according to the provided totalTime (only if the parent\'s smoothChildTiming is true and the animation isn\'t paused). It doesn\'t do any rendering or forcing things back into parent timelines, etc. - that\'s what totalTime() is for.\n  var parent = animation._dp;\n\n  if (parent && parent.smoothChildTiming && animation._ts) {\n    animation._start = _round(animation._dp._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts));\n\n    _setEnd(animation);\n\n    parent._dirty || _uncache(parent); //for performance improvement. If the parent\'s cache is already dirty, it already took care of marking the ancestors as dirty too, so skip the function call here.\n  }\n\n  return animation;\n},\n\n/*\n_totalTimeToTime = (clampedTotalTime, duration, repeat, repeatDelay, yoyo) => {\n\tlet cycleDuration = duration + repeatDelay,\n\t\ttime = _round(clampedTotalTime % cycleDuration);\n\tif (time > duration) {\n\t\ttime = duration;\n\t}\n\treturn (yoyo && (~~(clampedTotalTime / cycleDuration) & 1)) ? duration - time : time;\n},\n*/\n_postAddChecks = function _postAddChecks(timeline, child) {\n  var t;\n\n  if (child._time || child._initted && !child._dur) {\n    //in case, for example, the _start is moved on a tween that has already rendered. Imagine it\'s at its end state, then the startTime is moved WAY later (after the end of this timeline), it should render at its beginning.\n    t = _parentToChildTotalTime(timeline.rawTime(), child);\n\n    if (!child._dur || _clamp(0, child.totalDuration(), t) - child._tTime > _tinyNum) {\n      child.render(t, true);\n    }\n  } //if the timeline has already ended but the inserted tween/timeline extends the duration, we should enable this timeline again so that it renders properly. We should also align the playhead with the parent timeline\'s when appropriate.\n\n\n  if (_uncache(timeline)._dp && timeline._initted && timeline._time >= timeline._dur && timeline._ts) {\n    //in case any of the ancestors had completed but should now be enabled...\n    if (timeline._dur < timeline.duration()) {\n      t = timeline;\n\n      while (t._dp) {\n        t.rawTime() >= 0 && t.totalTime(t._tTime); //moves the timeline (shifts its startTime) if necessary, and also enables it. If it\'s currently zero, though, it may not be scheduled to render until later so there\'s no need to force it to align with the current playhead position. Only move to catch up with the playhead.\n\n        t = t._dp;\n      }\n    }\n\n    timeline._zTime = -_tinyNum; // helps ensure that the next render() will be forced (crossingStart = true in render()), even if the duration hasn\'t changed (we\'re adding a child which would need to get rendered). Definitely an edge case. Note: we MUST do this AFTER the loop above where the totalTime() might trigger a render() because this _addToTimeline() method gets called from the Animation constructor, BEFORE tweens even record their targets, etc. so we wouldn\'t want things to get triggered in the wrong order.\n  }\n},\n    _addToTimeline = function _addToTimeline(timeline, child, position, skipChecks) {\n  child.parent && _removeFromParent(child);\n  child._start = _round(position + child._delay);\n  child._end = _round(child._start + (child.totalDuration() / Math.abs(child.timeScale()) || 0));\n\n  _addLinkedListItem(timeline, child, "_first", "_last", timeline._sort ? "_start" : 0);\n\n  timeline._recent = child;\n  skipChecks || _postAddChecks(timeline, child);\n  return timeline;\n},\n    _scrollTrigger = function _scrollTrigger(animation, trigger) {\n  return (_globals.ScrollTrigger || _missingPlugin("scrollTrigger", trigger)) && _globals.ScrollTrigger.create(trigger, animation);\n},\n    _attemptInitTween = function _attemptInitTween(tween, totalTime, force, suppressEvents) {\n  _initTween(tween, totalTime);\n\n  if (!tween._initted) {\n    return 1;\n  }\n\n  if (!force && tween._pt && (tween._dur && tween.vars.lazy !== false || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame) {\n    _lazyTweens.push(tween);\n\n    tween._lazy = [totalTime, suppressEvents];\n    return 1;\n  }\n},\n    _renderZeroDurationTween = function _renderZeroDurationTween(tween, totalTime, suppressEvents, force) {\n  var prevRatio = tween.ratio,\n      ratio = totalTime < 0 || !totalTime && prevRatio && !tween._start && tween._zTime > _tinyNum && !tween._dp._lock || tween._ts < 0 || tween._dp._ts < 0 ? 0 : 1,\n      // check parent\'s _lock because when a timeline repeats/yoyos and does its artificial wrapping, we shouldn\'t force the ratio back to 0. Also, if the tween or its parent is reversed and the totalTime is 0, we should go to a ratio of 0.\n  repeatDelay = tween._rDelay,\n      tTime = 0,\n      pt,\n      iteration,\n      prevIteration;\n\n  if (repeatDelay && tween._repeat) {\n    // in case there\'s a zero-duration tween that has a repeat with a repeatDelay\n    tTime = _clamp(0, tween._tDur, totalTime);\n    iteration = _animationCycle(tTime, repeatDelay);\n    prevIteration = _animationCycle(tween._tTime, repeatDelay);\n\n    if (iteration !== prevIteration) {\n      prevRatio = 1 - ratio;\n      tween.vars.repeatRefresh && tween._initted && tween.invalidate();\n    }\n  }\n\n  if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents)) {\n    // if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn\'t need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.\n    return;\n  }\n\n  if (ratio !== prevRatio || force || tween._zTime === _tinyNum || !totalTime && tween._zTime) {\n    prevIteration = tween._zTime;\n    tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0); // when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it\'ll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there\'s a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.\n\n    suppressEvents || (suppressEvents = totalTime && !prevIteration); // if it was rendered previously at exactly 0 (_zTime) and now the playhead is moving away, DON\'T fire callbacks otherwise they\'ll seem like duplicates.\n\n    tween.ratio = ratio;\n    tween._from && (ratio = 1 - ratio);\n    tween._time = 0;\n    tween._tTime = tTime;\n    suppressEvents || _callback(tween, "onStart");\n    pt = tween._pt;\n\n    while (pt) {\n      pt.r(ratio, pt.d);\n      pt = pt._next;\n    }\n\n    tween._startAt && totalTime < 0 && tween._startAt.render(totalTime, true, true);\n    tween._onUpdate && !suppressEvents && _callback(tween, "onUpdate");\n    tTime && tween._repeat && !suppressEvents && tween.parent && _callback(tween, "onRepeat");\n\n    if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {\n      ratio && _removeFromParent(tween, 1);\n\n      if (!suppressEvents) {\n        _callback(tween, ratio ? "onComplete" : "onReverseComplete", true);\n\n        tween._prom && tween._prom();\n      }\n    }\n  } else if (!tween._zTime) {\n    tween._zTime = totalTime;\n  }\n},\n    _findNextPauseTween = function _findNextPauseTween(animation, prevTime, time) {\n  var child;\n\n  if (time > prevTime) {\n    child = animation._first;\n\n    while (child && child._start <= time) {\n      if (!child._dur && child.data === "isPause" && child._start > prevTime) {\n        return child;\n      }\n\n      child = child._next;\n    }\n  } else {\n    child = animation._last;\n\n    while (child && child._start >= time) {\n      if (!child._dur && child.data === "isPause" && child._start < prevTime) {\n        return child;\n      }\n\n      child = child._prev;\n    }\n  }\n},\n    _setDuration = function _setDuration(animation, duration, skipUncache) {\n  var repeat = animation._repeat,\n      dur = _round(duration) || 0;\n  animation._dur = dur;\n  animation._tDur = !repeat ? dur : repeat < 0 ? 1e10 : _round(dur * (repeat + 1) + animation._rDelay * repeat);\n\n  if (animation._time > dur) {\n    animation._time = dur;\n    animation._tTime = Math.min(animation._tTime, animation._tDur);\n  }\n\n  !skipUncache && _uncache(animation.parent);\n  animation.parent && _setEnd(animation);\n  return animation;\n},\n    _onUpdateTotalDuration = function _onUpdateTotalDuration(animation) {\n  return animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur);\n},\n    _zeroPosition = {\n  _start: 0,\n  endTime: _emptyFunc\n},\n    _parsePosition = function _parsePosition(animation, position) {\n  var labels = animation.labels,\n      recent = animation._recent || _zeroPosition,\n      clippedDuration = animation.duration() >= _bigNum ? recent.endTime(false) : animation._dur,\n      //in case there\'s a child that infinitely repeats, users almost never intend for the insertion point of a new child to be based on a SUPER long value like that so we clip it and assume the most recently-added child\'s endTime should be used instead.\n  i,\n      offset;\n\n  if (_isString(position) && (isNaN(position) || position in labels)) {\n    //if the string is a number like "1", check to see if there\'s a label with that name, otherwise interpret it as a number (absolute value).\n    i = position.charAt(0);\n\n    if (i === "<" || i === ">") {\n      return (i === "<" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position.substr(1)) || 0);\n    }\n\n    i = position.indexOf("=");\n\n    if (i < 0) {\n      position in labels || (labels[position] = clippedDuration);\n      return labels[position];\n    }\n\n    offset = +(position.charAt(i - 1) + position.substr(i + 1));\n    return i > 1 ? _parsePosition(animation, position.substr(0, i - 1)) + offset : clippedDuration + offset;\n  }\n\n  return position == null ? clippedDuration : +position;\n},\n    _conditionalReturn = function _conditionalReturn(value, func) {\n  return value || value === 0 ? func(value) : func;\n},\n    _clamp = function _clamp(min, max, value) {\n  return value < min ? min : value > max ? max : value;\n},\n    getUnit = function getUnit(value) {\n  return (value + "").substr((parseFloat(value) + "").length);\n},\n    clamp = function clamp(min, max, value) {\n  return _conditionalReturn(value, function (v) {\n    return _clamp(min, max, v);\n  });\n},\n    _slice = [].slice,\n    _isArrayLike = function _isArrayLike(value, nonEmpty) {\n  return value && _isObject(value) && "length" in value && (!nonEmpty && !value.length || value.length - 1 in value && _isObject(value[0])) && !value.nodeType && value !== _win;\n},\n    _flatten = function _flatten(ar, leaveStrings, accumulator) {\n  if (accumulator === void 0) {\n    accumulator = [];\n  }\n\n  return ar.forEach(function (value) {\n    var _accumulator;\n\n    return _isString(value) && !leaveStrings || _isArrayLike(value, 1) ? (_accumulator = accumulator).push.apply(_accumulator, toArray(value)) : accumulator.push(value);\n  }) || accumulator;\n},\n    //takes any value and returns an array. If it\'s a string (and leaveStrings isn\'t true), it\'ll use document.querySelectorAll() and convert that to an array. It\'ll also accept iterables like jQuery objects.\ntoArray = function toArray(value, leaveStrings) {\n  return _isString(value) && !leaveStrings && (_coreInitted || !_wake()) ? _slice.call(_doc.querySelectorAll(value), 0) : _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [value] : [];\n},\n    shuffle = function shuffle(a) {\n  return a.sort(function () {\n    return .5 - Math.random();\n  });\n},\n    // alternative that\'s a bit faster and more reliably diverse but bigger:   for (let j, v, i = a.length; i; j = Math.floor(Math.random() * i), v = a[--i], a[i] = a[j], a[j] = v); return a;\n//for distributing values across an array. Can accept a number, a function or (most commonly) a function which can contain the following properties: {base, amount, from, ease, grid, axis, length, each}. Returns a function that expects the following parameters: index, target, array. Recognizes the following\ndistribute = function distribute(v) {\n  if (_isFunction(v)) {\n    return v;\n  }\n\n  var vars = _isObject(v) ? v : {\n    each: v\n  },\n      //n:1 is just to indicate v was a number; we leverage that later to set v according to the length we get. If a number is passed in, we treat it like the old stagger value where 0.1, for example, would mean that things would be distributed with 0.1 between each element in the array rather than a total "amount" that\'s chunked out among them all.\n  ease = _parseEase(vars.ease),\n      from = vars.from || 0,\n      base = parseFloat(vars.base) || 0,\n      cache = {},\n      isDecimal = from > 0 && from < 1,\n      ratios = isNaN(from) || isDecimal,\n      axis = vars.axis,\n      ratioX = from,\n      ratioY = from;\n\n  if (_isString(from)) {\n    ratioX = ratioY = {\n      center: .5,\n      edges: .5,\n      end: 1\n    }[from] || 0;\n  } else if (!isDecimal && ratios) {\n    ratioX = from[0];\n    ratioY = from[1];\n  }\n\n  return function (i, target, a) {\n    var l = (a || vars).length,\n        distances = cache[l],\n        originX,\n        originY,\n        x,\n        y,\n        d,\n        j,\n        max,\n        min,\n        wrapAt;\n\n    if (!distances) {\n      wrapAt = vars.grid === "auto" ? 0 : (vars.grid || [1, _bigNum])[1];\n\n      if (!wrapAt) {\n        max = -_bigNum;\n\n        while (max < (max = a[wrapAt++].getBoundingClientRect().left) && wrapAt < l) {}\n\n        wrapAt--;\n      }\n\n      distances = cache[l] = [];\n      originX = ratios ? Math.min(wrapAt, l) * ratioX - .5 : from % wrapAt;\n      originY = ratios ? l * ratioY / wrapAt - .5 : from / wrapAt | 0;\n      max = 0;\n      min = _bigNum;\n\n      for (j = 0; j < l; j++) {\n        x = j % wrapAt - originX;\n        y = originY - (j / wrapAt | 0);\n        distances[j] = d = !axis ? _sqrt(x * x + y * y) : Math.abs(axis === "y" ? y : x);\n        d > max && (max = d);\n        d < min && (min = d);\n      }\n\n      from === "random" && shuffle(distances);\n      distances.max = max - min;\n      distances.min = min;\n      distances.v = l = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l ? l - 1 : !axis ? Math.max(wrapAt, l / wrapAt) : axis === "y" ? l / wrapAt : wrapAt) || 0) * (from === "edges" ? -1 : 1);\n      distances.b = l < 0 ? base - l : base;\n      distances.u = getUnit(vars.amount || vars.each) || 0; //unit\n\n      ease = ease && l < 0 ? _invertEase(ease) : ease;\n    }\n\n    l = (distances[i] - distances.min) / distances.max || 0;\n    return _round(distances.b + (ease ? ease(l) : l) * distances.v) + distances.u; //round in order to work around floating point errors\n  };\n},\n    _roundModifier = function _roundModifier(v) {\n  //pass in 0.1 get a function that\'ll round to the nearest tenth, or 5 to round to the closest 5, or 0.001 to the closest 1000th, etc.\n  var p = v < 1 ? Math.pow(10, (v + "").length - 2) : 1; //to avoid floating point math errors (like 24 * 0.1 == 2.4000000000000004), we chop off at a specific number of decimal places (much faster than toFixed()\n\n  return function (raw) {\n    return Math.floor(Math.round(parseFloat(raw) / v) * v * p) / p + (_isNumber(raw) ? 0 : getUnit(raw));\n  };\n},\n    snap = function snap(snapTo, value) {\n  var isArray = _isArray(snapTo),\n      radius,\n      is2D;\n\n  if (!isArray && _isObject(snapTo)) {\n    radius = isArray = snapTo.radius || _bigNum;\n\n    if (snapTo.values) {\n      snapTo = toArray(snapTo.values);\n\n      if (is2D = !_isNumber(snapTo[0])) {\n        radius *= radius; //performance optimization so we don\'t have to Math.sqrt() in the loop.\n      }\n    } else {\n      snapTo = _roundModifier(snapTo.increment);\n    }\n  }\n\n  return _conditionalReturn(value, !isArray ? _roundModifier(snapTo) : _isFunction(snapTo) ? function (raw) {\n    is2D = snapTo(raw);\n    return Math.abs(is2D - raw) <= radius ? is2D : raw;\n  } : function (raw) {\n    var x = parseFloat(is2D ? raw.x : raw),\n        y = parseFloat(is2D ? raw.y : 0),\n        min = _bigNum,\n        closest = 0,\n        i = snapTo.length,\n        dx,\n        dy;\n\n    while (i--) {\n      if (is2D) {\n        dx = snapTo[i].x - x;\n        dy = snapTo[i].y - y;\n        dx = dx * dx + dy * dy;\n      } else {\n        dx = Math.abs(snapTo[i] - x);\n      }\n\n      if (dx < min) {\n        min = dx;\n        closest = i;\n      }\n    }\n\n    closest = !radius || min <= radius ? snapTo[closest] : raw;\n    return is2D || closest === raw || _isNumber(raw) ? closest : closest + getUnit(raw);\n  });\n},\n    random = function random(min, max, roundingIncrement, returnFunction) {\n  return _conditionalReturn(_isArray(min) ? !max : roundingIncrement === true ? !!(roundingIncrement = 0) : !returnFunction, function () {\n    return _isArray(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement + "").length - 2) : 1) && Math.floor(Math.round((min + Math.random() * (max - min)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction;\n  });\n},\n    pipe = function pipe() {\n  for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) {\n    functions[_key] = arguments[_key];\n  }\n\n  return function (value) {\n    return functions.reduce(function (v, f) {\n      return f(v);\n    }, value);\n  };\n},\n    unitize = function unitize(func, unit) {\n  return function (value) {\n    return func(parseFloat(value)) + (unit || getUnit(value));\n  };\n},\n    normalize = function normalize(min, max, value) {\n  return mapRange(min, max, 0, 1, value);\n},\n    _wrapArray = function _wrapArray(a, wrapper, value) {\n  return _conditionalReturn(value, function (index) {\n    return a[~~wrapper(index)];\n  });\n},\n    wrap = function wrap(min, max, value) {\n  // NOTE: wrap() CANNOT be an arrow function! A very odd compiling bug causes problems (unrelated to GSAP).\n  var range = max - min;\n  return _isArray(min) ? _wrapArray(min, wrap(0, min.length), max) : _conditionalReturn(value, function (value) {\n    return (range + (value - min) % range) % range + min;\n  });\n},\n    wrapYoyo = function wrapYoyo(min, max, value) {\n  var range = max - min,\n      total = range * 2;\n  return _isArray(min) ? _wrapArray(min, wrapYoyo(0, min.length - 1), max) : _conditionalReturn(value, function (value) {\n    value = (total + (value - min) % total) % total || 0;\n    return min + (value > range ? total - value : value);\n  });\n},\n    _replaceRandom = function _replaceRandom(value) {\n  //replaces all occurrences of random(...) in a string with the calculated random value. can be a range like random(-100, 100, 5) or an array like random([0, 100, 500])\n  var prev = 0,\n      s = "",\n      i,\n      nums,\n      end,\n      isArray;\n\n  while (~(i = value.indexOf("random(", prev))) {\n    end = value.indexOf(")", i);\n    isArray = value.charAt(i + 7) === "[";\n    nums = value.substr(i + 7, end - i - 7).match(isArray ? _delimitedValueExp : _strictNumExp);\n    s += value.substr(prev, i - prev) + random(isArray ? nums : +nums[0], +nums[1], +nums[2] || 1e-5);\n    prev = end + 1;\n  }\n\n  return s + value.substr(prev, value.length - prev);\n},\n    mapRange = function mapRange(inMin, inMax, outMin, outMax, value) {\n  var inRange = inMax - inMin,\n      outRange = outMax - outMin;\n  return _conditionalReturn(value, function (value) {\n    return outMin + ((value - inMin) / inRange * outRange || 0);\n  });\n},\n    interpolate = function interpolate(start, end, progress, mutate) {\n  var func = isNaN(start + end) ? 0 : function (p) {\n    return (1 - p) * start + p * end;\n  };\n\n  if (!func) {\n    var isString = _isString(start),\n        master = {},\n        p,\n        i,\n        interpolators,\n        l,\n        il;\n\n    progress === true && (mutate = 1) && (progress = null);\n\n    if (isString) {\n      start = {\n        p: start\n      };\n      end = {\n        p: end\n      };\n    } else if (_isArray(start) && !_isArray(end)) {\n      interpolators = [];\n      l = start.length;\n      il = l - 2;\n\n      for (i = 1; i < l; i++) {\n        interpolators.push(interpolate(start[i - 1], start[i])); //build the interpolators up front as a performance optimization so that when the function is called many times, it can just reuse them.\n      }\n\n      l--;\n\n      func = function func(p) {\n        p *= l;\n        var i = Math.min(il, ~~p);\n        return interpolators[i](p - i);\n      };\n\n      progress = end;\n    } else if (!mutate) {\n      start = _merge(_isArray(start) ? [] : {}, start);\n    }\n\n    if (!interpolators) {\n      for (p in end) {\n        _addPropTween.call(master, start, p, "get", end[p]);\n      }\n\n      func = function func(p) {\n        return _renderPropTweens(p, master) || (isString ? start.p : start);\n      };\n    }\n  }\n\n  return _conditionalReturn(progress, func);\n},\n    _getLabelInDirection = function _getLabelInDirection(timeline, fromTime, backward) {\n  //used for nextLabel() and previousLabel()\n  var labels = timeline.labels,\n      min = _bigNum,\n      p,\n      distance,\n      label;\n\n  for (p in labels) {\n    distance = labels[p] - fromTime;\n\n    if (distance < 0 === !!backward && distance && min > (distance = Math.abs(distance))) {\n      label = p;\n      min = distance;\n    }\n  }\n\n  return label;\n},\n    _callback = function _callback(animation, type, executeLazyFirst) {\n  var v = animation.vars,\n      callback = v[type],\n      params,\n      scope;\n\n  if (!callback) {\n    return;\n  }\n\n  params = v[type + "Params"];\n  scope = v.callbackScope || animation;\n  executeLazyFirst && _lazyTweens.length && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.\n\n  return params ? callback.apply(scope, params) : callback.call(scope);\n},\n    _interrupt = function _interrupt(animation) {\n  _removeFromParent(animation);\n\n  if (animation.progress() < 1) {\n    _callback(animation, "onInterrupt");\n  }\n\n  return animation;\n},\n    _quickTween,\n    _createPlugin = function _createPlugin(config) {\n  config = !config.name && config["default"] || config; //UMD packaging wraps things oddly, so for example MotionPathHelper becomes {MotionPathHelper:MotionPathHelper, default:MotionPathHelper}.\n\n  var name = config.name,\n      isFunc = _isFunction(config),\n      Plugin = name && !isFunc && config.init ? function () {\n    this._props = [];\n  } : config,\n      //in case someone passes in an object that\'s not a plugin, like CustomEase\n  instanceDefaults = {\n    init: _emptyFunc,\n    render: _renderPropTweens,\n    add: _addPropTween,\n    kill: _killPropTweensOf,\n    modifier: _addPluginModifier,\n    rawVars: 0\n  },\n      statics = {\n    targetTest: 0,\n    get: 0,\n    getSetter: _getSetter,\n    aliases: {},\n    register: 0\n  };\n\n  _wake();\n\n  if (config !== Plugin) {\n    if (_plugins[name]) {\n      return;\n    }\n\n    _setDefaults(Plugin, _setDefaults(_copyExcluding(config, instanceDefaults), statics)); //static methods\n\n\n    _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config, statics))); //instance methods\n\n\n    _plugins[Plugin.prop = name] = Plugin;\n\n    if (config.targetTest) {\n      _harnessPlugins.push(Plugin);\n\n      _reservedProps[name] = 1;\n    }\n\n    name = (name === "css" ? "CSS" : name.charAt(0).toUpperCase() + name.substr(1)) + "Plugin"; //for the global name. "motionPath" should become MotionPathPlugin\n  }\n\n  _addGlobal(name, Plugin);\n\n  if (config.register) {\n    config.register(gsap, Plugin, PropTween);\n  }\n},\n\n/*\n * --------------------------------------------------------------------------------------\n * COLORS\n * --------------------------------------------------------------------------------------\n */\n_255 = 255,\n    _colorLookup = {\n  aqua: [0, _255, _255],\n  lime: [0, _255, 0],\n  silver: [192, 192, 192],\n  black: [0, 0, 0],\n  maroon: [128, 0, 0],\n  teal: [0, 128, 128],\n  blue: [0, 0, _255],\n  navy: [0, 0, 128],\n  white: [_255, _255, _255],\n  olive: [128, 128, 0],\n  yellow: [_255, _255, 0],\n  orange: [_255, 165, 0],\n  gray: [128, 128, 128],\n  purple: [128, 0, 128],\n  green: [0, 128, 0],\n  red: [_255, 0, 0],\n  pink: [_255, 192, 203],\n  cyan: [0, _255, _255],\n  transparent: [_255, _255, _255, 0]\n},\n    _hue = function _hue(h, m1, m2) {\n  h = h < 0 ? h + 1 : h > 1 ? h - 1 : h;\n  return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < .5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * _255 + .5 | 0;\n},\n    splitColor = function splitColor(v, toHSL, forceAlpha) {\n  var a = !v ? _colorLookup.black : _isNumber(v) ? [v >> 16, v >> 8 & _255, v & _255] : 0,\n      r,\n      g,\n      b,\n      h,\n      s,\n      l,\n      max,\n      min,\n      d,\n      wasHSL;\n\n  if (!a) {\n    if (v.substr(-1) === ",") {\n      //sometimes a trailing comma is included and we should chop it off (typically from a comma-delimited list of values like a textShadow:"2px 2px 2px blue, 5px 5px 5px rgb(255,0,0)" - in this example "blue," has a trailing comma. We could strip it out inside parseComplex() but we\'d need to do it to the beginning and ending values plus it wouldn\'t provide protection from other potential scenarios like if the user passes in a similar value.\n      v = v.substr(0, v.length - 1);\n    }\n\n    if (_colorLookup[v]) {\n      a = _colorLookup[v];\n    } else if (v.charAt(0) === "#") {\n      if (v.length === 4) {\n        //for shorthand like #9F0\n        r = v.charAt(1);\n        g = v.charAt(2);\n        b = v.charAt(3);\n        v = "#" + r + r + g + g + b + b;\n      }\n\n      v = parseInt(v.substr(1), 16);\n      a = [v >> 16, v >> 8 & _255, v & _255];\n    } else if (v.substr(0, 3) === "hsl") {\n      a = wasHSL = v.match(_strictNumExp);\n\n      if (!toHSL) {\n        h = +a[0] % 360 / 360;\n        s = +a[1] / 100;\n        l = +a[2] / 100;\n        g = l <= .5 ? l * (s + 1) : l + s - l * s;\n        r = l * 2 - g;\n\n        if (a.length > 3) {\n          a[3] *= 1; //cast as number\n        }\n\n        a[0] = _hue(h + 1 / 3, r, g);\n        a[1] = _hue(h, r, g);\n        a[2] = _hue(h - 1 / 3, r, g);\n      } else if (~v.indexOf("=")) {\n        //if relative values are found, just return the raw strings with the relative prefixes in place.\n        a = v.match(_numExp);\n        forceAlpha && a.length < 4 && (a[3] = 1);\n        return a;\n      }\n    } else {\n      a = v.match(_strictNumExp) || _colorLookup.transparent;\n    }\n\n    a = a.map(Number);\n  }\n\n  if (toHSL && !wasHSL) {\n    r = a[0] / _255;\n    g = a[1] / _255;\n    b = a[2] / _255;\n    max = Math.max(r, g, b);\n    min = Math.min(r, g, b);\n    l = (max + min) / 2;\n\n    if (max === min) {\n      h = s = 0;\n    } else {\n      d = max - min;\n      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n      h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;\n      h *= 60;\n    }\n\n    a[0] = ~~(h + .5);\n    a[1] = ~~(s * 100 + .5);\n    a[2] = ~~(l * 100 + .5);\n  }\n\n  forceAlpha && a.length < 4 && (a[3] = 1);\n  return a;\n},\n    _colorOrderData = function _colorOrderData(v) {\n  // strips out the colors from the string, finds all the numeric slots (with units) and returns an array of those. The Array also has a "c" property which is an Array of the index values where the colors belong. This is to help work around issues where there\'s a mis-matched order of color/numeric data like drop-shadow(#f00 0px 1px 2px) and drop-shadow(0x 1px 2px #f00). This is basically a helper function used in _formatColors()\n  var values = [],\n      c = [],\n      i = -1;\n  v.split(_colorExp).forEach(function (v) {\n    var a = v.match(_numWithUnitExp) || [];\n    values.push.apply(values, a);\n    c.push(i += a.length + 1);\n  });\n  values.c = c;\n  return values;\n},\n    _formatColors = function _formatColors(s, toHSL, orderMatchData) {\n  var result = "",\n      colors = (s + result).match(_colorExp),\n      type = toHSL ? "hsla(" : "rgba(",\n      i = 0,\n      c,\n      shell,\n      d,\n      l;\n\n  if (!colors) {\n    return s;\n  }\n\n  colors = colors.map(function (color) {\n    return (color = splitColor(color, toHSL, 1)) && type + (toHSL ? color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : color.join(",")) + ")";\n  });\n\n  if (orderMatchData) {\n    d = _colorOrderData(s);\n    c = orderMatchData.c;\n\n    if (c.join(result) !== d.c.join(result)) {\n      shell = s.replace(_colorExp, "1").split(_numWithUnitExp);\n      l = shell.length - 1;\n\n      for (; i < l; i++) {\n        result += shell[i] + (~c.indexOf(i) ? colors.shift() || type + "0,0,0,0)" : (d.length ? d : colors.length ? colors : orderMatchData).shift());\n      }\n    }\n  }\n\n  if (!shell) {\n    shell = s.split(_colorExp);\n    l = shell.length - 1;\n\n    for (; i < l; i++) {\n      result += shell[i] + colors[i];\n    }\n  }\n\n  return result + shell[l];\n},\n    _colorExp = function () {\n  var s = "(?:\\\\b(?:(?:rgb|rgba|hsl|hsla)\\\\(.+?\\\\))|\\\\B#(?:[0-9a-f]{3}){1,2}\\\\b",\n      //we\'ll dynamically build this Regular Expression to conserve file size. After building it, it will be able to find rgb(), rgba(), # (hexadecimal), and named color values like red, blue, purple, etc.,\n  p;\n\n  for (p in _colorLookup) {\n    s += "|" + p + "\\\\b";\n  }\n\n  return new RegExp(s + ")", "gi");\n}(),\n    _hslExp = /hsl[a]?\\(/,\n    _colorStringFilter = function _colorStringFilter(a) {\n  var combined = a.join(" "),\n      toHSL;\n  _colorExp.lastIndex = 0;\n\n  if (_colorExp.test(combined)) {\n    toHSL = _hslExp.test(combined);\n    a[1] = _formatColors(a[1], toHSL);\n    a[0] = _formatColors(a[0], toHSL, _colorOrderData(a[1])); // make sure the order of numbers/colors match with the END value.\n\n    return true;\n  }\n},\n\n/*\n * --------------------------------------------------------------------------------------\n * TICKER\n * --------------------------------------------------------------------------------------\n */\n_tickerActive,\n    _ticker = function () {\n  var _getTime = Date.now,\n      _lagThreshold = 500,\n      _adjustedLag = 33,\n      _startTime = _getTime(),\n      _lastUpdate = _startTime,\n      _gap = 1 / 240,\n      _nextTime = _gap,\n      _listeners = [],\n      _id,\n      _req,\n      _raf,\n      _self,\n      _tick = function _tick(v) {\n    var elapsed = _getTime() - _lastUpdate,\n        manual = v === true,\n        overlap,\n        dispatch;\n\n    if (elapsed > _lagThreshold) {\n      _startTime += elapsed - _adjustedLag;\n    }\n\n    _lastUpdate += elapsed;\n    _self.time = (_lastUpdate - _startTime) / 1000;\n    overlap = _self.time - _nextTime;\n\n    if (overlap > 0 || manual) {\n      _self.frame++;\n      _nextTime += overlap + (overlap >= _gap ? 0.004 : _gap - overlap);\n      dispatch = 1;\n    }\n\n    manual || (_id = _req(_tick)); //make sure the request is made before we dispatch the "tick" event so that timing is maintained. Otherwise, if processing the "tick" requires a bunch of time (like 15ms) and we\'re using a setTimeout() that\'s based on 16.7ms, it\'d technically take 31.7ms between frames otherwise.\n\n    dispatch && _listeners.forEach(function (l) {\n      return l(_self.time, elapsed, _self.frame, v);\n    });\n  };\n\n  _self = {\n    time: 0,\n    frame: 0,\n    tick: function tick() {\n      _tick(true);\n    },\n    wake: function wake() {\n      if (_coreReady) {\n        if (!_coreInitted && _windowExists()) {\n          _win = _coreInitted = window;\n          _doc = _win.document || {};\n          _globals.gsap = gsap;\n          (_win.gsapVersions || (_win.gsapVersions = [])).push(gsap.version);\n\n          _install(_installScope || _win.GreenSockGlobals || !_win.gsap && _win || {});\n\n          _raf = _win.requestAnimationFrame;\n        }\n\n        _id && _self.sleep();\n\n        _req = _raf || function (f) {\n          return setTimeout(f, (_nextTime - _self.time) * 1000 + 1 | 0);\n        };\n\n        _tickerActive = 1;\n\n        _tick(2);\n      }\n    },\n    sleep: function sleep() {\n      (_raf ? _win.cancelAnimationFrame : clearTimeout)(_id);\n      _tickerActive = 0;\n      _req = _emptyFunc;\n    },\n    lagSmoothing: function lagSmoothing(threshold, adjustedLag) {\n      _lagThreshold = threshold || 1 / _tinyNum; //zero should be interpreted as basically unlimited\n\n      _adjustedLag = Math.min(adjustedLag, _lagThreshold, 0);\n    },\n    fps: function fps(_fps) {\n      _gap = 1 / (_fps || 240);\n      _nextTime = _self.time + _gap;\n    },\n    add: function add(callback) {\n      _listeners.indexOf(callback) < 0 && _listeners.push(callback);\n\n      _wake();\n    },\n    remove: function remove(callback) {\n      var i;\n      ~(i = _listeners.indexOf(callback)) && _listeners.splice(i, 1);\n    },\n    _listeners: _listeners\n  };\n  return _self;\n}(),\n    _wake = function _wake() {\n  return !_tickerActive && _ticker.wake();\n},\n    //also ensures the core classes are initialized.\n\n/*\n* -------------------------------------------------\n* EASING\n* -------------------------------------------------\n*/\n_easeMap = {},\n    _customEaseExp = /^[\\d.\\-M][\\d.\\-,\\s]/,\n    _quotesExp = /["\']/g,\n    _parseObjectInString = function _parseObjectInString(value) {\n  //takes a string like "{wiggles:10, type:anticipate})" and turns it into a real object. Notice it ends in ")" and includes the {} wrappers. This is because we only use this function for parsing ease configs and prioritized optimization rather than reusability.\n  var obj = {},\n      split = value.substr(1, value.length - 3).split(":"),\n      key = split[0],\n      i = 1,\n      l = split.length,\n      index,\n      val,\n      parsedVal;\n\n  for (; i < l; i++) {\n    val = split[i];\n    index = i !== l - 1 ? val.lastIndexOf(",") : val.length;\n    parsedVal = val.substr(0, index);\n    obj[key] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, "").trim() : +parsedVal;\n    key = val.substr(index + 1).trim();\n  }\n\n  return obj;\n},\n    _configEaseFromString = function _configEaseFromString(name) {\n  //name can be a string like "elastic.out(1,0.5)", and pass in _easeMap as obj and it\'ll parse it out and call the actual function like _easeMap.Elastic.easeOut.config(1,0.5). It will also parse custom ease strings as long as CustomEase is loaded and registered (internally as _easeMap._CE).\n  var split = (name + "").split("("),\n      ease = _easeMap[split[0]];\n  return ease && split.length > 1 && ease.config ? ease.config.apply(null, ~name.indexOf("{") ? [_parseObjectInString(split[1])] : _parenthesesExp.exec(name)[1].split(",").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name) ? _easeMap._CE("", name) : ease;\n},\n    _invertEase = function _invertEase(ease) {\n  return function (p) {\n    return 1 - ease(1 - p);\n  };\n},\n    // allow yoyoEase to be set in children and have those affected when the parent/ancestor timeline yoyos.\n_propagateYoyoEase = function _propagateYoyoEase(timeline, isYoyo) {\n  var child = timeline._first,\n      ease;\n\n  while (child) {\n    if (child instanceof Timeline) {\n      _propagateYoyoEase(child, isYoyo);\n    } else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) {\n      if (child.timeline) {\n        _propagateYoyoEase(child.timeline, isYoyo);\n      } else {\n        ease = child._ease;\n        child._ease = child._yEase;\n        child._yEase = ease;\n        child._yoyo = isYoyo;\n      }\n    }\n\n    child = child._next;\n  }\n},\n    _parseEase = function _parseEase(ease, defaultEase) {\n  return !ease ? defaultEase : (_isFunction(ease) ? ease : _easeMap[ease] || _configEaseFromString(ease)) || defaultEase;\n},\n    _insertEase = function _insertEase(names, easeIn, easeOut, easeInOut) {\n  if (easeOut === void 0) {\n    easeOut = function easeOut(p) {\n      return 1 - easeIn(1 - p);\n    };\n  }\n\n  if (easeInOut === void 0) {\n    easeInOut = function easeInOut(p) {\n      return p < .5 ? easeIn(p * 2) / 2 : 1 - easeIn((1 - p) * 2) / 2;\n    };\n  }\n\n  var ease = {\n    easeIn: easeIn,\n    easeOut: easeOut,\n    easeInOut: easeInOut\n  },\n      lowercaseName;\n\n  _forEachName(names, function (name) {\n    _easeMap[name] = _globals[name] = ease;\n    _easeMap[lowercaseName = name.toLowerCase()] = easeOut;\n\n    for (var p in ease) {\n      _easeMap[lowercaseName + (p === "easeIn" ? ".in" : p === "easeOut" ? ".out" : ".inOut")] = _easeMap[name + "." + p] = ease[p];\n    }\n  });\n\n  return ease;\n},\n    _easeInOutFromOut = function _easeInOutFromOut(easeOut) {\n  return function (p) {\n    return p < .5 ? (1 - easeOut(1 - p * 2)) / 2 : .5 + easeOut((p - .5) * 2) / 2;\n  };\n},\n    _configElastic = function _configElastic(type, amplitude, period) {\n  var p1 = amplitude >= 1 ? amplitude : 1,\n      //note: if amplitude is < 1, we simply adjust the period for a more natural feel. Otherwise the math doesn\'t work right and the curve starts at 1.\n  p2 = (period || (type ? .3 : .45)) / (amplitude < 1 ? amplitude : 1),\n      p3 = p2 / _2PI * (Math.asin(1 / p1) || 0),\n      easeOut = function easeOut(p) {\n    return p === 1 ? 1 : p1 * Math.pow(2, -10 * p) * _sin((p - p3) * p2) + 1;\n  },\n      ease = type === "out" ? easeOut : type === "in" ? function (p) {\n    return 1 - easeOut(1 - p);\n  } : _easeInOutFromOut(easeOut);\n\n  p2 = _2PI / p2; //precalculate to optimize\n\n  ease.config = function (amplitude, period) {\n    return _configElastic(type, amplitude, period);\n  };\n\n  return ease;\n},\n    _configBack = function _configBack(type, overshoot) {\n  if (overshoot === void 0) {\n    overshoot = 1.70158;\n  }\n\n  var easeOut = function easeOut(p) {\n    return p ? --p * p * ((overshoot + 1) * p + overshoot) + 1 : 0;\n  },\n      ease = type === "out" ? easeOut : type === "in" ? function (p) {\n    return 1 - easeOut(1 - p);\n  } : _easeInOutFromOut(easeOut);\n\n  ease.config = function (overshoot) {\n    return _configBack(type, overshoot);\n  };\n\n  return ease;\n}; // a cheaper (kb and cpu) but more mild way to get a parameterized weighted ease by feeding in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.\n// _weightedEase = ratio => {\n// \tlet y = 0.5 + ratio / 2;\n// \treturn p => (2 * (1 - p) * p * y + p * p);\n// },\n// a stronger (but more expensive kb/cpu) parameterized weighted ease that lets you feed in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.\n// _weightedEaseStrong = ratio => {\n// \tratio = .5 + ratio / 2;\n// \tlet o = 1 / 3 * (ratio < .5 ? ratio : 1 - ratio),\n// \t\tb = ratio - o,\n// \t\tc = ratio + o;\n// \treturn p => p === 1 ? p : 3 * b * (1 - p) * (1 - p) * p + 3 * c * (1 - p) * p * p + p * p * p;\n// };\n\n\n_forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", function (name, i) {\n  var power = i < 5 ? i + 1 : i;\n\n  _insertEase(name + ",Power" + (power - 1), i ? function (p) {\n    return Math.pow(p, power);\n  } : function (p) {\n    return p;\n  }, function (p) {\n    return 1 - Math.pow(1 - p, power);\n  }, function (p) {\n    return p < .5 ? Math.pow(p * 2, power) / 2 : 1 - Math.pow((1 - p) * 2, power) / 2;\n  });\n});\n\n_easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;\n\n_insertEase("Elastic", _configElastic("in"), _configElastic("out"), _configElastic());\n\n(function (n, c) {\n  var n1 = 1 / c,\n      n2 = 2 * n1,\n      n3 = 2.5 * n1,\n      easeOut = function easeOut(p) {\n    return p < n1 ? n * p * p : p < n2 ? n * Math.pow(p - 1.5 / c, 2) + .75 : p < n3 ? n * (p -= 2.25 / c) * p + .9375 : n * Math.pow(p - 2.625 / c, 2) + .984375;\n  };\n\n  _insertEase("Bounce", function (p) {\n    return 1 - easeOut(1 - p);\n  }, easeOut);\n})(7.5625, 2.75);\n\n_insertEase("Expo", function (p) {\n  return p ? Math.pow(2, 10 * (p - 1)) : 0;\n});\n\n_insertEase("Circ", function (p) {\n  return -(_sqrt(1 - p * p) - 1);\n});\n\n_insertEase("Sine", function (p) {\n  return p === 1 ? 1 : -_cos(p * _HALF_PI) + 1;\n});\n\n_insertEase("Back", _configBack("in"), _configBack("out"), _configBack());\n\n_easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {\n  config: function config(steps, immediateStart) {\n    if (steps === void 0) {\n      steps = 1;\n    }\n\n    var p1 = 1 / steps,\n        p2 = steps + (immediateStart ? 0 : 1),\n        p3 = immediateStart ? 1 : 0,\n        max = 1 - _tinyNum;\n    return function (p) {\n      return ((p2 * _clamp(0, max, p) | 0) + p3) * p1;\n    };\n  }\n};\n_defaults.ease = _easeMap["quad.out"];\n\n_forEachName("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function (name) {\n  return _callbackNames += name + "," + name + "Params,";\n});\n/*\n * --------------------------------------------------------------------------------------\n * CACHE\n * --------------------------------------------------------------------------------------\n */\n\n\nvar GSCache = function GSCache(target, harness) {\n  this.id = _gsID++;\n  target._gsap = this;\n  this.target = target;\n  this.harness = harness;\n  this.get = harness ? harness.get : _getProperty;\n  this.set = harness ? harness.getSetter : _getSetter;\n};\n/*\n * --------------------------------------------------------------------------------------\n * ANIMATION\n * --------------------------------------------------------------------------------------\n */\n\nvar Animation = /*#__PURE__*/function () {\n  function Animation(vars, time) {\n    var parent = vars.parent || _globalTimeline;\n    this.vars = vars;\n    this._delay = +vars.delay || 0;\n\n    if (this._repeat = vars.repeat || 0) {\n      this._rDelay = vars.repeatDelay || 0;\n      this._yoyo = !!vars.yoyo || !!vars.yoyoEase;\n    }\n\n    this._ts = 1;\n\n    _setDuration(this, +vars.duration, 1);\n\n    this.data = vars.data;\n    _tickerActive || _ticker.wake();\n    parent && _addToTimeline(parent, this, time || time === 0 ? time : parent._time, 1);\n    vars.reversed && this.reverse();\n    vars.paused && this.paused(true);\n  }\n\n  var _proto = Animation.prototype;\n\n  _proto.delay = function delay(value) {\n    if (value || value === 0) {\n      this.parent && this.parent.smoothChildTiming && this.startTime(this._start + value - this._delay);\n      this._delay = value;\n      return this;\n    }\n\n    return this._delay;\n  };\n\n  _proto.duration = function duration(value) {\n    return arguments.length ? this.totalDuration(this._repeat > 0 ? value + (value + this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur;\n  };\n\n  _proto.totalDuration = function totalDuration(value) {\n    if (!arguments.length) {\n      return this._tDur;\n    }\n\n    this._dirty = 0;\n    var t = this._time / this._dur || 0;\n\n    _setDuration(this, this._repeat < 0 ? value : (value - this._repeat * this._rDelay) / (this._repeat + 1));\n\n    return this._tTime ? _alignPlayhead(this, t * value + _elapsedCycleDuration(this)) : this; // in case the animation hasn\'t even started yet and it has a delay. Aligning the playhead in that case would make it appear to lose the delay.\n  };\n\n  _proto.totalTime = function totalTime(_totalTime, suppressEvents) {\n    _wake();\n\n    if (!arguments.length) {\n      return this._tTime;\n    }\n\n    var parent = this._dp;\n\n    if (parent && parent.smoothChildTiming && this._ts) {\n      _alignPlayhead(this, _totalTime); //in case any of the ancestor timelines had completed but should now be enabled, we should reset their totalTime() which will also ensure that they\'re lined up properly and enabled. Skip for animations that are on the root (wasteful). Example: a TimelineLite.exportRoot() is performed when there\'s a paused tween on the root, the export will not complete until that tween is unpaused, but imagine a child gets restarted later, after all [unpaused] tweens have completed. The start of that child would get pushed out, but one of the ancestors may have completed.\n\n\n      while (parent.parent) {\n        if (parent.parent._time !== parent._start + (parent._ts >= 0 ? parent._tTime / parent._ts : (parent.totalDuration() - parent._tTime) / -parent._ts)) {\n          parent.totalTime(parent._tTime, true);\n        }\n\n        parent = parent.parent;\n      }\n\n      if (!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && _totalTime < this._tDur || this._ts < 0 && _totalTime > 0 || !this._tDur && !_totalTime)) {\n        //if the animation doesn\'t have a parent, put it back into its last parent (recorded as _dp for exactly cases like this). Limit to parents with autoRemoveChildren (like globalTimeline) so that if the user manually removes an animation from a timeline and then alters its playhead, it doesn\'t get added back in.\n        _addToTimeline(this._dp, this, this._start - this._delay);\n      }\n    }\n\n    if (this._tTime !== _totalTime || !this._dur && !suppressEvents || this._initted && Math.abs(this._zTime) === _tinyNum || !_totalTime && !this._initted) {\n      this._ts || (this._pTime = _totalTime); // otherwise, if an animation is paused, then the playhead is moved back to zero, then resumed, it\'d revert back to the original time at the pause\n\n      _lazySafeRender(this, _totalTime, suppressEvents);\n    }\n\n    return this;\n  };\n\n  _proto.time = function time(value, suppressEvents) {\n    return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value + _elapsedCycleDuration(this)) % this._dur || (value ? this._dur : 0), suppressEvents) : this._time; // note: if the modulus results in 0, the playhead could be exactly at the end or the beginning, and we always defer to the END with a non-zero value, otherwise if you set the time() to the very end (duration()), it would render at the START!\n  };\n\n  _proto.totalProgress = function totalProgress(value, suppressEvents) {\n    return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio;\n  };\n\n  _proto.progress = function progress(value, suppressEvents) {\n    return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value : value) + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio;\n  };\n\n  _proto.iteration = function iteration(value, suppressEvents) {\n    var cycleDuration = this.duration() + this._rDelay;\n\n    return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1;\n  } // potential future addition:\n  // isPlayingBackwards() {\n  // \tlet animation = this,\n  // \t\torientation = 1; // 1 = forward, -1 = backward\n  // \twhile (animation) {\n  // \t\torientation *= animation.reversed() || (animation.repeat() && !(animation.iteration() & 1)) ? -1 : 1;\n  // \t\tanimation = animation.parent;\n  // \t}\n  // \treturn orientation < 0;\n  // }\n  ;\n\n  _proto.timeScale = function timeScale(value) {\n    if (!arguments.length) {\n      return this._rts === -_tinyNum ? 0 : this._rts; // recorded timeScale. Special case: if someone calls reverse() on an animation with timeScale of 0, we assign it -_tinyNum to remember it\'s reversed.\n    }\n\n    if (this._rts === value) {\n      return this;\n    }\n\n    var tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime; // make sure to do the parentToChildTotalTime() BEFORE setting the new _ts because the old one must be used in that calculation.\n    // prioritize rendering where the parent\'s playhead lines up instead of this._tTime because there could be a tween that\'s animating another tween\'s timeScale in the same rendering loop (same parent), thus if the timeScale tween renders first, it would alter _start BEFORE _tTime was set on that tick (in the rendering loop), effectively freezing it until the timeScale tween finishes.\n\n    this._rts = +value || 0;\n    this._ts = this._ps || value === -_tinyNum ? 0 : this._rts; // _ts is the functional timeScale which would be 0 if the animation is paused.\n\n    return _recacheAncestors(this.totalTime(_clamp(-this._delay, this._tDur, tTime), true));\n  };\n\n  _proto.paused = function paused(value) {\n    if (!arguments.length) {\n      return this._ps;\n    }\n\n    if (this._ps !== value) {\n      this._ps = value;\n\n      if (value) {\n        this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()); // if the pause occurs during the delay phase, make sure that\'s factored in when resuming.\n\n        this._ts = this._act = 0; // _ts is the functional timeScale, so a paused tween would effectively have a timeScale of 0. We record the "real" timeScale as _rts (recorded time scale)\n      } else {\n        _wake();\n\n        this._ts = this._rts; //only defer to _pTime (pauseTime) if tTime is zero. Remember, someone could pause() an animation, then scrub the playhead and resume(). If the parent doesn\'t have smoothChildTiming, we render at the rawTime() because the startTime won\'t get updated.\n\n        this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && (this._tTime -= _tinyNum) && Math.abs(this._zTime) !== _tinyNum); // edge case: animation.progress(1).pause().play() wouldn\'t render again because the playhead is already at the end, but the call to totalTime() below will add it back to its parent...and not remove it again (since removing only happens upon rendering at a new time). Offsetting the _tTime slightly is done simply to cause the final render in totalTime() that\'ll pop it off its timeline (if autoRemoveChildren is true, of course). Check to make sure _zTime isn\'t -_tinyNum to avoid an edge case where the playhead is pushed to the end but INSIDE a tween/callback, the timeline itself is paused thus halting rendering and leaving a few unrendered. When resuming, it wouldn\'t render those otherwise.\n      }\n    }\n\n    return this;\n  };\n\n  _proto.startTime = function startTime(value) {\n    if (arguments.length) {\n      this._start = value;\n      var parent = this.parent || this._dp;\n      parent && (parent._sort || !this.parent) && _addToTimeline(parent, this, value - this._delay);\n      return this;\n    }\n\n    return this._start;\n  };\n\n  _proto.endTime = function endTime(includeRepeats) {\n    return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts);\n  };\n\n  _proto.rawTime = function rawTime(wrapRepeats) {\n    var parent = this.parent || this._dp; // _dp = detatched parent\n\n    return !parent ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent.rawTime(wrapRepeats), this);\n  };\n\n  _proto.globalTime = function globalTime(rawTime) {\n    var animation = this,\n        time = arguments.length ? rawTime : animation.rawTime();\n\n    while (animation) {\n      time = animation._start + time / (animation._ts || 1);\n      animation = animation._dp;\n    }\n\n    return time;\n  };\n\n  _proto.repeat = function repeat(value) {\n    if (arguments.length) {\n      this._repeat = value;\n      return _onUpdateTotalDuration(this);\n    }\n\n    return this._repeat;\n  };\n\n  _proto.repeatDelay = function repeatDelay(value) {\n    if (arguments.length) {\n      this._rDelay = value;\n      return _onUpdateTotalDuration(this);\n    }\n\n    return this._rDelay;\n  };\n\n  _proto.yoyo = function yoyo(value) {\n    if (arguments.length) {\n      this._yoyo = value;\n      return this;\n    }\n\n    return this._yoyo;\n  };\n\n  _proto.seek = function seek(position, suppressEvents) {\n    return this.totalTime(_parsePosition(this, position), _isNotFalse(suppressEvents));\n  };\n\n  _proto.restart = function restart(includeDelay, suppressEvents) {\n    return this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents));\n  };\n\n  _proto.play = function play(from, suppressEvents) {\n    if (from != null) {\n      this.seek(from, suppressEvents);\n    }\n\n    return this.reversed(false).paused(false);\n  };\n\n  _proto.reverse = function reverse(from, suppressEvents) {\n    if (from != null) {\n      this.seek(from || this.totalDuration(), suppressEvents);\n    }\n\n    return this.reversed(true).paused(false);\n  };\n\n  _proto.pause = function pause(atTime, suppressEvents) {\n    if (atTime != null) {\n      this.seek(atTime, suppressEvents);\n    }\n\n    return this.paused(true);\n  };\n\n  _proto.resume = function resume() {\n    return this.paused(false);\n  };\n\n  _proto.reversed = function reversed(value) {\n    if (arguments.length) {\n      if (!!value !== this.reversed()) {\n        this.timeScale(-this._rts || (value ? -_tinyNum : 0)); // in case timeScale is zero, reversing would have no effect so we use _tinyNum.\n      }\n\n      return this;\n    }\n\n    return this._rts < 0;\n  };\n\n  _proto.invalidate = function invalidate() {\n    this._initted = 0;\n    this._zTime = -_tinyNum;\n    return this;\n  };\n\n  _proto.isActive = function isActive() {\n    var parent = this.parent || this._dp,\n        start = this._start,\n        rawTime;\n    return !!(!parent || this._ts && this._initted && parent.isActive() && (rawTime = parent.rawTime(true)) >= start && rawTime < this.endTime(true) - _tinyNum);\n  };\n\n  _proto.eventCallback = function eventCallback(type, callback, params) {\n    var vars = this.vars;\n\n    if (arguments.length > 1) {\n      if (!callback) {\n        delete vars[type];\n      } else {\n        vars[type] = callback;\n\n        if (params) {\n          vars[type + "Params"] = params;\n        }\n\n        if (type === "onUpdate") {\n          this._onUpdate = callback;\n        }\n      }\n\n      return this;\n    }\n\n    return vars[type];\n  };\n\n  _proto.then = function then(onFulfilled) {\n    var self = this;\n    return new Promise(function (resolve) {\n      var f = _isFunction(onFulfilled) ? onFulfilled : _passThrough,\n          _resolve = function _resolve() {\n        var _then = self.then;\n        self.then = null; // temporarily null the then() method to avoid an infinite loop (see https://github.com/greensock/GSAP/issues/322)\n\n        _isFunction(f) && (f = f(self)) && (f.then || f === self) && (self.then = _then);\n        resolve(f);\n        self.then = _then;\n      };\n\n      if (self._initted && self.totalProgress() === 1 && self._ts >= 0 || !self._tTime && self._ts < 0) {\n        _resolve();\n      } else {\n        self._prom = _resolve;\n      }\n    });\n  };\n\n  _proto.kill = function kill() {\n    _interrupt(this);\n  };\n\n  return Animation;\n}();\n\n_setDefaults(Animation.prototype, {\n  _time: 0,\n  _start: 0,\n  _end: 0,\n  _tTime: 0,\n  _tDur: 0,\n  _dirty: 0,\n  _repeat: 0,\n  _yoyo: false,\n  parent: null,\n  _initted: false,\n  _rDelay: 0,\n  _ts: 1,\n  _dp: 0,\n  ratio: 0,\n  _zTime: -_tinyNum,\n  _prom: 0,\n  _ps: false,\n  _rts: 1\n});\n/*\n * -------------------------------------------------\n * TIMELINE\n * -------------------------------------------------\n */\n\n\nvar Timeline = /*#__PURE__*/function (_Animation) {\n  _inheritsLoose(Timeline, _Animation);\n\n  function Timeline(vars, time) {\n    var _this;\n\n    if (vars === void 0) {\n      vars = {};\n    }\n\n    _this = _Animation.call(this, vars, time) || this;\n    _this.labels = {};\n    _this.smoothChildTiming = !!vars.smoothChildTiming;\n    _this.autoRemoveChildren = !!vars.autoRemoveChildren;\n    _this._sort = _isNotFalse(vars.sortChildren);\n    _this.parent && _postAddChecks(_this.parent, _assertThisInitialized(_this));\n    vars.scrollTrigger && _scrollTrigger(_assertThisInitialized(_this), vars.scrollTrigger);\n    return _this;\n  }\n\n  var _proto2 = Timeline.prototype;\n\n  _proto2.to = function to(targets, vars, position) {\n    new Tween(targets, _parseVars(arguments, 0, this), _parsePosition(this, _isNumber(vars) ? arguments[3] : position));\n    return this;\n  };\n\n  _proto2.from = function from(targets, vars, position) {\n    new Tween(targets, _parseVars(arguments, 1, this), _parsePosition(this, _isNumber(vars) ? arguments[3] : position));\n    return this;\n  };\n\n  _proto2.fromTo = function fromTo(targets, fromVars, toVars, position) {\n    new Tween(targets, _parseVars(arguments, 2, this), _parsePosition(this, _isNumber(fromVars) ? arguments[4] : position));\n    return this;\n  };\n\n  _proto2.set = function set(targets, vars, position) {\n    vars.duration = 0;\n    vars.parent = this;\n    _inheritDefaults(vars).repeatDelay || (vars.repeat = 0);\n    vars.immediateRender = !!vars.immediateRender;\n    new Tween(targets, vars, _parsePosition(this, position), 1);\n    return this;\n  };\n\n  _proto2.call = function call(callback, params, position) {\n    return _addToTimeline(this, Tween.delayedCall(0, callback, params), _parsePosition(this, position));\n  } //ONLY for backward compatibility! Maybe delete?\n  ;\n\n  _proto2.staggerTo = function staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {\n    vars.duration = duration;\n    vars.stagger = vars.stagger || stagger;\n    vars.onComplete = onCompleteAll;\n    vars.onCompleteParams = onCompleteAllParams;\n    vars.parent = this;\n    new Tween(targets, vars, _parsePosition(this, position));\n    return this;\n  };\n\n  _proto2.staggerFrom = function staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {\n    vars.runBackwards = 1;\n    _inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);\n    return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams);\n  };\n\n  _proto2.staggerFromTo = function staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {\n    toVars.startAt = fromVars;\n    _inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);\n    return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams);\n  };\n\n  _proto2.render = function render(totalTime, suppressEvents, force) {\n    var prevTime = this._time,\n        tDur = this._dirty ? this.totalDuration() : this._tDur,\n        dur = this._dur,\n        tTime = this !== _globalTimeline && totalTime > tDur - _tinyNum && totalTime >= 0 ? tDur : totalTime < _tinyNum ? 0 : totalTime,\n        crossingStart = this._zTime < 0 !== totalTime < 0 && (this._initted || !dur),\n        time,\n        child,\n        next,\n        iteration,\n        cycleDuration,\n        prevPaused,\n        pauseTween,\n        timeScale,\n        prevStart,\n        prevIteration,\n        yoyo,\n        isYoyo;\n\n    if (tTime !== this._tTime || force || crossingStart) {\n      if (prevTime !== this._time && dur) {\n        //if totalDuration() finds a child with a negative startTime and smoothChildTiming is true, things get shifted around internally so we need to adjust the time accordingly. For example, if a tween starts at -30 we must shift EVERYTHING forward 30 seconds and move this timeline\'s startTime backward by 30 seconds so that things align with the playhead (no jump).\n        tTime += this._time - prevTime;\n        totalTime += this._time - prevTime;\n      }\n\n      time = tTime;\n      prevStart = this._start;\n      timeScale = this._ts;\n      prevPaused = !timeScale;\n\n      if (crossingStart) {\n        dur || (prevTime = this._zTime); //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline, we need to discern if events are suppressed so that when the playhead moves again (next time), it\'ll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there\'s a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.\n\n        (totalTime || !suppressEvents) && (this._zTime = totalTime);\n      }\n\n      if (this._repeat) {\n        //adjust the time for repeats and yoyos\n        yoyo = this._yoyo;\n        cycleDuration = dur + this._rDelay;\n        time = _round(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)\n\n        if (time > dur || tDur === tTime) {\n          time = dur;\n        }\n\n        iteration = ~~(tTime / cycleDuration);\n\n        if (iteration && iteration === tTime / cycleDuration) {\n          time = dur;\n          iteration--;\n        }\n\n        prevIteration = _animationCycle(this._tTime, cycleDuration);\n        !prevTime && this._tTime && prevIteration !== iteration && (prevIteration = iteration); // edge case - if someone does addPause() at the very beginning of a repeating timeline, that pause is technically at the same spot as the end which causes this._time to get set to 0 when the totalTime would normally place the playhead at the end. See https://greensock.com/forums/topic/23823-closing-nav-animation-not-working-on-ie-and-iphone-6-maybe-other-older-browser/?tab=comments#comment-113005\n\n        if (yoyo && iteration & 1) {\n          time = dur - time;\n          isYoyo = 1;\n        }\n        /*\n        make sure children at the end/beginning of the timeline are rendered properly. If, for example,\n        a 3-second long timeline rendered at 2.9 seconds previously, and now renders at 3.2 seconds (which\n        would get translated to 2.8 seconds if the timeline yoyos or 0.2 seconds if it just repeats), there\n        could be a callback or a short tween that\'s at 2.95 or 3 seconds in which wouldn\'t render. So\n        we need to push the timeline to the end (and/or beginning depending on its yoyo value). Also we must\n        ensure that zero-duration tweens at the very beginning or end of the Timeline work.\n        */\n\n\n        if (iteration !== prevIteration && !this._lock) {\n          var rewinding = yoyo && prevIteration & 1,\n              doesWrap = rewinding === (yoyo && iteration & 1);\n\n          if (iteration < prevIteration) {\n            rewinding = !rewinding;\n          }\n\n          prevTime = rewinding ? 0 : dur;\n          this._lock = 1;\n          this.render(prevTime || (isYoyo ? 0 : _round(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0;\n\n          if (!suppressEvents && this.parent) {\n            _callback(this, "onRepeat");\n          }\n\n          this.vars.repeatRefresh && !isYoyo && (this.invalidate()._lock = 1);\n\n          if (prevTime !== this._time || prevPaused !== !this._ts) {\n            return this;\n          }\n\n          if (doesWrap) {\n            this._lock = 2;\n            prevTime = rewinding ? dur + 0.0001 : -0.0001;\n            this.render(prevTime, true);\n            this.vars.repeatRefresh && !isYoyo && this.invalidate();\n          }\n\n          this._lock = 0;\n\n          if (!this._ts && !prevPaused) {\n            return this;\n          } //in order for yoyoEase to work properly when there\'s a stagger, we must swap out the ease in each sub-tween.\n\n\n          _propagateYoyoEase(this, isYoyo);\n        }\n      }\n\n      if (this._hasPause && !this._forcing && this._lock < 2) {\n        pauseTween = _findNextPauseTween(this, _round(prevTime), _round(time));\n\n        if (pauseTween) {\n          tTime -= time - (time = pauseTween._start);\n        }\n      }\n\n      this._tTime = tTime;\n      this._time = time;\n      this._act = !timeScale; //as long as it\'s not paused, force it to be active so that if the user renders independent of the parent timeline, it\'ll be forced to re-render on the next tick.\n\n      if (!this._initted) {\n        this._onUpdate = this.vars.onUpdate;\n        this._initted = 1;\n        this._zTime = totalTime;\n      }\n\n      if (!prevTime && time && !suppressEvents) {\n        _callback(this, "onStart");\n      }\n\n      if (time >= prevTime && totalTime >= 0) {\n        child = this._first;\n\n        while (child) {\n          next = child._next;\n\n          if ((child._act || time >= child._start) && child._ts && pauseTween !== child) {\n            if (child.parent !== this) {\n              // an extreme edge case - the child\'s render could do something like kill() the "next" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.\n              return this.render(totalTime, suppressEvents, force);\n            }\n\n            child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time - child._start) * child._ts, suppressEvents, force);\n\n            if (time !== this._time || !this._ts && !prevPaused) {\n              //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete\n              pauseTween = 0;\n              next && (tTime += this._zTime = -_tinyNum); // it didn\'t finish rendering, so flag zTime as negative so that so that the next time render() is called it\'ll be forced (to render any remaining children)\n\n              break;\n            }\n          }\n\n          child = next;\n        }\n      } else {\n        child = this._last;\n        var adjustedTime = totalTime < 0 ? totalTime : time; //when the playhead goes backward beyond the start of this timeline, we must pass that information down to the child animations so that zero-duration tweens know whether to render their starting or ending values.\n\n        while (child) {\n          next = child._prev;\n\n          if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {\n            if (child.parent !== this) {\n              // an extreme edge case - the child\'s render could do something like kill() the "next" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.\n              return this.render(totalTime, suppressEvents, force);\n            }\n\n            child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force);\n\n            if (time !== this._time || !this._ts && !prevPaused) {\n              //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete\n              pauseTween = 0;\n              next && (tTime += this._zTime = adjustedTime ? -_tinyNum : _tinyNum); // it didn\'t finish rendering, so adjust zTime so that so that the next time render() is called it\'ll be forced (to render any remaining children)\n\n              break;\n            }\n          }\n\n          child = next;\n        }\n      }\n\n      if (pauseTween && !suppressEvents) {\n        this.pause();\n        pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime = time >= prevTime ? 1 : -1;\n\n        if (this._ts) {\n          //the callback resumed playback! So since we may have held back the playhead due to where the pause is positioned, go ahead and jump to where it\'s SUPPOSED to be (if no pause happened).\n          this._start = prevStart; //if the pause was at an earlier time and the user resumed in the callback, it could reposition the timeline (changing its startTime), throwing things off slightly, so we make sure the _start doesn\'t shift.\n\n          _setEnd(this);\n\n          return this.render(totalTime, suppressEvents, force);\n        }\n      }\n\n      this._onUpdate && !suppressEvents && _callback(this, "onUpdate", true);\n      if (tTime === tDur && tDur >= this.totalDuration() || !tTime && prevTime) if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts)) if (!this._lock) {\n        (totalTime || !dur) && (tTime === tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don\'t remove if the timeline is reversed and the playhead isn\'t at 0, otherwise tl.progress(1).reverse() won\'t work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.\n\n        if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime)) {\n          _callback(this, tTime === tDur ? "onComplete" : "onReverseComplete", true);\n\n          this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();\n        }\n      }\n    }\n\n    return this;\n  };\n\n  _proto2.add = function add(child, position) {\n    var _this2 = this;\n\n    if (!_isNumber(position)) {\n      position = _parsePosition(this, position);\n    }\n\n    if (!(child instanceof Animation)) {\n      if (_isArray(child)) {\n        child.forEach(function (obj) {\n          return _this2.add(obj, position);\n        });\n        return _uncache(this);\n      }\n\n      if (_isString(child)) {\n        return this.addLabel(child, position);\n      }\n\n      if (_isFunction(child)) {\n        child = Tween.delayedCall(0, child);\n      } else {\n        return this;\n      }\n    }\n\n    return this !== child ? _addToTimeline(this, child, position) : this; //don\'t allow a timeline to be added to itself as a child!\n  };\n\n  _proto2.getChildren = function getChildren(nested, tweens, timelines, ignoreBeforeTime) {\n    if (nested === void 0) {\n      nested = true;\n    }\n\n    if (tweens === void 0) {\n      tweens = true;\n    }\n\n    if (timelines === void 0) {\n      timelines = true;\n    }\n\n    if (ignoreBeforeTime === void 0) {\n      ignoreBeforeTime = -_bigNum;\n    }\n\n    var a = [],\n        child = this._first;\n\n    while (child) {\n      if (child._start >= ignoreBeforeTime) {\n        if (child instanceof Tween) {\n          tweens && a.push(child);\n        } else {\n          timelines && a.push(child);\n          nested && a.push.apply(a, child.getChildren(true, tweens, timelines));\n        }\n      }\n\n      child = child._next;\n    }\n\n    return a;\n  };\n\n  _proto2.getById = function getById(id) {\n    var animations = this.getChildren(1, 1, 1),\n        i = animations.length;\n\n    while (i--) {\n      if (animations[i].vars.id === id) {\n        return animations[i];\n      }\n    }\n  };\n\n  _proto2.remove = function remove(child) {\n    if (_isString(child)) {\n      return this.removeLabel(child);\n    }\n\n    if (_isFunction(child)) {\n      return this.killTweensOf(child);\n    }\n\n    _removeLinkedListItem(this, child);\n\n    if (child === this._recent) {\n      this._recent = this._last;\n    }\n\n    return _uncache(this);\n  };\n\n  _proto2.totalTime = function totalTime(_totalTime2, suppressEvents) {\n    if (!arguments.length) {\n      return this._tTime;\n    }\n\n    this._forcing = 1;\n\n    if (!this._dp && this._ts) {\n      //special case for the global timeline (or any other that has no parent or detached parent).\n      this._start = _round(_ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts));\n    }\n\n    _Animation.prototype.totalTime.call(this, _totalTime2, suppressEvents);\n\n    this._forcing = 0;\n    return this;\n  };\n\n  _proto2.addLabel = function addLabel(label, position) {\n    this.labels[label] = _parsePosition(this, position);\n    return this;\n  };\n\n  _proto2.removeLabel = function removeLabel(label) {\n    delete this.labels[label];\n    return this;\n  };\n\n  _proto2.addPause = function addPause(position, callback, params) {\n    var t = Tween.delayedCall(0, callback || _emptyFunc, params);\n    t.data = "isPause";\n    this._hasPause = 1;\n    return _addToTimeline(this, t, _parsePosition(this, position));\n  };\n\n  _proto2.removePause = function removePause(position) {\n    var child = this._first;\n    position = _parsePosition(this, position);\n\n    while (child) {\n      if (child._start === position && child.data === "isPause") {\n        _removeFromParent(child);\n      }\n\n      child = child._next;\n    }\n  };\n\n  _proto2.killTweensOf = function killTweensOf(targets, props, onlyActive) {\n    var tweens = this.getTweensOf(targets, onlyActive),\n        i = tweens.length;\n\n    while (i--) {\n      _overwritingTween !== tweens[i] && tweens[i].kill(targets, props);\n    }\n\n    return this;\n  };\n\n  _proto2.getTweensOf = function getTweensOf(targets, onlyActive) {\n    var a = [],\n        parsedTargets = toArray(targets),\n        child = this._first,\n        isGlobalTime = _isNumber(onlyActive),\n        // a number is interpreted as a global time. If the animation spans\n    children;\n\n    while (child) {\n      if (child instanceof Tween) {\n        if (_arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || child._initted && child._ts) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive())) {\n          // note: if this is for overwriting, it should only be for tweens that aren\'t paused and are initted.\n          a.push(child);\n        }\n      } else if ((children = child.getTweensOf(parsedTargets, onlyActive)).length) {\n        a.push.apply(a, children);\n      }\n\n      child = child._next;\n    }\n\n    return a;\n  };\n\n  _proto2.tweenTo = function tweenTo(position, vars) {\n    vars = vars || {};\n\n    var tl = this,\n        endTime = _parsePosition(tl, position),\n        _vars = vars,\n        startAt = _vars.startAt,\n        _onStart = _vars.onStart,\n        onStartParams = _vars.onStartParams,\n        tween = Tween.to(tl, _setDefaults(vars, {\n      ease: "none",\n      lazy: false,\n      time: endTime,\n      duration: vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || _tinyNum,\n      onStart: function onStart() {\n        tl.pause();\n        var duration = vars.duration || Math.abs((endTime - tl._time) / tl.timeScale());\n        tween._dur !== duration && _setDuration(tween, duration).render(tween._time, true, true);\n        _onStart && _onStart.apply(tween, onStartParams || []); //in case the user had an onStart in the vars - we don\'t want to overwrite it.\n      }\n    }));\n\n    return tween;\n  };\n\n  _proto2.tweenFromTo = function tweenFromTo(fromPosition, toPosition, vars) {\n    return this.tweenTo(toPosition, _setDefaults({\n      startAt: {\n        time: _parsePosition(this, fromPosition)\n      }\n    }, vars));\n  };\n\n  _proto2.recent = function recent() {\n    return this._recent;\n  };\n\n  _proto2.nextLabel = function nextLabel(afterTime) {\n    if (afterTime === void 0) {\n      afterTime = this._time;\n    }\n\n    return _getLabelInDirection(this, _parsePosition(this, afterTime));\n  };\n\n  _proto2.previousLabel = function previousLabel(beforeTime) {\n    if (beforeTime === void 0) {\n      beforeTime = this._time;\n    }\n\n    return _getLabelInDirection(this, _parsePosition(this, beforeTime), 1);\n  };\n\n  _proto2.currentLabel = function currentLabel(value) {\n    return arguments.length ? this.seek(value, true) : this.previousLabel(this._time + _tinyNum);\n  };\n\n  _proto2.shiftChildren = function shiftChildren(amount, adjustLabels, ignoreBeforeTime) {\n    if (ignoreBeforeTime === void 0) {\n      ignoreBeforeTime = 0;\n    }\n\n    var child = this._first,\n        labels = this.labels,\n        p;\n\n    while (child) {\n      if (child._start >= ignoreBeforeTime) {\n        child._start += amount;\n      }\n\n      child = child._next;\n    }\n\n    if (adjustLabels) {\n      for (p in labels) {\n        if (labels[p] >= ignoreBeforeTime) {\n          labels[p] += amount;\n        }\n      }\n    }\n\n    return _uncache(this);\n  };\n\n  _proto2.invalidate = function invalidate() {\n    var child = this._first;\n    this._lock = 0;\n\n    while (child) {\n      child.invalidate();\n      child = child._next;\n    }\n\n    return _Animation.prototype.invalidate.call(this);\n  };\n\n  _proto2.clear = function clear(includeLabels) {\n    if (includeLabels === void 0) {\n      includeLabels = true;\n    }\n\n    var child = this._first,\n        next;\n\n    while (child) {\n      next = child._next;\n      this.remove(child);\n      child = next;\n    }\n\n    this._time = this._tTime = this._pTime = 0;\n\n    if (includeLabels) {\n      this.labels = {};\n    }\n\n    return _uncache(this);\n  };\n\n  _proto2.totalDuration = function totalDuration(value) {\n    var max = 0,\n        self = this,\n        child = self._last,\n        prevStart = _bigNum,\n        prev,\n        end,\n        start,\n        parent;\n\n    if (arguments.length) {\n      return self.timeScale((self._repeat < 0 ? self.duration() : self.totalDuration()) / (self.reversed() ? -value : value));\n    }\n\n    if (self._dirty) {\n      parent = self.parent;\n\n      while (child) {\n        prev = child._prev; //record it here in case the tween changes position in the sequence...\n\n        child._dirty && child.totalDuration(); //could change the tween._startTime, so make sure the animation\'s cache is clean before analyzing it.\n\n        start = child._start;\n\n        if (start > prevStart && self._sort && child._ts && !self._lock) {\n          //in case one of the tweens shifted out of order, it needs to be re-inserted into the correct position in the sequence\n          self._lock = 1; //prevent endless recursive calls - there are methods that get triggered that check duration/totalDuration when we add().\n\n          _addToTimeline(self, child, start - child._delay, 1)._lock = 0;\n        } else {\n          prevStart = start;\n        }\n\n        if (start < 0 && child._ts) {\n          //children aren\'t allowed to have negative startTimes unless smoothChildTiming is true, so adjust here if one is found.\n          max -= start;\n\n          if (!parent && !self._dp || parent && parent.smoothChildTiming) {\n            self._start += start / self._ts;\n            self._time -= start;\n            self._tTime -= start;\n          }\n\n          self.shiftChildren(-start, false, -1e999);\n          prevStart = 0;\n        }\n\n        end = _setEnd(child);\n\n        if (end > max && child._ts) {\n          max = end;\n        }\n\n        child = prev;\n      }\n\n      _setDuration(self, self === _globalTimeline && self._time > max ? self._time : max, 1);\n\n      self._dirty = 0;\n    }\n\n    return self._tDur;\n  };\n\n  Timeline.updateRoot = function updateRoot(time) {\n    if (_globalTimeline._ts) {\n      _lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline));\n\n      _lastRenderedFrame = _ticker.frame;\n    }\n\n    if (_ticker.frame >= _nextGCFrame) {\n      _nextGCFrame += _config.autoSleep || 120;\n      var child = _globalTimeline._first;\n      if (!child || !child._ts) if (_config.autoSleep && _ticker._listeners.length < 2) {\n        while (child && !child._ts) {\n          child = child._next;\n        }\n\n        child || _ticker.sleep();\n      }\n    }\n  };\n\n  return Timeline;\n}(Animation);\n\n_setDefaults(Timeline.prototype, {\n  _lock: 0,\n  _hasPause: 0,\n  _forcing: 0\n});\n\nvar _addComplexStringPropTween = function _addComplexStringPropTween(target, prop, start, end, setter, stringFilter, funcParam) {\n  //note: we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it\'s scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.\n  var pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter),\n      index = 0,\n      matchIndex = 0,\n      result,\n      startNums,\n      color,\n      endNum,\n      chunk,\n      startNum,\n      hasRandom,\n      a;\n  pt.b = start;\n  pt.e = end;\n  start += ""; //ensure values are strings\n\n  end += "";\n\n  if (hasRandom = ~end.indexOf("random(")) {\n    end = _replaceRandom(end);\n  }\n\n  if (stringFilter) {\n    a = [start, end];\n    stringFilter(a, target, prop); //pass an array with the starting and ending values and let the filter do whatever it needs to the values.\n\n    start = a[0];\n    end = a[1];\n  }\n\n  startNums = start.match(_complexStringNumExp) || [];\n\n  while (result = _complexStringNumExp.exec(end)) {\n    endNum = result[0];\n    chunk = end.substring(index, result.index);\n\n    if (color) {\n      color = (color + 1) % 5;\n    } else if (chunk.substr(-5) === "rgba(") {\n      color = 1;\n    }\n\n    if (endNum !== startNums[matchIndex++]) {\n      startNum = parseFloat(startNums[matchIndex - 1]) || 0; //these nested PropTweens are handled in a special way - we\'ll never actually call a render or setter method on them. We\'ll just loop through them in the parent complex string PropTween\'s render method.\n\n      pt._pt = {\n        _next: pt._pt,\n        p: chunk || matchIndex === 1 ? chunk : ",",\n        //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.\n        s: startNum,\n        c: endNum.charAt(1) === "=" ? parseFloat(endNum.substr(2)) * (endNum.charAt(0) === "-" ? -1 : 1) : parseFloat(endNum) - startNum,\n        m: color && color < 4 ? Math.round : 0\n      };\n      index = _complexStringNumExp.lastIndex;\n    }\n  }\n\n  pt.c = index < end.length ? end.substring(index, end.length) : ""; //we use the "c" of the PropTween to store the final part of the string (after the last number)\n\n  pt.fp = funcParam;\n\n  if (_relExp.test(end) || hasRandom) {\n    pt.e = 0; //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don\'t actually set it to the string with += or -= characters (forces it to use the calculated value).\n  }\n\n  this._pt = pt; //start the linked list with this new PropTween. Remember, we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it\'s scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.\n\n  return pt;\n},\n    _addPropTween = function _addPropTween(target, prop, start, end, index, targets, modifier, stringFilter, funcParam) {\n  _isFunction(end) && (end = end(index || 0, target, targets));\n  var currentValue = target[prop],\n      parsedStart = start !== "get" ? start : !_isFunction(currentValue) ? currentValue : funcParam ? target[prop.indexOf("set") || !_isFunction(target["get" + prop.substr(3)]) ? prop : "get" + prop.substr(3)](funcParam) : target[prop](),\n      setter = !_isFunction(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc,\n      pt;\n\n  if (_isString(end)) {\n    if (~end.indexOf("random(")) {\n      end = _replaceRandom(end);\n    }\n\n    if (end.charAt(1) === "=") {\n      end = parseFloat(parsedStart) + parseFloat(end.substr(2)) * (end.charAt(0) === "-" ? -1 : 1) + (getUnit(parsedStart) || 0);\n    }\n  }\n\n  if (parsedStart !== end) {\n    if (!isNaN(parsedStart * end)) {\n      pt = new PropTween(this._pt, target, prop, +parsedStart || 0, end - (parsedStart || 0), typeof currentValue === "boolean" ? _renderBoolean : _renderPlain, 0, setter);\n      funcParam && (pt.fp = funcParam);\n      modifier && pt.modifier(modifier, this, target);\n      return this._pt = pt;\n    }\n\n    !currentValue && !(prop in target) && _missingPlugin(prop, end);\n    return _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config.stringFilter, funcParam);\n  }\n},\n    //creates a copy of the vars object and processes any function-based values (putting the resulting values directly into the copy) as well as strings with "random()" in them. It does NOT process relative values.\n_processVars = function _processVars(vars, index, target, targets, tween) {\n  if (_isFunction(vars)) {\n    vars = _parseFuncOrString(vars, tween, index, target, targets);\n  }\n\n  if (!_isObject(vars) || vars.style && vars.nodeType || _isArray(vars)) {\n    return _isString(vars) ? _parseFuncOrString(vars, tween, index, target, targets) : vars;\n  }\n\n  var copy = {},\n      p;\n\n  for (p in vars) {\n    copy[p] = _parseFuncOrString(vars[p], tween, index, target, targets);\n  }\n\n  return copy;\n},\n    _checkPlugin = function _checkPlugin(property, vars, tween, index, target, targets) {\n  var plugin, pt, ptLookup, i;\n\n  if (_plugins[property] && (plugin = new _plugins[property]()).init(target, plugin.rawVars ? vars[property] : _processVars(vars[property], index, target, targets, tween), tween, index, targets) !== false) {\n    tween._pt = pt = new PropTween(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority);\n\n    if (tween !== _quickTween) {\n      ptLookup = tween._ptLookup[tween._targets.indexOf(target)]; //note: we can\'t use tween._ptLookup[index] because for staggered tweens, the index from the fullTargets array won\'t match what it is in each individual tween that spawns from the stagger.\n\n      i = plugin._props.length;\n\n      while (i--) {\n        ptLookup[plugin._props[i]] = pt;\n      }\n    }\n  }\n\n  return plugin;\n},\n    _overwritingTween,\n    //store a reference temporarily so we can avoid overwriting itself.\n_initTween = function _initTween(tween, time) {\n  var vars = tween.vars,\n      ease = vars.ease,\n      startAt = vars.startAt,\n      immediateRender = vars.immediateRender,\n      lazy = vars.lazy,\n      onUpdate = vars.onUpdate,\n      onUpdateParams = vars.onUpdateParams,\n      callbackScope = vars.callbackScope,\n      runBackwards = vars.runBackwards,\n      yoyoEase = vars.yoyoEase,\n      keyframes = vars.keyframes,\n      autoRevert = vars.autoRevert,\n      dur = tween._dur,\n      prevStartAt = tween._startAt,\n      targets = tween._targets,\n      parent = tween.parent,\n      fullTargets = parent && parent.data === "nested" ? parent.parent._targets : targets,\n      autoOverwrite = tween._overwrite === "auto",\n      tl = tween.timeline,\n      cleanVars,\n      i,\n      p,\n      pt,\n      target,\n      hasPriority,\n      gsData,\n      harness,\n      plugin,\n      ptLookup,\n      index,\n      harnessVars,\n      overwritten;\n  tl && (!keyframes || !ease) && (ease = "none");\n  tween._ease = _parseEase(ease, _defaults.ease);\n  tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease : yoyoEase, _defaults.ease)) : 0;\n\n  if (yoyoEase && tween._yoyo && !tween._repeat) {\n    //there must have been a parent timeline with yoyo:true that is currently in its yoyo phase, so flip the eases.\n    yoyoEase = tween._yEase;\n    tween._yEase = tween._ease;\n    tween._ease = yoyoEase;\n  }\n\n  if (!tl) {\n    //if there\'s an internal timeline, skip all the parsing because we passed that task down the chain.\n    harness = targets[0] ? _getCache(targets[0]).harness : 0;\n    harnessVars = harness && vars[harness.prop]; //someone may need to specify CSS-specific values AND non-CSS values, like if the element has an "x" property plus it\'s a standard DOM element. We allow people to distinguish by wrapping plugin-specific stuff in a css:{} object for example.\n\n    cleanVars = _copyExcluding(vars, _reservedProps);\n    prevStartAt && prevStartAt.render(-1, true).kill();\n\n    if (startAt) {\n      _removeFromParent(tween._startAt = Tween.set(targets, _setDefaults({\n        data: "isStart",\n        overwrite: false,\n        parent: parent,\n        immediateRender: true,\n        lazy: _isNotFalse(lazy),\n        startAt: null,\n        delay: 0,\n        onUpdate: onUpdate,\n        onUpdateParams: onUpdateParams,\n        callbackScope: callbackScope,\n        stagger: 0\n      }, startAt))); //copy the properties/values into a new object to avoid collisions, like var to = {x:0}, from = {x:500}; timeline.fromTo(e, from, to).fromTo(e, to, from);\n\n\n      if (immediateRender) {\n        if (time > 0) {\n          !autoRevert && (tween._startAt = 0); //tweens that render immediately (like most from() and fromTo() tweens) shouldn\'t revert when their parent timeline\'s playhead goes backward past the startTime because the initial render could have happened anytime and it shouldn\'t be directly correlated to this tween\'s startTime. Imagine setting up a complex animation where the beginning states of various objects are rendered immediately but the tween doesn\'t happen for quite some time - if we revert to the starting values as soon as the playhead goes backward past the tween\'s startTime, it will throw things off visually. Reversion should only happen in Timeline instances where immediateRender was false or when autoRevert is explicitly set to true.\n        } else if (dur && !(time < 0 && prevStartAt)) {\n          tween._zTime = time;\n          return; //we skip initialization here so that overwriting doesn\'t occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a Timeline, the last one created would overwrite the first ones because they didn\'t get placed into the timeline yet before the first render occurs and kicks in overwriting.\n        }\n      }\n    } else if (runBackwards && dur) {\n      //from() tweens must be handled uniquely: their beginning values must be rendered but we don\'t want overwriting to occur yet (when time is still 0). Wait until the tween actually begins before doing all the routines like overwriting. At that time, we should render at the END of the tween to ensure that things initialize correctly (remember, from() tweens go backwards)\n      if (prevStartAt) {\n        !autoRevert && (tween._startAt = 0);\n      } else {\n        time && (immediateRender = false); //in rare cases (like if a from() tween runs and then is invalidate()-ed), immediateRender could be true but the initial forced-render gets skipped, so there\'s no need to force the render in this context when the _time is greater than 0\n\n        p = _setDefaults({\n          overwrite: false,\n          data: "isFromStart",\n          //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that\'s setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it\'d kick back in.\n          lazy: immediateRender && _isNotFalse(lazy),\n          immediateRender: immediateRender,\n          //zero-duration tweens render immediately by default, but if we\'re not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we\'d have to render(-1) immediately after)\n          stagger: 0,\n          parent: parent //ensures that nested tweens that had a stagger are handled properly, like gsap.from(".class", {y:gsap.utils.wrap([-100,100])})\n\n        }, cleanVars);\n        harnessVars && (p[harness.prop] = harnessVars); // in case someone does something like .from(..., {css:{}})\n\n        _removeFromParent(tween._startAt = Tween.set(targets, p));\n\n        if (!immediateRender) {\n          _initTween(tween._startAt, _tinyNum); //ensures that the initial values are recorded\n\n        } else if (!time) {\n          return;\n        }\n      }\n    }\n\n    tween._pt = 0;\n    lazy = dur && _isNotFalse(lazy) || lazy && !dur;\n\n    for (i = 0; i < targets.length; i++) {\n      target = targets[i];\n      gsData = target._gsap || _harness(targets)[i]._gsap;\n      tween._ptLookup[i] = ptLookup = {};\n      _lazyLookup[gsData.id] && _lazyRender(); //if other tweens of the same target have recently initted but haven\'t rendered yet, we\'ve got to force the render so that the starting values are correct (imagine populating a timeline with a bunch of sequential tweens and then jumping to the end)\n\n      index = fullTargets === targets ? i : fullTargets.indexOf(target);\n\n      if (harness && (plugin = new harness()).init(target, harnessVars || cleanVars, tween, index, fullTargets) !== false) {\n        tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);\n\n        plugin._props.forEach(function (name) {\n          ptLookup[name] = pt;\n        });\n\n        plugin.priority && (hasPriority = 1);\n      }\n\n      if (!harness || harnessVars) {\n        for (p in cleanVars) {\n          if (_plugins[p] && (plugin = _checkPlugin(p, cleanVars, tween, index, target, fullTargets))) {\n            plugin.priority && (hasPriority = 1);\n          } else {\n            ptLookup[p] = pt = _addPropTween.call(tween, target, p, "get", cleanVars[p], index, fullTargets, 0, vars.stringFilter);\n          }\n        }\n      }\n\n      tween._op && tween._op[i] && tween.kill(target, tween._op[i]);\n\n      if (autoOverwrite && tween._pt) {\n        _overwritingTween = tween;\n\n        _globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(0)); //Also make sure the overwriting doesn\'t overwrite THIS tween!!!\n\n\n        overwritten = !tween.parent;\n        _overwritingTween = 0;\n      }\n\n      tween._pt && lazy && (_lazyLookup[gsData.id] = 1);\n    }\n\n    hasPriority && _sortPropTweensByPriority(tween);\n    tween._onInit && tween._onInit(tween); //plugins like RoundProps must wait until ALL of the PropTweens are instantiated. In the plugin\'s init() function, it sets the _onInit on the tween instance. May not be pretty/intuitive, but it\'s fast and keeps file size down.\n  }\n\n  tween._from = !tl && !!vars.runBackwards; //nested timelines should never run backwards - the backwards-ness is in the child tweens.\n\n  tween._onUpdate = onUpdate;\n  tween._initted = (!tween._op || tween._pt) && !overwritten; // if overwrittenProps resulted in the entire tween being killed, do NOT flag it as initted or else it may render for one tick.\n},\n    _addAliasesToVars = function _addAliasesToVars(targets, vars) {\n  var harness = targets[0] ? _getCache(targets[0]).harness : 0,\n      propertyAliases = harness && harness.aliases,\n      copy,\n      p,\n      i,\n      aliases;\n\n  if (!propertyAliases) {\n    return vars;\n  }\n\n  copy = _merge({}, vars);\n\n  for (p in propertyAliases) {\n    if (p in copy) {\n      aliases = propertyAliases[p].split(",");\n      i = aliases.length;\n\n      while (i--) {\n        copy[aliases[i]] = copy[p];\n      }\n    }\n  }\n\n  return copy;\n},\n    _parseFuncOrString = function _parseFuncOrString(value, tween, i, target, targets) {\n  return _isFunction(value) ? value.call(tween, i, target, targets) : _isString(value) && ~value.indexOf("random(") ? _replaceRandom(value) : value;\n},\n    _staggerTweenProps = _callbackNames + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase",\n    _staggerPropsToSkip = (_staggerTweenProps + ",id,stagger,delay,duration,paused,scrollTrigger").split(",");\n/*\n * --------------------------------------------------------------------------------------\n * TWEEN\n * --------------------------------------------------------------------------------------\n */\n\n\nvar Tween = /*#__PURE__*/function (_Animation2) {\n  _inheritsLoose(Tween, _Animation2);\n\n  function Tween(targets, vars, time, skipInherit) {\n    var _this3;\n\n    if (typeof vars === "number") {\n      time.duration = vars;\n      vars = time;\n      time = null;\n    }\n\n    _this3 = _Animation2.call(this, skipInherit ? vars : _inheritDefaults(vars), time) || this;\n    var _this3$vars = _this3.vars,\n        duration = _this3$vars.duration,\n        delay = _this3$vars.delay,\n        immediateRender = _this3$vars.immediateRender,\n        stagger = _this3$vars.stagger,\n        overwrite = _this3$vars.overwrite,\n        keyframes = _this3$vars.keyframes,\n        defaults = _this3$vars.defaults,\n        scrollTrigger = _this3$vars.scrollTrigger,\n        yoyoEase = _this3$vars.yoyoEase,\n        parent = _this3.parent,\n        parsedTargets = (_isArray(targets) ? _isNumber(targets[0]) : "length" in vars) ? [targets] : toArray(targets),\n        tl,\n        i,\n        copy,\n        l,\n        p,\n        curTarget,\n        staggerFunc,\n        staggerVarsToMerge;\n    _this3._targets = parsedTargets.length ? _harness(parsedTargets) : _warn("GSAP target " + targets + " not found. https://greensock.com", !_config.nullTargetWarn) || [];\n    _this3._ptLookup = []; //PropTween lookup. An array containing an object for each target, having keys for each tweening property\n\n    _this3._overwrite = overwrite;\n\n    if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {\n      vars = _this3.vars;\n      tl = _this3.timeline = new Timeline({\n        data: "nested",\n        defaults: defaults || {}\n      });\n      tl.kill();\n      tl.parent = _assertThisInitialized(_this3);\n\n      if (keyframes) {\n        _setDefaults(tl.vars.defaults, {\n          ease: "none"\n        });\n\n        keyframes.forEach(function (frame) {\n          return tl.to(parsedTargets, frame, ">");\n        });\n      } else {\n        l = parsedTargets.length;\n        staggerFunc = stagger ? distribute(stagger) : _emptyFunc;\n\n        if (_isObject(stagger)) {\n          //users can pass in callbacks like onStart/onComplete in the stagger object. These should fire with each individual tween.\n          for (p in stagger) {\n            if (~_staggerTweenProps.indexOf(p)) {\n              staggerVarsToMerge || (staggerVarsToMerge = {});\n              staggerVarsToMerge[p] = stagger[p];\n            }\n          }\n        }\n\n        for (i = 0; i < l; i++) {\n          copy = {};\n\n          for (p in vars) {\n            if (_staggerPropsToSkip.indexOf(p) < 0) {\n              copy[p] = vars[p];\n            }\n          }\n\n          copy.stagger = 0;\n          yoyoEase && (copy.yoyoEase = yoyoEase);\n          staggerVarsToMerge && _merge(copy, staggerVarsToMerge);\n          curTarget = parsedTargets[i]; //don\'t just copy duration or delay because if they\'re a string or function, we\'d end up in an infinite loop because _isFuncOrString() would evaluate as true in the child tweens, entering this loop, etc. So we parse the value straight from vars and default to 0.\n\n          copy.duration = +_parseFuncOrString(duration, _assertThisInitialized(_this3), i, curTarget, parsedTargets);\n          copy.delay = (+_parseFuncOrString(delay, _assertThisInitialized(_this3), i, curTarget, parsedTargets) || 0) - _this3._delay;\n\n          if (!stagger && l === 1 && copy.delay) {\n            // if someone does delay:"random(1, 5)", repeat:-1, for example, the delay shouldn\'t be inside the repeat.\n            _this3._delay = delay = copy.delay;\n            _this3._start += delay;\n            copy.delay = 0;\n          }\n\n          tl.to(curTarget, copy, staggerFunc(i, curTarget, parsedTargets));\n        }\n\n        tl.duration() ? duration = delay = 0 : _this3.timeline = 0; // if the timeline\'s duration is 0, we don\'t need a timeline internally!\n      }\n\n      duration || _this3.duration(duration = tl.duration());\n    } else {\n      _this3.timeline = 0; //speed optimization, faster lookups (no going up the prototype chain)\n    }\n\n    if (overwrite === true) {\n      _overwritingTween = _assertThisInitialized(_this3);\n\n      _globalTimeline.killTweensOf(parsedTargets);\n\n      _overwritingTween = 0;\n    }\n\n    parent && _postAddChecks(parent, _assertThisInitialized(_this3));\n\n    if (immediateRender || !duration && !keyframes && _this3._start === _round(parent._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors(_assertThisInitialized(_this3)) && parent.data !== "nested") {\n      _this3._tTime = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)\n\n      _this3.render(Math.max(0, -delay)); //in case delay is negative\n\n    }\n\n    scrollTrigger && _scrollTrigger(_assertThisInitialized(_this3), scrollTrigger);\n    return _this3;\n  }\n\n  var _proto3 = Tween.prototype;\n\n  _proto3.render = function render(totalTime, suppressEvents, force) {\n    var prevTime = this._time,\n        tDur = this._tDur,\n        dur = this._dur,\n        tTime = totalTime > tDur - _tinyNum && totalTime >= 0 ? tDur : totalTime < _tinyNum ? 0 : totalTime,\n        time,\n        pt,\n        iteration,\n        cycleDuration,\n        prevIteration,\n        isYoyo,\n        ratio,\n        timeline,\n        yoyoEase;\n\n    if (!dur) {\n      _renderZeroDurationTween(this, totalTime, suppressEvents, force);\n    } else if (tTime !== this._tTime || !totalTime || force || this._startAt && this._zTime < 0 !== totalTime < 0) {\n      //this senses if we\'re crossing over the start time, in which case we must record _zTime and force the render, but we do it in this lengthy conditional way for performance reasons (usually we can skip the calculations): this._initted && (this._zTime < 0) !== (totalTime < 0)\n      time = tTime;\n      timeline = this.timeline;\n\n      if (this._repeat) {\n        //adjust the time for repeats and yoyos\n        cycleDuration = dur + this._rDelay;\n        time = _round(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)\n\n        if (time > dur || tDur === tTime) {\n          // the tDur === tTime is for edge cases where there\'s a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn\'t)\n          time = dur;\n        }\n\n        iteration = ~~(tTime / cycleDuration);\n\n        if (iteration && iteration === tTime / cycleDuration) {\n          time = dur;\n          iteration--;\n        }\n\n        isYoyo = this._yoyo && iteration & 1;\n\n        if (isYoyo) {\n          yoyoEase = this._yEase;\n          time = dur - time;\n        }\n\n        prevIteration = _animationCycle(this._tTime, cycleDuration);\n\n        if (time === prevTime && !force && this._initted) {\n          //could be during the repeatDelay part. No need to render and fire callbacks.\n          return this;\n        }\n\n        if (iteration !== prevIteration) {\n          timeline && this._yEase && _propagateYoyoEase(timeline, isYoyo); //repeatRefresh functionality\n\n          if (this.vars.repeatRefresh && !isYoyo && !this._lock) {\n            this._lock = force = 1; //force, otherwise if lazy is true, the _attemptInitTween() will return and we\'ll jump out and get caught bouncing on each tick.\n\n            this.render(_round(cycleDuration * iteration), true).invalidate()._lock = 0;\n          }\n        }\n      }\n\n      if (!this._initted) {\n        if (_attemptInitTween(this, totalTime < 0 ? totalTime : time, force, suppressEvents)) {\n          this._tTime = 0; // in constructor if immediateRender is true, we set _tTime to -_tinyNum to have the playhead cross the starting point but we can\'t leave _tTime as a negative number.\n\n          return this;\n        }\n\n        if (dur !== this._dur) {\n          // while initting, a plugin like InertiaPlugin might alter the duration, so rerun from the start to ensure everything renders as it should.\n          return this.render(totalTime, suppressEvents, force);\n        }\n      }\n\n      this._tTime = tTime;\n      this._time = time;\n\n      if (!this._act && this._ts) {\n        this._act = 1; //as long as it\'s not paused, force it to be active so that if the user renders independent of the parent timeline, it\'ll be forced to re-render on the next tick.\n\n        this._lazy = 0;\n      }\n\n      this.ratio = ratio = (yoyoEase || this._ease)(time / dur);\n\n      if (this._from) {\n        this.ratio = ratio = 1 - ratio;\n      }\n\n      time && !prevTime && !suppressEvents && _callback(this, "onStart");\n      pt = this._pt;\n\n      while (pt) {\n        pt.r(ratio, pt.d);\n        pt = pt._next;\n      }\n\n      timeline && timeline.render(totalTime < 0 ? totalTime : !time && isYoyo ? -_tinyNum : timeline._dur * ratio, suppressEvents, force) || this._startAt && (this._zTime = totalTime);\n\n      if (this._onUpdate && !suppressEvents) {\n        if (totalTime < 0 && this._startAt) {\n          this._startAt.render(totalTime, true, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don\'t have an onUpdate). We\'d just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it\'s not called, we do so later near the onComplete.\n\n        }\n\n        _callback(this, "onUpdate");\n      }\n\n      this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback(this, "onRepeat");\n\n      if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {\n        totalTime < 0 && this._startAt && !this._onUpdate && this._startAt.render(totalTime, true, true);\n        (totalTime || !dur) && (tTime === this._tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don\'t remove if we\'re rendering at exactly a time of 0, as there could be autoRevert values that should get set on the next tick (if the playhead goes backward beyond the startTime, negative totalTime). Don\'t remove if the timeline is reversed and the playhead isn\'t at 0, otherwise tl.progress(1).reverse() won\'t work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.\n\n        if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime)) {\n          // if prevTime and tTime are zero, we shouldn\'t fire the onReverseComplete. This could happen if you gsap.to(... {paused:true}).play();\n          _callback(this, tTime === tDur ? "onComplete" : "onReverseComplete", true);\n\n          this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();\n        }\n      }\n    }\n\n    return this;\n  };\n\n  _proto3.targets = function targets() {\n    return this._targets;\n  };\n\n  _proto3.invalidate = function invalidate() {\n    this._pt = this._op = this._startAt = this._onUpdate = this._act = this._lazy = 0;\n    this._ptLookup = [];\n    this.timeline && this.timeline.invalidate();\n    return _Animation2.prototype.invalidate.call(this);\n  };\n\n  _proto3.kill = function kill(targets, vars) {\n    if (vars === void 0) {\n      vars = "all";\n    }\n\n    if (!targets && (!vars || vars === "all")) {\n      this._lazy = 0;\n\n      if (this.parent) {\n        return _interrupt(this);\n      }\n    }\n\n    if (this.timeline) {\n      var tDur = this.timeline.totalDuration();\n      this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== true)._first || _interrupt(this); // if nothing is left tweenng, interrupt.\n\n      this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur); // if a nested tween is killed that changes the duration, it should affect this tween\'s duration. We must use the ratio, though, because sometimes the internal timeline is stretched like for keyframes where they don\'t all add up to whatever the parent tween\'s duration was set to.\n\n      return this;\n    }\n\n    var parsedTargets = this._targets,\n        killingTargets = targets ? toArray(targets) : parsedTargets,\n        propTweenLookup = this._ptLookup,\n        firstPT = this._pt,\n        overwrittenProps,\n        curLookup,\n        curOverwriteProps,\n        props,\n        p,\n        pt,\n        i;\n\n    if ((!vars || vars === "all") && _arraysMatch(parsedTargets, killingTargets)) {\n      vars === "all" && (this._pt = 0);\n      return _interrupt(this);\n    }\n\n    overwrittenProps = this._op = this._op || [];\n\n    if (vars !== "all") {\n      //so people can pass in a comma-delimited list of property names\n      if (_isString(vars)) {\n        p = {};\n\n        _forEachName(vars, function (name) {\n          return p[name] = 1;\n        });\n\n        vars = p;\n      }\n\n      vars = _addAliasesToVars(parsedTargets, vars);\n    }\n\n    i = parsedTargets.length;\n\n    while (i--) {\n      if (~killingTargets.indexOf(parsedTargets[i])) {\n        curLookup = propTweenLookup[i];\n\n        if (vars === "all") {\n          overwrittenProps[i] = vars;\n          props = curLookup;\n          curOverwriteProps = {};\n        } else {\n          curOverwriteProps = overwrittenProps[i] = overwrittenProps[i] || {};\n          props = vars;\n        }\n\n        for (p in props) {\n          pt = curLookup && curLookup[p];\n\n          if (pt) {\n            if (!("kill" in pt.d) || pt.d.kill(p) === true) {\n              _removeLinkedListItem(this, pt, "_pt");\n            }\n\n            delete curLookup[p];\n          }\n\n          if (curOverwriteProps !== "all") {\n            curOverwriteProps[p] = 1;\n          }\n        }\n      }\n    }\n\n    this._initted && !this._pt && firstPT && _interrupt(this); //if all tweening properties are killed, kill the tween. Without this line, if there\'s a tween with multiple targets and then you killTweensOf() each target individually, the tween would technically still remain active and fire its onComplete even though there aren\'t any more properties tweening.\n\n    return this;\n  };\n\n  Tween.to = function to(targets, vars) {\n    return new Tween(targets, vars, arguments[2]);\n  };\n\n  Tween.from = function from(targets, vars) {\n    return new Tween(targets, _parseVars(arguments, 1));\n  };\n\n  Tween.delayedCall = function delayedCall(delay, callback, params, scope) {\n    return new Tween(callback, 0, {\n      immediateRender: false,\n      lazy: false,\n      overwrite: false,\n      delay: delay,\n      onComplete: callback,\n      onReverseComplete: callback,\n      onCompleteParams: params,\n      onReverseCompleteParams: params,\n      callbackScope: scope\n    });\n  };\n\n  Tween.fromTo = function fromTo(targets, fromVars, toVars) {\n    return new Tween(targets, _parseVars(arguments, 2));\n  };\n\n  Tween.set = function set(targets, vars) {\n    vars.duration = 0;\n    vars.repeatDelay || (vars.repeat = 0);\n    return new Tween(targets, vars);\n  };\n\n  Tween.killTweensOf = function killTweensOf(targets, props, onlyActive) {\n    return _globalTimeline.killTweensOf(targets, props, onlyActive);\n  };\n\n  return Tween;\n}(Animation);\n\n_setDefaults(Tween.prototype, {\n  _targets: [],\n  _lazy: 0,\n  _startAt: 0,\n  _op: 0,\n  _onInit: 0\n}); //add the pertinent timeline methods to Tween instances so that users can chain conveniently and create a timeline automatically. (removed due to concerns that it\'d ultimately add to more confusion especially for beginners)\n// _forEachName("to,from,fromTo,set,call,add,addLabel,addPause", name => {\n// \tTween.prototype[name] = function() {\n// \t\tlet tl = new Timeline();\n// \t\treturn _addToTimeline(tl, this)[name].apply(tl, toArray(arguments));\n// \t}\n// });\n//for backward compatibility. Leverage the timeline calls.\n\n\n_forEachName("staggerTo,staggerFrom,staggerFromTo", function (name) {\n  Tween[name] = function () {\n    var tl = new Timeline(),\n        params = _slice.call(arguments, 0);\n\n    params.splice(name === "staggerFromTo" ? 5 : 4, 0, 0);\n    return tl[name].apply(tl, params);\n  };\n});\n/*\n * --------------------------------------------------------------------------------------\n * PROPTWEEN\n * --------------------------------------------------------------------------------------\n */\n\n\nvar _setterPlain = function _setterPlain(target, property, value) {\n  return target[property] = value;\n},\n    _setterFunc = function _setterFunc(target, property, value) {\n  return target[property](value);\n},\n    _setterFuncWithParam = function _setterFuncWithParam(target, property, value, data) {\n  return target[property](data.fp, value);\n},\n    _setterAttribute = function _setterAttribute(target, property, value) {\n  return target.setAttribute(property, value);\n},\n    _getSetter = function _getSetter(target, property) {\n  return _isFunction(target[property]) ? _setterFunc : _isUndefined(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain;\n},\n    _renderPlain = function _renderPlain(ratio, data) {\n  return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 10000) / 10000, data);\n},\n    _renderBoolean = function _renderBoolean(ratio, data) {\n  return data.set(data.t, data.p, !!(data.s + data.c * ratio), data);\n},\n    _renderComplexString = function _renderComplexString(ratio, data) {\n  var pt = data._pt,\n      s = "";\n\n  if (!ratio && data.b) {\n    //b = beginning string\n    s = data.b;\n  } else if (ratio === 1 && data.e) {\n    //e = ending string\n    s = data.e;\n  } else {\n    while (pt) {\n      s = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : Math.round((pt.s + pt.c * ratio) * 10000) / 10000) + s; //we use the "p" property for the text inbetween (like a suffix). And in the context of a complex string, the modifier (m) is typically just Math.round(), like for RGB colors.\n\n      pt = pt._next;\n    }\n\n    s += data.c; //we use the "c" of the PropTween to store the final chunk of non-numeric text.\n  }\n\n  data.set(data.t, data.p, s, data);\n},\n    _renderPropTweens = function _renderPropTweens(ratio, data) {\n  var pt = data._pt;\n\n  while (pt) {\n    pt.r(ratio, pt.d);\n    pt = pt._next;\n  }\n},\n    _addPluginModifier = function _addPluginModifier(modifier, tween, target, property) {\n  var pt = this._pt,\n      next;\n\n  while (pt) {\n    next = pt._next;\n\n    if (pt.p === property) {\n      pt.modifier(modifier, tween, target);\n    }\n\n    pt = next;\n  }\n},\n    _killPropTweensOf = function _killPropTweensOf(property) {\n  var pt = this._pt,\n      hasNonDependentRemaining,\n      next;\n\n  while (pt) {\n    next = pt._next;\n\n    if (pt.p === property && !pt.op || pt.op === property) {\n      _removeLinkedListItem(this, pt, "_pt");\n    } else if (!pt.dep) {\n      hasNonDependentRemaining = 1;\n    }\n\n    pt = next;\n  }\n\n  return !hasNonDependentRemaining;\n},\n    _setterWithModifier = function _setterWithModifier(target, property, value, data) {\n  data.mSet(target, property, data.m.call(data.tween, value, data.mt), data);\n},\n    _sortPropTweensByPriority = function _sortPropTweensByPriority(parent) {\n  var pt = parent._pt,\n      next,\n      pt2,\n      first,\n      last; //sorts the PropTween linked list in order of priority because some plugins need to do their work after ALL of the PropTweens were created (like RoundPropsPlugin and ModifiersPlugin)\n\n  while (pt) {\n    next = pt._next;\n    pt2 = first;\n\n    while (pt2 && pt2.pr > pt.pr) {\n      pt2 = pt2._next;\n    }\n\n    if (pt._prev = pt2 ? pt2._prev : last) {\n      pt._prev._next = pt;\n    } else {\n      first = pt;\n    }\n\n    if (pt._next = pt2) {\n      pt2._prev = pt;\n    } else {\n      last = pt;\n    }\n\n    pt = next;\n  }\n\n  parent._pt = first;\n}; //PropTween key: t = target, p = prop, r = renderer, d = data, s = start, c = change, op = overwriteProperty (ONLY populated when it\'s different than p), pr = priority, _next/_prev for the linked list siblings, set = setter, m = modifier, mSet = modifierSetter (the original setter, before a modifier was added)\n\n\nvar PropTween = /*#__PURE__*/function () {\n  function PropTween(next, target, prop, start, change, renderer, data, setter, priority) {\n    this.t = target;\n    this.s = start;\n    this.c = change;\n    this.p = prop;\n    this.r = renderer || _renderPlain;\n    this.d = data || this;\n    this.set = setter || _setterPlain;\n    this.pr = priority || 0;\n    this._next = next;\n\n    if (next) {\n      next._prev = this;\n    }\n  }\n\n  var _proto4 = PropTween.prototype;\n\n  _proto4.modifier = function modifier(func, tween, target) {\n    this.mSet = this.mSet || this.set; //in case it was already set (a PropTween can only have one modifier)\n\n    this.set = _setterWithModifier;\n    this.m = func;\n    this.mt = target; //modifier target\n\n    this.tween = tween;\n  };\n\n  return PropTween;\n}(); //Initialization tasks\n\n_forEachName(_callbackNames + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function (name) {\n  return _reservedProps[name] = 1;\n});\n\n_globals.TweenMax = _globals.TweenLite = Tween;\n_globals.TimelineLite = _globals.TimelineMax = Timeline;\n_globalTimeline = new Timeline({\n  sortChildren: false,\n  defaults: _defaults,\n  autoRemoveChildren: true,\n  id: "root",\n  smoothChildTiming: true\n});\n_config.stringFilter = _colorStringFilter;\n/*\n * --------------------------------------------------------------------------------------\n * GSAP\n * --------------------------------------------------------------------------------------\n */\n\nvar _gsap = {\n  registerPlugin: function registerPlugin() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    args.forEach(function (config) {\n      return _createPlugin(config);\n    });\n  },\n  timeline: function timeline(vars) {\n    return new Timeline(vars);\n  },\n  getTweensOf: function getTweensOf(targets, onlyActive) {\n    return _globalTimeline.getTweensOf(targets, onlyActive);\n  },\n  getProperty: function getProperty(target, property, unit, uncache) {\n    if (_isString(target)) {\n      //in case selector text or an array is passed in\n      target = toArray(target)[0];\n    }\n\n    var getter = _getCache(target || {}).get,\n        format = unit ? _passThrough : _numericIfPossible;\n\n    if (unit === "native") {\n      unit = "";\n    }\n\n    return !target ? target : !property ? function (property, unit, uncache) {\n      return format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));\n    } : format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));\n  },\n  quickSetter: function quickSetter(target, property, unit) {\n    target = toArray(target);\n\n    if (target.length > 1) {\n      var setters = target.map(function (t) {\n        return gsap.quickSetter(t, property, unit);\n      }),\n          l = setters.length;\n      return function (value) {\n        var i = l;\n\n        while (i--) {\n          setters[i](value);\n        }\n      };\n    }\n\n    target = target[0] || {};\n\n    var Plugin = _plugins[property],\n        cache = _getCache(target),\n        p = cache.harness && (cache.harness.aliases || {})[property] || property,\n        // in case it\'s an alias, like "rotate" for "rotation".\n    setter = Plugin ? function (value) {\n      var p = new Plugin();\n      _quickTween._pt = 0;\n      p.init(target, unit ? value + unit : value, _quickTween, 0, [target]);\n      p.render(1, p);\n      _quickTween._pt && _renderPropTweens(1, _quickTween);\n    } : cache.set(target, p);\n\n    return Plugin ? setter : function (value) {\n      return setter(target, p, unit ? value + unit : value, cache, 1);\n    };\n  },\n  isTweening: function isTweening(targets) {\n    return _globalTimeline.getTweensOf(targets, true).length > 0;\n  },\n  defaults: function defaults(value) {\n    if (value && value.ease) {\n      value.ease = _parseEase(value.ease, _defaults.ease);\n    }\n\n    return _mergeDeep(_defaults, value || {});\n  },\n  config: function config(value) {\n    return _mergeDeep(_config, value || {});\n  },\n  registerEffect: function registerEffect(_ref) {\n    var name = _ref.name,\n        effect = _ref.effect,\n        plugins = _ref.plugins,\n        defaults = _ref.defaults,\n        extendTimeline = _ref.extendTimeline;\n    (plugins || "").split(",").forEach(function (pluginName) {\n      return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name + " effect requires " + pluginName + " plugin.");\n    });\n\n    _effects[name] = function (targets, vars, tl) {\n      return effect(toArray(targets), _setDefaults(vars || {}, defaults), tl);\n    };\n\n    if (extendTimeline) {\n      Timeline.prototype[name] = function (targets, vars, position) {\n        return this.add(_effects[name](targets, _isObject(vars) ? vars : (position = vars) && {}, this), position);\n      };\n    }\n  },\n  registerEase: function registerEase(name, ease) {\n    _easeMap[name] = _parseEase(ease);\n  },\n  parseEase: function parseEase(ease, defaultEase) {\n    return arguments.length ? _parseEase(ease, defaultEase) : _easeMap;\n  },\n  getById: function getById(id) {\n    return _globalTimeline.getById(id);\n  },\n  exportRoot: function exportRoot(vars, includeDelayedCalls) {\n    if (vars === void 0) {\n      vars = {};\n    }\n\n    var tl = new Timeline(vars),\n        child,\n        next;\n    tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);\n\n    _globalTimeline.remove(tl);\n\n    tl._dp = 0; //otherwise it\'ll get re-activated when adding children and be re-introduced into _globalTimeline\'s linked list (then added to itself).\n\n    tl._time = tl._tTime = _globalTimeline._time;\n    child = _globalTimeline._first;\n\n    while (child) {\n      next = child._next;\n\n      if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) {\n        _addToTimeline(tl, child, child._start - child._delay);\n      }\n\n      child = next;\n    }\n\n    _addToTimeline(_globalTimeline, tl, 0);\n\n    return tl;\n  },\n  utils: {\n    wrap: wrap,\n    wrapYoyo: wrapYoyo,\n    distribute: distribute,\n    random: random,\n    snap: snap,\n    normalize: normalize,\n    getUnit: getUnit,\n    clamp: clamp,\n    splitColor: splitColor,\n    toArray: toArray,\n    mapRange: mapRange,\n    pipe: pipe,\n    unitize: unitize,\n    interpolate: interpolate,\n    shuffle: shuffle\n  },\n  install: _install,\n  effects: _effects,\n  ticker: _ticker,\n  updateRoot: Timeline.updateRoot,\n  plugins: _plugins,\n  globalTimeline: _globalTimeline,\n  core: {\n    PropTween: PropTween,\n    globals: _addGlobal,\n    Tween: Tween,\n    Timeline: Timeline,\n    Animation: Animation,\n    getCache: _getCache,\n    _removeLinkedListItem: _removeLinkedListItem\n  }\n};\n\n_forEachName("to,from,fromTo,delayedCall,set,killTweensOf", function (name) {\n  return _gsap[name] = Tween[name];\n});\n\n_ticker.add(Timeline.updateRoot);\n\n_quickTween = _gsap.to({}, {\n  duration: 0\n}); // ---- EXTRA PLUGINS --------------------------------------------------------\n\nvar _getPluginPropTween = function _getPluginPropTween(plugin, prop) {\n  var pt = plugin._pt;\n\n  while (pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop) {\n    pt = pt._next;\n  }\n\n  return pt;\n},\n    _addModifiers = function _addModifiers(tween, modifiers) {\n  var targets = tween._targets,\n      p,\n      i,\n      pt;\n\n  for (p in modifiers) {\n    i = targets.length;\n\n    while (i--) {\n      pt = tween._ptLookup[i][p];\n\n      if (pt && (pt = pt.d)) {\n        if (pt._pt) {\n          // is a plugin\n          pt = _getPluginPropTween(pt, p);\n        }\n\n        pt && pt.modifier && pt.modifier(modifiers[p], tween, targets[i], p);\n      }\n    }\n  }\n},\n    _buildModifierPlugin = function _buildModifierPlugin(name, modifier) {\n  return {\n    name: name,\n    rawVars: 1,\n    //don\'t pre-process function-based values or "random()" strings.\n    init: function init(target, vars, tween) {\n      tween._onInit = function (tween) {\n        var temp, p;\n\n        if (_isString(vars)) {\n          temp = {};\n\n          _forEachName(vars, function (name) {\n            return temp[name] = 1;\n          }); //if the user passes in a comma-delimited list of property names to roundProps, like "x,y", we round to whole numbers.\n\n\n          vars = temp;\n        }\n\n        if (modifier) {\n          temp = {};\n\n          for (p in vars) {\n            temp[p] = modifier(vars[p]);\n          }\n\n          vars = temp;\n        }\n\n        _addModifiers(tween, vars);\n      };\n    }\n  };\n}; //register core plugins\n\n\nvar gsap = _gsap.registerPlugin({\n  name: "attr",\n  init: function init(target, vars, tween, index, targets) {\n    var p, pt;\n\n    for (p in vars) {\n      pt = this.add(target, "setAttribute", (target.getAttribute(p) || 0) + "", vars[p], index, targets, 0, 0, p);\n      pt && (pt.op = p); //this.add(target, "setAttribute", (target.getAttribute((p in target.dataset ? (p = "data-" + p) : p)) || 0) + "", vars[p], index, targets, 0, 0, p);\n\n      this._props.push(p);\n    }\n  }\n}, {\n  name: "endArray",\n  init: function init(target, value) {\n    var i = value.length;\n\n    while (i--) {\n      this.add(target, i, target[i] || 0, value[i]);\n    }\n  }\n}, _buildModifierPlugin("roundProps", _roundModifier), _buildModifierPlugin("modifiers"), _buildModifierPlugin("snap", snap)) || _gsap; //to prevent the core plugins from being dropped via aggressive tree shaking, we must include them in the variable declaration in this way.\n\nTween.version = Timeline.version = gsap.version = "3.4.2";\n_coreReady = 1;\n\nif (_windowExists()) {\n  _wake();\n}\n\nvar Power0 = _easeMap.Power0,\n    Power1 = _easeMap.Power1,\n    Power2 = _easeMap.Power2,\n    Power3 = _easeMap.Power3,\n    Power4 = _easeMap.Power4,\n    Linear = _easeMap.Linear,\n    Quad = _easeMap.Quad,\n    Cubic = _easeMap.Cubic,\n    Quart = _easeMap.Quart,\n    Quint = _easeMap.Quint,\n    Strong = _easeMap.Strong,\n    Elastic = _easeMap.Elastic,\n    Back = _easeMap.Back,\n    SteppedEase = _easeMap.SteppedEase,\n    Bounce = _easeMap.Bounce,\n    Sine = _easeMap.Sine,\n    Expo = _easeMap.Expo,\n    Circ = _easeMap.Circ;\n\n //export some internal methods/orojects for use in CSSPlugin so that we can externalize that file and allow custom builds that exclude it.\n\n\n// CONCATENATED MODULE: ./node_modules/gsap/CSSPlugin.js\n/*!\n * CSSPlugin 3.4.2\n * https://greensock.com\n *\n * Copyright 2008-2020, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n\n/* eslint-disable */\n\n\nvar CSSPlugin_win,\n    CSSPlugin_doc,\n    _docElement,\n    _pluginInitted,\n    _tempDiv,\n    _tempDivStyler,\n    _recentSetterPlugin,\n    CSSPlugin_windowExists = function _windowExists() {\n  return typeof window !== "undefined";\n},\n    _transformProps = {},\n    _RAD2DEG = 180 / Math.PI,\n    _DEG2RAD = Math.PI / 180,\n    _atan2 = Math.atan2,\n    CSSPlugin_bigNum = 1e8,\n    _capsExp = /([A-Z])/g,\n    _horizontalExp = /(?:left|right|width|margin|padding|x)/i,\n    _complexExp = /[\\s,\\(]\\S/,\n    _propertyAliases = {\n  autoAlpha: "opacity,visibility",\n  scale: "scaleX,scaleY",\n  alpha: "opacity"\n},\n    _renderCSSProp = function _renderCSSProp(ratio, data) {\n  return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);\n},\n    _renderPropWithEnd = function _renderPropWithEnd(ratio, data) {\n  return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);\n},\n    _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning(ratio, data) {\n  return data.set(data.t, data.p, ratio ? Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u : data.b, data);\n},\n    //if units change, we need a way to render the original unit/value when the tween goes all the way back to the beginning (ratio:0)\n_renderRoundedCSSProp = function _renderRoundedCSSProp(ratio, data) {\n  var value = data.s + data.c * ratio;\n  data.set(data.t, data.p, ~~(value + (value < 0 ? -.5 : .5)) + data.u, data);\n},\n    _renderNonTweeningValue = function _renderNonTweeningValue(ratio, data) {\n  return data.set(data.t, data.p, ratio ? data.e : data.b, data);\n},\n    _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd(ratio, data) {\n  return data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data);\n},\n    _setterCSSStyle = function _setterCSSStyle(target, property, value) {\n  return target.style[property] = value;\n},\n    _setterCSSProp = function _setterCSSProp(target, property, value) {\n  return target.style.setProperty(property, value);\n},\n    _setterTransform = function _setterTransform(target, property, value) {\n  return target._gsap[property] = value;\n},\n    _setterScale = function _setterScale(target, property, value) {\n  return target._gsap.scaleX = target._gsap.scaleY = value;\n},\n    _setterScaleWithRender = function _setterScaleWithRender(target, property, value, data, ratio) {\n  var cache = target._gsap;\n  cache.scaleX = cache.scaleY = value;\n  cache.renderTransform(ratio, cache);\n},\n    _setterTransformWithRender = function _setterTransformWithRender(target, property, value, data, ratio) {\n  var cache = target._gsap;\n  cache[property] = value;\n  cache.renderTransform(ratio, cache);\n},\n    _transformProp = "transform",\n    _transformOriginProp = _transformProp + "Origin",\n    _supports3D,\n    _createElement = function _createElement(type, ns) {\n  var e = CSSPlugin_doc.createElementNS ? CSSPlugin_doc.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : CSSPlugin_doc.createElement(type); //some servers swap in https for http in the namespace which can break things, making "style" inaccessible.\n\n  return e.style ? e : CSSPlugin_doc.createElement(type); //some environments won\'t allow access to the element\'s style when created with a namespace in which case we default to the standard createElement() to work around the issue. Also note that when GSAP is embedded directly inside an SVG file, createElement() won\'t allow access to the style object in Firefox (see https://greensock.com/forums/topic/20215-problem-using-tweenmax-in-standalone-self-containing-svg-file-err-cannot-set-property-csstext-of-undefined/).\n},\n    _getComputedProperty = function _getComputedProperty(target, property, skipPrefixFallback) {\n  var cs = getComputedStyle(target);\n  return cs[property] || cs.getPropertyValue(property.replace(_capsExp, "-$1").toLowerCase()) || cs.getPropertyValue(property) || !skipPrefixFallback && _getComputedProperty(target, _checkPropPrefix(property) || property, 1) || ""; //css variables may not need caps swapped out for dashes and lowercase.\n},\n    _prefixes = "O,Moz,ms,Ms,Webkit".split(","),\n    _checkPropPrefix = function _checkPropPrefix(property, element, preferPrefix) {\n  var e = element || _tempDiv,\n      s = e.style,\n      i = 5;\n\n  if (property in s && !preferPrefix) {\n    return property;\n  }\n\n  property = property.charAt(0).toUpperCase() + property.substr(1);\n\n  while (i-- && !(_prefixes[i] + property in s)) {}\n\n  return i < 0 ? null : (i === 3 ? "ms" : i >= 0 ? _prefixes[i] : "") + property;\n},\n    _initCore = function _initCore() {\n  if (CSSPlugin_windowExists() && window.document) {\n    CSSPlugin_win = window;\n    CSSPlugin_doc = CSSPlugin_win.document;\n    _docElement = CSSPlugin_doc.documentElement;\n    _tempDiv = _createElement("div") || {\n      style: {}\n    };\n    _tempDivStyler = _createElement("div");\n    _transformProp = _checkPropPrefix(_transformProp);\n    _transformOriginProp = _transformProp + "Origin";\n    _tempDiv.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0"; //make sure to override certain properties that may contaminate measurements, in case the user has overreaching style sheets.\n\n    _supports3D = !!_checkPropPrefix("perspective");\n    _pluginInitted = 1;\n  }\n},\n    _getBBoxHack = function _getBBoxHack(swapIfPossible) {\n  //works around issues in some browsers (like Firefox) that don\'t correctly report getBBox() on SVG elements inside a <defs> element and/or <mask>. We try creating an SVG, adding it to the documentElement and toss the element in there so that it\'s definitely part of the rendering tree, then grab the bbox and if it works, we actually swap out the original getBBox() method for our own that does these extra steps whenever getBBox is needed. This helps ensure that performance is optimal (only do all these extra steps when absolutely necessary...most elements don\'t need it).\n  var svg = _createElement("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),\n      oldParent = this.parentNode,\n      oldSibling = this.nextSibling,\n      oldCSS = this.style.cssText,\n      bbox;\n\n  _docElement.appendChild(svg);\n\n  svg.appendChild(this);\n  this.style.display = "block";\n\n  if (swapIfPossible) {\n    try {\n      bbox = this.getBBox();\n      this._gsapBBox = this.getBBox; //store the original\n\n      this.getBBox = _getBBoxHack;\n    } catch (e) {}\n  } else if (this._gsapBBox) {\n    bbox = this._gsapBBox();\n  }\n\n  if (oldParent) {\n    if (oldSibling) {\n      oldParent.insertBefore(this, oldSibling);\n    } else {\n      oldParent.appendChild(this);\n    }\n  }\n\n  _docElement.removeChild(svg);\n\n  this.style.cssText = oldCSS;\n  return bbox;\n},\n    _getAttributeFallbacks = function _getAttributeFallbacks(target, attributesArray) {\n  var i = attributesArray.length;\n\n  while (i--) {\n    if (target.hasAttribute(attributesArray[i])) {\n      return target.getAttribute(attributesArray[i]);\n    }\n  }\n},\n    _getBBox = function _getBBox(target) {\n  var bounds;\n\n  try {\n    bounds = target.getBBox(); //Firefox throws errors if you try calling getBBox() on an SVG element that\'s not rendered (like in a <symbol> or <defs>). https://bugzilla.mozilla.org/show_bug.cgi?id=612118\n  } catch (error) {\n    bounds = _getBBoxHack.call(target, true);\n  }\n\n  bounds && (bounds.width || bounds.height) || target.getBBox === _getBBoxHack || (bounds = _getBBoxHack.call(target, true)); //some browsers (like Firefox) misreport the bounds if the element has zero width and height (it just assumes it\'s at x:0, y:0), thus we need to manually grab the position in that case.\n\n  return bounds && !bounds.width && !bounds.x && !bounds.y ? {\n    x: +_getAttributeFallbacks(target, ["x", "cx", "x1"]) || 0,\n    y: +_getAttributeFallbacks(target, ["y", "cy", "y1"]) || 0,\n    width: 0,\n    height: 0\n  } : bounds;\n},\n    _isSVG = function _isSVG(e) {\n  return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e));\n},\n    //reports if the element is an SVG on which getBBox() actually works\n_removeProperty = function _removeProperty(target, property) {\n  if (property) {\n    var style = target.style;\n\n    if (property in _transformProps && property !== _transformOriginProp) {\n      property = _transformProp;\n    }\n\n    if (style.removeProperty) {\n      if (property.substr(0, 2) === "ms" || property.substr(0, 6) === "webkit") {\n        //Microsoft and some Webkit browsers don\'t conform to the standard of capitalizing the first prefix character, so we adjust so that when we prefix the caps with a dash, it\'s correct (otherwise it\'d be "ms-transform" instead of "-ms-transform" for IE9, for example)\n        property = "-" + property;\n      }\n\n      style.removeProperty(property.replace(_capsExp, "-$1").toLowerCase());\n    } else {\n      //note: old versions of IE use "removeAttribute()" instead of "removeProperty()"\n      style.removeAttribute(property);\n    }\n  }\n},\n    CSSPlugin_addNonTweeningPT = function _addNonTweeningPT(plugin, target, property, beginning, end, onlySetAtEnd) {\n  var pt = new PropTween(plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);\n  plugin._pt = pt;\n  pt.b = beginning;\n  pt.e = end;\n\n  plugin._props.push(property);\n\n  return pt;\n},\n    _nonConvertibleUnits = {\n  deg: 1,\n  rad: 1,\n  turn: 1\n},\n    //takes a single value like 20px and converts it to the unit specified, like "%", returning only the numeric amount.\nCSSPlugin_convertToUnit = function _convertToUnit(target, property, value, unit) {\n  var curValue = parseFloat(value) || 0,\n      curUnit = (value + "").trim().substr((curValue + "").length) || "px",\n      // some browsers leave extra whitespace at the beginning of CSS variables, hence the need to trim()\n  style = _tempDiv.style,\n      horizontal = _horizontalExp.test(property),\n      isRootSVG = target.tagName.toLowerCase() === "svg",\n      measureProperty = (isRootSVG ? "client" : "offset") + (horizontal ? "Width" : "Height"),\n      amount = 100,\n      toPixels = unit === "px",\n      toPercent = unit === "%",\n      px,\n      parent,\n      cache,\n      isSVG;\n\n  if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) {\n    return curValue;\n  }\n\n  curUnit !== "px" && !toPixels && (curValue = _convertToUnit(target, property, value, "px"));\n  isSVG = target.getCTM && _isSVG(target);\n\n  if (toPercent && (_transformProps[property] || ~property.indexOf("adius"))) {\n    //transforms and borderRadius are relative to the size of the element itself!\n    return _round(curValue / (isSVG ? target.getBBox()[horizontal ? "width" : "height"] : target[measureProperty]) * amount);\n  }\n\n  style[horizontal ? "width" : "height"] = amount + (toPixels ? curUnit : unit);\n  parent = ~property.indexOf("adius") || unit === "em" && target.appendChild && !isRootSVG ? target : target.parentNode;\n\n  if (isSVG) {\n    parent = (target.ownerSVGElement || {}).parentNode;\n  }\n\n  if (!parent || parent === CSSPlugin_doc || !parent.appendChild) {\n    parent = CSSPlugin_doc.body;\n  }\n\n  cache = parent._gsap;\n\n  if (cache && toPercent && cache.width && horizontal && cache.time === _ticker.time) {\n    return _round(curValue / cache.width * amount);\n  } else {\n    (toPercent || curUnit === "%") && (style.position = _getComputedProperty(target, "position"));\n    parent === target && (style.position = "static"); // like for borderRadius, if it\'s a % we must have it relative to the target itself but that may not have position: relative or position: absolute in which case it\'d go up the chain until it finds its offsetParent (bad). position: static protects against that.\n\n    parent.appendChild(_tempDiv);\n    px = _tempDiv[measureProperty];\n    parent.removeChild(_tempDiv);\n    style.position = "absolute";\n\n    if (horizontal && toPercent) {\n      cache = _getCache(parent);\n      cache.time = _ticker.time;\n      cache.width = parent[measureProperty];\n    }\n  }\n\n  return _round(toPixels ? px * curValue / amount : px && curValue ? amount / px * curValue : 0);\n},\n    CSSPlugin_get = function _get(target, property, unit, uncache) {\n  var value;\n  _pluginInitted || _initCore();\n\n  if (property in _propertyAliases && property !== "transform") {\n    property = _propertyAliases[property];\n\n    if (~property.indexOf(",")) {\n      property = property.split(",")[0];\n    }\n  }\n\n  if (_transformProps[property] && property !== "transform") {\n    value = CSSPlugin_parseTransform(target, uncache);\n    value = property !== "transformOrigin" ? value[property] : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + " " + value.zOrigin + "px";\n  } else {\n    value = target.style[property];\n\n    if (!value || value === "auto" || uncache || ~(value + "").indexOf("calc(")) {\n      value = _specialProps[property] && _specialProps[property](target, property, unit) || _getComputedProperty(target, property) || _getProperty(target, property) || (property === "opacity" ? 1 : 0); // note: some browsers, like Firefox, don\'t report borderRadius correctly! Instead, it only reports every corner like  borderTopLeftRadius\n    }\n  }\n\n  return unit && !~(value + "").indexOf(" ") ? CSSPlugin_convertToUnit(target, property, value, unit) + unit : value;\n},\n    CSSPlugin_tweenComplexCSSString = function _tweenComplexCSSString(target, prop, start, end) {\n  //note: we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it\'s scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.\n  if (!start || start === "none") {\n    // some browsers like Safari actually PREFER the prefixed property and mis-report the unprefixed value like clipPath (BUG). In other words, even though clipPath exists in the style ("clipPath" in target.style) and it\'s set in the CSS properly (along with -webkit-clip-path), Safari reports clipPath as "none" whereas WebkitClipPath reports accurately like "ellipse(100% 0% at 50% 0%)", so in this case we must SWITCH to using the prefixed property instead. See https://greensock.com/forums/topic/18310-clippath-doesnt-work-on-ios/\n    var p = _checkPropPrefix(prop, target, 1),\n        s = p && _getComputedProperty(target, p, 1);\n\n    if (s && s !== start) {\n      prop = p;\n      start = s;\n    } else if (prop === "borderColor") {\n      start = _getComputedProperty(target, "borderTopColor"); // Firefox bug: always reports "borderColor" as "", so we must fall back to borderTopColor. See https://greensock.com/forums/topic/24583-how-to-return-colors-that-i-had-after-reverse/\n    }\n  }\n\n  var pt = new PropTween(this._pt, target.style, prop, 0, 1, _renderComplexString),\n      index = 0,\n      matchIndex = 0,\n      a,\n      result,\n      startValues,\n      startNum,\n      color,\n      startValue,\n      endValue,\n      endNum,\n      chunk,\n      endUnit,\n      startUnit,\n      relative,\n      endValues;\n  pt.b = start;\n  pt.e = end;\n  start += ""; //ensure values are strings\n\n  end += "";\n\n  if (end === "auto") {\n    target.style[prop] = end;\n    end = _getComputedProperty(target, prop) || end;\n    target.style[prop] = start;\n  }\n\n  a = [start, end];\n\n  _colorStringFilter(a); //pass an array with the starting and ending values and let the filter do whatever it needs to the values. If colors are found, it returns true and then we must match where the color shows up order-wise because for things like boxShadow, sometimes the browser provides the computed values with the color FIRST, but the user provides it with the color LAST, so flip them if necessary. Same for drop-shadow().\n\n\n  start = a[0];\n  end = a[1];\n  startValues = start.match(_numWithUnitExp) || [];\n  endValues = end.match(_numWithUnitExp) || [];\n\n  if (endValues.length) {\n    while (result = _numWithUnitExp.exec(end)) {\n      endValue = result[0];\n      chunk = end.substring(index, result.index);\n\n      if (color) {\n        color = (color + 1) % 5;\n      } else if (chunk.substr(-5) === "rgba(" || chunk.substr(-5) === "hsla(") {\n        color = 1;\n      }\n\n      if (endValue !== (startValue = startValues[matchIndex++] || "")) {\n        startNum = parseFloat(startValue) || 0;\n        startUnit = startValue.substr((startNum + "").length);\n        relative = endValue.charAt(1) === "=" ? +(endValue.charAt(0) + "1") : 0;\n\n        if (relative) {\n          endValue = endValue.substr(2);\n        }\n\n        endNum = parseFloat(endValue);\n        endUnit = endValue.substr((endNum + "").length);\n        index = _numWithUnitExp.lastIndex - endUnit.length;\n\n        if (!endUnit) {\n          //if something like "perspective:300" is passed in and we must add a unit to the end\n          endUnit = endUnit || _config.units[prop] || startUnit;\n\n          if (index === end.length) {\n            end += endUnit;\n            pt.e += endUnit;\n          }\n        }\n\n        if (startUnit !== endUnit) {\n          startNum = CSSPlugin_convertToUnit(target, prop, startValue, endUnit) || 0;\n        } //these nested PropTweens are handled in a special way - we\'ll never actually call a render or setter method on them. We\'ll just loop through them in the parent complex string PropTween\'s render method.\n\n\n        pt._pt = {\n          _next: pt._pt,\n          p: chunk || matchIndex === 1 ? chunk : ",",\n          //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.\n          s: startNum,\n          c: relative ? relative * endNum : endNum - startNum,\n          m: color && color < 4 ? Math.round : 0\n        };\n      }\n    }\n\n    pt.c = index < end.length ? end.substring(index, end.length) : ""; //we use the "c" of the PropTween to store the final part of the string (after the last number)\n  } else {\n    pt.r = prop === "display" && end === "none" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;\n  }\n\n  if (_relExp.test(end)) {\n    pt.e = 0; //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don\'t actually set it to the string with += or -= characters (forces it to use the calculated value).\n  }\n\n  this._pt = pt; //start the linked list with this new PropTween. Remember, we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it\'s scoped properly. We may call it from within another plugin too, thus "this" would refer to the plugin.\n\n  return pt;\n},\n    _keywordToPercent = {\n  top: "0%",\n  bottom: "100%",\n  left: "0%",\n  right: "100%",\n  center: "50%"\n},\n    _convertKeywordsToPercentages = function _convertKeywordsToPercentages(value) {\n  var split = value.split(" "),\n      x = split[0],\n      y = split[1] || "50%";\n\n  if (x === "top" || x === "bottom" || y === "left" || y === "right") {\n    //the user provided them in the wrong order, so flip them\n    value = x;\n    x = y;\n    y = value;\n  }\n\n  split[0] = _keywordToPercent[x] || x;\n  split[1] = _keywordToPercent[y] || y;\n  return split.join(" ");\n},\n    _renderClearProps = function _renderClearProps(ratio, data) {\n  if (data.tween && data.tween._time === data.tween._dur) {\n    var target = data.t,\n        style = target.style,\n        props = data.u,\n        cache = target._gsap,\n        prop,\n        clearTransforms,\n        i;\n\n    if (props === "all" || props === true) {\n      style.cssText = "";\n      clearTransforms = 1;\n    } else {\n      props = props.split(",");\n      i = props.length;\n\n      while (--i > -1) {\n        prop = props[i];\n\n        if (_transformProps[prop]) {\n          clearTransforms = 1;\n          prop = prop === "transformOrigin" ? _transformOriginProp : _transformProp;\n        }\n\n        _removeProperty(target, prop);\n      }\n    }\n\n    if (clearTransforms) {\n      _removeProperty(target, _transformProp);\n\n      if (cache) {\n        cache.svg && target.removeAttribute("transform");\n\n        CSSPlugin_parseTransform(target, 1); // force all the cached values back to "normal"/identity, otherwise if there\'s another tween that\'s already set to render transforms on this element, it could display the wrong values.\n\n\n        cache.uncache = 1;\n      }\n    }\n  }\n},\n    // note: specialProps should return 1 if (and only if) they have a non-zero priority. It indicates we need to sort the linked list.\n_specialProps = {\n  clearProps: function clearProps(plugin, target, property, endValue, tween) {\n    if (tween.data !== "isFromStart") {\n      var pt = plugin._pt = new PropTween(plugin._pt, target, property, 0, 0, _renderClearProps);\n      pt.u = endValue;\n      pt.pr = -10;\n      pt.tween = tween;\n\n      plugin._props.push(property);\n\n      return 1;\n    }\n  }\n  /* className feature (about 0.4kb gzipped).\n  , className(plugin, target, property, endValue, tween) {\n  \tlet _renderClassName = (ratio, data) => {\n  \t\t\tdata.css.render(ratio, data.css);\n  \t\t\tif (!ratio || ratio === 1) {\n  \t\t\t\tlet inline = data.rmv,\n  \t\t\t\t\ttarget = data.t,\n  \t\t\t\t\tp;\n  \t\t\t\ttarget.setAttribute("class", ratio ? data.e : data.b);\n  \t\t\t\tfor (p in inline) {\n  \t\t\t\t\t_removeProperty(target, p);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t},\n  \t\t_getAllStyles = (target) => {\n  \t\t\tlet styles = {},\n  \t\t\t\tcomputed = getComputedStyle(target),\n  \t\t\t\tp;\n  \t\t\tfor (p in computed) {\n  \t\t\t\tif (isNaN(p) && p !== "cssText" && p !== "length") {\n  \t\t\t\t\tstyles[p] = computed[p];\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\t_setDefaults(styles, _parseTransform(target, 1));\n  \t\t\treturn styles;\n  \t\t},\n  \t\tstartClassList = target.getAttribute("class"),\n  \t\tstyle = target.style,\n  \t\tcssText = style.cssText,\n  \t\tcache = target._gsap,\n  \t\tclassPT = cache.classPT,\n  \t\tinlineToRemoveAtEnd = {},\n  \t\tdata = {t:target, plugin:plugin, rmv:inlineToRemoveAtEnd, b:startClassList, e:(endValue.charAt(1) !== "=") ? endValue : startClassList.replace(new RegExp("(?:\\\\s|^)" + endValue.substr(2) + "(?![\\\\w-])"), "") + ((endValue.charAt(0) === "+") ? " " + endValue.substr(2) : "")},\n  \t\tchangingVars = {},\n  \t\tstartVars = _getAllStyles(target),\n  \t\ttransformRelated = /(transform|perspective)/i,\n  \t\tendVars, p;\n  \tif (classPT) {\n  \t\tclassPT.r(1, classPT.d);\n  \t\t_removeLinkedListItem(classPT.d.plugin, classPT, "_pt");\n  \t}\n  \ttarget.setAttribute("class", data.e);\n  \tendVars = _getAllStyles(target, true);\n  \ttarget.setAttribute("class", startClassList);\n  \tfor (p in endVars) {\n  \t\tif (endVars[p] !== startVars[p] && !transformRelated.test(p)) {\n  \t\t\tchangingVars[p] = endVars[p];\n  \t\t\tif (!style[p] && style[p] !== "0") {\n  \t\t\t\tinlineToRemoveAtEnd[p] = 1;\n  \t\t\t}\n  \t\t}\n  \t}\n  \tcache.classPT = plugin._pt = new PropTween(plugin._pt, target, "className", 0, 0, _renderClassName, data, 0, -11);\n  \tif (style.cssText !== cssText) { //only apply if things change. Otherwise, in cases like a background-image that\'s pulled dynamically, it could cause a refresh. See https://greensock.com/forums/topic/20368-possible-gsap-bug-switching-classnames-in-chrome/.\n  \t\tstyle.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can\'t override properties we\'ve directly set on the target\'s style object due to specificity).\n  \t}\n  \t_parseTransform(target, true); //to clear the caching of transforms\n  \tdata.css = new gsap.plugins.css();\n  \tdata.css.init(target, changingVars, tween);\n  \tplugin._props.push(...data.css._props);\n  \treturn 1;\n  }\n  */\n\n},\n\n/*\n * --------------------------------------------------------------------------------------\n * TRANSFORMS\n * --------------------------------------------------------------------------------------\n */\n_identity2DMatrix = [1, 0, 0, 1, 0, 0],\n    _rotationalProperties = {},\n    _isNullTransform = function _isNullTransform(value) {\n  return value === "matrix(1, 0, 0, 1, 0, 0)" || value === "none" || !value;\n},\n    CSSPlugin_getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray(target) {\n  var matrixString = _getComputedProperty(target, _transformProp);\n\n  return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_numExp).map(_round);\n},\n    CSSPlugin_getMatrix = function _getMatrix(target, force2D) {\n  var cache = target._gsap || _getCache(target),\n      style = target.style,\n      matrix = CSSPlugin_getComputedTransformMatrixAsArray(target),\n      parent,\n      nextSibling,\n      temp,\n      addedToDOM;\n\n  if (cache.svg && target.getAttribute("transform")) {\n    temp = target.transform.baseVal.consolidate().matrix; //ensures that even complex values like "translate(50,60) rotate(135,0,0)" are parsed because it mashes it into a matrix.\n\n    matrix = [temp.a, temp.b, temp.c, temp.d, temp.e, temp.f];\n    return matrix.join(",") === "1,0,0,1,0,0" ? _identity2DMatrix : matrix;\n  } else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) {\n    //note: if offsetParent is null, that means the element isn\'t in the normal document flow, like if it has display:none or one of its ancestors has display:none). Firefox returns null for getComputedStyle() if the element is in an iframe that has display:none. https://bugzilla.mozilla.org/show_bug.cgi?id=548397\n    //browsers don\'t report transforms accurately unless the element is in the DOM and has a display value that\'s not "none". Firefox and Microsoft browsers have a partial bug where they\'ll report transforms even if display:none BUT not any percentage-based values like translate(-50%, 8px) will be reported as if it\'s translate(0, 8px).\n    temp = style.display;\n    style.display = "block";\n    parent = target.parentNode;\n\n    if (!parent || !target.offsetParent) {\n      // note: in 3.3.0 we switched target.offsetParent to _doc.body.contains(target) to avoid [sometimes unnecessary] MutationObserver calls but that wasn\'t adequate because there are edge cases where nested position: fixed elements need to get reparented to accurately sense transforms. See https://github.com/greensock/GSAP/issues/388 and https://github.com/greensock/GSAP/issues/375\n      addedToDOM = 1; //flag\n\n      nextSibling = target.nextSibling;\n\n      _docElement.appendChild(target); //we must add it to the DOM in order to get values properly\n\n    }\n\n    matrix = CSSPlugin_getComputedTransformMatrixAsArray(target);\n    temp ? style.display = temp : _removeProperty(target, "display");\n\n    if (addedToDOM) {\n      nextSibling ? parent.insertBefore(target, nextSibling) : parent ? parent.appendChild(target) : _docElement.removeChild(target);\n    }\n  }\n\n  return force2D && matrix.length > 6 ? [matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]] : matrix;\n},\n    _applySVGOrigin = function _applySVGOrigin(target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {\n  var cache = target._gsap,\n      matrix = matrixArray || CSSPlugin_getMatrix(target, true),\n      xOriginOld = cache.xOrigin || 0,\n      yOriginOld = cache.yOrigin || 0,\n      xOffsetOld = cache.xOffset || 0,\n      yOffsetOld = cache.yOffset || 0,\n      a = matrix[0],\n      b = matrix[1],\n      c = matrix[2],\n      d = matrix[3],\n      tx = matrix[4],\n      ty = matrix[5],\n      originSplit = origin.split(" "),\n      xOrigin = parseFloat(originSplit[0]) || 0,\n      yOrigin = parseFloat(originSplit[1]) || 0,\n      bounds,\n      determinant,\n      x,\n      y;\n\n  if (!originIsAbsolute) {\n    bounds = _getBBox(target);\n    xOrigin = bounds.x + (~originSplit[0].indexOf("%") ? xOrigin / 100 * bounds.width : xOrigin);\n    yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf("%") ? yOrigin / 100 * bounds.height : yOrigin);\n  } else if (matrix !== _identity2DMatrix && (determinant = a * d - b * c)) {\n    //if it\'s zero (like if scaleX and scaleY are zero), skip it to avoid errors with dividing by zero.\n    x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant;\n    y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;\n    xOrigin = x;\n    yOrigin = y;\n  }\n\n  if (smooth || smooth !== false && cache.smooth) {\n    tx = xOrigin - xOriginOld;\n    ty = yOrigin - yOriginOld;\n    cache.xOffset = xOffsetOld + (tx * a + ty * c) - tx;\n    cache.yOffset = yOffsetOld + (tx * b + ty * d) - ty;\n  } else {\n    cache.xOffset = cache.yOffset = 0;\n  }\n\n  cache.xOrigin = xOrigin;\n  cache.yOrigin = yOrigin;\n  cache.smooth = !!smooth;\n  cache.origin = origin;\n  cache.originIsAbsolute = !!originIsAbsolute;\n  target.style[_transformOriginProp] = "0px 0px"; //otherwise, if someone sets  an origin via CSS, it will likely interfere with the SVG transform attribute ones (because remember, we\'re baking the origin into the matrix() value).\n\n  if (pluginToAddPropTweensTo) {\n    CSSPlugin_addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOrigin", xOriginOld, xOrigin);\n\n    CSSPlugin_addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOrigin", yOriginOld, yOrigin);\n\n    CSSPlugin_addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOffset", xOffsetOld, cache.xOffset);\n\n    CSSPlugin_addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOffset", yOffsetOld, cache.yOffset);\n  }\n\n  target.setAttribute("data-svg-origin", xOrigin + " " + yOrigin);\n},\n    CSSPlugin_parseTransform = function _parseTransform(target, uncache) {\n  var cache = target._gsap || new GSCache(target);\n\n  if ("x" in cache && !uncache && !cache.uncache) {\n    return cache;\n  }\n\n  var style = target.style,\n      invertedScaleX = cache.scaleX < 0,\n      px = "px",\n      deg = "deg",\n      origin = _getComputedProperty(target, _transformOriginProp) || "0",\n      x,\n      y,\n      z,\n      scaleX,\n      scaleY,\n      rotation,\n      rotationX,\n      rotationY,\n      skewX,\n      skewY,\n      perspective,\n      xOrigin,\n      yOrigin,\n      matrix,\n      angle,\n      cos,\n      sin,\n      a,\n      b,\n      c,\n      d,\n      a12,\n      a22,\n      t1,\n      t2,\n      t3,\n      a13,\n      a23,\n      a33,\n      a42,\n      a43,\n      a32;\n  x = y = z = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;\n  scaleX = scaleY = 1;\n  cache.svg = !!(target.getCTM && _isSVG(target));\n  matrix = CSSPlugin_getMatrix(target, cache.svg);\n\n  if (cache.svg) {\n    t1 = !cache.uncache && target.getAttribute("data-svg-origin");\n\n    _applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, cache.smooth !== false, matrix);\n  }\n\n  xOrigin = cache.xOrigin || 0;\n  yOrigin = cache.yOrigin || 0;\n\n  if (matrix !== _identity2DMatrix) {\n    a = matrix[0]; //a11\n\n    b = matrix[1]; //a21\n\n    c = matrix[2]; //a31\n\n    d = matrix[3]; //a41\n\n    x = a12 = matrix[4];\n    y = a22 = matrix[5]; //2D matrix\n\n    if (matrix.length === 6) {\n      scaleX = Math.sqrt(a * a + b * b);\n      scaleY = Math.sqrt(d * d + c * c);\n      rotation = a || b ? _atan2(b, a) * _RAD2DEG : 0; //note: if scaleX is 0, we cannot accurately measure rotation. Same for skewX with a scaleY of 0. Therefore, we default to the previously recorded value (or zero if that doesn\'t exist).\n\n      skewX = c || d ? _atan2(c, d) * _RAD2DEG + rotation : 0;\n      skewX && (scaleY *= Math.cos(skewX * _DEG2RAD));\n\n      if (cache.svg) {\n        x -= xOrigin - (xOrigin * a + yOrigin * c);\n        y -= yOrigin - (xOrigin * b + yOrigin * d);\n      } //3D matrix\n\n    } else {\n      a32 = matrix[6];\n      a42 = matrix[7];\n      a13 = matrix[8];\n      a23 = matrix[9];\n      a33 = matrix[10];\n      a43 = matrix[11];\n      x = matrix[12];\n      y = matrix[13];\n      z = matrix[14];\n      angle = _atan2(a32, a33);\n      rotationX = angle * _RAD2DEG; //rotationX\n\n      if (angle) {\n        cos = Math.cos(-angle);\n        sin = Math.sin(-angle);\n        t1 = a12 * cos + a13 * sin;\n        t2 = a22 * cos + a23 * sin;\n        t3 = a32 * cos + a33 * sin;\n        a13 = a12 * -sin + a13 * cos;\n        a23 = a22 * -sin + a23 * cos;\n        a33 = a32 * -sin + a33 * cos;\n        a43 = a42 * -sin + a43 * cos;\n        a12 = t1;\n        a22 = t2;\n        a32 = t3;\n      } //rotationY\n\n\n      angle = _atan2(-c, a33);\n      rotationY = angle * _RAD2DEG;\n\n      if (angle) {\n        cos = Math.cos(-angle);\n        sin = Math.sin(-angle);\n        t1 = a * cos - a13 * sin;\n        t2 = b * cos - a23 * sin;\n        t3 = c * cos - a33 * sin;\n        a43 = d * sin + a43 * cos;\n        a = t1;\n        b = t2;\n        c = t3;\n      } //rotationZ\n\n\n      angle = _atan2(b, a);\n      rotation = angle * _RAD2DEG;\n\n      if (angle) {\n        cos = Math.cos(angle);\n        sin = Math.sin(angle);\n        t1 = a * cos + b * sin;\n        t2 = a12 * cos + a22 * sin;\n        b = b * cos - a * sin;\n        a22 = a22 * cos - a12 * sin;\n        a = t1;\n        a12 = t2;\n      }\n\n      if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) {\n        //when rotationY is set, it will often be parsed as 180 degrees different than it should be, and rotationX and rotation both being 180 (it looks the same), so we adjust for that here.\n        rotationX = rotation = 0;\n        rotationY = 180 - rotationY;\n      }\n\n      scaleX = _round(Math.sqrt(a * a + b * b + c * c));\n      scaleY = _round(Math.sqrt(a22 * a22 + a32 * a32));\n      angle = _atan2(a12, a22);\n      skewX = Math.abs(angle) > 0.0002 ? angle * _RAD2DEG : 0;\n      perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;\n    }\n\n    if (cache.svg) {\n      //sense if there are CSS transforms applied on an SVG element in which case we must overwrite them when rendering. The transform attribute is more reliable cross-browser, but we can\'t just remove the CSS ones because they may be applied in a CSS rule somewhere (not just inline).\n      t1 = target.getAttribute("transform");\n      cache.forceCSS = target.setAttribute("transform", "") || !_isNullTransform(_getComputedProperty(target, _transformProp));\n      t1 && target.setAttribute("transform", t1);\n    }\n  }\n\n  if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {\n    if (invertedScaleX) {\n      scaleX *= -1;\n      skewX += rotation <= 0 ? 180 : -180;\n      rotation += rotation <= 0 ? 180 : -180;\n    } else {\n      scaleY *= -1;\n      skewX += skewX <= 0 ? 180 : -180;\n    }\n  }\n\n  cache.x = ((cache.xPercent = x && Math.round(target.offsetWidth / 2) === Math.round(-x) ? -50 : 0) ? 0 : x) + px;\n  cache.y = ((cache.yPercent = y && Math.round(target.offsetHeight / 2) === Math.round(-y) ? -50 : 0) ? 0 : y) + px;\n  cache.z = z + px;\n  cache.scaleX = _round(scaleX);\n  cache.scaleY = _round(scaleY);\n  cache.rotation = _round(rotation) + deg;\n  cache.rotationX = _round(rotationX) + deg;\n  cache.rotationY = _round(rotationY) + deg;\n  cache.skewX = skewX + deg;\n  cache.skewY = skewY + deg;\n  cache.transformPerspective = perspective + px;\n\n  if (cache.zOrigin = parseFloat(origin.split(" ")[2]) || 0) {\n    style[_transformOriginProp] = _firstTwoOnly(origin);\n  }\n\n  cache.xOffset = cache.yOffset = 0;\n  cache.force3D = _config.force3D;\n  cache.renderTransform = cache.svg ? CSSPlugin_renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;\n  cache.uncache = 0;\n  return cache;\n},\n    _firstTwoOnly = function _firstTwoOnly(value) {\n  return (value = value.split(" "))[0] + " " + value[1];\n},\n    //for handling transformOrigin values, stripping out the 3rd dimension\nCSSPlugin_addPxTranslate = function _addPxTranslate(target, start, value) {\n  var unit = getUnit(start);\n  return _round(parseFloat(start) + parseFloat(CSSPlugin_convertToUnit(target, "x", value + "px", unit))) + unit;\n},\n    _renderNon3DTransforms = function _renderNon3DTransforms(ratio, cache) {\n  cache.z = "0px";\n  cache.rotationY = cache.rotationX = "0deg";\n  cache.force3D = 0;\n\n  _renderCSSTransforms(ratio, cache);\n},\n    _zeroDeg = "0deg",\n    _zeroPx = "0px",\n    _endParenthesis = ") ",\n    _renderCSSTransforms = function _renderCSSTransforms(ratio, cache) {\n  var _ref = cache || this,\n      xPercent = _ref.xPercent,\n      yPercent = _ref.yPercent,\n      x = _ref.x,\n      y = _ref.y,\n      z = _ref.z,\n      rotation = _ref.rotation,\n      rotationY = _ref.rotationY,\n      rotationX = _ref.rotationX,\n      skewX = _ref.skewX,\n      skewY = _ref.skewY,\n      scaleX = _ref.scaleX,\n      scaleY = _ref.scaleY,\n      transformPerspective = _ref.transformPerspective,\n      force3D = _ref.force3D,\n      target = _ref.target,\n      zOrigin = _ref.zOrigin,\n      transforms = "",\n      use3D = force3D === "auto" && ratio && ratio !== 1 || force3D === true; // Safari has a bug that causes it not to render 3D transform-origin values properly, so we force the z origin to 0, record it in the cache, and then do the math here to offset the translate values accordingly (basically do the 3D transform-origin part manually)\n\n\n  if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {\n    var angle = parseFloat(rotationY) * _DEG2RAD,\n        a13 = Math.sin(angle),\n        a33 = Math.cos(angle),\n        cos;\n\n    angle = parseFloat(rotationX) * _DEG2RAD;\n    cos = Math.cos(angle);\n    x = CSSPlugin_addPxTranslate(target, x, a13 * cos * -zOrigin);\n    y = CSSPlugin_addPxTranslate(target, y, -Math.sin(angle) * -zOrigin);\n    z = CSSPlugin_addPxTranslate(target, z, a33 * cos * -zOrigin + zOrigin);\n  }\n\n  if (transformPerspective !== _zeroPx) {\n    transforms += "perspective(" + transformPerspective + _endParenthesis;\n  }\n\n  if (xPercent || yPercent) {\n    transforms += "translate(" + xPercent + "%, " + yPercent + "%) ";\n  }\n\n  if (use3D || x !== _zeroPx || y !== _zeroPx || z !== _zeroPx) {\n    transforms += z !== _zeroPx || use3D ? "translate3d(" + x + ", " + y + ", " + z + ") " : "translate(" + x + ", " + y + _endParenthesis;\n  }\n\n  if (rotation !== _zeroDeg) {\n    transforms += "rotate(" + rotation + _endParenthesis;\n  }\n\n  if (rotationY !== _zeroDeg) {\n    transforms += "rotateY(" + rotationY + _endParenthesis;\n  }\n\n  if (rotationX !== _zeroDeg) {\n    transforms += "rotateX(" + rotationX + _endParenthesis;\n  }\n\n  if (skewX !== _zeroDeg || skewY !== _zeroDeg) {\n    transforms += "skew(" + skewX + ", " + skewY + _endParenthesis;\n  }\n\n  if (scaleX !== 1 || scaleY !== 1) {\n    transforms += "scale(" + scaleX + ", " + scaleY + _endParenthesis;\n  }\n\n  target.style[_transformProp] = transforms || "translate(0, 0)";\n},\n    CSSPlugin_renderSVGTransforms = function _renderSVGTransforms(ratio, cache) {\n  var _ref2 = cache || this,\n      xPercent = _ref2.xPercent,\n      yPercent = _ref2.yPercent,\n      x = _ref2.x,\n      y = _ref2.y,\n      rotation = _ref2.rotation,\n      skewX = _ref2.skewX,\n      skewY = _ref2.skewY,\n      scaleX = _ref2.scaleX,\n      scaleY = _ref2.scaleY,\n      target = _ref2.target,\n      xOrigin = _ref2.xOrigin,\n      yOrigin = _ref2.yOrigin,\n      xOffset = _ref2.xOffset,\n      yOffset = _ref2.yOffset,\n      forceCSS = _ref2.forceCSS,\n      tx = parseFloat(x),\n      ty = parseFloat(y),\n      a11,\n      a21,\n      a12,\n      a22,\n      temp;\n\n  rotation = parseFloat(rotation);\n  skewX = parseFloat(skewX);\n  skewY = parseFloat(skewY);\n\n  if (skewY) {\n    //for performance reasons, we combine all skewing into the skewX and rotation values. Remember, a skewY of 10 degrees looks the same as a rotation of 10 degrees plus a skewX of 10 degrees.\n    skewY = parseFloat(skewY);\n    skewX += skewY;\n    rotation += skewY;\n  }\n\n  if (rotation || skewX) {\n    rotation *= _DEG2RAD;\n    skewX *= _DEG2RAD;\n    a11 = Math.cos(rotation) * scaleX;\n    a21 = Math.sin(rotation) * scaleX;\n    a12 = Math.sin(rotation - skewX) * -scaleY;\n    a22 = Math.cos(rotation - skewX) * scaleY;\n\n    if (skewX) {\n      skewY *= _DEG2RAD;\n      temp = Math.tan(skewX - skewY);\n      temp = Math.sqrt(1 + temp * temp);\n      a12 *= temp;\n      a22 *= temp;\n\n      if (skewY) {\n        temp = Math.tan(skewY);\n        temp = Math.sqrt(1 + temp * temp);\n        a11 *= temp;\n        a21 *= temp;\n      }\n    }\n\n    a11 = _round(a11);\n    a21 = _round(a21);\n    a12 = _round(a12);\n    a22 = _round(a22);\n  } else {\n    a11 = scaleX;\n    a22 = scaleY;\n    a21 = a12 = 0;\n  }\n\n  if (tx && !~(x + "").indexOf("px") || ty && !~(y + "").indexOf("px")) {\n    tx = CSSPlugin_convertToUnit(target, "x", x, "px");\n    ty = CSSPlugin_convertToUnit(target, "y", y, "px");\n  }\n\n  if (xOrigin || yOrigin || xOffset || yOffset) {\n    tx = _round(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);\n    ty = _round(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset);\n  }\n\n  if (xPercent || yPercent) {\n    //The SVG spec doesn\'t support percentage-based translation in the "transform" attribute, so we merge it into the translation to simulate it.\n    temp = target.getBBox();\n    tx = _round(tx + xPercent / 100 * temp.width);\n    ty = _round(ty + yPercent / 100 * temp.height);\n  }\n\n  temp = "matrix(" + a11 + "," + a21 + "," + a12 + "," + a22 + "," + tx + "," + ty + ")";\n  target.setAttribute("transform", temp);\n\n  if (forceCSS) {\n    //some browsers prioritize CSS transforms over the transform attribute. When we sense that the user has CSS transforms applied, we must overwrite them this way (otherwise some browser simply won\'t render the  transform attribute changes!)\n    target.style[_transformProp] = temp;\n  }\n},\n    CSSPlugin_addRotationalPropTween = function _addRotationalPropTween(plugin, target, property, startNum, endValue, relative) {\n  var cap = 360,\n      isString = _isString(endValue),\n      endNum = parseFloat(endValue) * (isString && ~endValue.indexOf("rad") ? _RAD2DEG : 1),\n      change = relative ? endNum * relative : endNum - startNum,\n      finalValue = startNum + change + "deg",\n      direction,\n      pt;\n\n  if (isString) {\n    direction = endValue.split("_")[1];\n\n    if (direction === "short") {\n      change %= cap;\n\n      if (change !== change % (cap / 2)) {\n        change += change < 0 ? cap : -cap;\n      }\n    }\n\n    if (direction === "cw" && change < 0) {\n      change = (change + cap * CSSPlugin_bigNum) % cap - ~~(change / cap) * cap;\n    } else if (direction === "ccw" && change > 0) {\n      change = (change - cap * CSSPlugin_bigNum) % cap - ~~(change / cap) * cap;\n    }\n  }\n\n  plugin._pt = pt = new PropTween(plugin._pt, target, property, startNum, change, _renderPropWithEnd);\n  pt.e = finalValue;\n  pt.u = "deg";\n\n  plugin._props.push(property);\n\n  return pt;\n},\n    CSSPlugin_addRawTransformPTs = function _addRawTransformPTs(plugin, transforms, target) {\n  //for handling cases where someone passes in a whole transform string, like transform: "scale(2, 3) rotate(20deg) translateY(30em)"\n  var style = _tempDivStyler.style,\n      startCache = target._gsap,\n      exclude = "perspective,force3D,transformOrigin,svgOrigin",\n      endCache,\n      p,\n      startValue,\n      endValue,\n      startNum,\n      endNum,\n      startUnit,\n      endUnit;\n  style.cssText = getComputedStyle(target).cssText + ";position:absolute;display:block;"; //%-based translations will fail unless we set the width/height to match the original target (and padding/borders can affect it)\n\n  style[_transformProp] = transforms;\n\n  CSSPlugin_doc.body.appendChild(_tempDivStyler);\n\n  endCache = CSSPlugin_parseTransform(_tempDivStyler, 1);\n\n  for (p in _transformProps) {\n    startValue = startCache[p];\n    endValue = endCache[p];\n\n    if (startValue !== endValue && exclude.indexOf(p) < 0) {\n      //tweening to no perspective gives very unintuitive results - just keep the same perspective in that case.\n      startUnit = getUnit(startValue);\n      endUnit = getUnit(endValue);\n      startNum = startUnit !== endUnit ? CSSPlugin_convertToUnit(target, p, startValue, endUnit) : parseFloat(startValue);\n      endNum = parseFloat(endValue);\n      plugin._pt = new PropTween(plugin._pt, startCache, p, startNum, endNum - startNum, _renderCSSProp);\n      plugin._pt.u = endUnit || 0;\n\n      plugin._props.push(p);\n    }\n  }\n\n  CSSPlugin_doc.body.removeChild(_tempDivStyler);\n}; // handle splitting apart padding, margin, borderWidth, and borderRadius into their 4 components. Firefox, for example, won\'t report borderRadius correctly - it will only do borderTopLeftRadius and the other corners. We also want to handle paddingTop, marginLeft, borderRightWidth, etc.\n\n\n_forEachName("padding,margin,Width,Radius", function (name, index) {\n  var t = "Top",\n      r = "Right",\n      b = "Bottom",\n      l = "Left",\n      props = (index < 3 ? [t, r, b, l] : [t + l, t + r, b + r, b + l]).map(function (side) {\n    return index < 2 ? name + side : "border" + side + name;\n  });\n\n  _specialProps[index > 1 ? "border" + name : name] = function (plugin, target, property, endValue, tween) {\n    var a, vars;\n\n    if (arguments.length < 4) {\n      // getter, passed target, property, and unit (from _get())\n      a = props.map(function (prop) {\n        return CSSPlugin_get(plugin, prop, property);\n      });\n      vars = a.join(" ");\n      return vars.split(a[0]).length === 5 ? a[0] : vars;\n    }\n\n    a = (endValue + "").split(" ");\n    vars = {};\n    props.forEach(function (prop, i) {\n      return vars[prop] = a[i] = a[i] || a[(i - 1) / 2 | 0];\n    });\n    plugin.init(target, vars, tween);\n  };\n});\n\nvar CSSPlugin = {\n  name: "css",\n  register: _initCore,\n  targetTest: function targetTest(target) {\n    return target.style && target.nodeType;\n  },\n  init: function init(target, vars, tween, index, targets) {\n    var props = this._props,\n        style = target.style,\n        startValue,\n        endValue,\n        endNum,\n        startNum,\n        type,\n        specialProp,\n        p,\n        startUnit,\n        endUnit,\n        relative,\n        isTransformRelated,\n        transformPropTween,\n        cache,\n        smooth,\n        hasPriority;\n\n    if (!_pluginInitted) {\n      _initCore();\n    }\n\n    for (p in vars) {\n      if (p === "autoRound") {\n        continue;\n      }\n\n      endValue = vars[p];\n\n      if (_plugins[p] && _checkPlugin(p, vars, tween, index, target, targets)) {\n        //plugins\n        continue;\n      }\n\n      type = typeof endValue;\n      specialProp = _specialProps[p];\n\n      if (type === "function") {\n        endValue = endValue.call(tween, index, target, targets);\n        type = typeof endValue;\n      }\n\n      if (type === "string" && ~endValue.indexOf("random(")) {\n        endValue = _replaceRandom(endValue);\n      }\n\n      if (specialProp) {\n        if (specialProp(this, target, p, endValue, tween)) {\n          hasPriority = 1;\n        }\n      } else if (p.substr(0, 2) === "--") {\n        //CSS variable\n        this.add(style, "setProperty", getComputedStyle(target).getPropertyValue(p) + "", endValue + "", index, targets, 0, 0, p);\n      } else {\n        startValue = CSSPlugin_get(target, p);\n        startNum = parseFloat(startValue);\n        relative = type === "string" && endValue.charAt(1) === "=" ? +(endValue.charAt(0) + "1") : 0;\n\n        if (relative) {\n          endValue = endValue.substr(2);\n        }\n\n        endNum = parseFloat(endValue);\n\n        if (p in _propertyAliases) {\n          if (p === "autoAlpha") {\n            //special case where we control the visibility along with opacity. We still allow the opacity value to pass through and get tweened.\n            if (startNum === 1 && CSSPlugin_get(target, "visibility") === "hidden" && endNum) {\n              //if visibility is initially set to "hidden", we should interpret that as intent to make opacity 0 (a convenience)\n              startNum = 0;\n            }\n\n            CSSPlugin_addNonTweeningPT(this, style, "visibility", startNum ? "inherit" : "hidden", endNum ? "inherit" : "hidden", !endNum);\n          }\n\n          if (p !== "scale" && p !== "transform") {\n            p = _propertyAliases[p];\n\n            if (~p.indexOf(",")) {\n              p = p.split(",")[0];\n            }\n          }\n        }\n\n        isTransformRelated = p in _transformProps; //--- TRANSFORM-RELATED ---\n\n        if (isTransformRelated) {\n          if (!transformPropTween) {\n            cache = target._gsap;\n            cache.renderTransform || CSSPlugin_parseTransform(target); // if, for example, gsap.set(... {transform:"translateX(50vw)"}), the _get() call doesn\'t parse the transform, thus cache.renderTransform won\'t be set yet so force the parsing of the transform here.\n\n            smooth = vars.smoothOrigin !== false && cache.smooth;\n            transformPropTween = this._pt = new PropTween(this._pt, style, _transformProp, 0, 1, cache.renderTransform, cache, 0, -1); //the first time through, create the rendering PropTween so that it runs LAST (in the linked list, we keep adding to the beginning)\n\n            transformPropTween.dep = 1; //flag it as dependent so that if things get killed/overwritten and this is the only PropTween left, we can safely kill the whole tween.\n          }\n\n          if (p === "scale") {\n            this._pt = new PropTween(this._pt, cache, "scaleY", cache.scaleY, relative ? relative * endNum : endNum - cache.scaleY);\n            props.push("scaleY", p);\n            p += "X";\n          } else if (p === "transformOrigin") {\n            endValue = _convertKeywordsToPercentages(endValue); //in case something like "left top" or "bottom right" is passed in. Convert to percentages.\n\n            if (cache.svg) {\n              _applySVGOrigin(target, endValue, 0, smooth, 0, this);\n            } else {\n              endUnit = parseFloat(endValue.split(" ")[2]) || 0; //handle the zOrigin separately!\n\n              if (endUnit !== cache.zOrigin) {\n                CSSPlugin_addNonTweeningPT(this, cache, "zOrigin", cache.zOrigin, endUnit);\n              }\n\n              CSSPlugin_addNonTweeningPT(this, style, p, _firstTwoOnly(startValue), _firstTwoOnly(endValue));\n            }\n\n            continue;\n          } else if (p === "svgOrigin") {\n            _applySVGOrigin(target, endValue, 1, smooth, 0, this);\n\n            continue;\n          } else if (p in _rotationalProperties) {\n            CSSPlugin_addRotationalPropTween(this, cache, p, startNum, endValue, relative);\n\n            continue;\n          } else if (p === "smoothOrigin") {\n            CSSPlugin_addNonTweeningPT(this, cache, "smooth", cache.smooth, endValue);\n\n            continue;\n          } else if (p === "force3D") {\n            cache[p] = endValue;\n            continue;\n          } else if (p === "transform") {\n            CSSPlugin_addRawTransformPTs(this, endValue, target);\n\n            continue;\n          }\n        } else if (!(p in style)) {\n          p = _checkPropPrefix(p) || p;\n        }\n\n        if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p in style) {\n          startUnit = (startValue + "").substr((startNum + "").length);\n          endNum || (endNum = 0); // protect against NaN\n\n          endUnit = (endValue + "").substr((endNum + "").length) || (p in _config.units ? _config.units[p] : startUnit);\n\n          if (startUnit !== endUnit) {\n            startNum = CSSPlugin_convertToUnit(target, p, startValue, endUnit);\n          }\n\n          this._pt = new PropTween(this._pt, isTransformRelated ? cache : style, p, startNum, relative ? relative * endNum : endNum - startNum, endUnit === "px" && vars.autoRound !== false && !isTransformRelated ? _renderRoundedCSSProp : _renderCSSProp);\n          this._pt.u = endUnit || 0;\n\n          if (startUnit !== endUnit) {\n            //when the tween goes all the way back to the beginning, we need to revert it to the OLD/ORIGINAL value (with those units). We record that as a "b" (beginning) property and point to a render method that handles that. (performance optimization)\n            this._pt.b = startValue;\n            this._pt.r = _renderCSSPropWithBeginning;\n          }\n        } else if (!(p in style)) {\n          if (p in target) {\n            //maybe it\'s not a style - it could be a property added directly to an element in which case we\'ll try to animate that.\n            this.add(target, p, target[p], endValue, index, targets);\n          } else {\n            _missingPlugin(p, endValue);\n\n            continue;\n          }\n        } else {\n          CSSPlugin_tweenComplexCSSString.call(this, target, p, startValue, endValue);\n        }\n\n        props.push(p);\n      }\n    }\n\n    if (hasPriority) {\n      _sortPropTweensByPriority(this);\n    }\n  },\n  get: CSSPlugin_get,\n  aliases: _propertyAliases,\n  getSetter: function getSetter(target, property, plugin) {\n    //returns a setter function that accepts target, property, value and applies it accordingly. Remember, properties like "x" aren\'t as simple as target.style.property = value because they\'ve got to be applied to a proxy object and then merged into a transform string in a renderer.\n    var p = _propertyAliases[property];\n    p && p.indexOf(",") < 0 && (property = p);\n    return property in _transformProps && property !== _transformOriginProp && (target._gsap.x || CSSPlugin_get(target, "x")) ? plugin && _recentSetterPlugin === plugin ? property === "scale" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property === "scale" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !_isUndefined(target.style[property]) ? _setterCSSStyle : ~property.indexOf("-") ? _setterCSSProp : _getSetter(target, property);\n  },\n  core: {\n    _removeProperty: _removeProperty,\n    _getMatrix: CSSPlugin_getMatrix\n  }\n};\ngsap.utils.checkPrefix = _checkPropPrefix;\n\n(function (positionAndScale, rotation, others, aliases) {\n  var all = _forEachName(positionAndScale + "," + rotation + "," + others, function (name) {\n    _transformProps[name] = 1;\n  });\n\n  _forEachName(rotation, function (name) {\n    _config.units[name] = "deg";\n    _rotationalProperties[name] = 1;\n  });\n\n  _propertyAliases[all[13]] = positionAndScale + "," + rotation;\n\n  _forEachName(aliases, function (name) {\n    var split = name.split(":");\n    _propertyAliases[split[1]] = all[split[0]];\n  });\n})("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");\n\n_forEachName("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function (name) {\n  _config.units[name] = "px";\n});\n\ngsap.registerPlugin(CSSPlugin);\n\n// CONCATENATED MODULE: ./node_modules/gsap/index.js\n\n\nvar gsapWithCSS = gsap.registerPlugin(CSSPlugin) || gsap,\n    // to protect from tree shaking\nTweenMaxWithCSS = gsapWithCSS.core.Tween;\n\n// CONCATENATED MODULE: ./src/js/components/gsap-helpers.js\n/*\r\nFunction that "start" a timeline object and "reverse" it\r\nwhen it an event in a specified element is triggered.\r\n*/\nvar startAndReverse = function startAndReverse(elem, event, tl) {\n  return elem.addEventListener(event, function () {\n    return tl.reversed() ? tl.play() : tl.reverse();\n  });\n};\n// CONCATENATED MODULE: ./src/js/components/navigation.js\n\n\nvar line1 = document.querySelector(\'#line-1\'),\n    line2 = document.querySelector(\'#line-2\'),\n    line3 = document.querySelector(\'#line-3\'),\n    hamburguerMenu = document.querySelector(\'#nav__hamburguer-menu\'),\n    menu = document.querySelector(\'#nav__menu\');\n\nvar onReverseComplete = function onReverseComplete() {};\n\nvar onComplete = function onComplete() {};\n\nvar navigation_tl = gsapWithCSS.timeline({\n  paused: true,\n  reversed: true\n}).addLabel(\'init\').to(line1, .5, {\n  attr: {\n    y2: 28\n  }\n}).to(line2, .5, {\n  opacity: 0\n}, \'init\').to(line3, .5, {\n  attr: {\n    y2: 2\n  }\n}, \'init\').to(menu, 0.6, {\n  autoAlpha: 1\n}, \'init\').set(menu, {\n  zIndex: 10\n});\nstartAndReverse(hamburguerMenu, \'click\', navigation_tl);\n// CONCATENATED MODULE: ./src/js/components/scenes.js\n// import {gsap} from \'gsap\';\n// import {ScrollTrigger} from "gsap/ScrollTrigger";\n// gsap.registerPlugin(ScrollTrigger);\n\n\n\nvar scenes_onReverseComplete = function onReverseComplete() {};\n\nvar scenes_onComplete = function onComplete() {};\n\nvar scenes_infoLinkOnClick = function infoLinkOnClick(e) {\n  e.preventDefault();\n  var currentTarget = e.currentTarget;\n  var lines = currentTarget.querySelectorAll(\'line\');\n  var tl = gsapWithCSS.timeline({\n    paused: true,\n    reversed: true\n  }).addLabel(\'init\').to(lines[0], .5, {\n    attr: {\n      x2: 0,\n      y2: 20\n    }\n  }, \'init\').to(lines[1], .5, {\n    attr: {\n      x1: 20\n    }\n  }, \'init\');\n  startAndReverse(currentTarget, \'click\', tl); // info-link__line-1\n};\n\ndocument.querySelectorAll(\'.artist-section__info-link\').forEach(function (elem) {\n  return elem.addEventListener(\'click\', scenes_infoLinkOnClick);\n});\n/*\r\nconst buildArtistTimeline = artist => {\r\n    const section = document.querySelector(`#${artist}.artist-section`),\r\n        welcomeSection = document.querySelector(`#${artist} .artist-section__welcome`),\r\n        sectionWrapper = document.querySelector(`#${artist} .artist-section__wrapper`),\r\n        sectionInfo = document.querySelector(`#${artist} .artist-section__info`),\r\n        infoArr = document.querySelectorAll(`#${artist} .artist-section__info p`),\r\n        perspective = 1000;    \r\n    \r\n    const aTl = gsap.timeline({\r\n        scrollTrigger: {\r\n            trigger: section,\r\n            start: \'top top\',\r\n            end: \'+=15000\',\r\n            pin: true,\r\n            // anticipatePin: 1,\r\n            // markers: true,\r\n            scrub: 1            \r\n        }\r\n    });\r\n    \r\n    /*\r\n    const buildInfoTl = s_p => {\r\n        return gsap.timeline()\r\n        .to(infoArr[s_p], 1, {opacity: 1, display: \'block\'})\r\n        .addPause(2)\r\n        .to(infoArr[s_p], 1, {opacity: 0, display: \'none\'})\r\n    };\r\n    */\n//TODO: Improve this code\n// El valor aparece bruscamente\n\n/*return aTl\r\n    .set(sectionWrapper, {css:{transformPerspective: perspective, transformStyle: \'preserve-3d\'}})\r\n    // Improve Quality\r\n    .to(welcomeSection, 1, {css: {z: perspective}})\r\n    .fromTo(sectionInfo, 1, {opacity: 0}, {opacity: 1})\r\n    .addPause(3)\r\n    .to(infoArr[0], 1, {opacity: 0, display: \'none\'})\r\n    .fromTo(infoArr[1], 1, {opacity: 0}, {opacity: 1, display: \'block\'})\r\n    .addPause(3)\r\n    .to(infoArr[1], 1, {opacity: 0, display: \'none\'})\r\n    .fromTo(infoArr[2], 1, {opacity: 0}, {opacity: 1, display: \'block\'})\r\n    .addPause(3)\r\n    .to(infoArr[2], 1, {opacity: 0, display: \'none\'})\r\n    .fromTo(infoArr[3], 1, {opacity: 0}, {opacity: 1, display: \'block\'})\r\n    .addPause(3)\r\n    .to(infoArr[3], 1, {opacity: 0, display: \'none\'})\r\n    .fromTo(infoArr[4], 1, {opacity: 0}, {opacity: 1, display: \'block\'})\r\n    .addPause(3)\r\n    .to(infoArr[4], 1, {opacity: 0, display: \'none\'})\r\n    .fromTo(infoArr[5], 1, {opacity: 0}, {opacity: 1, display: \'block\'})\r\n    .addPause(3)\r\n    .to(infoArr[5], 1, {opacity: 0, display: \'none\'})\r\n    .fromTo(infoArr[6], 1, {opacity: 0}, {opacity: 1, display: \'block\'})\r\n    .addPause(3);        \r\n};\r\ngsap.timeline()\r\n.add(buildArtistTimeline(\'velazquez\'))\r\n.add(buildArtistTimeline(\'goya\'))\r\n.add(buildArtistTimeline(\'picasso\'))\r\n.add(buildArtistTimeline(\'dali\'));\r\n*/\n// CONCATENATED MODULE: ./node_modules/gsap/ScrollTrigger.js\n/*!\n * ScrollTrigger 3.4.2\n * https://greensock.com\n *\n * @license Copyright 2008-2020, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n\n/* eslint-disable */\nvar ScrollTrigger_gsap,\n    ScrollTrigger_coreInitted,\n    ScrollTrigger_win,\n    ScrollTrigger_doc,\n    _docEl,\n    _body,\n    _root,\n    _resizeDelay,\n    _raf,\n    _request,\n    _toArray,\n    ScrollTrigger_clamp,\n    _time2,\n    _syncInterval,\n    _refreshing,\n    _pointerIsDown,\n    ScrollTrigger_transformProp,\n    _i,\n    _prevWidth,\n    _prevHeight,\n    _autoRefresh,\n    _sort,\n    _limitCallbacks,\n    // if true, we\'ll only trigger callbacks if the active state toggles, so if you scroll immediately past both the start and end positions of a ScrollTrigger (thus inactive to inactive), neither its onEnter nor onLeave will be called. This is useful during startup.\n_startup = 1,\n    _proxies = [],\n    _scrollers = [],\n    _getTime = Date.now,\n    _time1 = _getTime(),\n    _lastScrollTime = 0,\n    _enabled = 1,\n    ScrollTrigger_passThrough = function _passThrough(v) {\n  return v;\n},\n    ScrollTrigger_windowExists = function _windowExists() {\n  return typeof window !== "undefined";\n},\n    _getGSAP = function _getGSAP() {\n  return ScrollTrigger_gsap || ScrollTrigger_windowExists() && (ScrollTrigger_gsap = window.gsap) && ScrollTrigger_gsap.registerPlugin && ScrollTrigger_gsap;\n},\n    _isViewport = function _isViewport(e) {\n  return !!~_root.indexOf(e);\n},\n    _getProxyProp = function _getProxyProp(element, property) {\n  return ~_proxies.indexOf(element) && _proxies[_proxies.indexOf(element) + 1][property];\n},\n    _getScrollFunc = function _getScrollFunc(element, _ref) {\n  var s = _ref.s,\n      sc = _ref.sc;\n\n  var i = _scrollers.indexOf(element),\n      func = ~i ? _scrollers[i + 1] : _getProxyProp(element, s) || (_isViewport(element) ? sc : function (value) {\n    return arguments.length ? element[s] = value : element[s];\n  });\n\n  !~i && _scrollers.push(element, func);\n  return func;\n},\n    _getBoundsFunc = function _getBoundsFunc(element) {\n  return _getProxyProp(element, "getBoundingClientRect") || (_isViewport(element) ? function () {\n    _winOffsets.width = ScrollTrigger_win.innerWidth;\n    _winOffsets.height = ScrollTrigger_win.innerHeight;\n    return _winOffsets;\n  } : function () {\n    return _getBounds(element);\n  });\n},\n    _getSizeFunc = function _getSizeFunc(scroller, isViewport, _ref2) {\n  var d = _ref2.d,\n      d2 = _ref2.d2,\n      a = _ref2.a;\n  return (a = _getProxyProp(scroller, "getBoundingClientRect")) ? function () {\n    return a()[d];\n  } : function () {\n    return (isViewport ? ScrollTrigger_win["inner" + d2] : scroller["client" + d2]) || 0;\n  };\n},\n    _getOffsetsFunc = function _getOffsetsFunc(element, isViewport) {\n  return !isViewport || ~_proxies.indexOf(element) ? _getBoundsFunc(element) : function () {\n    return _winOffsets;\n  };\n},\n    _maxScroll = function _maxScroll(element, _ref3) {\n  var s = _ref3.s,\n      d2 = _ref3.d2,\n      d = _ref3.d,\n      a = _ref3.a;\n  return (s = "scroll" + d2) && (a = _getProxyProp(element, s)) ? a() - _getBoundsFunc(element)()[d] : _isViewport(element) ? Math.max(_docEl[s], _body[s]) - (ScrollTrigger_win["inner" + d2] || _docEl["client" + d2] || _body["client" + d2]) : element[s] - element["offset" + d2];\n},\n    _iterateAutoRefresh = function _iterateAutoRefresh(func, events) {\n  for (var i = 0; i < _autoRefresh.length; i += 3) {\n    (!events || ~events.indexOf(_autoRefresh[i + 1])) && func(_autoRefresh[i], _autoRefresh[i + 1], _autoRefresh[i + 2]);\n  }\n},\n    ScrollTrigger_isString = function _isString(value) {\n  return typeof value === "string";\n},\n    ScrollTrigger_isFunction = function _isFunction(value) {\n  return typeof value === "function";\n},\n    ScrollTrigger_isNumber = function _isNumber(value) {\n  return typeof value === "number";\n},\n    ScrollTrigger_isObject = function _isObject(value) {\n  return typeof value === "object";\n},\n    _callIfFunc = function _callIfFunc(value) {\n  return ScrollTrigger_isFunction(value) && value();\n},\n    _combineFunc = function _combineFunc(f1, f2) {\n  return function () {\n    var result1 = _callIfFunc(f1),\n        result2 = _callIfFunc(f2);\n\n    return function () {\n      _callIfFunc(result1);\n\n      _callIfFunc(result2);\n    };\n  };\n},\n    _abs = Math.abs,\n    _scrollLeft = "scrollLeft",\n    _scrollTop = "scrollTop",\n    _left = "left",\n    _top = "top",\n    _right = "right",\n    _bottom = "bottom",\n    _width = "width",\n    _height = "height",\n    _Right = "Right",\n    _Left = "Left",\n    _Top = "Top",\n    _Bottom = "Bottom",\n    _padding = "padding",\n    _margin = "margin",\n    _Width = "Width",\n    _Height = "Height",\n    _px = "px",\n    _horizontal = {\n  s: _scrollLeft,\n  p: _left,\n  p2: _Left,\n  os: _right,\n  os2: _Right,\n  d: _width,\n  d2: _Width,\n  a: "x",\n  sc: function sc(value) {\n    return arguments.length ? ScrollTrigger_win.scrollTo(value, _vertical.sc()) : ScrollTrigger_win.pageXOffset || ScrollTrigger_doc[_scrollLeft] || _docEl[_scrollLeft] || _body[_scrollLeft] || 0;\n  }\n},\n    _vertical = {\n  s: _scrollTop,\n  p: _top,\n  p2: _Top,\n  os: _bottom,\n  os2: _Bottom,\n  d: _height,\n  d2: _Height,\n  a: "y",\n  op: _horizontal,\n  sc: function sc(value) {\n    return arguments.length ? ScrollTrigger_win.scrollTo(_horizontal.sc(), value) : ScrollTrigger_win.pageYOffset || ScrollTrigger_doc[_scrollTop] || _docEl[_scrollTop] || _body[_scrollTop] || 0;\n  }\n},\n    _getComputedStyle = function _getComputedStyle(element) {\n  return ScrollTrigger_win.getComputedStyle(element);\n},\n    _makePositionable = function _makePositionable(element) {\n  return element.style.position = _getComputedStyle(element).position === "absolute" ? "absolute" : "relative";\n},\n    // if the element already has position: absolute, leave that, otherwise make it position: relative\nScrollTrigger_setDefaults = function _setDefaults(obj, defaults) {\n  for (var p in defaults) {\n    p in obj || (obj[p] = defaults[p]);\n  }\n\n  return obj;\n},\n    //_isInViewport = element => (element = _getBounds(element)) && !(element.top > (_win.innerHeight || _docEl.clientHeight) || element.bottom < 0 || element.left > (_win.innerWidth || _docEl.clientWidth) || element.right < 0) && element,\n_getBounds = function _getBounds(element, withoutTransforms) {\n  var tween = withoutTransforms && _getComputedStyle(element)[ScrollTrigger_transformProp] !== "matrix(1, 0, 0, 1, 0, 0)" && ScrollTrigger_gsap.to(element, {\n    x: 0,\n    y: 0,\n    xPercent: 0,\n    yPercent: 0,\n    rotation: 0,\n    rotationX: 0,\n    rotationY: 0,\n    scale: 1,\n    skewX: 0,\n    skewY: 0\n  }).progress(1),\n      bounds = element.getBoundingClientRect();\n  tween && tween.progress(0).kill();\n  return bounds;\n},\n    _getSize = function _getSize(element, _ref4) {\n  var d2 = _ref4.d2;\n  return element["offset" + d2] || element["client" + d2] || 0;\n},\n    _getLabels = function _getLabels(animation) {\n  return function (value) {\n    var a = [],\n        labels = animation.labels,\n        duration = animation.duration(),\n        p;\n\n    for (p in labels) {\n      a.push(labels[p] / duration);\n    }\n\n    return ScrollTrigger_gsap.utils.snap(a, value);\n  };\n},\n    _multiListener = function _multiListener(func, element, types, callback) {\n  return types.split(",").forEach(function (type) {\n    return func(element, type, callback);\n  });\n},\n    _addListener = function _addListener(element, type, func) {\n  return element.addEventListener(type, func, {\n    passive: true\n  });\n},\n    _removeListener = function _removeListener(element, type, func) {\n  return element.removeEventListener(type, func);\n},\n    _markerDefaults = {\n  startColor: "green",\n  endColor: "red",\n  indent: 0,\n  fontSize: "16px",\n  fontWeight: "normal"\n},\n    ScrollTrigger_defaults = {\n  toggleActions: "play",\n  anticipatePin: 0\n},\n    _keywords = {\n  top: 0,\n  left: 0,\n  center: 0.5,\n  bottom: 1,\n  right: 1\n},\n    _offsetToPx = function _offsetToPx(value, size) {\n  if (ScrollTrigger_isString(value)) {\n    var eqIndex = value.indexOf("="),\n        relative = ~eqIndex ? +(value.charAt(eqIndex - 1) + 1) * parseFloat(value.substr(eqIndex + 1)) : 0;\n\n    if (relative) {\n      value.indexOf("%") > eqIndex && (relative *= size / 100);\n      value = value.substr(0, eqIndex - 1);\n    }\n\n    value = relative + (value in _keywords ? _keywords[value] * size : ~value.indexOf("%") ? parseFloat(value) * size / 100 : parseFloat(value) || 0);\n  }\n\n  return value;\n},\n    _createMarker = function _createMarker(type, name, container, direction, _ref5, offset, matchWidthEl) {\n  var startColor = _ref5.startColor,\n      endColor = _ref5.endColor,\n      fontSize = _ref5.fontSize,\n      indent = _ref5.indent,\n      fontWeight = _ref5.fontWeight;\n\n  var e = ScrollTrigger_doc.createElement("div"),\n      useFixedPosition = _isViewport(container) || _getProxyProp(container, "pinType") === "fixed",\n      isScroller = type.indexOf("scroller") !== -1,\n      parent = useFixedPosition ? _body : container,\n      isStart = type.indexOf("start") !== -1,\n      color = isStart ? startColor : endColor,\n      css = "border-color:" + color + ";font-size:" + fontSize + ";color:" + color + ";font-weight:" + fontWeight + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";\n\n  css += "position:" + (isScroller && useFixedPosition ? "fixed;" : "absolute;");\n  (isScroller || !useFixedPosition) && (css += (direction === _vertical ? _right : _bottom) + ":" + (offset + parseFloat(indent)) + "px;");\n  matchWidthEl && (css += "box-sizing:border-box;text-align:left;width:" + matchWidthEl.offsetWidth + "px;");\n  e._isStart = isStart;\n  e.setAttribute("class", "gsap-marker-" + type);\n  e.style.cssText = css;\n  e.innerText = name || name === 0 ? type + "-" + name : type;\n  parent.insertBefore(e, parent.children[0]);\n  e._offset = e["offset" + direction.op.d2];\n\n  _positionMarker(e, 0, direction, isStart);\n\n  return e;\n},\n    _positionMarker = function _positionMarker(marker, start, direction, flipped) {\n  var vars = {\n    display: "block"\n  },\n      side = direction[flipped ? "os2" : "p2"],\n      oppositeSide = direction[flipped ? "p2" : "os2"];\n  marker._isFlipped = flipped;\n  vars[direction.a + "Percent"] = flipped ? -100 : 0;\n  vars[direction.a] = flipped ? 1 : 0;\n  vars["border" + side + _Width] = 1;\n  vars["border" + oppositeSide + _Width] = 0;\n  vars[direction.p] = start;\n  ScrollTrigger_gsap.set(marker, vars);\n},\n    _triggers = [],\n    _ids = {},\n    _sync = function _sync() {\n  return _request || (_request = _raf(_updateAll));\n},\n    _onScroll = function _onScroll() {\n  if (!_request) {\n    _request = _raf(_updateAll);\n    _lastScrollTime || _dispatch("scrollStart");\n    _lastScrollTime = _getTime();\n  }\n},\n    _onResize = function _onResize() {\n  return !_refreshing && _resizeDelay.restart(true);\n},\n    // ignore resizes triggered by refresh()\n_listeners = {},\n    _emptyArray = [],\n    _media = [],\n    _creatingMedia,\n    // when ScrollTrigger.matchMedia() is called, we record the current media key here (like "(min-width: 800px)") so that we can assign it to everything that\'s created during that call. Then we can revert just those when necessary. In the ScrollTrigger\'s init() call, the _creatingMedia is recorded as a "media" property on the instance.\n_lastMediaTick,\n    _onMediaChange = function _onMediaChange(e) {\n  var tick = ScrollTrigger_gsap.ticker.frame,\n      matches = [],\n      i = 0;\n\n  if (_lastMediaTick !== tick || _startup) {\n    _revertAll();\n\n    for (; i < _media.length; i += 3) {\n      ScrollTrigger_win.matchMedia(_media[i]).matches ? matches.push(i) : _revertAll(1, _media[i]) || ScrollTrigger_isFunction(_media[i + 2]) && _media[i + 2](); // Firefox doesn\'t update the "matches" property of the MediaQueryList object correctly - it only does so as it calls its change handler - so we must re-create a media query here to ensure it\'s accurate.\n    }\n\n    _revertRecorded(); // in case killing/reverting any of the animations actually added inline styles back.\n\n\n    for (i = 0; i < matches.length; i++) {\n      _creatingMedia = _media[matches[i]];\n      _media[matches[i] + 2] = _media[matches[i] + 1](e);\n    }\n\n    _creatingMedia = 0;\n\n    _refreshAll(0, 1);\n\n    _lastMediaTick = tick;\n  }\n},\n    _softRefresh = function _softRefresh() {\n  return _removeListener(ScrollTrigger, "scrollEnd", _softRefresh) || _refreshAll(true);\n},\n    _dispatch = function _dispatch(type) {\n  return _listeners[type] && _listeners[type].map(function (f) {\n    return f();\n  }) || _emptyArray;\n},\n    _savedStyles = [],\n    // when ScrollTrigger.saveStyles() is called, the inline styles are recorded in this Array in a sequential format like [element, cssText, gsCache, media]. This keeps it very memory-efficient and fast to iterate through.\n_revertRecorded = function _revertRecorded(media) {\n  for (var i = 0; i < _savedStyles.length; i += 4) {\n    if (!media || _savedStyles[i + 3] === media) {\n      _savedStyles[i].style.cssText = _savedStyles[i + 1];\n      _savedStyles[i + 2].uncache = 1;\n    }\n  }\n},\n    _revertAll = function _revertAll(kill, media) {\n  var trigger;\n\n  for (_i = 0; _i < _triggers.length; _i++) {\n    trigger = _triggers[_i];\n\n    if (!media || trigger.media === media) {\n      if (kill) {\n        trigger.kill(1);\n      } else {\n        trigger.scroll.rec || (trigger.scroll.rec = trigger.scroll()); // record the scroll positions so that in each refresh() we can ensure that it doesn\'t shift. Remember, pinning can make things change around, especially if the same element is pinned multiple times. If one was already recorded, don\'t re-record because unpinning may have occurred and made it shorter.\n\n        trigger.revert();\n      }\n    }\n  }\n\n  _revertRecorded(media);\n\n  media || _dispatch("revert");\n},\n    _refreshAll = function _refreshAll(force, skipRevert) {\n  if (_lastScrollTime && !force) {\n    _addListener(ScrollTrigger, "scrollEnd", _softRefresh);\n\n    return;\n  }\n\n  var refreshInits = _dispatch("refreshInit");\n\n  _sort && ScrollTrigger.sort();\n  skipRevert || _revertAll();\n\n  for (_i = 0; _i < _triggers.length; _i++) {\n    _triggers[_i].refresh();\n  }\n\n  refreshInits.forEach(function (result) {\n    return result && result.render && result.render(-1);\n  }); // if the onRefreshInit() returns an animation (typically a gsap.set()), revert it. This makes it easy to put things in a certain spot before refreshing for measurement purposes, and then put things back.\n\n  _i = _triggers.length;\n\n  while (_i--) {\n    _triggers[_i].scroll.rec = 0;\n  }\n\n  _dispatch("refresh");\n},\n    _lastScroll = 0,\n    _direction = 1,\n    _updateAll = function _updateAll() {\n  var l = _triggers.length,\n      time = _getTime(),\n      recordVelocity = time - _time1 >= 50,\n      scroll = l && _triggers[0].scroll();\n\n  _direction = _lastScroll > scroll ? -1 : 1;\n  _lastScroll = scroll;\n\n  if (recordVelocity) {\n    if (_lastScrollTime && !_pointerIsDown && time - _lastScrollTime > 200) {\n      _lastScrollTime = 0;\n\n      _dispatch("scrollEnd");\n    }\n\n    _time2 = _time1;\n    _time1 = time;\n  }\n\n  if (_direction < 0) {\n    _i = l;\n\n    while (_i--) {\n      _triggers[_i].update(0, recordVelocity);\n    }\n\n    _direction = 1;\n  } else {\n    for (_i = 0; _i < l; _i++) {\n      _triggers[_i] && _triggers[_i].update(0, recordVelocity);\n    }\n  }\n\n  _request = 0;\n},\n    _propNamesToCopy = [_left, _top, _bottom, _right, _margin + _Bottom, _margin + _Right, _margin + _Top, _margin + _Left, "display", "flexShrink", "float"],\n    _stateProps = _propNamesToCopy.concat([_width, _height, "boxSizing", "max" + _Width, "max" + _Height, "position", _margin, _padding, _padding + _Top, _padding + _Right, _padding + _Bottom, _padding + _Left]),\n    _swapPinOut = function _swapPinOut(pin, spacer, state) {\n  _setState(state);\n\n  if (pin.parentNode === spacer) {\n    var parent = spacer.parentNode;\n\n    if (parent) {\n      parent.insertBefore(pin, spacer);\n      parent.removeChild(spacer);\n    }\n  }\n},\n    _swapPinIn = function _swapPinIn(pin, spacer, cs, spacerState) {\n  if (pin.parentNode !== spacer) {\n    var i = _propNamesToCopy.length,\n        spacerStyle = spacer.style,\n        pinStyle = pin.style,\n        p;\n\n    while (i--) {\n      p = _propNamesToCopy[i];\n      spacerStyle[p] = cs[p];\n    }\n\n    spacerStyle.position = cs.position === "absolute" ? "absolute" : "relative";\n    cs.display === "inline" && (spacerStyle.display = "inline-block");\n    pinStyle[_bottom] = pinStyle[_right] = "auto";\n    spacerStyle.overflow = "visible";\n    spacerStyle.boxSizing = "border-box";\n    spacerStyle[_width] = _getSize(pin, _horizontal) + _px;\n    spacerStyle[_height] = _getSize(pin, _vertical) + _px;\n    spacerStyle[_padding] = pinStyle[_margin] = pinStyle[_top] = pinStyle[_left] = "0";\n\n    _setState(spacerState);\n\n    pinStyle[_width] = cs[_width];\n    pinStyle[_height] = cs[_height];\n    pinStyle[_padding] = cs[_padding];\n    pin.parentNode.insertBefore(spacer, pin);\n    spacer.appendChild(pin);\n  }\n},\n    ScrollTrigger_capsExp = /([A-Z])/g,\n    _setState = function _setState(state) {\n  if (state) {\n    var style = state.t.style,\n        l = state.length,\n        i = 0,\n        p,\n        value;\n\n    for (; i < l; i += 2) {\n      value = state[i + 1];\n      p = state[i];\n\n      if (value) {\n        style[p] = value;\n      } else if (style[p]) {\n        style.removeProperty(p.replace(ScrollTrigger_capsExp, "-$1").toLowerCase());\n      }\n    }\n  }\n},\n    _getState = function _getState(element) {\n  // returns an array with alternating values like [property, value, property, value] and a "t" property pointing to the target (element). Makes it fast and cheap.\n  var l = _stateProps.length,\n      style = element.style,\n      state = [],\n      i = 0;\n\n  for (; i < l; i++) {\n    state.push(_stateProps[i], style[_stateProps[i]]);\n  }\n\n  state.t = element;\n  return state;\n},\n    _copyState = function _copyState(state, override, omitOffsets) {\n  var result = [],\n      l = state.length,\n      i = omitOffsets ? 8 : 0,\n      // skip top, left, right, bottom if omitOffsets is true\n  p;\n\n  for (; i < l; i += 2) {\n    p = state[i];\n    result.push(p, p in override ? override[p] : state[i + 1]);\n  }\n\n  result.t = state.t;\n  return result;\n},\n    _winOffsets = {\n  left: 0,\n  top: 0\n},\n    ScrollTrigger_parsePosition = function _parsePosition(value, trigger, scrollerSize, direction, scroll, marker, markerScroller, self, scrollerBounds, borderWidth, useFixedPosition, scrollerMax) {\n  ScrollTrigger_isFunction(value) && (value = value(self));\n\n  if (ScrollTrigger_isString(value) && value.substr(0, 3) === "max") {\n    value = scrollerMax + (value.charAt(4) === "=" ? _offsetToPx("0" + value.substr(3), scrollerSize) : 0);\n  }\n\n  if (!ScrollTrigger_isNumber(value)) {\n    ScrollTrigger_isFunction(trigger) && (trigger = trigger(self));\n\n    var element = _toArray(trigger)[0] || _body,\n        bounds = _getBounds(element) || {},\n        offsets = value.split(" "),\n        localOffset,\n        globalOffset,\n        display;\n\n    if ((!bounds || !bounds.left && !bounds.top) && _getComputedStyle(element).display === "none") {\n      // if display is "none", it won\'t report getBoundingClientRect() properly\n      display = element.style.display;\n      element.style.display = "block";\n      bounds = _getBounds(element);\n      display ? element.style.display = display : element.style.removeProperty("display");\n    }\n\n    localOffset = _offsetToPx(offsets[0], bounds[direction.d]);\n    globalOffset = _offsetToPx(offsets[1] || "0", scrollerSize);\n    value = bounds[direction.p] - scrollerBounds[direction.p] - borderWidth + localOffset + scroll - globalOffset;\n    markerScroller && _positionMarker(markerScroller, globalOffset, direction, scrollerSize - globalOffset < 20 || markerScroller._isStart && globalOffset > 20);\n    scrollerSize -= scrollerSize - globalOffset; // adjust for the marker\n  } else if (markerScroller) {\n    _positionMarker(markerScroller, scrollerSize, direction, true);\n  }\n\n  if (marker) {\n    var position = value + scrollerSize,\n        isStart = marker._isStart;\n    scrollerMax = "scroll" + direction.d2;\n\n    _positionMarker(marker, position, direction, isStart && position > 20 || !isStart && (useFixedPosition ? Math.max(_body[scrollerMax], _docEl[scrollerMax]) : marker.parentNode[scrollerMax]) <= position + 1);\n\n    if (useFixedPosition) {\n      scrollerBounds = _getBounds(markerScroller);\n      useFixedPosition && (marker.style[direction.op.p] = scrollerBounds[direction.op.p] - direction.op.m - marker._offset + _px);\n    }\n  }\n\n  return Math.round(value);\n},\n    _prefixExp = /(?:webkit|moz|length)/i,\n    _reparent = function _reparent(element, parent) {\n  if (element.parentNode !== parent) {\n    var style = element.style,\n        p,\n        cs;\n\n    if (parent === _body) {\n      element._stOrig = style.cssText; // record original inline styles so we can revert them later\n\n      cs = _getComputedStyle(element);\n\n      for (p in cs) {\n        // must copy all relevant styles to ensure that nothing changes visually when we reparent to the <body>. Skip the vendor prefixed ones.\n        if (!+p && !_prefixExp.test(p) && cs[p] && typeof style[p] === "string" && p !== "0") {\n          style[p] = cs[p];\n        }\n      }\n    } else {\n      style.cssText = element._stOrig;\n    }\n\n    parent.appendChild(element);\n  }\n},\n    // returns a function that can be used to tween the scroll position in the direction provided, and when doing so it\'ll add a .tween property to the FUNCTION itself, and remove it when the tween completes or gets killed. This gives us a way to have multiple ScrollTriggers use a central function for any given scroller and see if there\'s a scroll tween running (which would affect if/how things get updated)\n_getTweenCreator = function _getTweenCreator(scroller, direction) {\n  var getScroll = _getScrollFunc(scroller, direction),\n      prop = "_scroll" + direction.p2,\n      // add a tweenable property to the scroller that\'s a getter/setter function, like _scrollTop or _scrollLeft. This way, if someone does gsap.killTweensOf(scroller) it\'ll kill the scroll tween.\n  lastScroll,\n      getTween = function getTween(scrollTo, vars, initialValue, change1, change2) {\n    var tween = getTween.tween,\n        onComplete = vars.onComplete,\n        modifiers = {};\n    tween && tween.kill();\n    lastScroll = getScroll();\n    vars[prop] = scrollTo;\n    vars.modifiers = modifiers;\n\n    modifiers[prop] = function (value) {\n      if (Math.abs(getScroll() - lastScroll) > 7) {\n        // if the user scrolls, kill the tween. Need a margin of error because some browsers like iOS Safari misreport the scroll position!\n        tween.kill();\n        getTween.tween = 0;\n        value = getScroll();\n      } else if (change1) {\n        value = initialValue + change1 * tween.ratio + change2 * tween.ratio * tween.ratio;\n      }\n\n      return lastScroll = Math.round(value);\n    };\n\n    vars.onComplete = function () {\n      getTween.tween = 0;\n      onComplete && onComplete.call(tween);\n    };\n\n    tween = getTween.tween = ScrollTrigger_gsap.to(scroller, vars);\n    return tween;\n  };\n\n  scroller[prop] = getScroll;\n  return getTween;\n};\n\n_horizontal.op = _vertical;\nvar ScrollTrigger = /*#__PURE__*/function () {\n  function ScrollTrigger(vars, animation) {\n    ScrollTrigger_coreInitted || ScrollTrigger.register(ScrollTrigger_gsap) || console.warn("Please gsap.registerPlugin(ScrollTrigger)");\n    this.init(vars, animation);\n  }\n\n  var _proto = ScrollTrigger.prototype;\n\n  _proto.init = function init(vars, animation) {\n    this.progress = 0;\n    this.vars && this.kill(1); // in case it\'s being initted again\n\n    if (!_enabled) {\n      this.update = this.refresh = this.kill = ScrollTrigger_passThrough;\n      return;\n    }\n\n    vars = ScrollTrigger_setDefaults(ScrollTrigger_isString(vars) || ScrollTrigger_isNumber(vars) || vars.nodeType ? {\n      trigger: vars\n    } : vars, ScrollTrigger_defaults);\n\n    var direction = vars.horizontal ? _horizontal : _vertical,\n        _vars = vars,\n        onUpdate = _vars.onUpdate,\n        toggleClass = _vars.toggleClass,\n        id = _vars.id,\n        onToggle = _vars.onToggle,\n        onRefresh = _vars.onRefresh,\n        scrub = _vars.scrub,\n        trigger = _vars.trigger,\n        pin = _vars.pin,\n        pinSpacing = _vars.pinSpacing,\n        invalidateOnRefresh = _vars.invalidateOnRefresh,\n        anticipatePin = _vars.anticipatePin,\n        onScrubComplete = _vars.onScrubComplete,\n        onSnapComplete = _vars.onSnapComplete,\n        once = _vars.once,\n        snap = _vars.snap,\n        pinReparent = _vars.pinReparent,\n        isToggle = !scrub && scrub !== 0,\n        scroller = _toArray(vars.scroller || ScrollTrigger_win)[0],\n        scrollerCache = ScrollTrigger_gsap.core.getCache(scroller),\n        isViewport = _isViewport(scroller),\n        useFixedPosition = isViewport || _getProxyProp(scroller, "pinType") === "fixed",\n        callbacks = [vars.onEnter, vars.onLeave, vars.onEnterBack, vars.onLeaveBack],\n        toggleActions = isToggle && (once ? "play" : vars.toggleActions).split(" "),\n        markers = "markers" in vars ? vars.markers : ScrollTrigger_defaults.markers,\n        borderWidth = isViewport ? 0 : parseFloat(_getComputedStyle(scroller)["border" + direction.p2 + _Width]) || 0,\n        self = this,\n        onRefreshInit = vars.onRefreshInit && function () {\n      return vars.onRefreshInit(self);\n    },\n        getScrollerSize = _getSizeFunc(scroller, isViewport, direction),\n        getScrollerOffsets = _getOffsetsFunc(scroller, isViewport),\n        tweenTo,\n        pinCache,\n        snapFunc,\n        isReverted,\n        scroll1,\n        scroll2,\n        start,\n        end,\n        markerStart,\n        markerEnd,\n        markerStartTrigger,\n        markerEndTrigger,\n        markerVars,\n        change,\n        pinOriginalState,\n        pinActiveState,\n        pinState,\n        spacer,\n        offset,\n        pinGetter,\n        pinSetter,\n        pinStart,\n        pinChange,\n        spacingStart,\n        spacerState,\n        markerStartSetter,\n        markerEndSetter,\n        cs,\n        snap1,\n        snap2,\n        scrubScrollTime,\n        scrubTween,\n        scrubSmooth,\n        snapDurClamp,\n        snapDelayedCall,\n        prevProgress,\n        prevScroll,\n        prevAnimProgress;\n\n    self.media = _creatingMedia;\n    anticipatePin *= 45;\n\n    _triggers.push(self);\n\n    self.scroller = scroller;\n    self.scroll = _getScrollFunc(scroller, direction);\n    scroll1 = self.scroll();\n    self.vars = vars;\n    animation = animation || vars.animation;\n    "refreshPriority" in vars && (_sort = 1);\n    scrollerCache.tweenScroll = scrollerCache.tweenScroll || {\n      top: _getTweenCreator(scroller, _vertical),\n      left: _getTweenCreator(scroller, _horizontal)\n    };\n    self.tweenTo = tweenTo = scrollerCache.tweenScroll[direction.p];\n\n    if (animation) {\n      animation.vars.lazy = false;\n      animation._initted || animation.vars.immediateRender !== false && vars.immediateRender !== false && animation.render(0, true, true);\n      self.animation = animation.pause();\n      animation.scrollTrigger = self;\n      scrubSmooth = ScrollTrigger_isNumber(scrub) && scrub;\n      scrubSmooth && (scrubTween = ScrollTrigger_gsap.to(animation, {\n        ease: "power3",\n        duration: scrubSmooth,\n        onComplete: function onComplete() {\n          return onScrubComplete && onScrubComplete(self);\n        }\n      }));\n      snap1 = 0;\n      id || (id = animation.vars.id);\n    }\n\n    if (snap) {\n      ScrollTrigger_isObject(snap) || (snap = {\n        snapTo: snap\n      });\n      ScrollTrigger_gsap.set(isViewport ? [_body, _docEl] : scroller, {\n        scrollBehavior: "auto"\n      }); // smooth scrolling doesn\'t work with snap.\n\n      snapFunc = ScrollTrigger_isFunction(snap.snapTo) ? snap.snapTo : snap.snapTo === "labels" ? _getLabels(animation) : ScrollTrigger_gsap.utils.snap(snap.snapTo);\n      snapDurClamp = snap.duration || {\n        min: 0.1,\n        max: 2\n      };\n      snapDurClamp = ScrollTrigger_isObject(snapDurClamp) ? ScrollTrigger_clamp(snapDurClamp.min, snapDurClamp.max) : ScrollTrigger_clamp(snapDurClamp, snapDurClamp);\n      snapDelayedCall = ScrollTrigger_gsap.delayedCall(snap.delay || scrubSmooth / 2 || 0.1, function () {\n        if (!_lastScrollTime || _lastScrollTime === scrubScrollTime && !_pointerIsDown) {\n          var totalProgress = animation && !isToggle ? animation.totalProgress() : self.progress,\n              velocity = (totalProgress - snap2) / (_getTime() - _time2) * 1000 || 0,\n              change1 = _abs(velocity / 2) * velocity / 0.185,\n              naturalEnd = totalProgress + change1,\n              endValue = ScrollTrigger_clamp(0, 1, snapFunc(naturalEnd, self)),\n              change2 = endValue - totalProgress - change1,\n              scroll = self.scroll(),\n              endScroll = Math.round(start + endValue * change),\n              tween = tweenTo.tween;\n\n          if (scroll <= end && scroll >= start) {\n            if (tween && !tween._initted) {\n              // there\'s an overlapping snap! So we must figure out which one is closer and let that tween live.\n              if (tween.data <= Math.abs(endScroll - scroll)) {\n                return;\n              }\n\n              tween.kill();\n            }\n\n            tweenTo(endScroll, {\n              duration: snapDurClamp(_abs(Math.max(_abs(naturalEnd - totalProgress), _abs(endValue - totalProgress)) * 0.185 / velocity / 0.05 || 0)),\n              ease: snap.ease || "power3",\n              data: Math.abs(endScroll - scroll),\n              // record the distance so that if another snap tween occurs (conflict) we can prioritize the closest snap.\n              onComplete: function onComplete() {\n                snap1 = snap2 = animation && !isToggle ? animation.totalProgress() : self.progress;\n                onSnapComplete && onSnapComplete(self);\n              }\n            }, start + totalProgress * change, change1 * change, change2 * change);\n          }\n        } else {\n          snapDelayedCall.restart(true);\n        }\n      }).pause();\n    }\n\n    id && (_ids[id] = self);\n    trigger = self.trigger = _toArray(trigger || pin)[0];\n    pin = pin === true ? trigger : _toArray(pin)[0];\n    ScrollTrigger_isString(toggleClass) && (toggleClass = {\n      targets: trigger,\n      className: toggleClass\n    });\n\n    if (pin) {\n      pinSpacing === false || pinSpacing === _margin || (pinSpacing = _getComputedStyle(pin.parentNode).display === "flex" ? false : _padding); // if the parent is display: flex, don\'t apply pinSpacing by default.\n\n      self.pin = pin;\n      vars.force3D !== false && ScrollTrigger_gsap.set(pin, {\n        force3D: true\n      });\n      pinCache = ScrollTrigger_gsap.core.getCache(pin);\n\n      if (!pinCache.spacer) {\n        // record the spacer and pinOriginalState on the cache in case someone tries pinning the same element with MULTIPLE ScrollTriggers - we don\'t want to have multiple spacers or record the "original" pin state after it has already been affected by another ScrollTrigger.\n        pinCache.spacer = spacer = ScrollTrigger_doc.createElement("div");\n        spacer.setAttribute("class", "pin-spacer" + (id ? " pin-spacer-" + id : ""));\n        pinCache.pinState = pinOriginalState = _getState(pin);\n      } else {\n        pinOriginalState = pinCache.pinState;\n      }\n\n      self.spacer = spacer = pinCache.spacer;\n      cs = _getComputedStyle(pin);\n      spacingStart = cs[pinSpacing + direction.os2];\n      pinGetter = ScrollTrigger_gsap.getProperty(pin);\n      pinSetter = ScrollTrigger_gsap.quickSetter(pin, direction.a, _px);\n      pin.firstChild && !_maxScroll(pin, direction) && (pin.style.overflow = "hidden"); // protects from collapsing margins!\n\n      _swapPinIn(pin, spacer, cs);\n\n      pinState = _getState(pin);\n    }\n\n    if (markers) {\n      markerVars = ScrollTrigger_isObject(markers) ? ScrollTrigger_setDefaults(markers, _markerDefaults) : _markerDefaults;\n      markerStartTrigger = _createMarker("scroller-start", id, scroller, direction, markerVars, 0);\n      markerEndTrigger = _createMarker("scroller-end", id, scroller, direction, markerVars, 0, markerStartTrigger);\n      offset = markerStartTrigger["offset" + direction.op.d2];\n      markerStart = _createMarker("start", id, scroller, direction, markerVars, offset);\n      markerEnd = _createMarker("end", id, scroller, direction, markerVars, offset);\n\n      if (!useFixedPosition) {\n        _makePositionable(scroller);\n\n        ScrollTrigger_gsap.set([markerStartTrigger, markerEndTrigger], {\n          force3D: true\n        });\n        markerStartSetter = ScrollTrigger_gsap.quickSetter(markerStartTrigger, direction.a, _px);\n        markerEndSetter = ScrollTrigger_gsap.quickSetter(markerEndTrigger, direction.a, _px);\n      }\n    }\n\n    self.revert = function (revert) {\n      var r = revert !== false || !self.enabled,\n          prevRefreshing = _refreshing;\n\n      if (r !== isReverted) {\n        if (r) {\n          prevScroll = Math.max(self.scroll(), self.scroll.rec || 0); // record the scroll so we can revert later (repositioning/pinning things can affect scroll position). In the static refresh() method, we first record all the scroll positions as a reference.\n\n          prevProgress = self.progress;\n          prevAnimProgress = animation && animation.progress();\n        }\n\n        markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(function (m) {\n          return m.style.display = r ? "none" : "block";\n        });\n        _refreshing = 1;\n        self.update(r); // make sure the pin is back in its original position so that all the measurements are correct.\n\n        _refreshing = prevRefreshing;\n        pin && (r ? _swapPinOut(pin, spacer, pinOriginalState) : _swapPinIn(pin, spacer, _getComputedStyle(pin), spacerState));\n        isReverted = r;\n      }\n    };\n\n    self.refresh = function (soft) {\n      if (_refreshing || !self.enabled) {\n        return;\n      }\n\n      if (pin && soft && _lastScrollTime) {\n        _addListener(ScrollTrigger, "scrollEnd", _softRefresh);\n\n        return;\n      }\n\n      _refreshing = 1;\n      scrubTween && scrubTween.kill();\n      invalidateOnRefresh && animation && animation.progress(0).invalidate();\n      isReverted || self.revert();\n\n      var size = getScrollerSize(),\n          scrollerBounds = getScrollerOffsets(),\n          max = _maxScroll(scroller, direction),\n          offset = 0,\n          otherPinOffset = 0,\n          parsedEnd = vars.end,\n          parsedEndTrigger = vars.endTrigger || trigger,\n          parsedStart = vars.start || (pin || !trigger ? "0 0" : "0 100%"),\n          triggerIndex = trigger && Math.max(0, _triggers.indexOf(self)) || 0,\n          i = triggerIndex,\n          cs,\n          bounds,\n          scroll,\n          isVertical,\n          override,\n          curTrigger,\n          curPin;\n\n      while (i--) {\n        // user might try to pin the same element more than once, so we must find any prior triggers with the same pin, revert them, and determine how long they\'re pinning so that we can offset things appropriately. Make sure we revert from last to first so that things "rewind" properly.\n        curPin = _triggers[i].pin;\n        curPin && (curPin === trigger || curPin === pin) && _triggers[i].revert();\n      }\n\n      start = ScrollTrigger_parsePosition(parsedStart, trigger, size, direction, self.scroll(), markerStart, markerStartTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max) || (pin ? -0.001 : 0);\n      ScrollTrigger_isFunction(parsedEnd) && (parsedEnd = parsedEnd(self));\n\n      if (ScrollTrigger_isString(parsedEnd) && !parsedEnd.indexOf("+=")) {\n        if (~parsedEnd.indexOf(" ")) {\n          parsedEnd = (ScrollTrigger_isString(parsedStart) ? parsedStart.split(" ")[0] : "") + parsedEnd;\n        } else {\n          offset = _offsetToPx(parsedEnd.substr(2), size);\n          parsedEnd = ScrollTrigger_isString(parsedStart) ? parsedStart : start + offset; // _parsePosition won\'t factor in the offset if the start is a number, so do it here.\n\n          parsedEndTrigger = trigger;\n        }\n      }\n\n      end = Math.max(start, ScrollTrigger_parsePosition(parsedEnd || (parsedEndTrigger ? "100% 0" : max), parsedEndTrigger, size, direction, self.scroll() + offset, markerEnd, markerEndTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max)) || -0.001;\n      change = end - start || (start -= 0.01) && 0.001;\n      offset = 0;\n      i = triggerIndex;\n\n      while (i--) {\n        curTrigger = _triggers[i];\n        curPin = curTrigger.pin;\n\n        if (curPin && curTrigger.start - curTrigger._pinPush < start) {\n          cs = curTrigger.end - curTrigger.start;\n          curPin === trigger && (offset += cs);\n          curPin === pin && (otherPinOffset += cs);\n        }\n      }\n\n      start += offset;\n      end += offset;\n      self._pinPush = otherPinOffset;\n\n      if (markerStart && offset) {\n        // offset the markers if necessary\n        cs = {};\n        cs[direction.a] = "+=" + offset;\n        ScrollTrigger_gsap.set([markerStart, markerEnd], cs);\n      }\n\n      if (pin) {\n        cs = _getComputedStyle(pin);\n        isVertical = direction === _vertical;\n        scroll = self.scroll(); // recalculate because the triggers can affect the scroll\n\n        pinStart = parseFloat(pinGetter(direction.a)) + otherPinOffset;\n\n        _swapPinIn(pin, spacer, cs);\n\n        pinState = _getState(pin); // transforms will interfere with the top/left/right/bottom placement, so remove them temporarily. getBoundingClientRect() factors in transforms.\n\n        bounds = _getBounds(pin, true);\n\n        if (pinSpacing) {\n          spacerState = [pinSpacing + direction.os2, change + otherPinOffset + _px];\n          spacerState.t = spacer;\n          i = pinSpacing === _padding ? _getSize(pin, direction) + change + otherPinOffset : 0;\n          i && spacerState.push(direction.d, i + _px); // for box-sizing: border-box (must include padding).\n\n          _setState(spacerState);\n\n          useFixedPosition && self.scroll(prevScroll);\n        }\n\n        if (useFixedPosition) {\n          override = {\n            top: bounds.top + (isVertical ? scroll - start : 0) + _px,\n            left: bounds.left + (isVertical ? 0 : scroll - start) + _px,\n            boxSizing: "border-box",\n            position: "fixed"\n          };\n          override[_width] = override["max" + _Width] = Math.ceil(bounds.width) + _px;\n          override[_height] = override["max" + _Height] = Math.ceil(bounds.height) + _px;\n          override[_margin] = override[_margin + _Top] = override[_margin + _Right] = override[_margin + _Bottom] = override[_margin + _Left] = "0";\n          override[_padding] = cs[_padding];\n          override[_padding + _Top] = cs[_padding + _Top];\n          override[_padding + _Right] = cs[_padding + _Right];\n          override[_padding + _Bottom] = cs[_padding + _Bottom];\n          override[_padding + _Left] = cs[_padding + _Left];\n          pinActiveState = _copyState(pinOriginalState, override, pinReparent);\n        }\n\n        if (animation) {\n          // the animation might be affecting the transform, so we must jump to the end, check the value, and compensate accordingly. Otherwise, when it becomes unpinned, the pinSetter() will get set to a value that doesn\'t include whatever the animation did.\n          animation.progress(1, true);\n          pinChange = pinGetter(direction.a) - pinStart + change + otherPinOffset;\n          change !== pinChange && pinActiveState.splice(pinActiveState.length - 2, 2); // transform is the last property/value set in the state Array. Since the animation is controlling that, we should omit it.\n\n          animation.progress(0, true);\n        } else {\n          pinChange = change;\n        }\n      } else if (trigger && self.scroll()) {\n        // it may be INSIDE a pinned element, so walk up the tree and look for any elements with _pinOffset to compensate because anything with pinSpacing that\'s already scrolled would throw off the measurements in getBoundingClientRect()\n        bounds = trigger.parentNode;\n\n        while (bounds && bounds !== _body) {\n          if (bounds._pinOffset) {\n            start -= bounds._pinOffset;\n            end -= bounds._pinOffset;\n          }\n\n          bounds = bounds.parentNode;\n        }\n      }\n\n      for (i = 0; i < triggerIndex; i++) {\n        // make sure we revert from first to last to make sure things reach their end state properly\n        curTrigger = _triggers[i].pin;\n        curTrigger && (curTrigger === trigger || curTrigger === pin) && _triggers[i].revert(false);\n      }\n\n      self.start = start;\n      self.end = end;\n      scroll1 = scroll2 = self.scroll(); // reset velocity\n\n      scroll1 < prevScroll && self.scroll(prevScroll);\n      self.revert(false);\n      _refreshing = 0;\n      prevAnimProgress && isToggle && animation.progress(prevAnimProgress, true);\n\n      if (prevProgress !== self.progress) {\n        // ensures that the direction is set properly (when refreshing, progress is set back to 0 initially, then back again to wherever it needs to be) and that callbacks are triggered.\n        scrubTween && animation.totalProgress(prevProgress, true); // to avoid issues where animation callbacks like onStart aren\'t triggered.\n\n        self.progress = prevProgress;\n        self.update();\n      }\n\n      pin && pinSpacing && (spacer._pinOffset = Math.round(self.progress * pinChange));\n      onRefresh && onRefresh(self);\n    };\n\n    self.getVelocity = function () {\n      return (self.scroll() - scroll2) / (_getTime() - _time2) * 1000 || 0;\n    };\n\n    self.update = function (reset, recordVelocity) {\n      var scroll = self.scroll(),\n          p = reset ? 0 : (scroll - start) / change,\n          clipped = p < 0 ? 0 : p > 1 ? 1 : p || 0,\n          prevProgress = self.progress,\n          isActive,\n          wasActive,\n          toggleState,\n          action,\n          stateChanged,\n          toggled;\n\n      if (recordVelocity) {\n        scroll2 = scroll1;\n        scroll1 = scroll;\n\n        if (snap) {\n          snap2 = snap1;\n          snap1 = animation && !isToggle ? animation.totalProgress() : clipped;\n        }\n      } // anticipate the pinning a few ticks ahead of time based on velocity to avoid a visual glitch due to the fact that most browsers do scrolling on a separate thread (not synced with requestAnimationFrame).\n\n\n      anticipatePin && !clipped && pin && !_refreshing && !_startup && _lastScrollTime && start < scroll + (scroll - scroll2) / (_getTime() - _time2) * anticipatePin && (clipped = 0.0001);\n\n      if (clipped !== prevProgress && self.enabled) {\n        isActive = self.isActive = !!clipped && clipped < 1;\n        wasActive = !!prevProgress && prevProgress < 1;\n        toggled = isActive !== wasActive;\n        stateChanged = toggled || !!clipped !== !!prevProgress; // could go from start all the way to end, thus it didn\'t toggle but it did change state in a sense (may need to fire a callback)\n\n        self.direction = clipped > prevProgress ? 1 : -1;\n        self.progress = clipped;\n\n        if (!isToggle) {\n          if (scrubTween && !_refreshing && !_startup) {\n            scrubTween.vars.totalProgress = clipped;\n            scrubTween.invalidate().restart();\n          } else if (animation) {\n            animation.totalProgress(clipped, !!_refreshing);\n          }\n        }\n\n        if (pin) {\n          reset && pinSpacing && (spacer.style[pinSpacing + direction.os2] = spacingStart);\n\n          if (!useFixedPosition) {\n            pinSetter(pinStart + pinChange * clipped);\n          } else if (stateChanged) {\n            action = !reset && clipped > prevProgress && end + 1 > scroll && scroll + 1 >= _maxScroll(scroller, direction); // if it\'s at the VERY end of the page, don\'t switch away from position: fixed because it\'s pointless and it could cause a brief flash when the user scrolls back up (when it gets pinned again)\n\n            if (pinReparent) {\n              if (!_refreshing && (isActive || action)) {\n                var bounds = _getBounds(pin, true),\n                    _offset = scroll - start;\n\n                pin.style.top = bounds.top + (direction === _vertical ? _offset : 0) + _px;\n                pin.style.left = bounds.left + (direction === _vertical ? 0 : _offset) + _px;\n              }\n\n              _reparent(pin, !_refreshing && (isActive || action) ? _body : spacer);\n            }\n\n            _setState(isActive || action ? pinActiveState : pinState);\n\n            pinChange !== change && clipped < 1 && isActive || pinSetter(pinStart + (clipped === 1 && !action ? pinChange : 0));\n          }\n        }\n\n        if (snap && !tweenTo.tween && !_refreshing && !_startup) {\n          scrubScrollTime = _lastScrollTime;\n          snapDelayedCall.restart(true);\n        }\n\n        toggleClass && toggled && (!once || isActive) && _toArray(toggleClass.targets).forEach(function (el) {\n          return el.classList[isActive ? "add" : "remove"](toggleClass.className);\n        }); // classes could affect positioning, so do it even if reset or refreshing is true.\n\n        onUpdate && !isToggle && !reset && onUpdate(self);\n\n        if (stateChanged && !_refreshing) {\n          toggleState = clipped && !prevProgress ? 0 : clipped === 1 ? 1 : prevProgress === 1 ? 2 : 3; // 0 = enter, 1 = leave, 2 = enterBack, 3 = leaveBack (we prioritize the FIRST encounter, thus if you scroll really fast past the onEnter and onLeave in one tick, it\'d prioritize onEnter.\n\n          if (isToggle) {\n            action = !toggled && toggleActions[toggleState + 1] !== "none" && toggleActions[toggleState + 1] || toggleActions[toggleState]; // if it didn\'t toggle, that means it shot right past and since we prioritize the "enter" action, we should switch to the "leave" in this case (but only if one is defined)\n\n            if (animation && (action === "complete" || action === "reset" || action in animation)) {\n              if (action === "complete") {\n                animation.pause().totalProgress(1);\n              } else if (action === "reset") {\n                animation.restart(true).pause();\n              } else {\n                animation[action]();\n              }\n            }\n\n            onUpdate && onUpdate(self);\n          }\n\n          if (toggled || !_limitCallbacks) {\n            // on startup, the page could be scrolled and we don\'t want to fire callbacks that didn\'t toggle. For example onEnter shouldn\'t fire if the ScrollTrigger isn\'t actually entered.\n            onToggle && toggled && onToggle(self);\n            callbacks[toggleState] && callbacks[toggleState](self);\n            once && (clipped === 1 ? self.kill(false, 1) : callbacks[toggleState] = 0); // a callback shouldn\'t be called again if once is true.\n\n            if (!toggled) {\n              // it\'s possible to go completely past, like from before the start to after the end (or vice-versa) in which case BOTH callbacks should be fired in that order\n              toggleState = clipped === 1 ? 1 : 3;\n              callbacks[toggleState] && callbacks[toggleState](self);\n            }\n          }\n        } else if (isToggle && onUpdate && !_refreshing) {\n          onUpdate(self);\n        }\n      } // update absolutely-positioned markers (only if the scroller isn\'t the viewport)\n\n\n      if (markerEndSetter) {\n        markerStartSetter(scroll + (markerStartTrigger._isFlipped ? 1 : 0));\n        markerEndSetter(scroll);\n      }\n    };\n\n    self.enable = function () {\n      if (!self.enabled) {\n        self.enabled = true;\n\n        _addListener(scroller, "resize", _onResize);\n\n        _addListener(scroller, "scroll", _onScroll);\n\n        onRefreshInit && _addListener(ScrollTrigger, "refreshInit", onRefreshInit);\n        !animation || !animation.add ? self.refresh() : ScrollTrigger_gsap.delayedCall(0.01, self.refresh) && (change = 0.01) && (start = end = 0); // if the animation is a timeline, it may not have been populated yet, so it wouldn\'t render at the proper place on the first refresh(), thus we should schedule one for the next tick.\n      }\n    };\n\n    self.disable = function (reset, allowScrub) {\n      if (self.enabled) {\n        reset !== false && self.revert();\n        self.enabled = self.isActive = false;\n        allowScrub || scrubTween && scrubTween.pause();\n        prevScroll = 0;\n        pinCache && (pinCache.uncache = 1);\n        onRefreshInit && _removeListener(ScrollTrigger, "refreshInit", onRefreshInit);\n\n        if (snapDelayedCall) {\n          snapDelayedCall.pause();\n          tweenTo.tween && tweenTo.tween.kill();\n        }\n\n        if (!isViewport) {\n          var i = _triggers.length;\n\n          while (i--) {\n            if (_triggers[i].scroller === scroller && _triggers[i] !== self) {\n              return; //don\'t remove the listeners if there are still other triggers referencing it.\n            }\n          }\n\n          _removeListener(scroller, "resize", _onResize);\n\n          _removeListener(scroller, "scroll", _onScroll);\n        }\n      }\n    };\n\n    self.kill = function (revert, allowScrub) {\n      self.disable(revert, allowScrub);\n      id && delete _ids[id];\n\n      var i = _triggers.indexOf(self);\n\n      _triggers.splice(i, 1);\n\n      i === _i && _direction > 0 && _i--; // if we\'re in the middle of a refresh() or update(), splicing would cause skips in the index, so adjust...\n\n      if (animation) {\n        animation.scrollTrigger = null;\n        revert && animation.render(-1);\n        allowScrub && scrubTween || animation.kill();\n      }\n\n      markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(function (m) {\n        return m.parentNode.removeChild(m);\n      });\n      pinCache && (pinCache.uncache = 1);\n    };\n\n    self.enable();\n  };\n\n  ScrollTrigger.register = function register(core) {\n    if (!ScrollTrigger_coreInitted) {\n      ScrollTrigger_gsap = core || _getGSAP();\n\n      if (ScrollTrigger_windowExists() && window.document) {\n        ScrollTrigger_win = window;\n        ScrollTrigger_doc = document;\n        _docEl = ScrollTrigger_doc.documentElement;\n        _body = ScrollTrigger_doc.body;\n      }\n\n      if (ScrollTrigger_gsap) {\n        _toArray = ScrollTrigger_gsap.utils.toArray;\n        ScrollTrigger_clamp = ScrollTrigger_gsap.utils.clamp;\n        ScrollTrigger_gsap.core.globals("ScrollTrigger", ScrollTrigger); // must register the global manually because in Internet Explorer, functions (classes) don\'t have a "name" property.\n\n        if (_body) {\n          _raf = ScrollTrigger_win.requestAnimationFrame || function (f) {\n            return setTimeout(f, 16);\n          };\n\n          _addListener(ScrollTrigger_win, "mousewheel", _onScroll);\n\n          _root = [ScrollTrigger_win, ScrollTrigger_doc, _docEl, _body];\n\n          _addListener(ScrollTrigger_doc, "scroll", _onScroll); // some browsers (like Chrome), the window stops dispatching scroll events on the window if you scroll really fast, but it\'s consistent on the document!\n\n\n          var bodyStyle = _body.style,\n              border = bodyStyle.borderTop,\n              bounds;\n          bodyStyle.borderTop = "1px solid #000"; // works around an issue where a margin of a child element could throw off the bounds of the _body, making it seem like there\'s a margin when there actually isn\'t. The border ensures that the bounds are accurate.\n\n          bounds = _getBounds(_body);\n          _vertical.m = Math.round(bounds.top + _vertical.sc()) || 0; // accommodate the offset of the <body> caused by margins and/or padding\n\n          _horizontal.m = Math.round(bounds.left + _horizontal.sc()) || 0;\n          border ? bodyStyle.borderTop = border : bodyStyle.removeProperty("border-top");\n          _syncInterval = setInterval(_sync, 200);\n          ScrollTrigger_gsap.delayedCall(0.5, function () {\n            return _startup = 0;\n          });\n\n          _addListener(ScrollTrigger_doc, "touchcancel", ScrollTrigger_passThrough); // some older Android devices intermittently stop dispatching "touchmove" events if we don\'t listen for "touchcancel" on the document.\n\n\n          _addListener(_body, "touchstart", ScrollTrigger_passThrough); //works around Safari bug: https://greensock.com/forums/topic/21450-draggable-in-iframe-on-mobile-is-buggy/\n\n\n          _multiListener(_addListener, ScrollTrigger_doc, "pointerdown,touchstart,mousedown", function () {\n            return _pointerIsDown = 1;\n          });\n\n          _multiListener(_addListener, ScrollTrigger_doc, "pointerup,touchend,mouseup", function () {\n            return _pointerIsDown = 0;\n          });\n\n          ScrollTrigger_transformProp = ScrollTrigger_gsap.utils.checkPrefix("transform");\n\n          _stateProps.push(ScrollTrigger_transformProp);\n\n          ScrollTrigger_coreInitted = _getTime();\n          _resizeDelay = ScrollTrigger_gsap.delayedCall(0.2, _refreshAll).pause();\n          _autoRefresh = [ScrollTrigger_doc, "visibilitychange", function () {\n            var w = ScrollTrigger_win.innerWidth,\n                h = ScrollTrigger_win.innerHeight;\n\n            if (ScrollTrigger_doc.hidden) {\n              _prevWidth = w;\n              _prevHeight = h;\n            } else if (_prevWidth !== w || _prevHeight !== h) {\n              _onResize();\n            }\n          }, ScrollTrigger_doc, "DOMContentLoaded", _refreshAll, ScrollTrigger_win, "load", function () {\n            return _lastScrollTime || _refreshAll();\n          }, ScrollTrigger_win, "resize", _onResize];\n\n          _iterateAutoRefresh(_addListener);\n        }\n      }\n    }\n\n    return ScrollTrigger_coreInitted;\n  };\n\n  ScrollTrigger.defaults = function defaults(config) {\n    for (var p in config) {\n      ScrollTrigger_defaults[p] = config[p];\n    }\n  };\n\n  ScrollTrigger.kill = function kill() {\n    _enabled = 0;\n\n    _triggers.slice(0).forEach(function (trigger) {\n      return trigger.kill(1);\n    });\n  };\n\n  ScrollTrigger.config = function config(vars) {\n    "limitCallbacks" in vars && (_limitCallbacks = !!vars.limitCallbacks);\n    var ms = vars.syncInterval;\n    ms && clearInterval(_syncInterval) || (_syncInterval = ms) && setInterval(_sync, ms);\n    "autoRefreshEvents" in vars && (_iterateAutoRefresh(_removeListener) || _iterateAutoRefresh(_addListener, vars.autoRefreshEvents || "none"));\n  };\n\n  ScrollTrigger.scrollerProxy = function scrollerProxy(target, vars) {\n    var t = _toArray(target)[0];\n\n    _isViewport(t) ? _proxies.unshift(ScrollTrigger_win, vars, _body, vars, _docEl, vars) : _proxies.unshift(t, vars);\n  };\n\n  ScrollTrigger.matchMedia = function matchMedia(vars) {\n    var mq, p, i, func, result;\n\n    for (p in vars) {\n      i = _media.indexOf(p);\n      func = vars[p];\n      _creatingMedia = p;\n\n      if (p === "all") {\n        func();\n      } else {\n        mq = ScrollTrigger_win.matchMedia(p);\n\n        if (mq) {\n          mq.matches && (result = func());\n\n          if (~i) {\n            _media[i + 1] = _combineFunc(_media[i + 1], func);\n            _media[i + 2] = _combineFunc(_media[i + 2], result);\n          } else {\n            i = _media.length;\n\n            _media.push(p, func, result);\n\n            mq.addListener ? mq.addListener(_onMediaChange) : mq.addEventListener("change", _onMediaChange);\n          }\n        }\n      }\n\n      _creatingMedia = 0;\n    }\n\n    return _media;\n  };\n\n  return ScrollTrigger;\n}();\nScrollTrigger.version = "3.4.2";\n\nScrollTrigger.saveStyles = function (targets) {\n  return targets ? _toArray(targets).forEach(function (target) {\n    var i = _savedStyles.indexOf(target);\n\n    i >= 0 && _savedStyles.splice(i, 4);\n\n    _savedStyles.push(target, target.style.cssText, ScrollTrigger_gsap.core.getCache(target), _creatingMedia);\n  }) : _savedStyles;\n};\n\nScrollTrigger.revert = function (soft, media) {\n  return _revertAll(!soft, media);\n};\n\nScrollTrigger.create = function (vars, animation) {\n  return new ScrollTrigger(vars, animation);\n};\n\nScrollTrigger.refresh = function (safe) {\n  return safe ? _onResize() : _refreshAll(true);\n};\n\nScrollTrigger.update = _updateAll;\n\nScrollTrigger.maxScroll = function (element, horizontal) {\n  return _maxScroll(element, horizontal ? _horizontal : _vertical);\n};\n\nScrollTrigger.getScrollFunc = function (element, horizontal) {\n  return _getScrollFunc(_toArray(element)[0], horizontal ? _horizontal : _vertical);\n};\n\nScrollTrigger.getById = function (id) {\n  return _ids[id];\n};\n\nScrollTrigger.getAll = function () {\n  return _triggers.slice(0);\n};\n\nScrollTrigger.isScrolling = function () {\n  return !!_lastScrollTime;\n};\n\nScrollTrigger.addEventListener = function (type, callback) {\n  var a = _listeners[type] || (_listeners[type] = []);\n  ~a.indexOf(callback) || a.push(callback);\n};\n\nScrollTrigger.removeEventListener = function (type, callback) {\n  var a = _listeners[type],\n      i = a && a.indexOf(callback);\n  i >= 0 && a.splice(i, 1);\n};\n\nScrollTrigger.batch = function (targets, vars) {\n  var result = [],\n      varsCopy = {},\n      interval = vars.interval || 0.016,\n      batchMax = vars.batchMax || 1e9,\n      proxyCallback = function proxyCallback(type, callback) {\n    var elements = [],\n        triggers = [],\n        delay = ScrollTrigger_gsap.delayedCall(interval, function () {\n      callback(elements, triggers);\n      elements = [];\n      triggers = [];\n    }).pause();\n    return function (self) {\n      elements.length || delay.restart(true);\n      elements.push(self.trigger);\n      triggers.push(self);\n      batchMax <= elements.length && delay.progress(1);\n    };\n  },\n      p;\n\n  for (p in vars) {\n    varsCopy[p] = p.substr(0, 2) === "on" && ScrollTrigger_isFunction(vars[p]) && p !== "onRefreshInit" ? proxyCallback(p, vars[p]) : vars[p];\n  }\n\n  if (ScrollTrigger_isFunction(batchMax)) {\n    batchMax = batchMax();\n\n    _addListener(ScrollTrigger, "refresh", function () {\n      return batchMax = vars.batchMax();\n    });\n  }\n\n  _toArray(targets).forEach(function (target) {\n    var config = {};\n\n    for (p in varsCopy) {\n      config[p] = varsCopy[p];\n    }\n\n    config.trigger = target;\n    result.push(ScrollTrigger.create(config));\n  });\n\n  return result;\n};\n\nScrollTrigger.sort = function (func) {\n  return _triggers.sort(func || function (a, b) {\n    return (a.vars.refreshPriority || 0) * -1e6 + a.start - (b.start + (b.vars.refreshPriority || 0) * -1e6);\n  });\n};\n\n_getGSAP() && ScrollTrigger_gsap.registerPlugin(ScrollTrigger);\n\n// CONCATENATED MODULE: ./src/js/components/velazquez_scene.js\n\n\ngsapWithCSS.registerPlugin(ScrollTrigger);\nvar section = document.querySelector(\'#velazquez.artist-section\'),\n    welcomeSection = document.querySelector(\'#velazquez .artist-section__welcome\'),\n    sectionWrapper = document.querySelector(\'#velazquez .artist-section__wrapper\'),\n    sectionInfo = document.querySelector(\'#velazquez .artist-section__info\'),\n    velazquezInfo_1 = document.querySelectorAll(\'#velazquez-info-1\'),\n    velazquezInfo_2 = document.querySelectorAll(\'#velazquez-info-2\'),\n    velazquezInfo_3 = document.querySelectorAll(\'#velazquez-info-3\'),\n    velazquezInfo_4 = document.querySelectorAll(\'#velazquez-info-4\'),\n    velazquezInfo_5 = document.querySelectorAll(\'#velazquez-info-5\'),\n    velazquezInfo_6 = document.querySelectorAll(\'#velazquez-info-6\'),\n    velazquezInfo_7 = document.querySelectorAll(\'#velazquez-info-7\'),\n    velazquezImage_2 = document.querySelectorAll(\'#velazquez-image-2\'),\n    velazquezImage_3 = document.querySelectorAll(\'#velazquez-image-3\'),\n    velazquezImage_4 = document.querySelectorAll(\'#velazquez-image-4\'),\n    velazquezImage_5 = document.querySelectorAll(\'#velazquez-image-5\'),\n    velazquezImage_6 = document.querySelectorAll(\'#velazquez-image-6\'),\n    velazquez_scene_perspective = 1000;\ngsapWithCSS.timeline({\n  scrollTrigger: {\n    trigger: section,\n    start: \'top top\',\n    end: \'+=15000\',\n    pin: true,\n    anticipatePin: 1,\n    // markers: true,\n    scrub: 1\n  }\n}).set(sectionWrapper, {\n  css: {\n    transformPerspective: velazquez_scene_perspective,\n    transformStyle: \'preserve-3d\'\n  }\n}) // Improve Quality\n.to(welcomeSection, 1, {\n  css: {\n    z: velazquez_scene_perspective\n  }\n}).fromTo(sectionInfo, 1, {\n  opacity: 0\n}, {\n  opacity: 1\n}).addLabel(\'show_info_1\').addPause(3).to(velazquezInfo_1, 1, {\n  opacity: 0,\n  display: \'none\'\n}).fromTo(velazquezInfo_2, 1, {\n  opacity: 0\n}, {\n  opacity: 1,\n  display: \'block\'\n}).addPause(3).to(velazquezInfo_2, 1, {\n  opacity: 0,\n  display: \'none\'\n}).fromTo(velazquezInfo_3, 1, {\n  opacity: 0\n}, {\n  opacity: 1,\n  display: \'block\'\n}).addPause(3).to(velazquezInfo_3, 1, {\n  opacity: 0,\n  display: \'none\'\n}).fromTo(velazquezInfo_4, 1, {\n  opacity: 0\n}, {\n  opacity: 1,\n  display: \'block\'\n}).addLabel(\'show_info_4\').addPause(3).to(velazquezInfo_4, 1, {\n  opacity: 0,\n  display: \'none\'\n}).fromTo(velazquezInfo_5, 1, {\n  opacity: 0\n}, {\n  opacity: 1,\n  display: \'block\'\n}).addPause(3).to(velazquezInfo_5, 1, {\n  opacity: 0,\n  display: \'none\'\n}).fromTo(velazquezInfo_6, 1, {\n  opacity: 0\n}, {\n  opacity: 1,\n  display: \'block\'\n}).addPause(3).to(velazquezInfo_6, 1, {\n  opacity: 0,\n  display: \'none\'\n}).fromTo(velazquezInfo_7, 1, {\n  opacity: 0\n}, {\n  opacity: 1,\n  display: \'block\'\n}).addPause(3).to(velazquezImage_3, 10, {\n  y: -8\n}, \'show_info_1\').to(velazquezImage_4, 10, {\n  y: -5\n}, \'show_info_1\').to(velazquezImage_5, 10, {\n  y: -8\n}, \'show_info_1\').to(velazquezImage_6, 10, {\n  y: -10\n}, \'show_info_1\');\n// CONCATENATED MODULE: ./src/js/components/goya_scene.js\n\n\ngsapWithCSS.registerPlugin(ScrollTrigger);\nvar goya_scene_section = document.querySelector(\'#goya.artist-section\'),\n    goya_scene_welcomeSection = document.querySelector(\'#goya .artist-section__welcome\'),\n    goya_scene_sectionWrapper = document.querySelector(\'#goya .artist-section__wrapper\'),\n    goya_scene_sectionInfo = document.querySelector(\'#goya .artist-section__info\'),\n    goyaInfo_1 = document.querySelectorAll(\'#goya-info-1\'),\n    goyaInfo_2 = document.querySelectorAll(\'#goya-info-2\'),\n    goyaInfo_3 = document.querySelectorAll(\'#goya-info-3\'),\n    goyaInfo_4 = document.querySelectorAll(\'#goya-info-4\'),\n    goyaInfo_5 = document.querySelectorAll(\'#goya-info-5\'),\n    goyaInfo_6 = document.querySelectorAll(\'#goya-info-6\'),\n    goyaInfo_7 = document.querySelectorAll(\'#goya-info-7\'),\n    goyaImage_1 = document.querySelectorAll(\'#goya-image-1\'),\n    goyaImage_2 = document.querySelectorAll(\'#goya-image-2\'),\n    goyaImage_3 = document.querySelectorAll(\'#goya-image-3\'),\n    goyaImage_4 = document.querySelectorAll(\'#goya-image-4\'),\n    goyaImage_5 = document.querySelectorAll(\'#goya-image-5\'),\n    goya_scene_perspective = 1000;\ngsapWithCSS.timeline({\n  scrollTrigger: {\n    trigger: goya_scene_section,\n    start: \'top top\',\n    end: \'+=15000\',\n    pin: true,\n    anticipatePin: 1,\n    // markers: true,\n    scrub: 1\n  }\n}).set(goya_scene_sectionWrapper, {\n  css: {\n    transformPerspective: goya_scene_perspective,\n    transformStyle: \'preserve-3d\'\n  }\n}) // Improve Quality\n.to(goya_scene_welcomeSection, 1, {\n  z: goya_scene_perspective\n}).fromTo(goya_scene_sectionInfo, 1, {\n  opacity: 0\n}, {\n  opacity: 1\n}).addLabel(\'show_info_1\').addPause(3).to(goyaInfo_1, 1, {\n  opacity: 0,\n  display: \'none\'\n}).fromTo(goyaInfo_2, 1, {\n  opacity: 0\n}, {\n  opacity: 1,\n  display: \'block\'\n}).addPause(3).to(goyaInfo_2, 1, {\n  opacity: 0,\n  display: \'none\'\n}).fromTo(goyaInfo_3, 1, {\n  opacity: 0\n}, {\n  opacity: 1,\n  display: \'block\'\n}).addPause(3).to(goyaInfo_3, 1, {\n  opacity: 0,\n  display: \'none\'\n}).fromTo(goyaInfo_4, 1, {\n  opacity: 0\n}, {\n  opacity: 1,\n  display: \'block\'\n}).addLabel(\'show_info_4\').addPause(3).to(goyaInfo_4, 1, {\n  opacity: 0,\n  display: \'none\'\n}).fromTo(goyaInfo_5, 1, {\n  opacity: 0\n}, {\n  opacity: 1,\n  display: \'block\'\n}).addPause(3).to(goyaInfo_5, 1, {\n  opacity: 0,\n  display: \'none\'\n}).fromTo(goyaInfo_6, 1, {\n  opacity: 0\n}, {\n  opacity: 1,\n  display: \'block\'\n}).addPause(3).to(goyaInfo_6, 1, {\n  opacity: 0,\n  display: \'none\'\n}).fromTo(goyaInfo_7, 1, {\n  opacity: 0\n}, {\n  opacity: 1,\n  display: \'block\'\n}).addPause(3).to(goyaImage_1, 8, {\n  y: 30\n}, \'show_info_1\').to(goyaImage_2, 8, {\n  y: 15\n}, \'show_info_1\').to(goyaImage_3, 8, {\n  y: 10\n}, \'show_info_1\').to(goyaImage_4, 8, {\n  scale: 1.005,\n  z: 10\n}, \'show_info_1\').to(goyaImage_5, 8, {\n  scale: 1.005\n}, \'show_info_1\');\n// CONCATENATED MODULE: ./src/js/components/picasso_scene.js\n\n\ngsapWithCSS.registerPlugin(ScrollTrigger);\nvar picasso_scene_section = document.querySelector(\'#picasso.artist-section\'),\n    picasso_scene_welcomeSection = document.querySelector(\'#picasso .artist-section__welcome\'),\n    picasso_scene_sectionWrapper = document.querySelector(\'#picasso .artist-section__wrapper\'),\n    picasso_scene_sectionInfo = document.querySelector(\'#picasso .artist-section__info\'),\n    picassoInfo_1 = document.querySelectorAll(\'#picasso-info-1\'),\n    picassoInfo_2 = document.querySelectorAll(\'#picasso-info-2\'),\n    picassoInfo_3 = document.querySelectorAll(\'#picasso-info-3\'),\n    picassoInfo_4 = document.querySelectorAll(\'#picasso-info-4\'),\n    picassoInfo_5 = document.querySelectorAll(\'#picasso-info-5\'),\n    picassoInfo_6 = document.querySelectorAll(\'#picasso-info-6\'),\n    picassoInfo_7 = document.querySelectorAll(\'#picasso-info-7\'),\n    picassoImage_1 = document.querySelectorAll(\'#picasso-image-1\'),\n    picassoImage_2 = document.querySelectorAll(\'#picasso-image-2\'),\n    picassoImage_3 = document.querySelectorAll(\'#picasso-image-3\'),\n    picassoImage_4 = document.querySelectorAll(\'#picasso-image-4\'),\n    picassoImage_5 = document.querySelectorAll(\'#picasso-image-5\'),\n    picassoImage_6 = document.querySelectorAll(\'#picasso-image-6\'),\n    picassoImage_7 = document.querySelectorAll(\'#picasso-image-7\'),\n    picassoImage_8 = document.querySelectorAll(\'#picasso-image-8\'),\n    picassoImage_9 = document.querySelectorAll(\'#picasso-image-9\'),\n    picassoImage_10 = document.querySelectorAll(\'#picasso-image-10\'),\n    picassoImage_11 = document.querySelectorAll(\'#picasso-image-11\'),\n    picasso_scene_perspective = 1000;\ngsapWithCSS.timeline({\n  scrollTrigger: {\n    trigger: picasso_scene_section,\n    start: \'top top\',\n    end: \'+=15000\',\n    pin: true,\n    anticipatePin: 1,\n    // markers: true,\n    scrub: 1\n  }\n}).set(picasso_scene_sectionWrapper, {\n  css: {\n    transformPerspective: picasso_scene_perspective,\n    transformStyle: \'preserve-3d\'\n  }\n}) // Improve Quality\n.to(picasso_scene_welcomeSection, 1, {\n  css: {\n    z: picasso_scene_perspective\n  }\n}).fromTo(picasso_scene_sectionInfo, 1, {\n  opacity: 0\n}, {\n  opacity: 1\n}).addLabel(\'show_info_1\').addPause(3).to(picassoInfo_1, 1, {\n  opacity: 0,\n  display: \'none\'\n}).fromTo(picassoInfo_2, 1, {\n  opacity: 0\n}, {\n  opacity: 1,\n  display: \'block\'\n}).addPause(3).to(picassoInfo_2, 1, {\n  opacity: 0,\n  display: \'none\'\n}).fromTo(picassoInfo_3, 1, {\n  opacity: 0\n}, {\n  opacity: 1,\n  display: \'block\'\n}).addPause(3).to(picassoInfo_3, 1, {\n  opacity: 0,\n  display: \'none\'\n}).fromTo(picassoInfo_4, 1, {\n  opacity: 0\n}, {\n  opacity: 1,\n  display: \'block\'\n}).addLabel(\'show_info_4\').addPause(3).to(picassoInfo_4, 1, {\n  opacity: 0,\n  display: \'none\'\n}).fromTo(picassoInfo_5, 1, {\n  opacity: 0\n}, {\n  opacity: 1,\n  display: \'block\'\n}).addPause(3).to(picassoInfo_5, 1, {\n  opacity: 0,\n  display: \'none\'\n}).fromTo(picassoInfo_6, 1, {\n  opacity: 0\n}, {\n  opacity: 1,\n  display: \'block\'\n}).addPause(3).to(picassoInfo_6, 1, {\n  opacity: 0,\n  display: \'none\'\n}).fromTo(picassoInfo_7, 1, {\n  opacity: 0\n}, {\n  opacity: 1,\n  display: \'block\'\n}).addPause(3).to(picassoImage_1, 10, {\n  y: -15\n}, \'show_info_1\').to(picassoImage_2, 10, {\n  y: -10\n}, \'show_info_1\').to(picassoImage_3, 10, {\n  y: -8\n}, \'show_info_1\').to(picassoImage_4, 10, {\n  y: -6\n}, \'show_info_1\').to(picassoImage_5, 10, {\n  y: -20\n}, \'show_info_1\').to(picassoImage_6, 10, {\n  y: -11,\n  scale: 1.015\n}, \'show_info_1\').to(picassoImage_7, 10, {\n  y: -2\n}, \'show_info_1\').to(picassoImage_8, 10, {\n  y: -20,\n  scale: 1.015\n}, \'show_info_1\').to(picassoImage_9, 10, {\n  y: -20,\n  scale: 1.015\n}, \'show_info_1\').to(picassoImage_10, 10, {\n  y: -10,\n  scale: 1.015\n}, \'show_info_1\').to(picassoImage_11, 10, {\n  x: -30,\n  y: -18,\n  scale: 1.05\n}, \'show_info_1\');\n// CONCATENATED MODULE: ./src/js/components/dali_scene.js\n\n\ngsapWithCSS.registerPlugin(ScrollTrigger);\nvar dali_scene_section = document.querySelector(\'#dali.artist-section\'),\n    dali_scene_welcomeSection = document.querySelector(\'#dali .artist-section__welcome\'),\n    dali_scene_sectionWrapper = document.querySelector(\'#dali .artist-section__wrapper\'),\n    dali_scene_sectionInfo = document.querySelector(\'#dali .artist-section__info\'),\n    daliInfo_1 = document.querySelectorAll(\'#dali-info-1\'),\n    daliInfo_2 = document.querySelectorAll(\'#dali-info-2\'),\n    daliInfo_3 = document.querySelectorAll(\'#dali-info-3\'),\n    daliInfo_4 = document.querySelectorAll(\'#dali-info-4\'),\n    daliInfo_5 = document.querySelectorAll(\'#dali-info-5\'),\n    daliInfo_6 = document.querySelectorAll(\'#dali-info-6\'),\n    daliInfo_7 = document.querySelectorAll(\'#dali-info-7\'),\n    daliImage_1 = document.querySelectorAll(\'#dali-image-1\'),\n    daliImage_2 = document.querySelectorAll(\'#dali-image-2\'),\n    daliImage_3 = document.querySelectorAll(\'#dali-image-3\'),\n    daliImage_4 = document.querySelectorAll(\'#dali-image-4\'),\n    dali_scene_perspective = 1000;\ngsapWithCSS.timeline({\n  scrollTrigger: {\n    trigger: dali_scene_section,\n    start: \'top top\',\n    end: \'+=15000\',\n    pin: true,\n    anticipatePin: 1,\n    // markers: true,\n    scrub: 1\n  }\n}).set(dali_scene_sectionWrapper, {\n  css: {\n    transformPerspective: dali_scene_perspective,\n    transformStyle: \'preserve-3d\'\n  }\n}) // Improve Quality\n.to(dali_scene_welcomeSection, 1, {\n  css: {\n    z: dali_scene_perspective\n  }\n}).fromTo(dali_scene_sectionInfo, 1, {\n  opacity: 0\n}, {\n  opacity: 1\n}).addLabel(\'show_info_1\').addPause(3).to(daliInfo_1, 1, {\n  opacity: 0,\n  display: \'none\'\n}).fromTo(daliInfo_2, 1, {\n  opacity: 0\n}, {\n  opacity: 1,\n  display: \'block\'\n}).addPause(3).to(daliInfo_2, 1, {\n  opacity: 0,\n  display: \'none\'\n}).fromTo(daliInfo_3, 1, {\n  opacity: 0\n}, {\n  opacity: 1,\n  display: \'block\'\n}).addPause(3).to(daliInfo_3, 1, {\n  opacity: 0,\n  display: \'none\'\n}).fromTo(daliInfo_4, 1, {\n  opacity: 0\n}, {\n  opacity: 1,\n  display: \'block\'\n}).addLabel(\'show_info_4\').addPause(3).to(daliInfo_4, 1, {\n  opacity: 0,\n  display: \'none\'\n}).fromTo(daliInfo_5, 1, {\n  opacity: 0\n}, {\n  opacity: 1,\n  display: \'block\'\n}).addPause(3).to(daliInfo_5, 1, {\n  opacity: 0,\n  display: \'none\'\n}).fromTo(daliInfo_6, 1, {\n  opacity: 0\n}, {\n  opacity: 1,\n  display: \'block\'\n}).addPause(3).to(daliInfo_6, 1, {\n  opacity: 0,\n  display: \'none\'\n}).fromTo(daliInfo_7, 1, {\n  opacity: 0\n}, {\n  opacity: 1,\n  display: \'block\'\n}).addPause(3).to(daliImage_2, 10, {\n  y: -30\n}, \'show_info_1\').to(daliImage_3, 10, {\n  y: -10\n}, \'show_info_1\').to(daliImage_4, 10, {\n  y: -5\n}, \'show_info_1\');\n// CONCATENATED MODULE: ./src/js/components/index.js\n// import \'./loading\';\n // import \'./progress-bar\';\n\n\n\n\n\n\n// CONCATENATED MODULE: ./src/js/app.js\n// CSS\n // JS\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ3NhcC9nc2FwLWNvcmUuanM/YTVjZiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ3NhcC9DU1NQbHVnaW4uanM/OWNlNiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ3NhcC9pbmRleC5qcz9jZmZhIiwid2VicGFjazovLy8uL3NyYy9qcy9jb21wb25lbnRzL2dzYXAtaGVscGVycy5qcz8yOWE0Iiwid2VicGFjazovLy8uL3NyYy9qcy9jb21wb25lbnRzL25hdmlnYXRpb24uanM/M2JiNSIsIndlYnBhY2s6Ly8vLi9zcmMvanMvY29tcG9uZW50cy9zY2VuZXMuanM/Nzg2MCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ3NhcC9TY3JvbGxUcmlnZ2VyLmpzPzFkYWMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2NvbXBvbmVudHMvdmVsYXpxdWV6X3NjZW5lLmpzP2VmOTUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2NvbXBvbmVudHMvZ295YV9zY2VuZS5qcz8xZWU3Iiwid2VicGFjazovLy8uL3NyYy9qcy9jb21wb25lbnRzL3BpY2Fzc29fc2NlbmUuanM/NzE3ZCIsIndlYnBhY2s6Ly8vLi9zcmMvanMvY29tcG9uZW50cy9kYWxpX3NjZW5lLmpzP2RiZmUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2NvbXBvbmVudHMvaW5kZXguanM/Y2YzYSIsIndlYnBhY2s6Ly8vLi9zcmMvanMvYXBwLmpzPzkwZTkiXSwibmFtZXMiOlsic3RhcnRBbmRSZXZlcnNlIiwiZWxlbSIsImV2ZW50IiwidGwiLCJhZGRFdmVudExpc3RlbmVyIiwicmV2ZXJzZWQiLCJwbGF5IiwicmV2ZXJzZSIsImxpbmUxIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwibGluZTIiLCJsaW5lMyIsImhhbWJ1cmd1ZXJNZW51IiwibWVudSIsIm9uUmV2ZXJzZUNvbXBsZXRlIiwib25Db21wbGV0ZSIsImdzYXAiLCJ0aW1lbGluZSIsInBhdXNlZCIsImFkZExhYmVsIiwidG8iLCJhdHRyIiwieTIiLCJvcGFjaXR5IiwiYXV0b0FscGhhIiwic2V0IiwiekluZGV4IiwiaW5mb0xpbmtPbkNsaWNrIiwiZSIsInByZXZlbnREZWZhdWx0IiwiY3VycmVudFRhcmdldCIsImxpbmVzIiwicXVlcnlTZWxlY3RvckFsbCIsIngyIiwieDEiLCJmb3JFYWNoIiwicmVnaXN0ZXJQbHVnaW4iLCJTY3JvbGxUcmlnZ2VyIiwic2VjdGlvbiIsIndlbGNvbWVTZWN0aW9uIiwic2VjdGlvbldyYXBwZXIiLCJzZWN0aW9uSW5mbyIsInZlbGF6cXVlekluZm9fMSIsInZlbGF6cXVlekluZm9fMiIsInZlbGF6cXVlekluZm9fMyIsInZlbGF6cXVlekluZm9fNCIsInZlbGF6cXVlekluZm9fNSIsInZlbGF6cXVlekluZm9fNiIsInZlbGF6cXVlekluZm9fNyIsInZlbGF6cXVlekltYWdlXzIiLCJ2ZWxhenF1ZXpJbWFnZV8zIiwidmVsYXpxdWV6SW1hZ2VfNCIsInZlbGF6cXVlekltYWdlXzUiLCJ2ZWxhenF1ZXpJbWFnZV82IiwicGVyc3BlY3RpdmUiLCJzY3JvbGxUcmlnZ2VyIiwidHJpZ2dlciIsInN0YXJ0IiwiZW5kIiwicGluIiwiYW50aWNpcGF0ZVBpbiIsInNjcnViIiwiY3NzIiwidHJhbnNmb3JtUGVyc3BlY3RpdmUiLCJ0cmFuc2Zvcm1TdHlsZSIsInoiLCJmcm9tVG8iLCJhZGRQYXVzZSIsImRpc3BsYXkiLCJ5IiwiZ295YUluZm9fMSIsImdveWFJbmZvXzIiLCJnb3lhSW5mb18zIiwiZ295YUluZm9fNCIsImdveWFJbmZvXzUiLCJnb3lhSW5mb182IiwiZ295YUluZm9fNyIsImdveWFJbWFnZV8xIiwiZ295YUltYWdlXzIiLCJnb3lhSW1hZ2VfMyIsImdveWFJbWFnZV80IiwiZ295YUltYWdlXzUiLCJzY2FsZSIsInBpY2Fzc29JbmZvXzEiLCJwaWNhc3NvSW5mb18yIiwicGljYXNzb0luZm9fMyIsInBpY2Fzc29JbmZvXzQiLCJwaWNhc3NvSW5mb181IiwicGljYXNzb0luZm9fNiIsInBpY2Fzc29JbmZvXzciLCJwaWNhc3NvSW1hZ2VfMSIsInBpY2Fzc29JbWFnZV8yIiwicGljYXNzb0ltYWdlXzMiLCJwaWNhc3NvSW1hZ2VfNCIsInBpY2Fzc29JbWFnZV81IiwicGljYXNzb0ltYWdlXzYiLCJwaWNhc3NvSW1hZ2VfNyIsInBpY2Fzc29JbWFnZV84IiwicGljYXNzb0ltYWdlXzkiLCJwaWNhc3NvSW1hZ2VfMTAiLCJwaWNhc3NvSW1hZ2VfMTEiLCJ4IiwiZGFsaUluZm9fMSIsImRhbGlJbmZvXzIiLCJkYWxpSW5mb18zIiwiZGFsaUluZm9fNCIsImRhbGlJbmZvXzUiLCJkYWxpSW5mb182IiwiZGFsaUluZm9fNyIsImRhbGlJbWFnZV8xIiwiZGFsaUltYWdlXzIiLCJkYWxpSW1hZ2VfMyIsImRhbGlJbWFnZV80Il0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSx1Q0FBdUMsdUJBQXVCLHVGQUF1RixFQUFFLGFBQWE7O0FBRXBLLCtDQUErQywwREFBMEQsMkNBQTJDLGlDQUFpQzs7QUFFckw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsdUJBQXVCO0FBQ3ZCO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDO0FBQzNDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsOEpBQThKO0FBQzlKO0FBQ0E7O0FBRUEsUUFBUSw0Q0FBNEM7O0FBRXBEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMkNBQTJDO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQSxrREFBa0Q7QUFDbEQsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHNDQUFzQztBQUN0Qzs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0RBQWtEOztBQUVsRDtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDO0FBQ2hDO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdFQUFnRTs7QUFFaEUscUVBQXFFOztBQUVyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztB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O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsOEZBQThGO0FBQzlGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsdUNBQXVDOzs7QUFHdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzTEFBc0w7QUFDdEw7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEseUdBQXlHO0FBQ3pHOztBQUVBO0FBQ0EsK0RBQStEOztBQUUvRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0RUFBNEU7O0FBRTVFLGlDQUFpQztBQUNqQyxPQUFPO0FBQ1A7O0FBRUEsNkJBQTZCOztBQUU3Qiw4TUFBOE07QUFDOU07QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUNBQXlDOztBQUV6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0M7O0FBRXhDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7O0FBRTdDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtGQUErRjs7QUFFL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVzs7O0FBR1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseURBQXlEOztBQUV6RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLDREQUE0RDs7QUFFNUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRjs7QUFFbkY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQzs7QUFFbEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3SEFBd0g7O0FBRXhIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQSx5RUFBeUU7QUFDekU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7O0FBRTNCLDhDQUE4Qzs7QUFFOUM7O0FBRUE7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSw0REFBNEQ7O0FBRTVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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eEk7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJJQUEySTs7QUFFM0ksMEhBQTBIOztBQUUxSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4REFBOEQ7O0FBRTlEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsNEdBQTRHOztBQUU1RztBQUNBOztBQUVBLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdLO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7O0FBRUE7QUFDQSxDQUFDLEdBQUc7O0FBRUo7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBFQUEwRSxlQUFlO0FBQ3pGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEM7QUFDNUMsR0FBRztBQUNIO0FBQ0EsMENBQTBDO0FBQzFDLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDZEQUE2RDtBQUM3RDs7QUFFQTtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZUFBZTs7QUFFZjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7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Q0l1RixVQWpDSixFQWlDZ0IsQ0FqQ2hCLEVBaUNtQjtBQUFDcEYsU0FBTyxFQUFFLENBQVY7QUFBYTZDLFNBQU8sRUFBRTtBQUF0QixDQWpDbkIsRUFrQ0NGLE1BbENELENBa0NRMEMsVUFsQ1IsRUFrQ29CLENBbENwQixFQWtDdUI7QUFBQ3JGLFNBQU8sRUFBRTtBQUFWLENBbEN2QixFQWtDcUM7QUFBQ0EsU0FBTyxFQUFFLENBQVY7QUFBYTZDLFNBQU8sRUFBRTtBQUF0QixDQWxDckMsRUFtQ0NELFFBbkNELENBbUNVLENBbkNWLEVBb0NDL0MsRUFwQ0QsQ0FvQ0kwRixXQXBDSixFQW9DaUIsRUFwQ2pCLEVBb0NxQjtBQUFDekMsR0FBQyxFQUFFLENBQUM7QUFBTCxDQXBDckIsRUFvQytCLGFBcEMvQixFQXFDQ2pELEVBckNELENBcUNJMkYsV0FyQ0osRUFxQ2lCLEVBckNqQixFQXFDcUI7QUFBQzFDLEdBQUMsRUFBRSxDQUFDO0FBQUwsQ0FyQ3JCLEVBcUMrQixhQXJDL0IsRUFzQ0NqRCxFQXRDRCxDQXNDSTRGLFdBdENKLEVBc0NpQixFQXRDakIsRUFzQ3FCO0FBQUMzQyxHQUFDLEVBQUUsQ0FBQztBQUFMLENBdENyQixFQXNDOEIsYUF0QzlCLEU7O0FDdEJBO0NBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ05BO0NBR0EiLCJmaWxlIjoiNy5qcyIsInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyohXG4gKiBHU0FQIDMuNC4yXG4gKiBodHRwczovL2dyZWVuc29jay5jb21cbiAqXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgMjAwOC0yMDIwLCBHcmVlblNvY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBTdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwczovL2dyZWVuc29jay5jb20vc3RhbmRhcmQtbGljZW5zZSBvciBmb3JcbiAqIENsdWIgR3JlZW5Tb2NrIG1lbWJlcnMsIHRoZSBhZ3JlZW1lbnQgaXNzdWVkIHdpdGggdGhhdCBtZW1iZXJzaGlwLlxuICogQGF1dGhvcjogSmFjayBEb3lsZSwgamFja0BncmVlbnNvY2suY29tXG4qL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xudmFyIF9jb25maWcgPSB7XG4gIGF1dG9TbGVlcDogMTIwLFxuICBmb3JjZTNEOiBcImF1dG9cIixcbiAgbnVsbFRhcmdldFdhcm46IDEsXG4gIHVuaXRzOiB7XG4gICAgbGluZUhlaWdodDogXCJcIlxuICB9XG59LFxuICAgIF9kZWZhdWx0cyA9IHtcbiAgZHVyYXRpb246IC41LFxuICBvdmVyd3JpdGU6IGZhbHNlLFxuICBkZWxheTogMFxufSxcbiAgICBfYmlnTnVtID0gMWU4LFxuICAgIF90aW55TnVtID0gMSAvIF9iaWdOdW0sXG4gICAgXzJQSSA9IE1hdGguUEkgKiAyLFxuICAgIF9IQUxGX1BJID0gXzJQSSAvIDQsXG4gICAgX2dzSUQgPSAwLFxuICAgIF9zcXJ0ID0gTWF0aC5zcXJ0LFxuICAgIF9jb3MgPSBNYXRoLmNvcyxcbiAgICBfc2luID0gTWF0aC5zaW4sXG4gICAgX2lzU3RyaW5nID0gZnVuY3Rpb24gX2lzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCI7XG59LFxuICAgIF9pc0Z1bmN0aW9uID0gZnVuY3Rpb24gX2lzRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiO1xufSxcbiAgICBfaXNOdW1iZXIgPSBmdW5jdGlvbiBfaXNOdW1iZXIodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIjtcbn0sXG4gICAgX2lzVW5kZWZpbmVkID0gZnVuY3Rpb24gX2lzVW5kZWZpbmVkKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCI7XG59LFxuICAgIF9pc09iamVjdCA9IGZ1bmN0aW9uIF9pc09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiO1xufSxcbiAgICBfaXNOb3RGYWxzZSA9IGZ1bmN0aW9uIF9pc05vdEZhbHNlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gZmFsc2U7XG59LFxuICAgIF93aW5kb3dFeGlzdHMgPSBmdW5jdGlvbiBfd2luZG93RXhpc3RzKCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIjtcbn0sXG4gICAgX2lzRnVuY09yU3RyaW5nID0gZnVuY3Rpb24gX2lzRnVuY09yU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBfaXNGdW5jdGlvbih2YWx1ZSkgfHwgX2lzU3RyaW5nKHZhbHVlKTtcbn0sXG4gICAgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5LFxuICAgIF9zdHJpY3ROdW1FeHAgPSAvKD86LT9cXC4/XFxkfFxcLikrL2dpLFxuICAgIC8vb25seSBudW1iZXJzIChpbmNsdWRpbmcgbmVnYXRpdmVzIGFuZCBkZWNpbWFscykgYnV0IE5PVCByZWxhdGl2ZSB2YWx1ZXMuXG5fbnVtRXhwID0gL1stKz0uXSpcXGQrWy5lXFwtK10qXFxkKltlXFwtXFwrXSpcXGQqL2csXG4gICAgLy9maW5kcyBhbnkgbnVtYmVycywgaW5jbHVkaW5nIG9uZXMgdGhhdCBzdGFydCB3aXRoICs9IG9yIC09LCBuZWdhdGl2ZSBudW1iZXJzLCBhbmQgb25lcyBpbiBzY2llbnRpZmljIG5vdGF0aW9uIGxpa2UgMWUtOC5cbl9udW1XaXRoVW5pdEV4cCA9IC9bLSs9Ll0qXFxkK1suZS1dKlxcZCpbYS16JV0qL2csXG4gICAgX2NvbXBsZXhTdHJpbmdOdW1FeHAgPSAvWy0rPS5dKlxcZCsoPzpcXC58ZS18ZSkqXFxkKi9naSxcbiAgICAvL2R1cGxpY2F0ZSBzbyB0aGF0IHdoaWxlIHdlJ3JlIGxvb3BpbmcgdGhyb3VnaCBtYXRjaGVzIGZyb20gZXhlYygpLCBpdCBkb2Vzbid0IGNvbnRhbWluYXRlIHRoZSBsYXN0SW5kZXggb2YgX251bUV4cCB3aGljaCB3ZSB1c2UgdG8gc2VhcmNoIGZvciBjb2xvcnMgdG9vLlxuX3BhcmVudGhlc2VzRXhwID0gL1xcKChbXigpXSspXFwpL2ksXG4gICAgLy9maW5kcyB0aGUgc3RyaW5nIGJldHdlZW4gcGFyZW50aGVzZXMuXG5fcmVsRXhwID0gL1srLV09LT9bXFwuXFxkXSsvLFxuICAgIF9kZWxpbWl0ZWRWYWx1ZUV4cCA9IC9bI1xcLSsuXSpcXGJbYS16XFxkLT0rJS5dKy9naSxcbiAgICBfZ2xvYmFsVGltZWxpbmUsXG4gICAgX3dpbixcbiAgICBfY29yZUluaXR0ZWQsXG4gICAgX2RvYyxcbiAgICBfZ2xvYmFscyA9IHt9LFxuICAgIF9pbnN0YWxsU2NvcGUgPSB7fSxcbiAgICBfY29yZVJlYWR5LFxuICAgIF9pbnN0YWxsID0gZnVuY3Rpb24gX2luc3RhbGwoc2NvcGUpIHtcbiAgcmV0dXJuIChfaW5zdGFsbFNjb3BlID0gX21lcmdlKHNjb3BlLCBfZ2xvYmFscykpICYmIGdzYXA7XG59LFxuICAgIF9taXNzaW5nUGx1Z2luID0gZnVuY3Rpb24gX21pc3NpbmdQbHVnaW4ocHJvcGVydHksIHZhbHVlKSB7XG4gIHJldHVybiBjb25zb2xlLndhcm4oXCJJbnZhbGlkIHByb3BlcnR5XCIsIHByb3BlcnR5LCBcInNldCB0b1wiLCB2YWx1ZSwgXCJNaXNzaW5nIHBsdWdpbj8gZ3NhcC5yZWdpc3RlclBsdWdpbigpXCIpO1xufSxcbiAgICBfd2FybiA9IGZ1bmN0aW9uIF93YXJuKG1lc3NhZ2UsIHN1cHByZXNzKSB7XG4gIHJldHVybiAhc3VwcHJlc3MgJiYgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xufSxcbiAgICBfYWRkR2xvYmFsID0gZnVuY3Rpb24gX2FkZEdsb2JhbChuYW1lLCBvYmopIHtcbiAgcmV0dXJuIG5hbWUgJiYgKF9nbG9iYWxzW25hbWVdID0gb2JqKSAmJiBfaW5zdGFsbFNjb3BlICYmIChfaW5zdGFsbFNjb3BlW25hbWVdID0gb2JqKSB8fCBfZ2xvYmFscztcbn0sXG4gICAgX2VtcHR5RnVuYyA9IGZ1bmN0aW9uIF9lbXB0eUZ1bmMoKSB7XG4gIHJldHVybiAwO1xufSxcbiAgICBfcmVzZXJ2ZWRQcm9wcyA9IHt9LFxuICAgIF9sYXp5VHdlZW5zID0gW10sXG4gICAgX2xhenlMb29rdXAgPSB7fSxcbiAgICBfbGFzdFJlbmRlcmVkRnJhbWUsXG4gICAgX3BsdWdpbnMgPSB7fSxcbiAgICBfZWZmZWN0cyA9IHt9LFxuICAgIF9uZXh0R0NGcmFtZSA9IDMwLFxuICAgIF9oYXJuZXNzUGx1Z2lucyA9IFtdLFxuICAgIF9jYWxsYmFja05hbWVzID0gXCJcIixcbiAgICBfaGFybmVzcyA9IGZ1bmN0aW9uIF9oYXJuZXNzKHRhcmdldHMpIHtcbiAgdmFyIHRhcmdldCA9IHRhcmdldHNbMF0sXG4gICAgICBoYXJuZXNzUGx1Z2luLFxuICAgICAgaTtcblxuICBpZiAoIV9pc09iamVjdCh0YXJnZXQpICYmICFfaXNGdW5jdGlvbih0YXJnZXQpKSB7XG4gICAgdGFyZ2V0cyA9IFt0YXJnZXRzXTtcbiAgfVxuXG4gIGlmICghKGhhcm5lc3NQbHVnaW4gPSAodGFyZ2V0Ll9nc2FwIHx8IHt9KS5oYXJuZXNzKSkge1xuICAgIGkgPSBfaGFybmVzc1BsdWdpbnMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGktLSAmJiAhX2hhcm5lc3NQbHVnaW5zW2ldLnRhcmdldFRlc3QodGFyZ2V0KSkge31cblxuICAgIGhhcm5lc3NQbHVnaW4gPSBfaGFybmVzc1BsdWdpbnNbaV07XG4gIH1cblxuICBpID0gdGFyZ2V0cy5sZW5ndGg7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIHRhcmdldHNbaV0gJiYgKHRhcmdldHNbaV0uX2dzYXAgfHwgKHRhcmdldHNbaV0uX2dzYXAgPSBuZXcgR1NDYWNoZSh0YXJnZXRzW2ldLCBoYXJuZXNzUGx1Z2luKSkpIHx8IHRhcmdldHMuc3BsaWNlKGksIDEpO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldHM7XG59LFxuICAgIF9nZXRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRDYWNoZSh0YXJnZXQpIHtcbiAgcmV0dXJuIHRhcmdldC5fZ3NhcCB8fCBfaGFybmVzcyh0b0FycmF5KHRhcmdldCkpWzBdLl9nc2FwO1xufSxcbiAgICBfZ2V0UHJvcGVydHkgPSBmdW5jdGlvbiBfZ2V0UHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSkge1xuICB2YXIgY3VycmVudFZhbHVlID0gdGFyZ2V0W3Byb3BlcnR5XTtcbiAgcmV0dXJuIF9pc0Z1bmN0aW9uKGN1cnJlbnRWYWx1ZSkgPyB0YXJnZXRbcHJvcGVydHldKCkgOiBfaXNVbmRlZmluZWQoY3VycmVudFZhbHVlKSAmJiB0YXJnZXQuZ2V0QXR0cmlidXRlKHByb3BlcnR5KSB8fCBjdXJyZW50VmFsdWU7XG59LFxuICAgIF9mb3JFYWNoTmFtZSA9IGZ1bmN0aW9uIF9mb3JFYWNoTmFtZShuYW1lcywgZnVuYykge1xuICByZXR1cm4gKG5hbWVzID0gbmFtZXMuc3BsaXQoXCIsXCIpKS5mb3JFYWNoKGZ1bmMpIHx8IG5hbWVzO1xufSxcbiAgICAvL3NwbGl0IGEgY29tbWEtZGVsaW1pdGVkIGxpc3Qgb2YgbmFtZXMgaW50byBhbiBhcnJheSwgdGhlbiBydW4gYSBmb3JFYWNoKCkgZnVuY3Rpb24gYW5kIHJldHVybiB0aGUgc3BsaXQgYXJyYXkgKHRoaXMgaXMganVzdCBhIHdheSB0byBjb25zb2xpZGF0ZS9zaG9ydGVuIHNvbWUgY29kZSkuXG5fcm91bmQgPSBmdW5jdGlvbiBfcm91bmQodmFsdWUpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiAxMDAwMDApIC8gMTAwMDAwIHx8IDA7XG59LFxuICAgIF9hcnJheUNvbnRhaW5zQW55ID0gZnVuY3Rpb24gX2FycmF5Q29udGFpbnNBbnkodG9TZWFyY2gsIHRvRmluZCkge1xuICAvL3NlYXJjaGVzIG9uZSBhcnJheSB0byBmaW5kIG1hdGNoZXMgZm9yIGFueSBvZiB0aGUgaXRlbXMgaW4gdGhlIHRvRmluZCBhcnJheS4gQXMgc29vbiBhcyBvbmUgaXMgZm91bmQsIGl0IHJldHVybnMgdHJ1ZS4gSXQgZG9lcyBOT1QgcmV0dXJuIGFsbCB0aGUgbWF0Y2hlczsgaXQncyBzaW1wbHkgYSBib29sZWFuIHNlYXJjaC5cbiAgdmFyIGwgPSB0b0ZpbmQubGVuZ3RoLFxuICAgICAgaSA9IDA7XG5cbiAgZm9yICg7IHRvU2VhcmNoLmluZGV4T2YodG9GaW5kW2ldKSA8IDAgJiYgKytpIDwgbDspIHt9XG5cbiAgcmV0dXJuIGkgPCBsO1xufSxcbiAgICBfcGFyc2VWYXJzID0gZnVuY3Rpb24gX3BhcnNlVmFycyhwYXJhbXMsIHR5cGUsIHBhcmVudCkge1xuICAvL3JlYWRzIHRoZSBhcmd1bWVudHMgcGFzc2VkIHRvIG9uZSBvZiB0aGUga2V5IG1ldGhvZHMgYW5kIGZpZ3VyZXMgb3V0IGlmIHRoZSB1c2VyIGlzIGRlZmluaW5nIHRoaW5ncyB3aXRoIHRoZSBPTEQvbGVnYWN5IHN5bnRheCB3aGVyZSB0aGUgZHVyYXRpb24gaXMgdGhlIDJuZCBwYXJhbWV0ZXIsIGFuZCB0aGVuIGl0IGFkanVzdHMgdGhpbmdzIGFjY29yZGluZ2x5IGFuZCBzcGl0cyBiYWNrIHRoZSBjb3JyZWN0ZWQgdmFycyBvYmplY3QgKHdpdGggdGhlIGR1cmF0aW9uIGFkZGVkIGlmIG5lY2Vzc2FyeSwgYXMgd2VsbCBhcyBydW5CYWNrd2FyZHMgb3Igc3RhcnRBdCBvciBpbW1lZGlhdGVSZW5kZXIpLiB0eXBlIDAgPSB0bygpL3N0YWdnZXJUbygpLCAxID0gZnJvbSgpL3N0YWdnZXJGcm9tKCksIDIgPSBmcm9tVG8oKS9zdGFnZ2VyRnJvbVRvKClcbiAgdmFyIGlzTGVnYWN5ID0gX2lzTnVtYmVyKHBhcmFtc1sxXSksXG4gICAgICB2YXJzSW5kZXggPSAoaXNMZWdhY3kgPyAyIDogMSkgKyAodHlwZSA8IDIgPyAwIDogMSksXG4gICAgICB2YXJzID0gcGFyYW1zW3ZhcnNJbmRleF0sXG4gICAgICBpclZhcnM7XG5cbiAgaWYgKGlzTGVnYWN5KSB7XG4gICAgdmFycy5kdXJhdGlvbiA9IHBhcmFtc1sxXTtcbiAgfVxuXG4gIHZhcnMucGFyZW50ID0gcGFyZW50O1xuXG4gIGlmICh0eXBlKSB7XG4gICAgaXJWYXJzID0gdmFycztcblxuICAgIHdoaWxlIChwYXJlbnQgJiYgIShcImltbWVkaWF0ZVJlbmRlclwiIGluIGlyVmFycykpIHtcbiAgICAgIC8vIGluaGVyaXRhbmNlIGhhc24ndCBoYXBwZW5lZCB5ZXQsIGJ1dCBzb21lb25lIG1heSBoYXZlIHNldCBhIGRlZmF1bHQgaW4gYW4gYW5jZXN0b3IgdGltZWxpbmUuIFdlIGNvdWxkIGRvIHZhcnMuaW1tZWRpYXRlUmVuZGVyID0gX2lzTm90RmFsc2UoX2luaGVyaXREZWZhdWx0cyh2YXJzKS5pbW1lZGlhdGVSZW5kZXIpIGJ1dCB0aGF0J2QgZXhhY3QgYSBzbGlnaHQgcGVyZm9ybWFuY2UgcGVuYWx0eSBiZWNhdXNlIF9pbmhlcml0RGVmYXVsdHMoKSBhbHNvIHJ1bnMgaW4gdGhlIFR3ZWVuIGNvbnN0cnVjdG9yLiBXZSdyZSBwYXlpbmcgYSBzbWFsbCBrYiBwcmljZSBoZXJlIHRvIGdhaW4gc3BlZWQuXG4gICAgICBpclZhcnMgPSBwYXJlbnQudmFycy5kZWZhdWx0cyB8fCB7fTtcbiAgICAgIHBhcmVudCA9IF9pc05vdEZhbHNlKHBhcmVudC52YXJzLmluaGVyaXQpICYmIHBhcmVudC5wYXJlbnQ7XG4gICAgfVxuXG4gICAgdmFycy5pbW1lZGlhdGVSZW5kZXIgPSBfaXNOb3RGYWxzZShpclZhcnMuaW1tZWRpYXRlUmVuZGVyKTtcblxuICAgIGlmICh0eXBlIDwgMikge1xuICAgICAgdmFycy5ydW5CYWNrd2FyZHMgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXJzLnN0YXJ0QXQgPSBwYXJhbXNbdmFyc0luZGV4IC0gMV07IC8vIFwiZnJvbVwiIHZhcnNcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFycztcbn0sXG4gICAgX2xhenlSZW5kZXIgPSBmdW5jdGlvbiBfbGF6eVJlbmRlcigpIHtcbiAgdmFyIGwgPSBfbGF6eVR3ZWVucy5sZW5ndGgsXG4gICAgICBhID0gX2xhenlUd2VlbnMuc2xpY2UoMCksXG4gICAgICBpLFxuICAgICAgdHdlZW47XG5cbiAgX2xhenlMb29rdXAgPSB7fTtcbiAgX2xhenlUd2VlbnMubGVuZ3RoID0gMDtcblxuICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgdHdlZW4gPSBhW2ldO1xuICAgIHR3ZWVuICYmIHR3ZWVuLl9sYXp5ICYmICh0d2Vlbi5yZW5kZXIodHdlZW4uX2xhenlbMF0sIHR3ZWVuLl9sYXp5WzFdLCB0cnVlKS5fbGF6eSA9IDApO1xuICB9XG59LFxuICAgIF9sYXp5U2FmZVJlbmRlciA9IGZ1bmN0aW9uIF9sYXp5U2FmZVJlbmRlcihhbmltYXRpb24sIHRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSkge1xuICBfbGF6eVR3ZWVucy5sZW5ndGggJiYgX2xhenlSZW5kZXIoKTtcbiAgYW5pbWF0aW9uLnJlbmRlcih0aW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuICBfbGF6eVR3ZWVucy5sZW5ndGggJiYgX2xhenlSZW5kZXIoKTsgLy9pbiBjYXNlIHJlbmRlcmluZyBjYXVzZWQgYW55IHR3ZWVucyB0byBsYXp5LWluaXQsIHdlIHNob3VsZCByZW5kZXIgdGhlbSBiZWNhdXNlIHR5cGljYWxseSB3aGVuIHNvbWVvbmUgY2FsbHMgc2VlaygpIG9yIHRpbWUoKSBvciBwcm9ncmVzcygpLCB0aGV5IGV4cGVjdCBhbiBpbW1lZGlhdGUgcmVuZGVyLlxufSxcbiAgICBfbnVtZXJpY0lmUG9zc2libGUgPSBmdW5jdGlvbiBfbnVtZXJpY0lmUG9zc2libGUodmFsdWUpIHtcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgcmV0dXJuIChuIHx8IG4gPT09IDApICYmICh2YWx1ZSArIFwiXCIpLm1hdGNoKF9kZWxpbWl0ZWRWYWx1ZUV4cCkubGVuZ3RoIDwgMiA/IG4gOiB2YWx1ZTtcbn0sXG4gICAgX3Bhc3NUaHJvdWdoID0gZnVuY3Rpb24gX3Bhc3NUaHJvdWdoKHApIHtcbiAgcmV0dXJuIHA7XG59LFxuICAgIF9zZXREZWZhdWx0cyA9IGZ1bmN0aW9uIF9zZXREZWZhdWx0cyhvYmosIGRlZmF1bHRzKSB7XG4gIGZvciAodmFyIHAgaW4gZGVmYXVsdHMpIHtcbiAgICBwIGluIG9iaiB8fCAob2JqW3BdID0gZGVmYXVsdHNbcF0pO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn0sXG4gICAgX3NldEtleWZyYW1lRGVmYXVsdHMgPSBmdW5jdGlvbiBfc2V0S2V5ZnJhbWVEZWZhdWx0cyhvYmosIGRlZmF1bHRzKSB7XG4gIGZvciAodmFyIHAgaW4gZGVmYXVsdHMpIHtcbiAgICBpZiAoIShwIGluIG9iaikgJiYgcCAhPT0gXCJkdXJhdGlvblwiICYmIHAgIT09IFwiZWFzZVwiKSB7XG4gICAgICBvYmpbcF0gPSBkZWZhdWx0c1twXTtcbiAgICB9XG4gIH1cbn0sXG4gICAgX21lcmdlID0gZnVuY3Rpb24gX21lcmdlKGJhc2UsIHRvTWVyZ2UpIHtcbiAgZm9yICh2YXIgcCBpbiB0b01lcmdlKSB7XG4gICAgYmFzZVtwXSA9IHRvTWVyZ2VbcF07XG4gIH1cblxuICByZXR1cm4gYmFzZTtcbn0sXG4gICAgX21lcmdlRGVlcCA9IGZ1bmN0aW9uIF9tZXJnZURlZXAoYmFzZSwgdG9NZXJnZSkge1xuICBmb3IgKHZhciBwIGluIHRvTWVyZ2UpIHtcbiAgICBiYXNlW3BdID0gX2lzT2JqZWN0KHRvTWVyZ2VbcF0pID8gX21lcmdlRGVlcChiYXNlW3BdIHx8IChiYXNlW3BdID0ge30pLCB0b01lcmdlW3BdKSA6IHRvTWVyZ2VbcF07XG4gIH1cblxuICByZXR1cm4gYmFzZTtcbn0sXG4gICAgX2NvcHlFeGNsdWRpbmcgPSBmdW5jdGlvbiBfY29weUV4Y2x1ZGluZyhvYmosIGV4Y2x1ZGluZykge1xuICB2YXIgY29weSA9IHt9LFxuICAgICAgcDtcblxuICBmb3IgKHAgaW4gb2JqKSB7XG4gICAgcCBpbiBleGNsdWRpbmcgfHwgKGNvcHlbcF0gPSBvYmpbcF0pO1xuICB9XG5cbiAgcmV0dXJuIGNvcHk7XG59LFxuICAgIF9pbmhlcml0RGVmYXVsdHMgPSBmdW5jdGlvbiBfaW5oZXJpdERlZmF1bHRzKHZhcnMpIHtcbiAgdmFyIHBhcmVudCA9IHZhcnMucGFyZW50IHx8IF9nbG9iYWxUaW1lbGluZSxcbiAgICAgIGZ1bmMgPSB2YXJzLmtleWZyYW1lcyA/IF9zZXRLZXlmcmFtZURlZmF1bHRzIDogX3NldERlZmF1bHRzO1xuXG4gIGlmIChfaXNOb3RGYWxzZSh2YXJzLmluaGVyaXQpKSB7XG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgZnVuYyh2YXJzLCBwYXJlbnQudmFycy5kZWZhdWx0cyk7XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50IHx8IHBhcmVudC5fZHA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZhcnM7XG59LFxuICAgIF9hcnJheXNNYXRjaCA9IGZ1bmN0aW9uIF9hcnJheXNNYXRjaChhMSwgYTIpIHtcbiAgdmFyIGkgPSBhMS5sZW5ndGgsXG4gICAgICBtYXRjaCA9IGkgPT09IGEyLmxlbmd0aDtcblxuICB3aGlsZSAobWF0Y2ggJiYgaS0tICYmIGExW2ldID09PSBhMltpXSkge31cblxuICByZXR1cm4gaSA8IDA7XG59LFxuICAgIF9hZGRMaW5rZWRMaXN0SXRlbSA9IGZ1bmN0aW9uIF9hZGRMaW5rZWRMaXN0SXRlbShwYXJlbnQsIGNoaWxkLCBmaXJzdFByb3AsIGxhc3RQcm9wLCBzb3J0QnkpIHtcbiAgaWYgKGZpcnN0UHJvcCA9PT0gdm9pZCAwKSB7XG4gICAgZmlyc3RQcm9wID0gXCJfZmlyc3RcIjtcbiAgfVxuXG4gIGlmIChsYXN0UHJvcCA9PT0gdm9pZCAwKSB7XG4gICAgbGFzdFByb3AgPSBcIl9sYXN0XCI7XG4gIH1cblxuICB2YXIgcHJldiA9IHBhcmVudFtsYXN0UHJvcF0sXG4gICAgICB0O1xuXG4gIGlmIChzb3J0QnkpIHtcbiAgICB0ID0gY2hpbGRbc29ydEJ5XTtcblxuICAgIHdoaWxlIChwcmV2ICYmIHByZXZbc29ydEJ5XSA+IHQpIHtcbiAgICAgIHByZXYgPSBwcmV2Ll9wcmV2O1xuICAgIH1cbiAgfVxuXG4gIGlmIChwcmV2KSB7XG4gICAgY2hpbGQuX25leHQgPSBwcmV2Ll9uZXh0O1xuICAgIHByZXYuX25leHQgPSBjaGlsZDtcbiAgfSBlbHNlIHtcbiAgICBjaGlsZC5fbmV4dCA9IHBhcmVudFtmaXJzdFByb3BdO1xuICAgIHBhcmVudFtmaXJzdFByb3BdID0gY2hpbGQ7XG4gIH1cblxuICBpZiAoY2hpbGQuX25leHQpIHtcbiAgICBjaGlsZC5fbmV4dC5fcHJldiA9IGNoaWxkO1xuICB9IGVsc2Uge1xuICAgIHBhcmVudFtsYXN0UHJvcF0gPSBjaGlsZDtcbiAgfVxuXG4gIGNoaWxkLl9wcmV2ID0gcHJldjtcbiAgY2hpbGQucGFyZW50ID0gY2hpbGQuX2RwID0gcGFyZW50O1xuICByZXR1cm4gY2hpbGQ7XG59LFxuICAgIF9yZW1vdmVMaW5rZWRMaXN0SXRlbSA9IGZ1bmN0aW9uIF9yZW1vdmVMaW5rZWRMaXN0SXRlbShwYXJlbnQsIGNoaWxkLCBmaXJzdFByb3AsIGxhc3RQcm9wKSB7XG4gIGlmIChmaXJzdFByb3AgPT09IHZvaWQgMCkge1xuICAgIGZpcnN0UHJvcCA9IFwiX2ZpcnN0XCI7XG4gIH1cblxuICBpZiAobGFzdFByb3AgPT09IHZvaWQgMCkge1xuICAgIGxhc3RQcm9wID0gXCJfbGFzdFwiO1xuICB9XG5cbiAgdmFyIHByZXYgPSBjaGlsZC5fcHJldixcbiAgICAgIG5leHQgPSBjaGlsZC5fbmV4dDtcblxuICBpZiAocHJldikge1xuICAgIHByZXYuX25leHQgPSBuZXh0O1xuICB9IGVsc2UgaWYgKHBhcmVudFtmaXJzdFByb3BdID09PSBjaGlsZCkge1xuICAgIHBhcmVudFtmaXJzdFByb3BdID0gbmV4dDtcbiAgfVxuXG4gIGlmIChuZXh0KSB7XG4gICAgbmV4dC5fcHJldiA9IHByZXY7XG4gIH0gZWxzZSBpZiAocGFyZW50W2xhc3RQcm9wXSA9PT0gY2hpbGQpIHtcbiAgICBwYXJlbnRbbGFzdFByb3BdID0gcHJldjtcbiAgfVxuXG4gIGNoaWxkLl9uZXh0ID0gY2hpbGQuX3ByZXYgPSBjaGlsZC5wYXJlbnQgPSBudWxsOyAvLyBkb24ndCBkZWxldGUgdGhlIF9kcCBqdXN0IHNvIHdlIGNhbiByZXZlcnQgaWYgbmVjZXNzYXJ5LiBCdXQgcGFyZW50IHNob3VsZCBiZSBudWxsIHRvIGluZGljYXRlIHRoZSBpdGVtIGlzbid0IGluIGEgbGlua2VkIGxpc3QuXG59LFxuICAgIF9yZW1vdmVGcm9tUGFyZW50ID0gZnVuY3Rpb24gX3JlbW92ZUZyb21QYXJlbnQoY2hpbGQsIG9ubHlJZlBhcmVudEhhc0F1dG9SZW1vdmUpIHtcbiAgY2hpbGQucGFyZW50ICYmICghb25seUlmUGFyZW50SGFzQXV0b1JlbW92ZSB8fCBjaGlsZC5wYXJlbnQuYXV0b1JlbW92ZUNoaWxkcmVuKSAmJiBjaGlsZC5wYXJlbnQucmVtb3ZlKGNoaWxkKTtcbiAgY2hpbGQuX2FjdCA9IDA7XG59LFxuICAgIF91bmNhY2hlID0gZnVuY3Rpb24gX3VuY2FjaGUoYW5pbWF0aW9uKSB7XG4gIHZhciBhID0gYW5pbWF0aW9uO1xuXG4gIHdoaWxlIChhKSB7XG4gICAgYS5fZGlydHkgPSAxO1xuICAgIGEgPSBhLnBhcmVudDtcbiAgfVxuXG4gIHJldHVybiBhbmltYXRpb247XG59LFxuICAgIF9yZWNhY2hlQW5jZXN0b3JzID0gZnVuY3Rpb24gX3JlY2FjaGVBbmNlc3RvcnMoYW5pbWF0aW9uKSB7XG4gIHZhciBwYXJlbnQgPSBhbmltYXRpb24ucGFyZW50O1xuXG4gIHdoaWxlIChwYXJlbnQgJiYgcGFyZW50LnBhcmVudCkge1xuICAgIC8vc29tZXRpbWVzIHdlIG11c3QgZm9yY2UgYSByZS1zb3J0IG9mIGFsbCBjaGlsZHJlbiBhbmQgdXBkYXRlIHRoZSBkdXJhdGlvbi90b3RhbER1cmF0aW9uIG9mIGFsbCBhbmNlc3RvciB0aW1lbGluZXMgaW1tZWRpYXRlbHkgaW4gY2FzZSwgZm9yIGV4YW1wbGUsIGluIHRoZSBtaWRkbGUgb2YgYSByZW5kZXIgbG9vcCwgb25lIHR3ZWVuIGFsdGVycyBhbm90aGVyIHR3ZWVuJ3MgdGltZVNjYWxlIHdoaWNoIHNob3ZlcyBpdHMgc3RhcnRUaW1lIGJlZm9yZSAwLCBmb3JjaW5nIHRoZSBwYXJlbnQgdGltZWxpbmUgdG8gc2hpZnQgYXJvdW5kIGFuZCBzaGlmdENoaWxkcmVuKCkgd2hpY2ggY291bGQgYWZmZWN0IHRoYXQgbmV4dCB0d2VlbidzIHJlbmRlciAoc3RhcnRUaW1lKS4gRG9lc24ndCBtYXR0ZXIgZm9yIHRoZSByb290IHRpbWVsaW5lIHRob3VnaC5cbiAgICBwYXJlbnQuX2RpcnR5ID0gMTtcbiAgICBwYXJlbnQudG90YWxEdXJhdGlvbigpO1xuICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gIH1cblxuICByZXR1cm4gYW5pbWF0aW9uO1xufSxcbiAgICBfaGFzTm9QYXVzZWRBbmNlc3RvcnMgPSBmdW5jdGlvbiBfaGFzTm9QYXVzZWRBbmNlc3RvcnMoYW5pbWF0aW9uKSB7XG4gIHJldHVybiAhYW5pbWF0aW9uIHx8IGFuaW1hdGlvbi5fdHMgJiYgX2hhc05vUGF1c2VkQW5jZXN0b3JzKGFuaW1hdGlvbi5wYXJlbnQpO1xufSxcbiAgICBfZWxhcHNlZEN5Y2xlRHVyYXRpb24gPSBmdW5jdGlvbiBfZWxhcHNlZEN5Y2xlRHVyYXRpb24oYW5pbWF0aW9uKSB7XG4gIHJldHVybiBhbmltYXRpb24uX3JlcGVhdCA/IF9hbmltYXRpb25DeWNsZShhbmltYXRpb24uX3RUaW1lLCBhbmltYXRpb24gPSBhbmltYXRpb24uZHVyYXRpb24oKSArIGFuaW1hdGlvbi5fckRlbGF5KSAqIGFuaW1hdGlvbiA6IDA7XG59LFxuICAgIC8vIGZlZWQgaW4gdGhlIHRvdGFsVGltZSBhbmQgY3ljbGVEdXJhdGlvbiBhbmQgaXQnbGwgcmV0dXJuIHRoZSBjeWNsZSAoaXRlcmF0aW9uIG1pbnVzIDEpIGFuZCBpZiB0aGUgcGxheWhlYWQgaXMgZXhhY3RseSBhdCB0aGUgdmVyeSBFTkQsIGl0IHdpbGwgTk9UIGJ1bXAgdXAgdG8gdGhlIG5leHQgY3ljbGUuXG5fYW5pbWF0aW9uQ3ljbGUgPSBmdW5jdGlvbiBfYW5pbWF0aW9uQ3ljbGUodFRpbWUsIGN5Y2xlRHVyYXRpb24pIHtcbiAgcmV0dXJuICh0VGltZSAvPSBjeWNsZUR1cmF0aW9uKSAmJiB+fnRUaW1lID09PSB0VGltZSA/IH5+dFRpbWUgLSAxIDogfn50VGltZTtcbn0sXG4gICAgX3BhcmVudFRvQ2hpbGRUb3RhbFRpbWUgPSBmdW5jdGlvbiBfcGFyZW50VG9DaGlsZFRvdGFsVGltZShwYXJlbnRUaW1lLCBjaGlsZCkge1xuICByZXR1cm4gKHBhcmVudFRpbWUgLSBjaGlsZC5fc3RhcnQpICogY2hpbGQuX3RzICsgKGNoaWxkLl90cyA+PSAwID8gMCA6IGNoaWxkLl9kaXJ0eSA/IGNoaWxkLnRvdGFsRHVyYXRpb24oKSA6IGNoaWxkLl90RHVyKTtcbn0sXG4gICAgX3NldEVuZCA9IGZ1bmN0aW9uIF9zZXRFbmQoYW5pbWF0aW9uKSB7XG4gIHJldHVybiBhbmltYXRpb24uX2VuZCA9IF9yb3VuZChhbmltYXRpb24uX3N0YXJ0ICsgKGFuaW1hdGlvbi5fdER1ciAvIE1hdGguYWJzKGFuaW1hdGlvbi5fdHMgfHwgYW5pbWF0aW9uLl9ydHMgfHwgX3RpbnlOdW0pIHx8IDApKTtcbn0sXG4gICAgX2FsaWduUGxheWhlYWQgPSBmdW5jdGlvbiBfYWxpZ25QbGF5aGVhZChhbmltYXRpb24sIHRvdGFsVGltZSkge1xuICAvLyBhZGp1c3RzIHRoZSBhbmltYXRpb24ncyBfc3RhcnQgYW5kIF9lbmQgYWNjb3JkaW5nIHRvIHRoZSBwcm92aWRlZCB0b3RhbFRpbWUgKG9ubHkgaWYgdGhlIHBhcmVudCdzIHNtb290aENoaWxkVGltaW5nIGlzIHRydWUgYW5kIHRoZSBhbmltYXRpb24gaXNuJ3QgcGF1c2VkKS4gSXQgZG9lc24ndCBkbyBhbnkgcmVuZGVyaW5nIG9yIGZvcmNpbmcgdGhpbmdzIGJhY2sgaW50byBwYXJlbnQgdGltZWxpbmVzLCBldGMuIC0gdGhhdCdzIHdoYXQgdG90YWxUaW1lKCkgaXMgZm9yLlxuICB2YXIgcGFyZW50ID0gYW5pbWF0aW9uLl9kcDtcblxuICBpZiAocGFyZW50ICYmIHBhcmVudC5zbW9vdGhDaGlsZFRpbWluZyAmJiBhbmltYXRpb24uX3RzKSB7XG4gICAgYW5pbWF0aW9uLl9zdGFydCA9IF9yb3VuZChhbmltYXRpb24uX2RwLl90aW1lIC0gKGFuaW1hdGlvbi5fdHMgPiAwID8gdG90YWxUaW1lIC8gYW5pbWF0aW9uLl90cyA6ICgoYW5pbWF0aW9uLl9kaXJ0eSA/IGFuaW1hdGlvbi50b3RhbER1cmF0aW9uKCkgOiBhbmltYXRpb24uX3REdXIpIC0gdG90YWxUaW1lKSAvIC1hbmltYXRpb24uX3RzKSk7XG5cbiAgICBfc2V0RW5kKGFuaW1hdGlvbik7XG5cbiAgICBwYXJlbnQuX2RpcnR5IHx8IF91bmNhY2hlKHBhcmVudCk7IC8vZm9yIHBlcmZvcm1hbmNlIGltcHJvdmVtZW50LiBJZiB0aGUgcGFyZW50J3MgY2FjaGUgaXMgYWxyZWFkeSBkaXJ0eSwgaXQgYWxyZWFkeSB0b29rIGNhcmUgb2YgbWFya2luZyB0aGUgYW5jZXN0b3JzIGFzIGRpcnR5IHRvbywgc28gc2tpcCB0aGUgZnVuY3Rpb24gY2FsbCBoZXJlLlxuICB9XG5cbiAgcmV0dXJuIGFuaW1hdGlvbjtcbn0sXG5cbi8qXG5fdG90YWxUaW1lVG9UaW1lID0gKGNsYW1wZWRUb3RhbFRpbWUsIGR1cmF0aW9uLCByZXBlYXQsIHJlcGVhdERlbGF5LCB5b3lvKSA9PiB7XG5cdGxldCBjeWNsZUR1cmF0aW9uID0gZHVyYXRpb24gKyByZXBlYXREZWxheSxcblx0XHR0aW1lID0gX3JvdW5kKGNsYW1wZWRUb3RhbFRpbWUgJSBjeWNsZUR1cmF0aW9uKTtcblx0aWYgKHRpbWUgPiBkdXJhdGlvbikge1xuXHRcdHRpbWUgPSBkdXJhdGlvbjtcblx0fVxuXHRyZXR1cm4gKHlveW8gJiYgKH5+KGNsYW1wZWRUb3RhbFRpbWUgLyBjeWNsZUR1cmF0aW9uKSAmIDEpKSA/IGR1cmF0aW9uIC0gdGltZSA6IHRpbWU7XG59LFxuKi9cbl9wb3N0QWRkQ2hlY2tzID0gZnVuY3Rpb24gX3Bvc3RBZGRDaGVja3ModGltZWxpbmUsIGNoaWxkKSB7XG4gIHZhciB0O1xuXG4gIGlmIChjaGlsZC5fdGltZSB8fCBjaGlsZC5faW5pdHRlZCAmJiAhY2hpbGQuX2R1cikge1xuICAgIC8vaW4gY2FzZSwgZm9yIGV4YW1wbGUsIHRoZSBfc3RhcnQgaXMgbW92ZWQgb24gYSB0d2VlbiB0aGF0IGhhcyBhbHJlYWR5IHJlbmRlcmVkLiBJbWFnaW5lIGl0J3MgYXQgaXRzIGVuZCBzdGF0ZSwgdGhlbiB0aGUgc3RhcnRUaW1lIGlzIG1vdmVkIFdBWSBsYXRlciAoYWZ0ZXIgdGhlIGVuZCBvZiB0aGlzIHRpbWVsaW5lKSwgaXQgc2hvdWxkIHJlbmRlciBhdCBpdHMgYmVnaW5uaW5nLlxuICAgIHQgPSBfcGFyZW50VG9DaGlsZFRvdGFsVGltZSh0aW1lbGluZS5yYXdUaW1lKCksIGNoaWxkKTtcblxuICAgIGlmICghY2hpbGQuX2R1ciB8fCBfY2xhbXAoMCwgY2hpbGQudG90YWxEdXJhdGlvbigpLCB0KSAtIGNoaWxkLl90VGltZSA+IF90aW55TnVtKSB7XG4gICAgICBjaGlsZC5yZW5kZXIodCwgdHJ1ZSk7XG4gICAgfVxuICB9IC8vaWYgdGhlIHRpbWVsaW5lIGhhcyBhbHJlYWR5IGVuZGVkIGJ1dCB0aGUgaW5zZXJ0ZWQgdHdlZW4vdGltZWxpbmUgZXh0ZW5kcyB0aGUgZHVyYXRpb24sIHdlIHNob3VsZCBlbmFibGUgdGhpcyB0aW1lbGluZSBhZ2FpbiBzbyB0aGF0IGl0IHJlbmRlcnMgcHJvcGVybHkuIFdlIHNob3VsZCBhbHNvIGFsaWduIHRoZSBwbGF5aGVhZCB3aXRoIHRoZSBwYXJlbnQgdGltZWxpbmUncyB3aGVuIGFwcHJvcHJpYXRlLlxuXG5cbiAgaWYgKF91bmNhY2hlKHRpbWVsaW5lKS5fZHAgJiYgdGltZWxpbmUuX2luaXR0ZWQgJiYgdGltZWxpbmUuX3RpbWUgPj0gdGltZWxpbmUuX2R1ciAmJiB0aW1lbGluZS5fdHMpIHtcbiAgICAvL2luIGNhc2UgYW55IG9mIHRoZSBhbmNlc3RvcnMgaGFkIGNvbXBsZXRlZCBidXQgc2hvdWxkIG5vdyBiZSBlbmFibGVkLi4uXG4gICAgaWYgKHRpbWVsaW5lLl9kdXIgPCB0aW1lbGluZS5kdXJhdGlvbigpKSB7XG4gICAgICB0ID0gdGltZWxpbmU7XG5cbiAgICAgIHdoaWxlICh0Ll9kcCkge1xuICAgICAgICB0LnJhd1RpbWUoKSA+PSAwICYmIHQudG90YWxUaW1lKHQuX3RUaW1lKTsgLy9tb3ZlcyB0aGUgdGltZWxpbmUgKHNoaWZ0cyBpdHMgc3RhcnRUaW1lKSBpZiBuZWNlc3NhcnksIGFuZCBhbHNvIGVuYWJsZXMgaXQuIElmIGl0J3MgY3VycmVudGx5IHplcm8sIHRob3VnaCwgaXQgbWF5IG5vdCBiZSBzY2hlZHVsZWQgdG8gcmVuZGVyIHVudGlsIGxhdGVyIHNvIHRoZXJlJ3Mgbm8gbmVlZCB0byBmb3JjZSBpdCB0byBhbGlnbiB3aXRoIHRoZSBjdXJyZW50IHBsYXloZWFkIHBvc2l0aW9uLiBPbmx5IG1vdmUgdG8gY2F0Y2ggdXAgd2l0aCB0aGUgcGxheWhlYWQuXG5cbiAgICAgICAgdCA9IHQuX2RwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRpbWVsaW5lLl96VGltZSA9IC1fdGlueU51bTsgLy8gaGVscHMgZW5zdXJlIHRoYXQgdGhlIG5leHQgcmVuZGVyKCkgd2lsbCBiZSBmb3JjZWQgKGNyb3NzaW5nU3RhcnQgPSB0cnVlIGluIHJlbmRlcigpKSwgZXZlbiBpZiB0aGUgZHVyYXRpb24gaGFzbid0IGNoYW5nZWQgKHdlJ3JlIGFkZGluZyBhIGNoaWxkIHdoaWNoIHdvdWxkIG5lZWQgdG8gZ2V0IHJlbmRlcmVkKS4gRGVmaW5pdGVseSBhbiBlZGdlIGNhc2UuIE5vdGU6IHdlIE1VU1QgZG8gdGhpcyBBRlRFUiB0aGUgbG9vcCBhYm92ZSB3aGVyZSB0aGUgdG90YWxUaW1lKCkgbWlnaHQgdHJpZ2dlciBhIHJlbmRlcigpIGJlY2F1c2UgdGhpcyBfYWRkVG9UaW1lbGluZSgpIG1ldGhvZCBnZXRzIGNhbGxlZCBmcm9tIHRoZSBBbmltYXRpb24gY29uc3RydWN0b3IsIEJFRk9SRSB0d2VlbnMgZXZlbiByZWNvcmQgdGhlaXIgdGFyZ2V0cywgZXRjLiBzbyB3ZSB3b3VsZG4ndCB3YW50IHRoaW5ncyB0byBnZXQgdHJpZ2dlcmVkIGluIHRoZSB3cm9uZyBvcmRlci5cbiAgfVxufSxcbiAgICBfYWRkVG9UaW1lbGluZSA9IGZ1bmN0aW9uIF9hZGRUb1RpbWVsaW5lKHRpbWVsaW5lLCBjaGlsZCwgcG9zaXRpb24sIHNraXBDaGVja3MpIHtcbiAgY2hpbGQucGFyZW50ICYmIF9yZW1vdmVGcm9tUGFyZW50KGNoaWxkKTtcbiAgY2hpbGQuX3N0YXJ0ID0gX3JvdW5kKHBvc2l0aW9uICsgY2hpbGQuX2RlbGF5KTtcbiAgY2hpbGQuX2VuZCA9IF9yb3VuZChjaGlsZC5fc3RhcnQgKyAoY2hpbGQudG90YWxEdXJhdGlvbigpIC8gTWF0aC5hYnMoY2hpbGQudGltZVNjYWxlKCkpIHx8IDApKTtcblxuICBfYWRkTGlua2VkTGlzdEl0ZW0odGltZWxpbmUsIGNoaWxkLCBcIl9maXJzdFwiLCBcIl9sYXN0XCIsIHRpbWVsaW5lLl9zb3J0ID8gXCJfc3RhcnRcIiA6IDApO1xuXG4gIHRpbWVsaW5lLl9yZWNlbnQgPSBjaGlsZDtcbiAgc2tpcENoZWNrcyB8fCBfcG9zdEFkZENoZWNrcyh0aW1lbGluZSwgY2hpbGQpO1xuICByZXR1cm4gdGltZWxpbmU7XG59LFxuICAgIF9zY3JvbGxUcmlnZ2VyID0gZnVuY3Rpb24gX3Njcm9sbFRyaWdnZXIoYW5pbWF0aW9uLCB0cmlnZ2VyKSB7XG4gIHJldHVybiAoX2dsb2JhbHMuU2Nyb2xsVHJpZ2dlciB8fCBfbWlzc2luZ1BsdWdpbihcInNjcm9sbFRyaWdnZXJcIiwgdHJpZ2dlcikpICYmIF9nbG9iYWxzLlNjcm9sbFRyaWdnZXIuY3JlYXRlKHRyaWdnZXIsIGFuaW1hdGlvbik7XG59LFxuICAgIF9hdHRlbXB0SW5pdFR3ZWVuID0gZnVuY3Rpb24gX2F0dGVtcHRJbml0VHdlZW4odHdlZW4sIHRvdGFsVGltZSwgZm9yY2UsIHN1cHByZXNzRXZlbnRzKSB7XG4gIF9pbml0VHdlZW4odHdlZW4sIHRvdGFsVGltZSk7XG5cbiAgaWYgKCF0d2Vlbi5faW5pdHRlZCkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgaWYgKCFmb3JjZSAmJiB0d2Vlbi5fcHQgJiYgKHR3ZWVuLl9kdXIgJiYgdHdlZW4udmFycy5sYXp5ICE9PSBmYWxzZSB8fCAhdHdlZW4uX2R1ciAmJiB0d2Vlbi52YXJzLmxhenkpICYmIF9sYXN0UmVuZGVyZWRGcmFtZSAhPT0gX3RpY2tlci5mcmFtZSkge1xuICAgIF9sYXp5VHdlZW5zLnB1c2godHdlZW4pO1xuXG4gICAgdHdlZW4uX2xhenkgPSBbdG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50c107XG4gICAgcmV0dXJuIDE7XG4gIH1cbn0sXG4gICAgX3JlbmRlclplcm9EdXJhdGlvblR3ZWVuID0gZnVuY3Rpb24gX3JlbmRlclplcm9EdXJhdGlvblR3ZWVuKHR3ZWVuLCB0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSkge1xuICB2YXIgcHJldlJhdGlvID0gdHdlZW4ucmF0aW8sXG4gICAgICByYXRpbyA9IHRvdGFsVGltZSA8IDAgfHwgIXRvdGFsVGltZSAmJiBwcmV2UmF0aW8gJiYgIXR3ZWVuLl9zdGFydCAmJiB0d2Vlbi5felRpbWUgPiBfdGlueU51bSAmJiAhdHdlZW4uX2RwLl9sb2NrIHx8IHR3ZWVuLl90cyA8IDAgfHwgdHdlZW4uX2RwLl90cyA8IDAgPyAwIDogMSxcbiAgICAgIC8vIGNoZWNrIHBhcmVudCdzIF9sb2NrIGJlY2F1c2Ugd2hlbiBhIHRpbWVsaW5lIHJlcGVhdHMveW95b3MgYW5kIGRvZXMgaXRzIGFydGlmaWNpYWwgd3JhcHBpbmcsIHdlIHNob3VsZG4ndCBmb3JjZSB0aGUgcmF0aW8gYmFjayB0byAwLiBBbHNvLCBpZiB0aGUgdHdlZW4gb3IgaXRzIHBhcmVudCBpcyByZXZlcnNlZCBhbmQgdGhlIHRvdGFsVGltZSBpcyAwLCB3ZSBzaG91bGQgZ28gdG8gYSByYXRpbyBvZiAwLlxuICByZXBlYXREZWxheSA9IHR3ZWVuLl9yRGVsYXksXG4gICAgICB0VGltZSA9IDAsXG4gICAgICBwdCxcbiAgICAgIGl0ZXJhdGlvbixcbiAgICAgIHByZXZJdGVyYXRpb247XG5cbiAgaWYgKHJlcGVhdERlbGF5ICYmIHR3ZWVuLl9yZXBlYXQpIHtcbiAgICAvLyBpbiBjYXNlIHRoZXJlJ3MgYSB6ZXJvLWR1cmF0aW9uIHR3ZWVuIHRoYXQgaGFzIGEgcmVwZWF0IHdpdGggYSByZXBlYXREZWxheVxuICAgIHRUaW1lID0gX2NsYW1wKDAsIHR3ZWVuLl90RHVyLCB0b3RhbFRpbWUpO1xuICAgIGl0ZXJhdGlvbiA9IF9hbmltYXRpb25DeWNsZSh0VGltZSwgcmVwZWF0RGVsYXkpO1xuICAgIHByZXZJdGVyYXRpb24gPSBfYW5pbWF0aW9uQ3ljbGUodHdlZW4uX3RUaW1lLCByZXBlYXREZWxheSk7XG5cbiAgICBpZiAoaXRlcmF0aW9uICE9PSBwcmV2SXRlcmF0aW9uKSB7XG4gICAgICBwcmV2UmF0aW8gPSAxIC0gcmF0aW87XG4gICAgICB0d2Vlbi52YXJzLnJlcGVhdFJlZnJlc2ggJiYgdHdlZW4uX2luaXR0ZWQgJiYgdHdlZW4uaW52YWxpZGF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghdHdlZW4uX2luaXR0ZWQgJiYgX2F0dGVtcHRJbml0VHdlZW4odHdlZW4sIHRvdGFsVGltZSwgZm9yY2UsIHN1cHByZXNzRXZlbnRzKSkge1xuICAgIC8vIGlmIHdlIHJlbmRlciB0aGUgdmVyeSBiZWdpbm5pbmcgKHRpbWUgPT0gMCkgb2YgYSBmcm9tVG8oKSwgd2UgbXVzdCBmb3JjZSB0aGUgcmVuZGVyIChub3JtYWwgdHdlZW5zIHdvdWxkbid0IG5lZWQgdG8gcmVuZGVyIGF0IGEgdGltZSBvZiAwIHdoZW4gdGhlIHByZXZUaW1lIHdhcyBhbHNvIDApLiBUaGlzIGlzIGFsc28gbWFuZGF0b3J5IHRvIG1ha2Ugc3VyZSBvdmVyd3JpdGluZyBraWNrcyBpbiBpbW1lZGlhdGVseS5cbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAocmF0aW8gIT09IHByZXZSYXRpbyB8fCBmb3JjZSB8fCB0d2Vlbi5felRpbWUgPT09IF90aW55TnVtIHx8ICF0b3RhbFRpbWUgJiYgdHdlZW4uX3pUaW1lKSB7XG4gICAgcHJldkl0ZXJhdGlvbiA9IHR3ZWVuLl96VGltZTtcbiAgICB0d2Vlbi5felRpbWUgPSB0b3RhbFRpbWUgfHwgKHN1cHByZXNzRXZlbnRzID8gX3RpbnlOdW0gOiAwKTsgLy8gd2hlbiB0aGUgcGxheWhlYWQgYXJyaXZlcyBhdCBFWEFDVExZIHRpbWUgMCAocmlnaHQgb24gdG9wKSBvZiBhIHplcm8tZHVyYXRpb24gdHdlZW4sIHdlIG5lZWQgdG8gZGlzY2VybiBpZiBldmVudHMgYXJlIHN1cHByZXNzZWQgc28gdGhhdCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBhZ2FpbiAobmV4dCB0aW1lKSwgaXQnbGwgdHJpZ2dlciB0aGUgY2FsbGJhY2suIElmIGV2ZW50cyBhcmUgTk9UIHN1cHByZXNzZWQsIG9idmlvdXNseSB0aGUgY2FsbGJhY2sgd291bGQgYmUgdHJpZ2dlcmVkIGluIHRoaXMgcmVuZGVyLiBCYXNpY2FsbHksIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZSBlaXRoZXIgd2hlbiB0aGUgcGxheWhlYWQgQVJSSVZFUyBvciBMRUFWRVMgdGhpcyBleGFjdCBzcG90LCBub3QgYm90aC4gSW1hZ2luZSBkb2luZyBhIHRpbWVsaW5lLnNlZWsoMCkgYW5kIHRoZXJlJ3MgYSBjYWxsYmFjayB0aGF0IHNpdHMgYXQgMC4gU2luY2UgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIG9uIHRoYXQgc2VlaygpIGJ5IGRlZmF1bHQsIG5vdGhpbmcgd2lsbCBmaXJlLCBidXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgb2ZmIG9mIHRoYXQgcG9zaXRpb24sIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZS4gVGhpcyBiZWhhdmlvciBpcyB3aGF0IHBlb3BsZSBpbnR1aXRpdmVseSBleHBlY3QuXG5cbiAgICBzdXBwcmVzc0V2ZW50cyB8fCAoc3VwcHJlc3NFdmVudHMgPSB0b3RhbFRpbWUgJiYgIXByZXZJdGVyYXRpb24pOyAvLyBpZiBpdCB3YXMgcmVuZGVyZWQgcHJldmlvdXNseSBhdCBleGFjdGx5IDAgKF96VGltZSkgYW5kIG5vdyB0aGUgcGxheWhlYWQgaXMgbW92aW5nIGF3YXksIERPTidUIGZpcmUgY2FsbGJhY2tzIG90aGVyd2lzZSB0aGV5J2xsIHNlZW0gbGlrZSBkdXBsaWNhdGVzLlxuXG4gICAgdHdlZW4ucmF0aW8gPSByYXRpbztcbiAgICB0d2Vlbi5fZnJvbSAmJiAocmF0aW8gPSAxIC0gcmF0aW8pO1xuICAgIHR3ZWVuLl90aW1lID0gMDtcbiAgICB0d2Vlbi5fdFRpbWUgPSB0VGltZTtcbiAgICBzdXBwcmVzc0V2ZW50cyB8fCBfY2FsbGJhY2sodHdlZW4sIFwib25TdGFydFwiKTtcbiAgICBwdCA9IHR3ZWVuLl9wdDtcblxuICAgIHdoaWxlIChwdCkge1xuICAgICAgcHQucihyYXRpbywgcHQuZCk7XG4gICAgICBwdCA9IHB0Ll9uZXh0O1xuICAgIH1cblxuICAgIHR3ZWVuLl9zdGFydEF0ICYmIHRvdGFsVGltZSA8IDAgJiYgdHdlZW4uX3N0YXJ0QXQucmVuZGVyKHRvdGFsVGltZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgdHdlZW4uX29uVXBkYXRlICYmICFzdXBwcmVzc0V2ZW50cyAmJiBfY2FsbGJhY2sodHdlZW4sIFwib25VcGRhdGVcIik7XG4gICAgdFRpbWUgJiYgdHdlZW4uX3JlcGVhdCAmJiAhc3VwcHJlc3NFdmVudHMgJiYgdHdlZW4ucGFyZW50ICYmIF9jYWxsYmFjayh0d2VlbiwgXCJvblJlcGVhdFwiKTtcblxuICAgIGlmICgodG90YWxUaW1lID49IHR3ZWVuLl90RHVyIHx8IHRvdGFsVGltZSA8IDApICYmIHR3ZWVuLnJhdGlvID09PSByYXRpbykge1xuICAgICAgcmF0aW8gJiYgX3JlbW92ZUZyb21QYXJlbnQodHdlZW4sIDEpO1xuXG4gICAgICBpZiAoIXN1cHByZXNzRXZlbnRzKSB7XG4gICAgICAgIF9jYWxsYmFjayh0d2VlbiwgcmF0aW8gPyBcIm9uQ29tcGxldGVcIiA6IFwib25SZXZlcnNlQ29tcGxldGVcIiwgdHJ1ZSk7XG5cbiAgICAgICAgdHdlZW4uX3Byb20gJiYgdHdlZW4uX3Byb20oKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoIXR3ZWVuLl96VGltZSkge1xuICAgIHR3ZWVuLl96VGltZSA9IHRvdGFsVGltZTtcbiAgfVxufSxcbiAgICBfZmluZE5leHRQYXVzZVR3ZWVuID0gZnVuY3Rpb24gX2ZpbmROZXh0UGF1c2VUd2VlbihhbmltYXRpb24sIHByZXZUaW1lLCB0aW1lKSB7XG4gIHZhciBjaGlsZDtcblxuICBpZiAodGltZSA+IHByZXZUaW1lKSB7XG4gICAgY2hpbGQgPSBhbmltYXRpb24uX2ZpcnN0O1xuXG4gICAgd2hpbGUgKGNoaWxkICYmIGNoaWxkLl9zdGFydCA8PSB0aW1lKSB7XG4gICAgICBpZiAoIWNoaWxkLl9kdXIgJiYgY2hpbGQuZGF0YSA9PT0gXCJpc1BhdXNlXCIgJiYgY2hpbGQuX3N0YXJ0ID4gcHJldlRpbWUpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgfVxuXG4gICAgICBjaGlsZCA9IGNoaWxkLl9uZXh0O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjaGlsZCA9IGFuaW1hdGlvbi5fbGFzdDtcblxuICAgIHdoaWxlIChjaGlsZCAmJiBjaGlsZC5fc3RhcnQgPj0gdGltZSkge1xuICAgICAgaWYgKCFjaGlsZC5fZHVyICYmIGNoaWxkLmRhdGEgPT09IFwiaXNQYXVzZVwiICYmIGNoaWxkLl9zdGFydCA8IHByZXZUaW1lKSB7XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgIH1cblxuICAgICAgY2hpbGQgPSBjaGlsZC5fcHJldjtcbiAgICB9XG4gIH1cbn0sXG4gICAgX3NldER1cmF0aW9uID0gZnVuY3Rpb24gX3NldER1cmF0aW9uKGFuaW1hdGlvbiwgZHVyYXRpb24sIHNraXBVbmNhY2hlKSB7XG4gIHZhciByZXBlYXQgPSBhbmltYXRpb24uX3JlcGVhdCxcbiAgICAgIGR1ciA9IF9yb3VuZChkdXJhdGlvbikgfHwgMDtcbiAgYW5pbWF0aW9uLl9kdXIgPSBkdXI7XG4gIGFuaW1hdGlvbi5fdER1ciA9ICFyZXBlYXQgPyBkdXIgOiByZXBlYXQgPCAwID8gMWUxMCA6IF9yb3VuZChkdXIgKiAocmVwZWF0ICsgMSkgKyBhbmltYXRpb24uX3JEZWxheSAqIHJlcGVhdCk7XG5cbiAgaWYgKGFuaW1hdGlvbi5fdGltZSA+IGR1cikge1xuICAgIGFuaW1hdGlvbi5fdGltZSA9IGR1cjtcbiAgICBhbmltYXRpb24uX3RUaW1lID0gTWF0aC5taW4oYW5pbWF0aW9uLl90VGltZSwgYW5pbWF0aW9uLl90RHVyKTtcbiAgfVxuXG4gICFza2lwVW5jYWNoZSAmJiBfdW5jYWNoZShhbmltYXRpb24ucGFyZW50KTtcbiAgYW5pbWF0aW9uLnBhcmVudCAmJiBfc2V0RW5kKGFuaW1hdGlvbik7XG4gIHJldHVybiBhbmltYXRpb247XG59LFxuICAgIF9vblVwZGF0ZVRvdGFsRHVyYXRpb24gPSBmdW5jdGlvbiBfb25VcGRhdGVUb3RhbER1cmF0aW9uKGFuaW1hdGlvbikge1xuICByZXR1cm4gYW5pbWF0aW9uIGluc3RhbmNlb2YgVGltZWxpbmUgPyBfdW5jYWNoZShhbmltYXRpb24pIDogX3NldER1cmF0aW9uKGFuaW1hdGlvbiwgYW5pbWF0aW9uLl9kdXIpO1xufSxcbiAgICBfemVyb1Bvc2l0aW9uID0ge1xuICBfc3RhcnQ6IDAsXG4gIGVuZFRpbWU6IF9lbXB0eUZ1bmNcbn0sXG4gICAgX3BhcnNlUG9zaXRpb24gPSBmdW5jdGlvbiBfcGFyc2VQb3NpdGlvbihhbmltYXRpb24sIHBvc2l0aW9uKSB7XG4gIHZhciBsYWJlbHMgPSBhbmltYXRpb24ubGFiZWxzLFxuICAgICAgcmVjZW50ID0gYW5pbWF0aW9uLl9yZWNlbnQgfHwgX3plcm9Qb3NpdGlvbixcbiAgICAgIGNsaXBwZWREdXJhdGlvbiA9IGFuaW1hdGlvbi5kdXJhdGlvbigpID49IF9iaWdOdW0gPyByZWNlbnQuZW5kVGltZShmYWxzZSkgOiBhbmltYXRpb24uX2R1cixcbiAgICAgIC8vaW4gY2FzZSB0aGVyZSdzIGEgY2hpbGQgdGhhdCBpbmZpbml0ZWx5IHJlcGVhdHMsIHVzZXJzIGFsbW9zdCBuZXZlciBpbnRlbmQgZm9yIHRoZSBpbnNlcnRpb24gcG9pbnQgb2YgYSBuZXcgY2hpbGQgdG8gYmUgYmFzZWQgb24gYSBTVVBFUiBsb25nIHZhbHVlIGxpa2UgdGhhdCBzbyB3ZSBjbGlwIGl0IGFuZCBhc3N1bWUgdGhlIG1vc3QgcmVjZW50bHktYWRkZWQgY2hpbGQncyBlbmRUaW1lIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXG4gIGksXG4gICAgICBvZmZzZXQ7XG5cbiAgaWYgKF9pc1N0cmluZyhwb3NpdGlvbikgJiYgKGlzTmFOKHBvc2l0aW9uKSB8fCBwb3NpdGlvbiBpbiBsYWJlbHMpKSB7XG4gICAgLy9pZiB0aGUgc3RyaW5nIGlzIGEgbnVtYmVyIGxpa2UgXCIxXCIsIGNoZWNrIHRvIHNlZSBpZiB0aGVyZSdzIGEgbGFiZWwgd2l0aCB0aGF0IG5hbWUsIG90aGVyd2lzZSBpbnRlcnByZXQgaXQgYXMgYSBudW1iZXIgKGFic29sdXRlIHZhbHVlKS5cbiAgICBpID0gcG9zaXRpb24uY2hhckF0KDApO1xuXG4gICAgaWYgKGkgPT09IFwiPFwiIHx8IGkgPT09IFwiPlwiKSB7XG4gICAgICByZXR1cm4gKGkgPT09IFwiPFwiID8gcmVjZW50Ll9zdGFydCA6IHJlY2VudC5lbmRUaW1lKHJlY2VudC5fcmVwZWF0ID49IDApKSArIChwYXJzZUZsb2F0KHBvc2l0aW9uLnN1YnN0cigxKSkgfHwgMCk7XG4gICAgfVxuXG4gICAgaSA9IHBvc2l0aW9uLmluZGV4T2YoXCI9XCIpO1xuXG4gICAgaWYgKGkgPCAwKSB7XG4gICAgICBwb3NpdGlvbiBpbiBsYWJlbHMgfHwgKGxhYmVsc1twb3NpdGlvbl0gPSBjbGlwcGVkRHVyYXRpb24pO1xuICAgICAgcmV0dXJuIGxhYmVsc1twb3NpdGlvbl07XG4gICAgfVxuXG4gICAgb2Zmc2V0ID0gKyhwb3NpdGlvbi5jaGFyQXQoaSAtIDEpICsgcG9zaXRpb24uc3Vic3RyKGkgKyAxKSk7XG4gICAgcmV0dXJuIGkgPiAxID8gX3BhcnNlUG9zaXRpb24oYW5pbWF0aW9uLCBwb3NpdGlvbi5zdWJzdHIoMCwgaSAtIDEpKSArIG9mZnNldCA6IGNsaXBwZWREdXJhdGlvbiArIG9mZnNldDtcbiAgfVxuXG4gIHJldHVybiBwb3NpdGlvbiA9PSBudWxsID8gY2xpcHBlZER1cmF0aW9uIDogK3Bvc2l0aW9uO1xufSxcbiAgICBfY29uZGl0aW9uYWxSZXR1cm4gPSBmdW5jdGlvbiBfY29uZGl0aW9uYWxSZXR1cm4odmFsdWUsIGZ1bmMpIHtcbiAgcmV0dXJuIHZhbHVlIHx8IHZhbHVlID09PSAwID8gZnVuYyh2YWx1ZSkgOiBmdW5jO1xufSxcbiAgICBfY2xhbXAgPSBmdW5jdGlvbiBfY2xhbXAobWluLCBtYXgsIHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA8IG1pbiA/IG1pbiA6IHZhbHVlID4gbWF4ID8gbWF4IDogdmFsdWU7XG59LFxuICAgIGdldFVuaXQgPSBmdW5jdGlvbiBnZXRVbml0KHZhbHVlKSB7XG4gIHJldHVybiAodmFsdWUgKyBcIlwiKS5zdWJzdHIoKHBhcnNlRmxvYXQodmFsdWUpICsgXCJcIikubGVuZ3RoKTtcbn0sXG4gICAgY2xhbXAgPSBmdW5jdGlvbiBjbGFtcChtaW4sIG1heCwgdmFsdWUpIHtcbiAgcmV0dXJuIF9jb25kaXRpb25hbFJldHVybih2YWx1ZSwgZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gX2NsYW1wKG1pbiwgbWF4LCB2KTtcbiAgfSk7XG59LFxuICAgIF9zbGljZSA9IFtdLnNsaWNlLFxuICAgIF9pc0FycmF5TGlrZSA9IGZ1bmN0aW9uIF9pc0FycmF5TGlrZSh2YWx1ZSwgbm9uRW1wdHkpIHtcbiAgcmV0dXJuIHZhbHVlICYmIF9pc09iamVjdCh2YWx1ZSkgJiYgXCJsZW5ndGhcIiBpbiB2YWx1ZSAmJiAoIW5vbkVtcHR5ICYmICF2YWx1ZS5sZW5ndGggfHwgdmFsdWUubGVuZ3RoIC0gMSBpbiB2YWx1ZSAmJiBfaXNPYmplY3QodmFsdWVbMF0pKSAmJiAhdmFsdWUubm9kZVR5cGUgJiYgdmFsdWUgIT09IF93aW47XG59LFxuICAgIF9mbGF0dGVuID0gZnVuY3Rpb24gX2ZsYXR0ZW4oYXIsIGxlYXZlU3RyaW5ncywgYWNjdW11bGF0b3IpIHtcbiAgaWYgKGFjY3VtdWxhdG9yID09PSB2b2lkIDApIHtcbiAgICBhY2N1bXVsYXRvciA9IFtdO1xuICB9XG5cbiAgcmV0dXJuIGFyLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIF9hY2N1bXVsYXRvcjtcblxuICAgIHJldHVybiBfaXNTdHJpbmcodmFsdWUpICYmICFsZWF2ZVN0cmluZ3MgfHwgX2lzQXJyYXlMaWtlKHZhbHVlLCAxKSA/IChfYWNjdW11bGF0b3IgPSBhY2N1bXVsYXRvcikucHVzaC5hcHBseShfYWNjdW11bGF0b3IsIHRvQXJyYXkodmFsdWUpKSA6IGFjY3VtdWxhdG9yLnB1c2godmFsdWUpO1xuICB9KSB8fCBhY2N1bXVsYXRvcjtcbn0sXG4gICAgLy90YWtlcyBhbnkgdmFsdWUgYW5kIHJldHVybnMgYW4gYXJyYXkuIElmIGl0J3MgYSBzdHJpbmcgKGFuZCBsZWF2ZVN0cmluZ3MgaXNuJ3QgdHJ1ZSksIGl0J2xsIHVzZSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCkgYW5kIGNvbnZlcnQgdGhhdCB0byBhbiBhcnJheS4gSXQnbGwgYWxzbyBhY2NlcHQgaXRlcmFibGVzIGxpa2UgalF1ZXJ5IG9iamVjdHMuXG50b0FycmF5ID0gZnVuY3Rpb24gdG9BcnJheSh2YWx1ZSwgbGVhdmVTdHJpbmdzKSB7XG4gIHJldHVybiBfaXNTdHJpbmcodmFsdWUpICYmICFsZWF2ZVN0cmluZ3MgJiYgKF9jb3JlSW5pdHRlZCB8fCAhX3dha2UoKSkgPyBfc2xpY2UuY2FsbChfZG9jLnF1ZXJ5U2VsZWN0b3JBbGwodmFsdWUpLCAwKSA6IF9pc0FycmF5KHZhbHVlKSA/IF9mbGF0dGVuKHZhbHVlLCBsZWF2ZVN0cmluZ3MpIDogX2lzQXJyYXlMaWtlKHZhbHVlKSA/IF9zbGljZS5jYWxsKHZhbHVlLCAwKSA6IHZhbHVlID8gW3ZhbHVlXSA6IFtdO1xufSxcbiAgICBzaHVmZmxlID0gZnVuY3Rpb24gc2h1ZmZsZShhKSB7XG4gIHJldHVybiBhLnNvcnQoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAuNSAtIE1hdGgucmFuZG9tKCk7XG4gIH0pO1xufSxcbiAgICAvLyBhbHRlcm5hdGl2ZSB0aGF0J3MgYSBiaXQgZmFzdGVyIGFuZCBtb3JlIHJlbGlhYmx5IGRpdmVyc2UgYnV0IGJpZ2dlcjogICBmb3IgKGxldCBqLCB2LCBpID0gYS5sZW5ndGg7IGk7IGogPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBpKSwgdiA9IGFbLS1pXSwgYVtpXSA9IGFbal0sIGFbal0gPSB2KTsgcmV0dXJuIGE7XG4vL2ZvciBkaXN0cmlidXRpbmcgdmFsdWVzIGFjcm9zcyBhbiBhcnJheS4gQ2FuIGFjY2VwdCBhIG51bWJlciwgYSBmdW5jdGlvbiBvciAobW9zdCBjb21tb25seSkgYSBmdW5jdGlvbiB3aGljaCBjYW4gY29udGFpbiB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6IHtiYXNlLCBhbW91bnQsIGZyb20sIGVhc2UsIGdyaWQsIGF4aXMsIGxlbmd0aCwgZWFjaH0uIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGV4cGVjdHMgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOiBpbmRleCwgdGFyZ2V0LCBhcnJheS4gUmVjb2duaXplcyB0aGUgZm9sbG93aW5nXG5kaXN0cmlidXRlID0gZnVuY3Rpb24gZGlzdHJpYnV0ZSh2KSB7XG4gIGlmIChfaXNGdW5jdGlvbih2KSkge1xuICAgIHJldHVybiB2O1xuICB9XG5cbiAgdmFyIHZhcnMgPSBfaXNPYmplY3QodikgPyB2IDoge1xuICAgIGVhY2g6IHZcbiAgfSxcbiAgICAgIC8vbjoxIGlzIGp1c3QgdG8gaW5kaWNhdGUgdiB3YXMgYSBudW1iZXI7IHdlIGxldmVyYWdlIHRoYXQgbGF0ZXIgdG8gc2V0IHYgYWNjb3JkaW5nIHRvIHRoZSBsZW5ndGggd2UgZ2V0LiBJZiBhIG51bWJlciBpcyBwYXNzZWQgaW4sIHdlIHRyZWF0IGl0IGxpa2UgdGhlIG9sZCBzdGFnZ2VyIHZhbHVlIHdoZXJlIDAuMSwgZm9yIGV4YW1wbGUsIHdvdWxkIG1lYW4gdGhhdCB0aGluZ3Mgd291bGQgYmUgZGlzdHJpYnV0ZWQgd2l0aCAwLjEgYmV0d2VlbiBlYWNoIGVsZW1lbnQgaW4gdGhlIGFycmF5IHJhdGhlciB0aGFuIGEgdG90YWwgXCJhbW91bnRcIiB0aGF0J3MgY2h1bmtlZCBvdXQgYW1vbmcgdGhlbSBhbGwuXG4gIGVhc2UgPSBfcGFyc2VFYXNlKHZhcnMuZWFzZSksXG4gICAgICBmcm9tID0gdmFycy5mcm9tIHx8IDAsXG4gICAgICBiYXNlID0gcGFyc2VGbG9hdCh2YXJzLmJhc2UpIHx8IDAsXG4gICAgICBjYWNoZSA9IHt9LFxuICAgICAgaXNEZWNpbWFsID0gZnJvbSA+IDAgJiYgZnJvbSA8IDEsXG4gICAgICByYXRpb3MgPSBpc05hTihmcm9tKSB8fCBpc0RlY2ltYWwsXG4gICAgICBheGlzID0gdmFycy5heGlzLFxuICAgICAgcmF0aW9YID0gZnJvbSxcbiAgICAgIHJhdGlvWSA9IGZyb207XG5cbiAgaWYgKF9pc1N0cmluZyhmcm9tKSkge1xuICAgIHJhdGlvWCA9IHJhdGlvWSA9IHtcbiAgICAgIGNlbnRlcjogLjUsXG4gICAgICBlZGdlczogLjUsXG4gICAgICBlbmQ6IDFcbiAgICB9W2Zyb21dIHx8IDA7XG4gIH0gZWxzZSBpZiAoIWlzRGVjaW1hbCAmJiByYXRpb3MpIHtcbiAgICByYXRpb1ggPSBmcm9tWzBdO1xuICAgIHJhdGlvWSA9IGZyb21bMV07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGksIHRhcmdldCwgYSkge1xuICAgIHZhciBsID0gKGEgfHwgdmFycykubGVuZ3RoLFxuICAgICAgICBkaXN0YW5jZXMgPSBjYWNoZVtsXSxcbiAgICAgICAgb3JpZ2luWCxcbiAgICAgICAgb3JpZ2luWSxcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgZCxcbiAgICAgICAgaixcbiAgICAgICAgbWF4LFxuICAgICAgICBtaW4sXG4gICAgICAgIHdyYXBBdDtcblxuICAgIGlmICghZGlzdGFuY2VzKSB7XG4gICAgICB3cmFwQXQgPSB2YXJzLmdyaWQgPT09IFwiYXV0b1wiID8gMCA6ICh2YXJzLmdyaWQgfHwgWzEsIF9iaWdOdW1dKVsxXTtcblxuICAgICAgaWYgKCF3cmFwQXQpIHtcbiAgICAgICAgbWF4ID0gLV9iaWdOdW07XG5cbiAgICAgICAgd2hpbGUgKG1heCA8IChtYXggPSBhW3dyYXBBdCsrXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0KSAmJiB3cmFwQXQgPCBsKSB7fVxuXG4gICAgICAgIHdyYXBBdC0tO1xuICAgICAgfVxuXG4gICAgICBkaXN0YW5jZXMgPSBjYWNoZVtsXSA9IFtdO1xuICAgICAgb3JpZ2luWCA9IHJhdGlvcyA/IE1hdGgubWluKHdyYXBBdCwgbCkgKiByYXRpb1ggLSAuNSA6IGZyb20gJSB3cmFwQXQ7XG4gICAgICBvcmlnaW5ZID0gcmF0aW9zID8gbCAqIHJhdGlvWSAvIHdyYXBBdCAtIC41IDogZnJvbSAvIHdyYXBBdCB8IDA7XG4gICAgICBtYXggPSAwO1xuICAgICAgbWluID0gX2JpZ051bTtcblxuICAgICAgZm9yIChqID0gMDsgaiA8IGw7IGorKykge1xuICAgICAgICB4ID0gaiAlIHdyYXBBdCAtIG9yaWdpblg7XG4gICAgICAgIHkgPSBvcmlnaW5ZIC0gKGogLyB3cmFwQXQgfCAwKTtcbiAgICAgICAgZGlzdGFuY2VzW2pdID0gZCA9ICFheGlzID8gX3NxcnQoeCAqIHggKyB5ICogeSkgOiBNYXRoLmFicyhheGlzID09PSBcInlcIiA/IHkgOiB4KTtcbiAgICAgICAgZCA+IG1heCAmJiAobWF4ID0gZCk7XG4gICAgICAgIGQgPCBtaW4gJiYgKG1pbiA9IGQpO1xuICAgICAgfVxuXG4gICAgICBmcm9tID09PSBcInJhbmRvbVwiICYmIHNodWZmbGUoZGlzdGFuY2VzKTtcbiAgICAgIGRpc3RhbmNlcy5tYXggPSBtYXggLSBtaW47XG4gICAgICBkaXN0YW5jZXMubWluID0gbWluO1xuICAgICAgZGlzdGFuY2VzLnYgPSBsID0gKHBhcnNlRmxvYXQodmFycy5hbW91bnQpIHx8IHBhcnNlRmxvYXQodmFycy5lYWNoKSAqICh3cmFwQXQgPiBsID8gbCAtIDEgOiAhYXhpcyA/IE1hdGgubWF4KHdyYXBBdCwgbCAvIHdyYXBBdCkgOiBheGlzID09PSBcInlcIiA/IGwgLyB3cmFwQXQgOiB3cmFwQXQpIHx8IDApICogKGZyb20gPT09IFwiZWRnZXNcIiA/IC0xIDogMSk7XG4gICAgICBkaXN0YW5jZXMuYiA9IGwgPCAwID8gYmFzZSAtIGwgOiBiYXNlO1xuICAgICAgZGlzdGFuY2VzLnUgPSBnZXRVbml0KHZhcnMuYW1vdW50IHx8IHZhcnMuZWFjaCkgfHwgMDsgLy91bml0XG5cbiAgICAgIGVhc2UgPSBlYXNlICYmIGwgPCAwID8gX2ludmVydEVhc2UoZWFzZSkgOiBlYXNlO1xuICAgIH1cblxuICAgIGwgPSAoZGlzdGFuY2VzW2ldIC0gZGlzdGFuY2VzLm1pbikgLyBkaXN0YW5jZXMubWF4IHx8IDA7XG4gICAgcmV0dXJuIF9yb3VuZChkaXN0YW5jZXMuYiArIChlYXNlID8gZWFzZShsKSA6IGwpICogZGlzdGFuY2VzLnYpICsgZGlzdGFuY2VzLnU7IC8vcm91bmQgaW4gb3JkZXIgdG8gd29yayBhcm91bmQgZmxvYXRpbmcgcG9pbnQgZXJyb3JzXG4gIH07XG59LFxuICAgIF9yb3VuZE1vZGlmaWVyID0gZnVuY3Rpb24gX3JvdW5kTW9kaWZpZXIodikge1xuICAvL3Bhc3MgaW4gMC4xIGdldCBhIGZ1bmN0aW9uIHRoYXQnbGwgcm91bmQgdG8gdGhlIG5lYXJlc3QgdGVudGgsIG9yIDUgdG8gcm91bmQgdG8gdGhlIGNsb3Nlc3QgNSwgb3IgMC4wMDEgdG8gdGhlIGNsb3Nlc3QgMTAwMHRoLCBldGMuXG4gIHZhciBwID0gdiA8IDEgPyBNYXRoLnBvdygxMCwgKHYgKyBcIlwiKS5sZW5ndGggLSAyKSA6IDE7IC8vdG8gYXZvaWQgZmxvYXRpbmcgcG9pbnQgbWF0aCBlcnJvcnMgKGxpa2UgMjQgKiAwLjEgPT0gMi40MDAwMDAwMDAwMDAwMDA0KSwgd2UgY2hvcCBvZmYgYXQgYSBzcGVjaWZpYyBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgKG11Y2ggZmFzdGVyIHRoYW4gdG9GaXhlZCgpXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChyYXcpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJvdW5kKHBhcnNlRmxvYXQocmF3KSAvIHYpICogdiAqIHApIC8gcCArIChfaXNOdW1iZXIocmF3KSA/IDAgOiBnZXRVbml0KHJhdykpO1xuICB9O1xufSxcbiAgICBzbmFwID0gZnVuY3Rpb24gc25hcChzbmFwVG8sIHZhbHVlKSB7XG4gIHZhciBpc0FycmF5ID0gX2lzQXJyYXkoc25hcFRvKSxcbiAgICAgIHJhZGl1cyxcbiAgICAgIGlzMkQ7XG5cbiAgaWYgKCFpc0FycmF5ICYmIF9pc09iamVjdChzbmFwVG8pKSB7XG4gICAgcmFkaXVzID0gaXNBcnJheSA9IHNuYXBUby5yYWRpdXMgfHwgX2JpZ051bTtcblxuICAgIGlmIChzbmFwVG8udmFsdWVzKSB7XG4gICAgICBzbmFwVG8gPSB0b0FycmF5KHNuYXBUby52YWx1ZXMpO1xuXG4gICAgICBpZiAoaXMyRCA9ICFfaXNOdW1iZXIoc25hcFRvWzBdKSkge1xuICAgICAgICByYWRpdXMgKj0gcmFkaXVzOyAvL3BlcmZvcm1hbmNlIG9wdGltaXphdGlvbiBzbyB3ZSBkb24ndCBoYXZlIHRvIE1hdGguc3FydCgpIGluIHRoZSBsb29wLlxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzbmFwVG8gPSBfcm91bmRNb2RpZmllcihzbmFwVG8uaW5jcmVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gX2NvbmRpdGlvbmFsUmV0dXJuKHZhbHVlLCAhaXNBcnJheSA/IF9yb3VuZE1vZGlmaWVyKHNuYXBUbykgOiBfaXNGdW5jdGlvbihzbmFwVG8pID8gZnVuY3Rpb24gKHJhdykge1xuICAgIGlzMkQgPSBzbmFwVG8ocmF3KTtcbiAgICByZXR1cm4gTWF0aC5hYnMoaXMyRCAtIHJhdykgPD0gcmFkaXVzID8gaXMyRCA6IHJhdztcbiAgfSA6IGZ1bmN0aW9uIChyYXcpIHtcbiAgICB2YXIgeCA9IHBhcnNlRmxvYXQoaXMyRCA/IHJhdy54IDogcmF3KSxcbiAgICAgICAgeSA9IHBhcnNlRmxvYXQoaXMyRCA/IHJhdy55IDogMCksXG4gICAgICAgIG1pbiA9IF9iaWdOdW0sXG4gICAgICAgIGNsb3Nlc3QgPSAwLFxuICAgICAgICBpID0gc25hcFRvLmxlbmd0aCxcbiAgICAgICAgZHgsXG4gICAgICAgIGR5O1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgaWYgKGlzMkQpIHtcbiAgICAgICAgZHggPSBzbmFwVG9baV0ueCAtIHg7XG4gICAgICAgIGR5ID0gc25hcFRvW2ldLnkgLSB5O1xuICAgICAgICBkeCA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZHggPSBNYXRoLmFicyhzbmFwVG9baV0gLSB4KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGR4IDwgbWluKSB7XG4gICAgICAgIG1pbiA9IGR4O1xuICAgICAgICBjbG9zZXN0ID0gaTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjbG9zZXN0ID0gIXJhZGl1cyB8fCBtaW4gPD0gcmFkaXVzID8gc25hcFRvW2Nsb3Nlc3RdIDogcmF3O1xuICAgIHJldHVybiBpczJEIHx8IGNsb3Nlc3QgPT09IHJhdyB8fCBfaXNOdW1iZXIocmF3KSA/IGNsb3Nlc3QgOiBjbG9zZXN0ICsgZ2V0VW5pdChyYXcpO1xuICB9KTtcbn0sXG4gICAgcmFuZG9tID0gZnVuY3Rpb24gcmFuZG9tKG1pbiwgbWF4LCByb3VuZGluZ0luY3JlbWVudCwgcmV0dXJuRnVuY3Rpb24pIHtcbiAgcmV0dXJuIF9jb25kaXRpb25hbFJldHVybihfaXNBcnJheShtaW4pID8gIW1heCA6IHJvdW5kaW5nSW5jcmVtZW50ID09PSB0cnVlID8gISEocm91bmRpbmdJbmNyZW1lbnQgPSAwKSA6ICFyZXR1cm5GdW5jdGlvbiwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaXNBcnJheShtaW4pID8gbWluW35+KE1hdGgucmFuZG9tKCkgKiBtaW4ubGVuZ3RoKV0gOiAocm91bmRpbmdJbmNyZW1lbnQgPSByb3VuZGluZ0luY3JlbWVudCB8fCAxZS01KSAmJiAocmV0dXJuRnVuY3Rpb24gPSByb3VuZGluZ0luY3JlbWVudCA8IDEgPyBNYXRoLnBvdygxMCwgKHJvdW5kaW5nSW5jcmVtZW50ICsgXCJcIikubGVuZ3RoIC0gMikgOiAxKSAmJiBNYXRoLmZsb29yKE1hdGgucm91bmQoKG1pbiArIE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSkgLyByb3VuZGluZ0luY3JlbWVudCkgKiByb3VuZGluZ0luY3JlbWVudCAqIHJldHVybkZ1bmN0aW9uKSAvIHJldHVybkZ1bmN0aW9uO1xuICB9KTtcbn0sXG4gICAgcGlwZSA9IGZ1bmN0aW9uIHBpcGUoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBmdW5jdGlvbnMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgZnVuY3Rpb25zW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbnMucmVkdWNlKGZ1bmN0aW9uICh2LCBmKSB7XG4gICAgICByZXR1cm4gZih2KTtcbiAgICB9LCB2YWx1ZSk7XG4gIH07XG59LFxuICAgIHVuaXRpemUgPSBmdW5jdGlvbiB1bml0aXplKGZ1bmMsIHVuaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHBhcnNlRmxvYXQodmFsdWUpKSArICh1bml0IHx8IGdldFVuaXQodmFsdWUpKTtcbiAgfTtcbn0sXG4gICAgbm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplKG1pbiwgbWF4LCB2YWx1ZSkge1xuICByZXR1cm4gbWFwUmFuZ2UobWluLCBtYXgsIDAsIDEsIHZhbHVlKTtcbn0sXG4gICAgX3dyYXBBcnJheSA9IGZ1bmN0aW9uIF93cmFwQXJyYXkoYSwgd3JhcHBlciwgdmFsdWUpIHtcbiAgcmV0dXJuIF9jb25kaXRpb25hbFJldHVybih2YWx1ZSwgZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgcmV0dXJuIGFbfn53cmFwcGVyKGluZGV4KV07XG4gIH0pO1xufSxcbiAgICB3cmFwID0gZnVuY3Rpb24gd3JhcChtaW4sIG1heCwgdmFsdWUpIHtcbiAgLy8gTk9URTogd3JhcCgpIENBTk5PVCBiZSBhbiBhcnJvdyBmdW5jdGlvbiEgQSB2ZXJ5IG9kZCBjb21waWxpbmcgYnVnIGNhdXNlcyBwcm9ibGVtcyAodW5yZWxhdGVkIHRvIEdTQVApLlxuICB2YXIgcmFuZ2UgPSBtYXggLSBtaW47XG4gIHJldHVybiBfaXNBcnJheShtaW4pID8gX3dyYXBBcnJheShtaW4sIHdyYXAoMCwgbWluLmxlbmd0aCksIG1heCkgOiBfY29uZGl0aW9uYWxSZXR1cm4odmFsdWUsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiAocmFuZ2UgKyAodmFsdWUgLSBtaW4pICUgcmFuZ2UpICUgcmFuZ2UgKyBtaW47XG4gIH0pO1xufSxcbiAgICB3cmFwWW95byA9IGZ1bmN0aW9uIHdyYXBZb3lvKG1pbiwgbWF4LCB2YWx1ZSkge1xuICB2YXIgcmFuZ2UgPSBtYXggLSBtaW4sXG4gICAgICB0b3RhbCA9IHJhbmdlICogMjtcbiAgcmV0dXJuIF9pc0FycmF5KG1pbikgPyBfd3JhcEFycmF5KG1pbiwgd3JhcFlveW8oMCwgbWluLmxlbmd0aCAtIDEpLCBtYXgpIDogX2NvbmRpdGlvbmFsUmV0dXJuKHZhbHVlLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YWx1ZSA9ICh0b3RhbCArICh2YWx1ZSAtIG1pbikgJSB0b3RhbCkgJSB0b3RhbCB8fCAwO1xuICAgIHJldHVybiBtaW4gKyAodmFsdWUgPiByYW5nZSA/IHRvdGFsIC0gdmFsdWUgOiB2YWx1ZSk7XG4gIH0pO1xufSxcbiAgICBfcmVwbGFjZVJhbmRvbSA9IGZ1bmN0aW9uIF9yZXBsYWNlUmFuZG9tKHZhbHVlKSB7XG4gIC8vcmVwbGFjZXMgYWxsIG9jY3VycmVuY2VzIG9mIHJhbmRvbSguLi4pIGluIGEgc3RyaW5nIHdpdGggdGhlIGNhbGN1bGF0ZWQgcmFuZG9tIHZhbHVlLiBjYW4gYmUgYSByYW5nZSBsaWtlIHJhbmRvbSgtMTAwLCAxMDAsIDUpIG9yIGFuIGFycmF5IGxpa2UgcmFuZG9tKFswLCAxMDAsIDUwMF0pXG4gIHZhciBwcmV2ID0gMCxcbiAgICAgIHMgPSBcIlwiLFxuICAgICAgaSxcbiAgICAgIG51bXMsXG4gICAgICBlbmQsXG4gICAgICBpc0FycmF5O1xuXG4gIHdoaWxlICh+KGkgPSB2YWx1ZS5pbmRleE9mKFwicmFuZG9tKFwiLCBwcmV2KSkpIHtcbiAgICBlbmQgPSB2YWx1ZS5pbmRleE9mKFwiKVwiLCBpKTtcbiAgICBpc0FycmF5ID0gdmFsdWUuY2hhckF0KGkgKyA3KSA9PT0gXCJbXCI7XG4gICAgbnVtcyA9IHZhbHVlLnN1YnN0cihpICsgNywgZW5kIC0gaSAtIDcpLm1hdGNoKGlzQXJyYXkgPyBfZGVsaW1pdGVkVmFsdWVFeHAgOiBfc3RyaWN0TnVtRXhwKTtcbiAgICBzICs9IHZhbHVlLnN1YnN0cihwcmV2LCBpIC0gcHJldikgKyByYW5kb20oaXNBcnJheSA/IG51bXMgOiArbnVtc1swXSwgK251bXNbMV0sICtudW1zWzJdIHx8IDFlLTUpO1xuICAgIHByZXYgPSBlbmQgKyAxO1xuICB9XG5cbiAgcmV0dXJuIHMgKyB2YWx1ZS5zdWJzdHIocHJldiwgdmFsdWUubGVuZ3RoIC0gcHJldik7XG59LFxuICAgIG1hcFJhbmdlID0gZnVuY3Rpb24gbWFwUmFuZ2UoaW5NaW4sIGluTWF4LCBvdXRNaW4sIG91dE1heCwgdmFsdWUpIHtcbiAgdmFyIGluUmFuZ2UgPSBpbk1heCAtIGluTWluLFxuICAgICAgb3V0UmFuZ2UgPSBvdXRNYXggLSBvdXRNaW47XG4gIHJldHVybiBfY29uZGl0aW9uYWxSZXR1cm4odmFsdWUsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBvdXRNaW4gKyAoKHZhbHVlIC0gaW5NaW4pIC8gaW5SYW5nZSAqIG91dFJhbmdlIHx8IDApO1xuICB9KTtcbn0sXG4gICAgaW50ZXJwb2xhdGUgPSBmdW5jdGlvbiBpbnRlcnBvbGF0ZShzdGFydCwgZW5kLCBwcm9ncmVzcywgbXV0YXRlKSB7XG4gIHZhciBmdW5jID0gaXNOYU4oc3RhcnQgKyBlbmQpID8gMCA6IGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuICgxIC0gcCkgKiBzdGFydCArIHAgKiBlbmQ7XG4gIH07XG5cbiAgaWYgKCFmdW5jKSB7XG4gICAgdmFyIGlzU3RyaW5nID0gX2lzU3RyaW5nKHN0YXJ0KSxcbiAgICAgICAgbWFzdGVyID0ge30sXG4gICAgICAgIHAsXG4gICAgICAgIGksXG4gICAgICAgIGludGVycG9sYXRvcnMsXG4gICAgICAgIGwsXG4gICAgICAgIGlsO1xuXG4gICAgcHJvZ3Jlc3MgPT09IHRydWUgJiYgKG11dGF0ZSA9IDEpICYmIChwcm9ncmVzcyA9IG51bGwpO1xuXG4gICAgaWYgKGlzU3RyaW5nKSB7XG4gICAgICBzdGFydCA9IHtcbiAgICAgICAgcDogc3RhcnRcbiAgICAgIH07XG4gICAgICBlbmQgPSB7XG4gICAgICAgIHA6IGVuZFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKF9pc0FycmF5KHN0YXJ0KSAmJiAhX2lzQXJyYXkoZW5kKSkge1xuICAgICAgaW50ZXJwb2xhdG9ycyA9IFtdO1xuICAgICAgbCA9IHN0YXJ0Lmxlbmd0aDtcbiAgICAgIGlsID0gbCAtIDI7XG5cbiAgICAgIGZvciAoaSA9IDE7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaW50ZXJwb2xhdG9ycy5wdXNoKGludGVycG9sYXRlKHN0YXJ0W2kgLSAxXSwgc3RhcnRbaV0pKTsgLy9idWlsZCB0aGUgaW50ZXJwb2xhdG9ycyB1cCBmcm9udCBhcyBhIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbiBzbyB0aGF0IHdoZW4gdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZCBtYW55IHRpbWVzLCBpdCBjYW4ganVzdCByZXVzZSB0aGVtLlxuICAgICAgfVxuXG4gICAgICBsLS07XG5cbiAgICAgIGZ1bmMgPSBmdW5jdGlvbiBmdW5jKHApIHtcbiAgICAgICAgcCAqPSBsO1xuICAgICAgICB2YXIgaSA9IE1hdGgubWluKGlsLCB+fnApO1xuICAgICAgICByZXR1cm4gaW50ZXJwb2xhdG9yc1tpXShwIC0gaSk7XG4gICAgICB9O1xuXG4gICAgICBwcm9ncmVzcyA9IGVuZDtcbiAgICB9IGVsc2UgaWYgKCFtdXRhdGUpIHtcbiAgICAgIHN0YXJ0ID0gX21lcmdlKF9pc0FycmF5KHN0YXJ0KSA/IFtdIDoge30sIHN0YXJ0KTtcbiAgICB9XG5cbiAgICBpZiAoIWludGVycG9sYXRvcnMpIHtcbiAgICAgIGZvciAocCBpbiBlbmQpIHtcbiAgICAgICAgX2FkZFByb3BUd2Vlbi5jYWxsKG1hc3Rlciwgc3RhcnQsIHAsIFwiZ2V0XCIsIGVuZFtwXSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmMgPSBmdW5jdGlvbiBmdW5jKHApIHtcbiAgICAgICAgcmV0dXJuIF9yZW5kZXJQcm9wVHdlZW5zKHAsIG1hc3RlcikgfHwgKGlzU3RyaW5nID8gc3RhcnQucCA6IHN0YXJ0KTtcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9jb25kaXRpb25hbFJldHVybihwcm9ncmVzcywgZnVuYyk7XG59LFxuICAgIF9nZXRMYWJlbEluRGlyZWN0aW9uID0gZnVuY3Rpb24gX2dldExhYmVsSW5EaXJlY3Rpb24odGltZWxpbmUsIGZyb21UaW1lLCBiYWNrd2FyZCkge1xuICAvL3VzZWQgZm9yIG5leHRMYWJlbCgpIGFuZCBwcmV2aW91c0xhYmVsKClcbiAgdmFyIGxhYmVscyA9IHRpbWVsaW5lLmxhYmVscyxcbiAgICAgIG1pbiA9IF9iaWdOdW0sXG4gICAgICBwLFxuICAgICAgZGlzdGFuY2UsXG4gICAgICBsYWJlbDtcblxuICBmb3IgKHAgaW4gbGFiZWxzKSB7XG4gICAgZGlzdGFuY2UgPSBsYWJlbHNbcF0gLSBmcm9tVGltZTtcblxuICAgIGlmIChkaXN0YW5jZSA8IDAgPT09ICEhYmFja3dhcmQgJiYgZGlzdGFuY2UgJiYgbWluID4gKGRpc3RhbmNlID0gTWF0aC5hYnMoZGlzdGFuY2UpKSkge1xuICAgICAgbGFiZWwgPSBwO1xuICAgICAgbWluID0gZGlzdGFuY2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxhYmVsO1xufSxcbiAgICBfY2FsbGJhY2sgPSBmdW5jdGlvbiBfY2FsbGJhY2soYW5pbWF0aW9uLCB0eXBlLCBleGVjdXRlTGF6eUZpcnN0KSB7XG4gIHZhciB2ID0gYW5pbWF0aW9uLnZhcnMsXG4gICAgICBjYWxsYmFjayA9IHZbdHlwZV0sXG4gICAgICBwYXJhbXMsXG4gICAgICBzY29wZTtcblxuICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcGFyYW1zID0gdlt0eXBlICsgXCJQYXJhbXNcIl07XG4gIHNjb3BlID0gdi5jYWxsYmFja1Njb3BlIHx8IGFuaW1hdGlvbjtcbiAgZXhlY3V0ZUxhenlGaXJzdCAmJiBfbGF6eVR3ZWVucy5sZW5ndGggJiYgX2xhenlSZW5kZXIoKTsgLy9pbiBjYXNlIHJlbmRlcmluZyBjYXVzZWQgYW55IHR3ZWVucyB0byBsYXp5LWluaXQsIHdlIHNob3VsZCByZW5kZXIgdGhlbSBiZWNhdXNlIHR5cGljYWxseSB3aGVuIGEgdGltZWxpbmUgZmluaXNoZXMsIHVzZXJzIGV4cGVjdCB0aGluZ3MgdG8gaGF2ZSByZW5kZXJlZCBmdWxseS4gSW1hZ2luZSBhbiBvblVwZGF0ZSBvbiBhIHRpbWVsaW5lIHRoYXQgcmVwb3J0cy9jaGVja3MgdHdlZW5lZCB2YWx1ZXMuXG5cbiAgcmV0dXJuIHBhcmFtcyA/IGNhbGxiYWNrLmFwcGx5KHNjb3BlLCBwYXJhbXMpIDogY2FsbGJhY2suY2FsbChzY29wZSk7XG59LFxuICAgIF9pbnRlcnJ1cHQgPSBmdW5jdGlvbiBfaW50ZXJydXB0KGFuaW1hdGlvbikge1xuICBfcmVtb3ZlRnJvbVBhcmVudChhbmltYXRpb24pO1xuXG4gIGlmIChhbmltYXRpb24ucHJvZ3Jlc3MoKSA8IDEpIHtcbiAgICBfY2FsbGJhY2soYW5pbWF0aW9uLCBcIm9uSW50ZXJydXB0XCIpO1xuICB9XG5cbiAgcmV0dXJuIGFuaW1hdGlvbjtcbn0sXG4gICAgX3F1aWNrVHdlZW4sXG4gICAgX2NyZWF0ZVBsdWdpbiA9IGZ1bmN0aW9uIF9jcmVhdGVQbHVnaW4oY29uZmlnKSB7XG4gIGNvbmZpZyA9ICFjb25maWcubmFtZSAmJiBjb25maWdbXCJkZWZhdWx0XCJdIHx8IGNvbmZpZzsgLy9VTUQgcGFja2FnaW5nIHdyYXBzIHRoaW5ncyBvZGRseSwgc28gZm9yIGV4YW1wbGUgTW90aW9uUGF0aEhlbHBlciBiZWNvbWVzIHtNb3Rpb25QYXRoSGVscGVyOk1vdGlvblBhdGhIZWxwZXIsIGRlZmF1bHQ6TW90aW9uUGF0aEhlbHBlcn0uXG5cbiAgdmFyIG5hbWUgPSBjb25maWcubmFtZSxcbiAgICAgIGlzRnVuYyA9IF9pc0Z1bmN0aW9uKGNvbmZpZyksXG4gICAgICBQbHVnaW4gPSBuYW1lICYmICFpc0Z1bmMgJiYgY29uZmlnLmluaXQgPyBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcHJvcHMgPSBbXTtcbiAgfSA6IGNvbmZpZyxcbiAgICAgIC8vaW4gY2FzZSBzb21lb25lIHBhc3NlcyBpbiBhbiBvYmplY3QgdGhhdCdzIG5vdCBhIHBsdWdpbiwgbGlrZSBDdXN0b21FYXNlXG4gIGluc3RhbmNlRGVmYXVsdHMgPSB7XG4gICAgaW5pdDogX2VtcHR5RnVuYyxcbiAgICByZW5kZXI6IF9yZW5kZXJQcm9wVHdlZW5zLFxuICAgIGFkZDogX2FkZFByb3BUd2VlbixcbiAgICBraWxsOiBfa2lsbFByb3BUd2VlbnNPZixcbiAgICBtb2RpZmllcjogX2FkZFBsdWdpbk1vZGlmaWVyLFxuICAgIHJhd1ZhcnM6IDBcbiAgfSxcbiAgICAgIHN0YXRpY3MgPSB7XG4gICAgdGFyZ2V0VGVzdDogMCxcbiAgICBnZXQ6IDAsXG4gICAgZ2V0U2V0dGVyOiBfZ2V0U2V0dGVyLFxuICAgIGFsaWFzZXM6IHt9LFxuICAgIHJlZ2lzdGVyOiAwXG4gIH07XG5cbiAgX3dha2UoKTtcblxuICBpZiAoY29uZmlnICE9PSBQbHVnaW4pIHtcbiAgICBpZiAoX3BsdWdpbnNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBfc2V0RGVmYXVsdHMoUGx1Z2luLCBfc2V0RGVmYXVsdHMoX2NvcHlFeGNsdWRpbmcoY29uZmlnLCBpbnN0YW5jZURlZmF1bHRzKSwgc3RhdGljcykpOyAvL3N0YXRpYyBtZXRob2RzXG5cblxuICAgIF9tZXJnZShQbHVnaW4ucHJvdG90eXBlLCBfbWVyZ2UoaW5zdGFuY2VEZWZhdWx0cywgX2NvcHlFeGNsdWRpbmcoY29uZmlnLCBzdGF0aWNzKSkpOyAvL2luc3RhbmNlIG1ldGhvZHNcblxuXG4gICAgX3BsdWdpbnNbUGx1Z2luLnByb3AgPSBuYW1lXSA9IFBsdWdpbjtcblxuICAgIGlmIChjb25maWcudGFyZ2V0VGVzdCkge1xuICAgICAgX2hhcm5lc3NQbHVnaW5zLnB1c2goUGx1Z2luKTtcblxuICAgICAgX3Jlc2VydmVkUHJvcHNbbmFtZV0gPSAxO1xuICAgIH1cblxuICAgIG5hbWUgPSAobmFtZSA9PT0gXCJjc3NcIiA/IFwiQ1NTXCIgOiBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zdWJzdHIoMSkpICsgXCJQbHVnaW5cIjsgLy9mb3IgdGhlIGdsb2JhbCBuYW1lLiBcIm1vdGlvblBhdGhcIiBzaG91bGQgYmVjb21lIE1vdGlvblBhdGhQbHVnaW5cbiAgfVxuXG4gIF9hZGRHbG9iYWwobmFtZSwgUGx1Z2luKTtcblxuICBpZiAoY29uZmlnLnJlZ2lzdGVyKSB7XG4gICAgY29uZmlnLnJlZ2lzdGVyKGdzYXAsIFBsdWdpbiwgUHJvcFR3ZWVuKTtcbiAgfVxufSxcblxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDT0xPUlNcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cbl8yNTUgPSAyNTUsXG4gICAgX2NvbG9yTG9va3VwID0ge1xuICBhcXVhOiBbMCwgXzI1NSwgXzI1NV0sXG4gIGxpbWU6IFswLCBfMjU1LCAwXSxcbiAgc2lsdmVyOiBbMTkyLCAxOTIsIDE5Ml0sXG4gIGJsYWNrOiBbMCwgMCwgMF0sXG4gIG1hcm9vbjogWzEyOCwgMCwgMF0sXG4gIHRlYWw6IFswLCAxMjgsIDEyOF0sXG4gIGJsdWU6IFswLCAwLCBfMjU1XSxcbiAgbmF2eTogWzAsIDAsIDEyOF0sXG4gIHdoaXRlOiBbXzI1NSwgXzI1NSwgXzI1NV0sXG4gIG9saXZlOiBbMTI4LCAxMjgsIDBdLFxuICB5ZWxsb3c6IFtfMjU1LCBfMjU1LCAwXSxcbiAgb3JhbmdlOiBbXzI1NSwgMTY1LCAwXSxcbiAgZ3JheTogWzEyOCwgMTI4LCAxMjhdLFxuICBwdXJwbGU6IFsxMjgsIDAsIDEyOF0sXG4gIGdyZWVuOiBbMCwgMTI4LCAwXSxcbiAgcmVkOiBbXzI1NSwgMCwgMF0sXG4gIHBpbms6IFtfMjU1LCAxOTIsIDIwM10sXG4gIGN5YW46IFswLCBfMjU1LCBfMjU1XSxcbiAgdHJhbnNwYXJlbnQ6IFtfMjU1LCBfMjU1LCBfMjU1LCAwXVxufSxcbiAgICBfaHVlID0gZnVuY3Rpb24gX2h1ZShoLCBtMSwgbTIpIHtcbiAgaCA9IGggPCAwID8gaCArIDEgOiBoID4gMSA/IGggLSAxIDogaDtcbiAgcmV0dXJuIChoICogNiA8IDEgPyBtMSArIChtMiAtIG0xKSAqIGggKiA2IDogaCA8IC41ID8gbTIgOiBoICogMyA8IDIgPyBtMSArIChtMiAtIG0xKSAqICgyIC8gMyAtIGgpICogNiA6IG0xKSAqIF8yNTUgKyAuNSB8IDA7XG59LFxuICAgIHNwbGl0Q29sb3IgPSBmdW5jdGlvbiBzcGxpdENvbG9yKHYsIHRvSFNMLCBmb3JjZUFscGhhKSB7XG4gIHZhciBhID0gIXYgPyBfY29sb3JMb29rdXAuYmxhY2sgOiBfaXNOdW1iZXIodikgPyBbdiA+PiAxNiwgdiA+PiA4ICYgXzI1NSwgdiAmIF8yNTVdIDogMCxcbiAgICAgIHIsXG4gICAgICBnLFxuICAgICAgYixcbiAgICAgIGgsXG4gICAgICBzLFxuICAgICAgbCxcbiAgICAgIG1heCxcbiAgICAgIG1pbixcbiAgICAgIGQsXG4gICAgICB3YXNIU0w7XG5cbiAgaWYgKCFhKSB7XG4gICAgaWYgKHYuc3Vic3RyKC0xKSA9PT0gXCIsXCIpIHtcbiAgICAgIC8vc29tZXRpbWVzIGEgdHJhaWxpbmcgY29tbWEgaXMgaW5jbHVkZWQgYW5kIHdlIHNob3VsZCBjaG9wIGl0IG9mZiAodHlwaWNhbGx5IGZyb20gYSBjb21tYS1kZWxpbWl0ZWQgbGlzdCBvZiB2YWx1ZXMgbGlrZSBhIHRleHRTaGFkb3c6XCIycHggMnB4IDJweCBibHVlLCA1cHggNXB4IDVweCByZ2IoMjU1LDAsMClcIiAtIGluIHRoaXMgZXhhbXBsZSBcImJsdWUsXCIgaGFzIGEgdHJhaWxpbmcgY29tbWEuIFdlIGNvdWxkIHN0cmlwIGl0IG91dCBpbnNpZGUgcGFyc2VDb21wbGV4KCkgYnV0IHdlJ2QgbmVlZCB0byBkbyBpdCB0byB0aGUgYmVnaW5uaW5nIGFuZCBlbmRpbmcgdmFsdWVzIHBsdXMgaXQgd291bGRuJ3QgcHJvdmlkZSBwcm90ZWN0aW9uIGZyb20gb3RoZXIgcG90ZW50aWFsIHNjZW5hcmlvcyBsaWtlIGlmIHRoZSB1c2VyIHBhc3NlcyBpbiBhIHNpbWlsYXIgdmFsdWUuXG4gICAgICB2ID0gdi5zdWJzdHIoMCwgdi5sZW5ndGggLSAxKTtcbiAgICB9XG5cbiAgICBpZiAoX2NvbG9yTG9va3VwW3ZdKSB7XG4gICAgICBhID0gX2NvbG9yTG9va3VwW3ZdO1xuICAgIH0gZWxzZSBpZiAodi5jaGFyQXQoMCkgPT09IFwiI1wiKSB7XG4gICAgICBpZiAodi5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgLy9mb3Igc2hvcnRoYW5kIGxpa2UgIzlGMFxuICAgICAgICByID0gdi5jaGFyQXQoMSk7XG4gICAgICAgIGcgPSB2LmNoYXJBdCgyKTtcbiAgICAgICAgYiA9IHYuY2hhckF0KDMpO1xuICAgICAgICB2ID0gXCIjXCIgKyByICsgciArIGcgKyBnICsgYiArIGI7XG4gICAgICB9XG5cbiAgICAgIHYgPSBwYXJzZUludCh2LnN1YnN0cigxKSwgMTYpO1xuICAgICAgYSA9IFt2ID4+IDE2LCB2ID4+IDggJiBfMjU1LCB2ICYgXzI1NV07XG4gICAgfSBlbHNlIGlmICh2LnN1YnN0cigwLCAzKSA9PT0gXCJoc2xcIikge1xuICAgICAgYSA9IHdhc0hTTCA9IHYubWF0Y2goX3N0cmljdE51bUV4cCk7XG5cbiAgICAgIGlmICghdG9IU0wpIHtcbiAgICAgICAgaCA9ICthWzBdICUgMzYwIC8gMzYwO1xuICAgICAgICBzID0gK2FbMV0gLyAxMDA7XG4gICAgICAgIGwgPSArYVsyXSAvIDEwMDtcbiAgICAgICAgZyA9IGwgPD0gLjUgPyBsICogKHMgKyAxKSA6IGwgKyBzIC0gbCAqIHM7XG4gICAgICAgIHIgPSBsICogMiAtIGc7XG5cbiAgICAgICAgaWYgKGEubGVuZ3RoID4gMykge1xuICAgICAgICAgIGFbM10gKj0gMTsgLy9jYXN0IGFzIG51bWJlclxuICAgICAgICB9XG5cbiAgICAgICAgYVswXSA9IF9odWUoaCArIDEgLyAzLCByLCBnKTtcbiAgICAgICAgYVsxXSA9IF9odWUoaCwgciwgZyk7XG4gICAgICAgIGFbMl0gPSBfaHVlKGggLSAxIC8gMywgciwgZyk7XG4gICAgICB9IGVsc2UgaWYgKH52LmluZGV4T2YoXCI9XCIpKSB7XG4gICAgICAgIC8vaWYgcmVsYXRpdmUgdmFsdWVzIGFyZSBmb3VuZCwganVzdCByZXR1cm4gdGhlIHJhdyBzdHJpbmdzIHdpdGggdGhlIHJlbGF0aXZlIHByZWZpeGVzIGluIHBsYWNlLlxuICAgICAgICBhID0gdi5tYXRjaChfbnVtRXhwKTtcbiAgICAgICAgZm9yY2VBbHBoYSAmJiBhLmxlbmd0aCA8IDQgJiYgKGFbM10gPSAxKTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSB2Lm1hdGNoKF9zdHJpY3ROdW1FeHApIHx8IF9jb2xvckxvb2t1cC50cmFuc3BhcmVudDtcbiAgICB9XG5cbiAgICBhID0gYS5tYXAoTnVtYmVyKTtcbiAgfVxuXG4gIGlmICh0b0hTTCAmJiAhd2FzSFNMKSB7XG4gICAgciA9IGFbMF0gLyBfMjU1O1xuICAgIGcgPSBhWzFdIC8gXzI1NTtcbiAgICBiID0gYVsyXSAvIF8yNTU7XG4gICAgbWF4ID0gTWF0aC5tYXgociwgZywgYik7XG4gICAgbWluID0gTWF0aC5taW4ociwgZywgYik7XG4gICAgbCA9IChtYXggKyBtaW4pIC8gMjtcblxuICAgIGlmIChtYXggPT09IG1pbikge1xuICAgICAgaCA9IHMgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBkID0gbWF4IC0gbWluO1xuICAgICAgcyA9IGwgPiAwLjUgPyBkIC8gKDIgLSBtYXggLSBtaW4pIDogZCAvIChtYXggKyBtaW4pO1xuICAgICAgaCA9IG1heCA9PT0gciA/IChnIC0gYikgLyBkICsgKGcgPCBiID8gNiA6IDApIDogbWF4ID09PSBnID8gKGIgLSByKSAvIGQgKyAyIDogKHIgLSBnKSAvIGQgKyA0O1xuICAgICAgaCAqPSA2MDtcbiAgICB9XG5cbiAgICBhWzBdID0gfn4oaCArIC41KTtcbiAgICBhWzFdID0gfn4ocyAqIDEwMCArIC41KTtcbiAgICBhWzJdID0gfn4obCAqIDEwMCArIC41KTtcbiAgfVxuXG4gIGZvcmNlQWxwaGEgJiYgYS5sZW5ndGggPCA0ICYmIChhWzNdID0gMSk7XG4gIHJldHVybiBhO1xufSxcbiAgICBfY29sb3JPcmRlckRhdGEgPSBmdW5jdGlvbiBfY29sb3JPcmRlckRhdGEodikge1xuICAvLyBzdHJpcHMgb3V0IHRoZSBjb2xvcnMgZnJvbSB0aGUgc3RyaW5nLCBmaW5kcyBhbGwgdGhlIG51bWVyaWMgc2xvdHMgKHdpdGggdW5pdHMpIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHRob3NlLiBUaGUgQXJyYXkgYWxzbyBoYXMgYSBcImNcIiBwcm9wZXJ0eSB3aGljaCBpcyBhbiBBcnJheSBvZiB0aGUgaW5kZXggdmFsdWVzIHdoZXJlIHRoZSBjb2xvcnMgYmVsb25nLiBUaGlzIGlzIHRvIGhlbHAgd29yayBhcm91bmQgaXNzdWVzIHdoZXJlIHRoZXJlJ3MgYSBtaXMtbWF0Y2hlZCBvcmRlciBvZiBjb2xvci9udW1lcmljIGRhdGEgbGlrZSBkcm9wLXNoYWRvdygjZjAwIDBweCAxcHggMnB4KSBhbmQgZHJvcC1zaGFkb3coMHggMXB4IDJweCAjZjAwKS4gVGhpcyBpcyBiYXNpY2FsbHkgYSBoZWxwZXIgZnVuY3Rpb24gdXNlZCBpbiBfZm9ybWF0Q29sb3JzKClcbiAgdmFyIHZhbHVlcyA9IFtdLFxuICAgICAgYyA9IFtdLFxuICAgICAgaSA9IC0xO1xuICB2LnNwbGl0KF9jb2xvckV4cCkuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgIHZhciBhID0gdi5tYXRjaChfbnVtV2l0aFVuaXRFeHApIHx8IFtdO1xuICAgIHZhbHVlcy5wdXNoLmFwcGx5KHZhbHVlcywgYSk7XG4gICAgYy5wdXNoKGkgKz0gYS5sZW5ndGggKyAxKTtcbiAgfSk7XG4gIHZhbHVlcy5jID0gYztcbiAgcmV0dXJuIHZhbHVlcztcbn0sXG4gICAgX2Zvcm1hdENvbG9ycyA9IGZ1bmN0aW9uIF9mb3JtYXRDb2xvcnMocywgdG9IU0wsIG9yZGVyTWF0Y2hEYXRhKSB7XG4gIHZhciByZXN1bHQgPSBcIlwiLFxuICAgICAgY29sb3JzID0gKHMgKyByZXN1bHQpLm1hdGNoKF9jb2xvckV4cCksXG4gICAgICB0eXBlID0gdG9IU0wgPyBcImhzbGEoXCIgOiBcInJnYmEoXCIsXG4gICAgICBpID0gMCxcbiAgICAgIGMsXG4gICAgICBzaGVsbCxcbiAgICAgIGQsXG4gICAgICBsO1xuXG4gIGlmICghY29sb3JzKSB7XG4gICAgcmV0dXJuIHM7XG4gIH1cblxuICBjb2xvcnMgPSBjb2xvcnMubWFwKGZ1bmN0aW9uIChjb2xvcikge1xuICAgIHJldHVybiAoY29sb3IgPSBzcGxpdENvbG9yKGNvbG9yLCB0b0hTTCwgMSkpICYmIHR5cGUgKyAodG9IU0wgPyBjb2xvclswXSArIFwiLFwiICsgY29sb3JbMV0gKyBcIiUsXCIgKyBjb2xvclsyXSArIFwiJSxcIiArIGNvbG9yWzNdIDogY29sb3Iuam9pbihcIixcIikpICsgXCIpXCI7XG4gIH0pO1xuXG4gIGlmIChvcmRlck1hdGNoRGF0YSkge1xuICAgIGQgPSBfY29sb3JPcmRlckRhdGEocyk7XG4gICAgYyA9IG9yZGVyTWF0Y2hEYXRhLmM7XG5cbiAgICBpZiAoYy5qb2luKHJlc3VsdCkgIT09IGQuYy5qb2luKHJlc3VsdCkpIHtcbiAgICAgIHNoZWxsID0gcy5yZXBsYWNlKF9jb2xvckV4cCwgXCIxXCIpLnNwbGl0KF9udW1XaXRoVW5pdEV4cCk7XG4gICAgICBsID0gc2hlbGwubGVuZ3RoIC0gMTtcblxuICAgICAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ICs9IHNoZWxsW2ldICsgKH5jLmluZGV4T2YoaSkgPyBjb2xvcnMuc2hpZnQoKSB8fCB0eXBlICsgXCIwLDAsMCwwKVwiIDogKGQubGVuZ3RoID8gZCA6IGNvbG9ycy5sZW5ndGggPyBjb2xvcnMgOiBvcmRlck1hdGNoRGF0YSkuc2hpZnQoKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKCFzaGVsbCkge1xuICAgIHNoZWxsID0gcy5zcGxpdChfY29sb3JFeHApO1xuICAgIGwgPSBzaGVsbC5sZW5ndGggLSAxO1xuXG4gICAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJlc3VsdCArPSBzaGVsbFtpXSArIGNvbG9yc1tpXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0ICsgc2hlbGxbbF07XG59LFxuICAgIF9jb2xvckV4cCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHMgPSBcIig/OlxcXFxiKD86KD86cmdifHJnYmF8aHNsfGhzbGEpXFxcXCguKz9cXFxcKSl8XFxcXEIjKD86WzAtOWEtZl17M30pezEsMn1cXFxcYlwiLFxuICAgICAgLy93ZSdsbCBkeW5hbWljYWxseSBidWlsZCB0aGlzIFJlZ3VsYXIgRXhwcmVzc2lvbiB0byBjb25zZXJ2ZSBmaWxlIHNpemUuIEFmdGVyIGJ1aWxkaW5nIGl0LCBpdCB3aWxsIGJlIGFibGUgdG8gZmluZCByZ2IoKSwgcmdiYSgpLCAjIChoZXhhZGVjaW1hbCksIGFuZCBuYW1lZCBjb2xvciB2YWx1ZXMgbGlrZSByZWQsIGJsdWUsIHB1cnBsZSwgZXRjLixcbiAgcDtcblxuICBmb3IgKHAgaW4gX2NvbG9yTG9va3VwKSB7XG4gICAgcyArPSBcInxcIiArIHAgKyBcIlxcXFxiXCI7XG4gIH1cblxuICByZXR1cm4gbmV3IFJlZ0V4cChzICsgXCIpXCIsIFwiZ2lcIik7XG59KCksXG4gICAgX2hzbEV4cCA9IC9oc2xbYV0/XFwoLyxcbiAgICBfY29sb3JTdHJpbmdGaWx0ZXIgPSBmdW5jdGlvbiBfY29sb3JTdHJpbmdGaWx0ZXIoYSkge1xuICB2YXIgY29tYmluZWQgPSBhLmpvaW4oXCIgXCIpLFxuICAgICAgdG9IU0w7XG4gIF9jb2xvckV4cC5sYXN0SW5kZXggPSAwO1xuXG4gIGlmIChfY29sb3JFeHAudGVzdChjb21iaW5lZCkpIHtcbiAgICB0b0hTTCA9IF9oc2xFeHAudGVzdChjb21iaW5lZCk7XG4gICAgYVsxXSA9IF9mb3JtYXRDb2xvcnMoYVsxXSwgdG9IU0wpO1xuICAgIGFbMF0gPSBfZm9ybWF0Q29sb3JzKGFbMF0sIHRvSFNMLCBfY29sb3JPcmRlckRhdGEoYVsxXSkpOyAvLyBtYWtlIHN1cmUgdGhlIG9yZGVyIG9mIG51bWJlcnMvY29sb3JzIG1hdGNoIHdpdGggdGhlIEVORCB2YWx1ZS5cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG59LFxuXG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFRJQ0tFUlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuX3RpY2tlckFjdGl2ZSxcbiAgICBfdGlja2VyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgX2dldFRpbWUgPSBEYXRlLm5vdyxcbiAgICAgIF9sYWdUaHJlc2hvbGQgPSA1MDAsXG4gICAgICBfYWRqdXN0ZWRMYWcgPSAzMyxcbiAgICAgIF9zdGFydFRpbWUgPSBfZ2V0VGltZSgpLFxuICAgICAgX2xhc3RVcGRhdGUgPSBfc3RhcnRUaW1lLFxuICAgICAgX2dhcCA9IDEgLyAyNDAsXG4gICAgICBfbmV4dFRpbWUgPSBfZ2FwLFxuICAgICAgX2xpc3RlbmVycyA9IFtdLFxuICAgICAgX2lkLFxuICAgICAgX3JlcSxcbiAgICAgIF9yYWYsXG4gICAgICBfc2VsZixcbiAgICAgIF90aWNrID0gZnVuY3Rpb24gX3RpY2sodikge1xuICAgIHZhciBlbGFwc2VkID0gX2dldFRpbWUoKSAtIF9sYXN0VXBkYXRlLFxuICAgICAgICBtYW51YWwgPSB2ID09PSB0cnVlLFxuICAgICAgICBvdmVybGFwLFxuICAgICAgICBkaXNwYXRjaDtcblxuICAgIGlmIChlbGFwc2VkID4gX2xhZ1RocmVzaG9sZCkge1xuICAgICAgX3N0YXJ0VGltZSArPSBlbGFwc2VkIC0gX2FkanVzdGVkTGFnO1xuICAgIH1cblxuICAgIF9sYXN0VXBkYXRlICs9IGVsYXBzZWQ7XG4gICAgX3NlbGYudGltZSA9IChfbGFzdFVwZGF0ZSAtIF9zdGFydFRpbWUpIC8gMTAwMDtcbiAgICBvdmVybGFwID0gX3NlbGYudGltZSAtIF9uZXh0VGltZTtcblxuICAgIGlmIChvdmVybGFwID4gMCB8fCBtYW51YWwpIHtcbiAgICAgIF9zZWxmLmZyYW1lKys7XG4gICAgICBfbmV4dFRpbWUgKz0gb3ZlcmxhcCArIChvdmVybGFwID49IF9nYXAgPyAwLjAwNCA6IF9nYXAgLSBvdmVybGFwKTtcbiAgICAgIGRpc3BhdGNoID0gMTtcbiAgICB9XG5cbiAgICBtYW51YWwgfHwgKF9pZCA9IF9yZXEoX3RpY2spKTsgLy9tYWtlIHN1cmUgdGhlIHJlcXVlc3QgaXMgbWFkZSBiZWZvcmUgd2UgZGlzcGF0Y2ggdGhlIFwidGlja1wiIGV2ZW50IHNvIHRoYXQgdGltaW5nIGlzIG1haW50YWluZWQuIE90aGVyd2lzZSwgaWYgcHJvY2Vzc2luZyB0aGUgXCJ0aWNrXCIgcmVxdWlyZXMgYSBidW5jaCBvZiB0aW1lIChsaWtlIDE1bXMpIGFuZCB3ZSdyZSB1c2luZyBhIHNldFRpbWVvdXQoKSB0aGF0J3MgYmFzZWQgb24gMTYuN21zLCBpdCdkIHRlY2huaWNhbGx5IHRha2UgMzEuN21zIGJldHdlZW4gZnJhbWVzIG90aGVyd2lzZS5cblxuICAgIGRpc3BhdGNoICYmIF9saXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobCkge1xuICAgICAgcmV0dXJuIGwoX3NlbGYudGltZSwgZWxhcHNlZCwgX3NlbGYuZnJhbWUsIHYpO1xuICAgIH0pO1xuICB9O1xuXG4gIF9zZWxmID0ge1xuICAgIHRpbWU6IDAsXG4gICAgZnJhbWU6IDAsXG4gICAgdGljazogZnVuY3Rpb24gdGljaygpIHtcbiAgICAgIF90aWNrKHRydWUpO1xuICAgIH0sXG4gICAgd2FrZTogZnVuY3Rpb24gd2FrZSgpIHtcbiAgICAgIGlmIChfY29yZVJlYWR5KSB7XG4gICAgICAgIGlmICghX2NvcmVJbml0dGVkICYmIF93aW5kb3dFeGlzdHMoKSkge1xuICAgICAgICAgIF93aW4gPSBfY29yZUluaXR0ZWQgPSB3aW5kb3c7XG4gICAgICAgICAgX2RvYyA9IF93aW4uZG9jdW1lbnQgfHwge307XG4gICAgICAgICAgX2dsb2JhbHMuZ3NhcCA9IGdzYXA7XG4gICAgICAgICAgKF93aW4uZ3NhcFZlcnNpb25zIHx8IChfd2luLmdzYXBWZXJzaW9ucyA9IFtdKSkucHVzaChnc2FwLnZlcnNpb24pO1xuXG4gICAgICAgICAgX2luc3RhbGwoX2luc3RhbGxTY29wZSB8fCBfd2luLkdyZWVuU29ja0dsb2JhbHMgfHwgIV93aW4uZ3NhcCAmJiBfd2luIHx8IHt9KTtcblxuICAgICAgICAgIF9yYWYgPSBfd2luLnJlcXVlc3RBbmltYXRpb25GcmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9pZCAmJiBfc2VsZi5zbGVlcCgpO1xuXG4gICAgICAgIF9yZXEgPSBfcmFmIHx8IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZiwgKF9uZXh0VGltZSAtIF9zZWxmLnRpbWUpICogMTAwMCArIDEgfCAwKTtcbiAgICAgICAgfTtcblxuICAgICAgICBfdGlja2VyQWN0aXZlID0gMTtcblxuICAgICAgICBfdGljaygyKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNsZWVwOiBmdW5jdGlvbiBzbGVlcCgpIHtcbiAgICAgIChfcmFmID8gX3dpbi5jYW5jZWxBbmltYXRpb25GcmFtZSA6IGNsZWFyVGltZW91dCkoX2lkKTtcbiAgICAgIF90aWNrZXJBY3RpdmUgPSAwO1xuICAgICAgX3JlcSA9IF9lbXB0eUZ1bmM7XG4gICAgfSxcbiAgICBsYWdTbW9vdGhpbmc6IGZ1bmN0aW9uIGxhZ1Ntb290aGluZyh0aHJlc2hvbGQsIGFkanVzdGVkTGFnKSB7XG4gICAgICBfbGFnVGhyZXNob2xkID0gdGhyZXNob2xkIHx8IDEgLyBfdGlueU51bTsgLy96ZXJvIHNob3VsZCBiZSBpbnRlcnByZXRlZCBhcyBiYXNpY2FsbHkgdW5saW1pdGVkXG5cbiAgICAgIF9hZGp1c3RlZExhZyA9IE1hdGgubWluKGFkanVzdGVkTGFnLCBfbGFnVGhyZXNob2xkLCAwKTtcbiAgICB9LFxuICAgIGZwczogZnVuY3Rpb24gZnBzKF9mcHMpIHtcbiAgICAgIF9nYXAgPSAxIC8gKF9mcHMgfHwgMjQwKTtcbiAgICAgIF9uZXh0VGltZSA9IF9zZWxmLnRpbWUgKyBfZ2FwO1xuICAgIH0sXG4gICAgYWRkOiBmdW5jdGlvbiBhZGQoY2FsbGJhY2spIHtcbiAgICAgIF9saXN0ZW5lcnMuaW5kZXhPZihjYWxsYmFjaykgPCAwICYmIF9saXN0ZW5lcnMucHVzaChjYWxsYmFjayk7XG5cbiAgICAgIF93YWtlKCk7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShjYWxsYmFjaykge1xuICAgICAgdmFyIGk7XG4gICAgICB+KGkgPSBfbGlzdGVuZXJzLmluZGV4T2YoY2FsbGJhY2spKSAmJiBfbGlzdGVuZXJzLnNwbGljZShpLCAxKTtcbiAgICB9LFxuICAgIF9saXN0ZW5lcnM6IF9saXN0ZW5lcnNcbiAgfTtcbiAgcmV0dXJuIF9zZWxmO1xufSgpLFxuICAgIF93YWtlID0gZnVuY3Rpb24gX3dha2UoKSB7XG4gIHJldHVybiAhX3RpY2tlckFjdGl2ZSAmJiBfdGlja2VyLndha2UoKTtcbn0sXG4gICAgLy9hbHNvIGVuc3VyZXMgdGhlIGNvcmUgY2xhc3NlcyBhcmUgaW5pdGlhbGl6ZWQuXG5cbi8qXG4qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiogRUFTSU5HXG4qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiovXG5fZWFzZU1hcCA9IHt9LFxuICAgIF9jdXN0b21FYXNlRXhwID0gL15bXFxkLlxcLU1dW1xcZC5cXC0sXFxzXS8sXG4gICAgX3F1b3Rlc0V4cCA9IC9bXCInXS9nLFxuICAgIF9wYXJzZU9iamVjdEluU3RyaW5nID0gZnVuY3Rpb24gX3BhcnNlT2JqZWN0SW5TdHJpbmcodmFsdWUpIHtcbiAgLy90YWtlcyBhIHN0cmluZyBsaWtlIFwie3dpZ2dsZXM6MTAsIHR5cGU6YW50aWNpcGF0ZX0pXCIgYW5kIHR1cm5zIGl0IGludG8gYSByZWFsIG9iamVjdC4gTm90aWNlIGl0IGVuZHMgaW4gXCIpXCIgYW5kIGluY2x1ZGVzIHRoZSB7fSB3cmFwcGVycy4gVGhpcyBpcyBiZWNhdXNlIHdlIG9ubHkgdXNlIHRoaXMgZnVuY3Rpb24gZm9yIHBhcnNpbmcgZWFzZSBjb25maWdzIGFuZCBwcmlvcml0aXplZCBvcHRpbWl6YXRpb24gcmF0aGVyIHRoYW4gcmV1c2FiaWxpdHkuXG4gIHZhciBvYmogPSB7fSxcbiAgICAgIHNwbGl0ID0gdmFsdWUuc3Vic3RyKDEsIHZhbHVlLmxlbmd0aCAtIDMpLnNwbGl0KFwiOlwiKSxcbiAgICAgIGtleSA9IHNwbGl0WzBdLFxuICAgICAgaSA9IDEsXG4gICAgICBsID0gc3BsaXQubGVuZ3RoLFxuICAgICAgaW5kZXgsXG4gICAgICB2YWwsXG4gICAgICBwYXJzZWRWYWw7XG5cbiAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICB2YWwgPSBzcGxpdFtpXTtcbiAgICBpbmRleCA9IGkgIT09IGwgLSAxID8gdmFsLmxhc3RJbmRleE9mKFwiLFwiKSA6IHZhbC5sZW5ndGg7XG4gICAgcGFyc2VkVmFsID0gdmFsLnN1YnN0cigwLCBpbmRleCk7XG4gICAgb2JqW2tleV0gPSBpc05hTihwYXJzZWRWYWwpID8gcGFyc2VkVmFsLnJlcGxhY2UoX3F1b3Rlc0V4cCwgXCJcIikudHJpbSgpIDogK3BhcnNlZFZhbDtcbiAgICBrZXkgPSB2YWwuc3Vic3RyKGluZGV4ICsgMSkudHJpbSgpO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn0sXG4gICAgX2NvbmZpZ0Vhc2VGcm9tU3RyaW5nID0gZnVuY3Rpb24gX2NvbmZpZ0Vhc2VGcm9tU3RyaW5nKG5hbWUpIHtcbiAgLy9uYW1lIGNhbiBiZSBhIHN0cmluZyBsaWtlIFwiZWxhc3RpYy5vdXQoMSwwLjUpXCIsIGFuZCBwYXNzIGluIF9lYXNlTWFwIGFzIG9iaiBhbmQgaXQnbGwgcGFyc2UgaXQgb3V0IGFuZCBjYWxsIHRoZSBhY3R1YWwgZnVuY3Rpb24gbGlrZSBfZWFzZU1hcC5FbGFzdGljLmVhc2VPdXQuY29uZmlnKDEsMC41KS4gSXQgd2lsbCBhbHNvIHBhcnNlIGN1c3RvbSBlYXNlIHN0cmluZ3MgYXMgbG9uZyBhcyBDdXN0b21FYXNlIGlzIGxvYWRlZCBhbmQgcmVnaXN0ZXJlZCAoaW50ZXJuYWxseSBhcyBfZWFzZU1hcC5fQ0UpLlxuICB2YXIgc3BsaXQgPSAobmFtZSArIFwiXCIpLnNwbGl0KFwiKFwiKSxcbiAgICAgIGVhc2UgPSBfZWFzZU1hcFtzcGxpdFswXV07XG4gIHJldHVybiBlYXNlICYmIHNwbGl0Lmxlbmd0aCA+IDEgJiYgZWFzZS5jb25maWcgPyBlYXNlLmNvbmZpZy5hcHBseShudWxsLCB+bmFtZS5pbmRleE9mKFwie1wiKSA/IFtfcGFyc2VPYmplY3RJblN0cmluZyhzcGxpdFsxXSldIDogX3BhcmVudGhlc2VzRXhwLmV4ZWMobmFtZSlbMV0uc3BsaXQoXCIsXCIpLm1hcChfbnVtZXJpY0lmUG9zc2libGUpKSA6IF9lYXNlTWFwLl9DRSAmJiBfY3VzdG9tRWFzZUV4cC50ZXN0KG5hbWUpID8gX2Vhc2VNYXAuX0NFKFwiXCIsIG5hbWUpIDogZWFzZTtcbn0sXG4gICAgX2ludmVydEVhc2UgPSBmdW5jdGlvbiBfaW52ZXJ0RWFzZShlYXNlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiAxIC0gZWFzZSgxIC0gcCk7XG4gIH07XG59LFxuICAgIC8vIGFsbG93IHlveW9FYXNlIHRvIGJlIHNldCBpbiBjaGlsZHJlbiBhbmQgaGF2ZSB0aG9zZSBhZmZlY3RlZCB3aGVuIHRoZSBwYXJlbnQvYW5jZXN0b3IgdGltZWxpbmUgeW95b3MuXG5fcHJvcGFnYXRlWW95b0Vhc2UgPSBmdW5jdGlvbiBfcHJvcGFnYXRlWW95b0Vhc2UodGltZWxpbmUsIGlzWW95bykge1xuICB2YXIgY2hpbGQgPSB0aW1lbGluZS5fZmlyc3QsXG4gICAgICBlYXNlO1xuXG4gIHdoaWxlIChjaGlsZCkge1xuICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIFRpbWVsaW5lKSB7XG4gICAgICBfcHJvcGFnYXRlWW95b0Vhc2UoY2hpbGQsIGlzWW95byk7XG4gICAgfSBlbHNlIGlmIChjaGlsZC52YXJzLnlveW9FYXNlICYmICghY2hpbGQuX3lveW8gfHwgIWNoaWxkLl9yZXBlYXQpICYmIGNoaWxkLl95b3lvICE9PSBpc1lveW8pIHtcbiAgICAgIGlmIChjaGlsZC50aW1lbGluZSkge1xuICAgICAgICBfcHJvcGFnYXRlWW95b0Vhc2UoY2hpbGQudGltZWxpbmUsIGlzWW95byk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlYXNlID0gY2hpbGQuX2Vhc2U7XG4gICAgICAgIGNoaWxkLl9lYXNlID0gY2hpbGQuX3lFYXNlO1xuICAgICAgICBjaGlsZC5feUVhc2UgPSBlYXNlO1xuICAgICAgICBjaGlsZC5feW95byA9IGlzWW95bztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjaGlsZCA9IGNoaWxkLl9uZXh0O1xuICB9XG59LFxuICAgIF9wYXJzZUVhc2UgPSBmdW5jdGlvbiBfcGFyc2VFYXNlKGVhc2UsIGRlZmF1bHRFYXNlKSB7XG4gIHJldHVybiAhZWFzZSA/IGRlZmF1bHRFYXNlIDogKF9pc0Z1bmN0aW9uKGVhc2UpID8gZWFzZSA6IF9lYXNlTWFwW2Vhc2VdIHx8IF9jb25maWdFYXNlRnJvbVN0cmluZyhlYXNlKSkgfHwgZGVmYXVsdEVhc2U7XG59LFxuICAgIF9pbnNlcnRFYXNlID0gZnVuY3Rpb24gX2luc2VydEVhc2UobmFtZXMsIGVhc2VJbiwgZWFzZU91dCwgZWFzZUluT3V0KSB7XG4gIGlmIChlYXNlT3V0ID09PSB2b2lkIDApIHtcbiAgICBlYXNlT3V0ID0gZnVuY3Rpb24gZWFzZU91dChwKSB7XG4gICAgICByZXR1cm4gMSAtIGVhc2VJbigxIC0gcCk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChlYXNlSW5PdXQgPT09IHZvaWQgMCkge1xuICAgIGVhc2VJbk91dCA9IGZ1bmN0aW9uIGVhc2VJbk91dChwKSB7XG4gICAgICByZXR1cm4gcCA8IC41ID8gZWFzZUluKHAgKiAyKSAvIDIgOiAxIC0gZWFzZUluKCgxIC0gcCkgKiAyKSAvIDI7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBlYXNlID0ge1xuICAgIGVhc2VJbjogZWFzZUluLFxuICAgIGVhc2VPdXQ6IGVhc2VPdXQsXG4gICAgZWFzZUluT3V0OiBlYXNlSW5PdXRcbiAgfSxcbiAgICAgIGxvd2VyY2FzZU5hbWU7XG5cbiAgX2ZvckVhY2hOYW1lKG5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIF9lYXNlTWFwW25hbWVdID0gX2dsb2JhbHNbbmFtZV0gPSBlYXNlO1xuICAgIF9lYXNlTWFwW2xvd2VyY2FzZU5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCldID0gZWFzZU91dDtcblxuICAgIGZvciAodmFyIHAgaW4gZWFzZSkge1xuICAgICAgX2Vhc2VNYXBbbG93ZXJjYXNlTmFtZSArIChwID09PSBcImVhc2VJblwiID8gXCIuaW5cIiA6IHAgPT09IFwiZWFzZU91dFwiID8gXCIub3V0XCIgOiBcIi5pbk91dFwiKV0gPSBfZWFzZU1hcFtuYW1lICsgXCIuXCIgKyBwXSA9IGVhc2VbcF07XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZWFzZTtcbn0sXG4gICAgX2Vhc2VJbk91dEZyb21PdXQgPSBmdW5jdGlvbiBfZWFzZUluT3V0RnJvbU91dChlYXNlT3V0KSB7XG4gIHJldHVybiBmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiBwIDwgLjUgPyAoMSAtIGVhc2VPdXQoMSAtIHAgKiAyKSkgLyAyIDogLjUgKyBlYXNlT3V0KChwIC0gLjUpICogMikgLyAyO1xuICB9O1xufSxcbiAgICBfY29uZmlnRWxhc3RpYyA9IGZ1bmN0aW9uIF9jb25maWdFbGFzdGljKHR5cGUsIGFtcGxpdHVkZSwgcGVyaW9kKSB7XG4gIHZhciBwMSA9IGFtcGxpdHVkZSA+PSAxID8gYW1wbGl0dWRlIDogMSxcbiAgICAgIC8vbm90ZTogaWYgYW1wbGl0dWRlIGlzIDwgMSwgd2Ugc2ltcGx5IGFkanVzdCB0aGUgcGVyaW9kIGZvciBhIG1vcmUgbmF0dXJhbCBmZWVsLiBPdGhlcndpc2UgdGhlIG1hdGggZG9lc24ndCB3b3JrIHJpZ2h0IGFuZCB0aGUgY3VydmUgc3RhcnRzIGF0IDEuXG4gIHAyID0gKHBlcmlvZCB8fCAodHlwZSA/IC4zIDogLjQ1KSkgLyAoYW1wbGl0dWRlIDwgMSA/IGFtcGxpdHVkZSA6IDEpLFxuICAgICAgcDMgPSBwMiAvIF8yUEkgKiAoTWF0aC5hc2luKDEgLyBwMSkgfHwgMCksXG4gICAgICBlYXNlT3V0ID0gZnVuY3Rpb24gZWFzZU91dChwKSB7XG4gICAgcmV0dXJuIHAgPT09IDEgPyAxIDogcDEgKiBNYXRoLnBvdygyLCAtMTAgKiBwKSAqIF9zaW4oKHAgLSBwMykgKiBwMikgKyAxO1xuICB9LFxuICAgICAgZWFzZSA9IHR5cGUgPT09IFwib3V0XCIgPyBlYXNlT3V0IDogdHlwZSA9PT0gXCJpblwiID8gZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gMSAtIGVhc2VPdXQoMSAtIHApO1xuICB9IDogX2Vhc2VJbk91dEZyb21PdXQoZWFzZU91dCk7XG5cbiAgcDIgPSBfMlBJIC8gcDI7IC8vcHJlY2FsY3VsYXRlIHRvIG9wdGltaXplXG5cbiAgZWFzZS5jb25maWcgPSBmdW5jdGlvbiAoYW1wbGl0dWRlLCBwZXJpb2QpIHtcbiAgICByZXR1cm4gX2NvbmZpZ0VsYXN0aWModHlwZSwgYW1wbGl0dWRlLCBwZXJpb2QpO1xuICB9O1xuXG4gIHJldHVybiBlYXNlO1xufSxcbiAgICBfY29uZmlnQmFjayA9IGZ1bmN0aW9uIF9jb25maWdCYWNrKHR5cGUsIG92ZXJzaG9vdCkge1xuICBpZiAob3ZlcnNob290ID09PSB2b2lkIDApIHtcbiAgICBvdmVyc2hvb3QgPSAxLjcwMTU4O1xuICB9XG5cbiAgdmFyIGVhc2VPdXQgPSBmdW5jdGlvbiBlYXNlT3V0KHApIHtcbiAgICByZXR1cm4gcCA/IC0tcCAqIHAgKiAoKG92ZXJzaG9vdCArIDEpICogcCArIG92ZXJzaG9vdCkgKyAxIDogMDtcbiAgfSxcbiAgICAgIGVhc2UgPSB0eXBlID09PSBcIm91dFwiID8gZWFzZU91dCA6IHR5cGUgPT09IFwiaW5cIiA/IGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIDEgLSBlYXNlT3V0KDEgLSBwKTtcbiAgfSA6IF9lYXNlSW5PdXRGcm9tT3V0KGVhc2VPdXQpO1xuXG4gIGVhc2UuY29uZmlnID0gZnVuY3Rpb24gKG92ZXJzaG9vdCkge1xuICAgIHJldHVybiBfY29uZmlnQmFjayh0eXBlLCBvdmVyc2hvb3QpO1xuICB9O1xuXG4gIHJldHVybiBlYXNlO1xufTsgLy8gYSBjaGVhcGVyIChrYiBhbmQgY3B1KSBidXQgbW9yZSBtaWxkIHdheSB0byBnZXQgYSBwYXJhbWV0ZXJpemVkIHdlaWdodGVkIGVhc2UgYnkgZmVlZGluZyBpbiBhIHZhbHVlIGJldHdlZW4gLTEgKGVhc2VJbikgYW5kIDEgKGVhc2VPdXQpIHdoZXJlIDAgaXMgbGluZWFyLlxuLy8gX3dlaWdodGVkRWFzZSA9IHJhdGlvID0+IHtcbi8vIFx0bGV0IHkgPSAwLjUgKyByYXRpbyAvIDI7XG4vLyBcdHJldHVybiBwID0+ICgyICogKDEgLSBwKSAqIHAgKiB5ICsgcCAqIHApO1xuLy8gfSxcbi8vIGEgc3Ryb25nZXIgKGJ1dCBtb3JlIGV4cGVuc2l2ZSBrYi9jcHUpIHBhcmFtZXRlcml6ZWQgd2VpZ2h0ZWQgZWFzZSB0aGF0IGxldHMgeW91IGZlZWQgaW4gYSB2YWx1ZSBiZXR3ZWVuIC0xIChlYXNlSW4pIGFuZCAxIChlYXNlT3V0KSB3aGVyZSAwIGlzIGxpbmVhci5cbi8vIF93ZWlnaHRlZEVhc2VTdHJvbmcgPSByYXRpbyA9PiB7XG4vLyBcdHJhdGlvID0gLjUgKyByYXRpbyAvIDI7XG4vLyBcdGxldCBvID0gMSAvIDMgKiAocmF0aW8gPCAuNSA/IHJhdGlvIDogMSAtIHJhdGlvKSxcbi8vIFx0XHRiID0gcmF0aW8gLSBvLFxuLy8gXHRcdGMgPSByYXRpbyArIG87XG4vLyBcdHJldHVybiBwID0+IHAgPT09IDEgPyBwIDogMyAqIGIgKiAoMSAtIHApICogKDEgLSBwKSAqIHAgKyAzICogYyAqICgxIC0gcCkgKiBwICogcCArIHAgKiBwICogcDtcbi8vIH07XG5cblxuX2ZvckVhY2hOYW1lKFwiTGluZWFyLFF1YWQsQ3ViaWMsUXVhcnQsUXVpbnQsU3Ryb25nXCIsIGZ1bmN0aW9uIChuYW1lLCBpKSB7XG4gIHZhciBwb3dlciA9IGkgPCA1ID8gaSArIDEgOiBpO1xuXG4gIF9pbnNlcnRFYXNlKG5hbWUgKyBcIixQb3dlclwiICsgKHBvd2VyIC0gMSksIGkgPyBmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiBNYXRoLnBvdyhwLCBwb3dlcik7XG4gIH0gOiBmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiBwO1xuICB9LCBmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiAxIC0gTWF0aC5wb3coMSAtIHAsIHBvd2VyKTtcbiAgfSwgZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gcCA8IC41ID8gTWF0aC5wb3cocCAqIDIsIHBvd2VyKSAvIDIgOiAxIC0gTWF0aC5wb3coKDEgLSBwKSAqIDIsIHBvd2VyKSAvIDI7XG4gIH0pO1xufSk7XG5cbl9lYXNlTWFwLkxpbmVhci5lYXNlTm9uZSA9IF9lYXNlTWFwLm5vbmUgPSBfZWFzZU1hcC5MaW5lYXIuZWFzZUluO1xuXG5faW5zZXJ0RWFzZShcIkVsYXN0aWNcIiwgX2NvbmZpZ0VsYXN0aWMoXCJpblwiKSwgX2NvbmZpZ0VsYXN0aWMoXCJvdXRcIiksIF9jb25maWdFbGFzdGljKCkpO1xuXG4oZnVuY3Rpb24gKG4sIGMpIHtcbiAgdmFyIG4xID0gMSAvIGMsXG4gICAgICBuMiA9IDIgKiBuMSxcbiAgICAgIG4zID0gMi41ICogbjEsXG4gICAgICBlYXNlT3V0ID0gZnVuY3Rpb24gZWFzZU91dChwKSB7XG4gICAgcmV0dXJuIHAgPCBuMSA/IG4gKiBwICogcCA6IHAgPCBuMiA/IG4gKiBNYXRoLnBvdyhwIC0gMS41IC8gYywgMikgKyAuNzUgOiBwIDwgbjMgPyBuICogKHAgLT0gMi4yNSAvIGMpICogcCArIC45Mzc1IDogbiAqIE1hdGgucG93KHAgLSAyLjYyNSAvIGMsIDIpICsgLjk4NDM3NTtcbiAgfTtcblxuICBfaW5zZXJ0RWFzZShcIkJvdW5jZVwiLCBmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiAxIC0gZWFzZU91dCgxIC0gcCk7XG4gIH0sIGVhc2VPdXQpO1xufSkoNy41NjI1LCAyLjc1KTtcblxuX2luc2VydEVhc2UoXCJFeHBvXCIsIGZ1bmN0aW9uIChwKSB7XG4gIHJldHVybiBwID8gTWF0aC5wb3coMiwgMTAgKiAocCAtIDEpKSA6IDA7XG59KTtcblxuX2luc2VydEVhc2UoXCJDaXJjXCIsIGZ1bmN0aW9uIChwKSB7XG4gIHJldHVybiAtKF9zcXJ0KDEgLSBwICogcCkgLSAxKTtcbn0pO1xuXG5faW5zZXJ0RWFzZShcIlNpbmVcIiwgZnVuY3Rpb24gKHApIHtcbiAgcmV0dXJuIHAgPT09IDEgPyAxIDogLV9jb3MocCAqIF9IQUxGX1BJKSArIDE7XG59KTtcblxuX2luc2VydEVhc2UoXCJCYWNrXCIsIF9jb25maWdCYWNrKFwiaW5cIiksIF9jb25maWdCYWNrKFwib3V0XCIpLCBfY29uZmlnQmFjaygpKTtcblxuX2Vhc2VNYXAuU3RlcHBlZEVhc2UgPSBfZWFzZU1hcC5zdGVwcyA9IF9nbG9iYWxzLlN0ZXBwZWRFYXNlID0ge1xuICBjb25maWc6IGZ1bmN0aW9uIGNvbmZpZyhzdGVwcywgaW1tZWRpYXRlU3RhcnQpIHtcbiAgICBpZiAoc3RlcHMgPT09IHZvaWQgMCkge1xuICAgICAgc3RlcHMgPSAxO1xuICAgIH1cblxuICAgIHZhciBwMSA9IDEgLyBzdGVwcyxcbiAgICAgICAgcDIgPSBzdGVwcyArIChpbW1lZGlhdGVTdGFydCA/IDAgOiAxKSxcbiAgICAgICAgcDMgPSBpbW1lZGlhdGVTdGFydCA/IDEgOiAwLFxuICAgICAgICBtYXggPSAxIC0gX3RpbnlOdW07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwKSB7XG4gICAgICByZXR1cm4gKChwMiAqIF9jbGFtcCgwLCBtYXgsIHApIHwgMCkgKyBwMykgKiBwMTtcbiAgICB9O1xuICB9XG59O1xuX2RlZmF1bHRzLmVhc2UgPSBfZWFzZU1hcFtcInF1YWQub3V0XCJdO1xuXG5fZm9yRWFjaE5hbWUoXCJvbkNvbXBsZXRlLG9uVXBkYXRlLG9uU3RhcnQsb25SZXBlYXQsb25SZXZlcnNlQ29tcGxldGUsb25JbnRlcnJ1cHRcIiwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIF9jYWxsYmFja05hbWVzICs9IG5hbWUgKyBcIixcIiArIG5hbWUgKyBcIlBhcmFtcyxcIjtcbn0pO1xuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDQUNIRVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5cbmV4cG9ydCB2YXIgR1NDYWNoZSA9IGZ1bmN0aW9uIEdTQ2FjaGUodGFyZ2V0LCBoYXJuZXNzKSB7XG4gIHRoaXMuaWQgPSBfZ3NJRCsrO1xuICB0YXJnZXQuX2dzYXAgPSB0aGlzO1xuICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgdGhpcy5oYXJuZXNzID0gaGFybmVzcztcbiAgdGhpcy5nZXQgPSBoYXJuZXNzID8gaGFybmVzcy5nZXQgOiBfZ2V0UHJvcGVydHk7XG4gIHRoaXMuc2V0ID0gaGFybmVzcyA/IGhhcm5lc3MuZ2V0U2V0dGVyIDogX2dldFNldHRlcjtcbn07XG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEFOSU1BVElPTlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5leHBvcnQgdmFyIEFuaW1hdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEFuaW1hdGlvbih2YXJzLCB0aW1lKSB7XG4gICAgdmFyIHBhcmVudCA9IHZhcnMucGFyZW50IHx8IF9nbG9iYWxUaW1lbGluZTtcbiAgICB0aGlzLnZhcnMgPSB2YXJzO1xuICAgIHRoaXMuX2RlbGF5ID0gK3ZhcnMuZGVsYXkgfHwgMDtcblxuICAgIGlmICh0aGlzLl9yZXBlYXQgPSB2YXJzLnJlcGVhdCB8fCAwKSB7XG4gICAgICB0aGlzLl9yRGVsYXkgPSB2YXJzLnJlcGVhdERlbGF5IHx8IDA7XG4gICAgICB0aGlzLl95b3lvID0gISF2YXJzLnlveW8gfHwgISF2YXJzLnlveW9FYXNlO1xuICAgIH1cblxuICAgIHRoaXMuX3RzID0gMTtcblxuICAgIF9zZXREdXJhdGlvbih0aGlzLCArdmFycy5kdXJhdGlvbiwgMSk7XG5cbiAgICB0aGlzLmRhdGEgPSB2YXJzLmRhdGE7XG4gICAgX3RpY2tlckFjdGl2ZSB8fCBfdGlja2VyLndha2UoKTtcbiAgICBwYXJlbnQgJiYgX2FkZFRvVGltZWxpbmUocGFyZW50LCB0aGlzLCB0aW1lIHx8IHRpbWUgPT09IDAgPyB0aW1lIDogcGFyZW50Ll90aW1lLCAxKTtcbiAgICB2YXJzLnJldmVyc2VkICYmIHRoaXMucmV2ZXJzZSgpO1xuICAgIHZhcnMucGF1c2VkICYmIHRoaXMucGF1c2VkKHRydWUpO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEFuaW1hdGlvbi5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmRlbGF5ID0gZnVuY3Rpb24gZGVsYXkodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgfHwgdmFsdWUgPT09IDApIHtcbiAgICAgIHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LnNtb290aENoaWxkVGltaW5nICYmIHRoaXMuc3RhcnRUaW1lKHRoaXMuX3N0YXJ0ICsgdmFsdWUgLSB0aGlzLl9kZWxheSk7XG4gICAgICB0aGlzLl9kZWxheSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2RlbGF5O1xuICB9O1xuXG4gIF9wcm90by5kdXJhdGlvbiA9IGZ1bmN0aW9uIGR1cmF0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLnRvdGFsRHVyYXRpb24odGhpcy5fcmVwZWF0ID4gMCA/IHZhbHVlICsgKHZhbHVlICsgdGhpcy5fckRlbGF5KSAqIHRoaXMuX3JlcGVhdCA6IHZhbHVlKSA6IHRoaXMudG90YWxEdXJhdGlvbigpICYmIHRoaXMuX2R1cjtcbiAgfTtcblxuICBfcHJvdG8udG90YWxEdXJhdGlvbiA9IGZ1bmN0aW9uIHRvdGFsRHVyYXRpb24odmFsdWUpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLl90RHVyO1xuICAgIH1cblxuICAgIHRoaXMuX2RpcnR5ID0gMDtcbiAgICB2YXIgdCA9IHRoaXMuX3RpbWUgLyB0aGlzLl9kdXIgfHwgMDtcblxuICAgIF9zZXREdXJhdGlvbih0aGlzLCB0aGlzLl9yZXBlYXQgPCAwID8gdmFsdWUgOiAodmFsdWUgLSB0aGlzLl9yZXBlYXQgKiB0aGlzLl9yRGVsYXkpIC8gKHRoaXMuX3JlcGVhdCArIDEpKTtcblxuICAgIHJldHVybiB0aGlzLl90VGltZSA/IF9hbGlnblBsYXloZWFkKHRoaXMsIHQgKiB2YWx1ZSArIF9lbGFwc2VkQ3ljbGVEdXJhdGlvbih0aGlzKSkgOiB0aGlzOyAvLyBpbiBjYXNlIHRoZSBhbmltYXRpb24gaGFzbid0IGV2ZW4gc3RhcnRlZCB5ZXQgYW5kIGl0IGhhcyBhIGRlbGF5LiBBbGlnbmluZyB0aGUgcGxheWhlYWQgaW4gdGhhdCBjYXNlIHdvdWxkIG1ha2UgaXQgYXBwZWFyIHRvIGxvc2UgdGhlIGRlbGF5LlxuICB9O1xuXG4gIF9wcm90by50b3RhbFRpbWUgPSBmdW5jdGlvbiB0b3RhbFRpbWUoX3RvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICBfd2FrZSgpO1xuXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdFRpbWU7XG4gICAgfVxuXG4gICAgdmFyIHBhcmVudCA9IHRoaXMuX2RwO1xuXG4gICAgaWYgKHBhcmVudCAmJiBwYXJlbnQuc21vb3RoQ2hpbGRUaW1pbmcgJiYgdGhpcy5fdHMpIHtcbiAgICAgIF9hbGlnblBsYXloZWFkKHRoaXMsIF90b3RhbFRpbWUpOyAvL2luIGNhc2UgYW55IG9mIHRoZSBhbmNlc3RvciB0aW1lbGluZXMgaGFkIGNvbXBsZXRlZCBidXQgc2hvdWxkIG5vdyBiZSBlbmFibGVkLCB3ZSBzaG91bGQgcmVzZXQgdGhlaXIgdG90YWxUaW1lKCkgd2hpY2ggd2lsbCBhbHNvIGVuc3VyZSB0aGF0IHRoZXkncmUgbGluZWQgdXAgcHJvcGVybHkgYW5kIGVuYWJsZWQuIFNraXAgZm9yIGFuaW1hdGlvbnMgdGhhdCBhcmUgb24gdGhlIHJvb3QgKHdhc3RlZnVsKS4gRXhhbXBsZTogYSBUaW1lbGluZUxpdGUuZXhwb3J0Um9vdCgpIGlzIHBlcmZvcm1lZCB3aGVuIHRoZXJlJ3MgYSBwYXVzZWQgdHdlZW4gb24gdGhlIHJvb3QsIHRoZSBleHBvcnQgd2lsbCBub3QgY29tcGxldGUgdW50aWwgdGhhdCB0d2VlbiBpcyB1bnBhdXNlZCwgYnV0IGltYWdpbmUgYSBjaGlsZCBnZXRzIHJlc3RhcnRlZCBsYXRlciwgYWZ0ZXIgYWxsIFt1bnBhdXNlZF0gdHdlZW5zIGhhdmUgY29tcGxldGVkLiBUaGUgc3RhcnQgb2YgdGhhdCBjaGlsZCB3b3VsZCBnZXQgcHVzaGVkIG91dCwgYnV0IG9uZSBvZiB0aGUgYW5jZXN0b3JzIG1heSBoYXZlIGNvbXBsZXRlZC5cblxuXG4gICAgICB3aGlsZSAocGFyZW50LnBhcmVudCkge1xuICAgICAgICBpZiAocGFyZW50LnBhcmVudC5fdGltZSAhPT0gcGFyZW50Ll9zdGFydCArIChwYXJlbnQuX3RzID49IDAgPyBwYXJlbnQuX3RUaW1lIC8gcGFyZW50Ll90cyA6IChwYXJlbnQudG90YWxEdXJhdGlvbigpIC0gcGFyZW50Ll90VGltZSkgLyAtcGFyZW50Ll90cykpIHtcbiAgICAgICAgICBwYXJlbnQudG90YWxUaW1lKHBhcmVudC5fdFRpbWUsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLnBhcmVudCAmJiB0aGlzLl9kcC5hdXRvUmVtb3ZlQ2hpbGRyZW4gJiYgKHRoaXMuX3RzID4gMCAmJiBfdG90YWxUaW1lIDwgdGhpcy5fdER1ciB8fCB0aGlzLl90cyA8IDAgJiYgX3RvdGFsVGltZSA+IDAgfHwgIXRoaXMuX3REdXIgJiYgIV90b3RhbFRpbWUpKSB7XG4gICAgICAgIC8vaWYgdGhlIGFuaW1hdGlvbiBkb2Vzbid0IGhhdmUgYSBwYXJlbnQsIHB1dCBpdCBiYWNrIGludG8gaXRzIGxhc3QgcGFyZW50IChyZWNvcmRlZCBhcyBfZHAgZm9yIGV4YWN0bHkgY2FzZXMgbGlrZSB0aGlzKS4gTGltaXQgdG8gcGFyZW50cyB3aXRoIGF1dG9SZW1vdmVDaGlsZHJlbiAobGlrZSBnbG9iYWxUaW1lbGluZSkgc28gdGhhdCBpZiB0aGUgdXNlciBtYW51YWxseSByZW1vdmVzIGFuIGFuaW1hdGlvbiBmcm9tIGEgdGltZWxpbmUgYW5kIHRoZW4gYWx0ZXJzIGl0cyBwbGF5aGVhZCwgaXQgZG9lc24ndCBnZXQgYWRkZWQgYmFjayBpbi5cbiAgICAgICAgX2FkZFRvVGltZWxpbmUodGhpcy5fZHAsIHRoaXMsIHRoaXMuX3N0YXJ0IC0gdGhpcy5fZGVsYXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl90VGltZSAhPT0gX3RvdGFsVGltZSB8fCAhdGhpcy5fZHVyICYmICFzdXBwcmVzc0V2ZW50cyB8fCB0aGlzLl9pbml0dGVkICYmIE1hdGguYWJzKHRoaXMuX3pUaW1lKSA9PT0gX3RpbnlOdW0gfHwgIV90b3RhbFRpbWUgJiYgIXRoaXMuX2luaXR0ZWQpIHtcbiAgICAgIHRoaXMuX3RzIHx8ICh0aGlzLl9wVGltZSA9IF90b3RhbFRpbWUpOyAvLyBvdGhlcndpc2UsIGlmIGFuIGFuaW1hdGlvbiBpcyBwYXVzZWQsIHRoZW4gdGhlIHBsYXloZWFkIGlzIG1vdmVkIGJhY2sgdG8gemVybywgdGhlbiByZXN1bWVkLCBpdCdkIHJldmVydCBiYWNrIHRvIHRoZSBvcmlnaW5hbCB0aW1lIGF0IHRoZSBwYXVzZVxuXG4gICAgICBfbGF6eVNhZmVSZW5kZXIodGhpcywgX3RvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by50aW1lID0gZnVuY3Rpb24gdGltZSh2YWx1ZSwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMudG90YWxUaW1lKE1hdGgubWluKHRoaXMudG90YWxEdXJhdGlvbigpLCB2YWx1ZSArIF9lbGFwc2VkQ3ljbGVEdXJhdGlvbih0aGlzKSkgJSB0aGlzLl9kdXIgfHwgKHZhbHVlID8gdGhpcy5fZHVyIDogMCksIHN1cHByZXNzRXZlbnRzKSA6IHRoaXMuX3RpbWU7IC8vIG5vdGU6IGlmIHRoZSBtb2R1bHVzIHJlc3VsdHMgaW4gMCwgdGhlIHBsYXloZWFkIGNvdWxkIGJlIGV4YWN0bHkgYXQgdGhlIGVuZCBvciB0aGUgYmVnaW5uaW5nLCBhbmQgd2UgYWx3YXlzIGRlZmVyIHRvIHRoZSBFTkQgd2l0aCBhIG5vbi16ZXJvIHZhbHVlLCBvdGhlcndpc2UgaWYgeW91IHNldCB0aGUgdGltZSgpIHRvIHRoZSB2ZXJ5IGVuZCAoZHVyYXRpb24oKSksIGl0IHdvdWxkIHJlbmRlciBhdCB0aGUgU1RBUlQhXG4gIH07XG5cbiAgX3Byb3RvLnRvdGFsUHJvZ3Jlc3MgPSBmdW5jdGlvbiB0b3RhbFByb2dyZXNzKHZhbHVlLCBzdXBwcmVzc0V2ZW50cykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy50b3RhbFRpbWUodGhpcy50b3RhbER1cmF0aW9uKCkgKiB2YWx1ZSwgc3VwcHJlc3NFdmVudHMpIDogdGhpcy50b3RhbER1cmF0aW9uKCkgPyBNYXRoLm1pbigxLCB0aGlzLl90VGltZSAvIHRoaXMuX3REdXIpIDogdGhpcy5yYXRpbztcbiAgfTtcblxuICBfcHJvdG8ucHJvZ3Jlc3MgPSBmdW5jdGlvbiBwcm9ncmVzcyh2YWx1ZSwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMudG90YWxUaW1lKHRoaXMuZHVyYXRpb24oKSAqICh0aGlzLl95b3lvICYmICEodGhpcy5pdGVyYXRpb24oKSAmIDEpID8gMSAtIHZhbHVlIDogdmFsdWUpICsgX2VsYXBzZWRDeWNsZUR1cmF0aW9uKHRoaXMpLCBzdXBwcmVzc0V2ZW50cykgOiB0aGlzLmR1cmF0aW9uKCkgPyBNYXRoLm1pbigxLCB0aGlzLl90aW1lIC8gdGhpcy5fZHVyKSA6IHRoaXMucmF0aW87XG4gIH07XG5cbiAgX3Byb3RvLml0ZXJhdGlvbiA9IGZ1bmN0aW9uIGl0ZXJhdGlvbih2YWx1ZSwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICB2YXIgY3ljbGVEdXJhdGlvbiA9IHRoaXMuZHVyYXRpb24oKSArIHRoaXMuX3JEZWxheTtcblxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy50b3RhbFRpbWUodGhpcy5fdGltZSArICh2YWx1ZSAtIDEpICogY3ljbGVEdXJhdGlvbiwgc3VwcHJlc3NFdmVudHMpIDogdGhpcy5fcmVwZWF0ID8gX2FuaW1hdGlvbkN5Y2xlKHRoaXMuX3RUaW1lLCBjeWNsZUR1cmF0aW9uKSArIDEgOiAxO1xuICB9IC8vIHBvdGVudGlhbCBmdXR1cmUgYWRkaXRpb246XG4gIC8vIGlzUGxheWluZ0JhY2t3YXJkcygpIHtcbiAgLy8gXHRsZXQgYW5pbWF0aW9uID0gdGhpcyxcbiAgLy8gXHRcdG9yaWVudGF0aW9uID0gMTsgLy8gMSA9IGZvcndhcmQsIC0xID0gYmFja3dhcmRcbiAgLy8gXHR3aGlsZSAoYW5pbWF0aW9uKSB7XG4gIC8vIFx0XHRvcmllbnRhdGlvbiAqPSBhbmltYXRpb24ucmV2ZXJzZWQoKSB8fCAoYW5pbWF0aW9uLnJlcGVhdCgpICYmICEoYW5pbWF0aW9uLml0ZXJhdGlvbigpICYgMSkpID8gLTEgOiAxO1xuICAvLyBcdFx0YW5pbWF0aW9uID0gYW5pbWF0aW9uLnBhcmVudDtcbiAgLy8gXHR9XG4gIC8vIFx0cmV0dXJuIG9yaWVudGF0aW9uIDwgMDtcbiAgLy8gfVxuICA7XG5cbiAgX3Byb3RvLnRpbWVTY2FsZSA9IGZ1bmN0aW9uIHRpbWVTY2FsZSh2YWx1ZSkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3J0cyA9PT0gLV90aW55TnVtID8gMCA6IHRoaXMuX3J0czsgLy8gcmVjb3JkZWQgdGltZVNjYWxlLiBTcGVjaWFsIGNhc2U6IGlmIHNvbWVvbmUgY2FsbHMgcmV2ZXJzZSgpIG9uIGFuIGFuaW1hdGlvbiB3aXRoIHRpbWVTY2FsZSBvZiAwLCB3ZSBhc3NpZ24gaXQgLV90aW55TnVtIHRvIHJlbWVtYmVyIGl0J3MgcmV2ZXJzZWQuXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3J0cyA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciB0VGltZSA9IHRoaXMucGFyZW50ICYmIHRoaXMuX3RzID8gX3BhcmVudFRvQ2hpbGRUb3RhbFRpbWUodGhpcy5wYXJlbnQuX3RpbWUsIHRoaXMpIDogdGhpcy5fdFRpbWU7IC8vIG1ha2Ugc3VyZSB0byBkbyB0aGUgcGFyZW50VG9DaGlsZFRvdGFsVGltZSgpIEJFRk9SRSBzZXR0aW5nIHRoZSBuZXcgX3RzIGJlY2F1c2UgdGhlIG9sZCBvbmUgbXVzdCBiZSB1c2VkIGluIHRoYXQgY2FsY3VsYXRpb24uXG4gICAgLy8gcHJpb3JpdGl6ZSByZW5kZXJpbmcgd2hlcmUgdGhlIHBhcmVudCdzIHBsYXloZWFkIGxpbmVzIHVwIGluc3RlYWQgb2YgdGhpcy5fdFRpbWUgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBhIHR3ZWVuIHRoYXQncyBhbmltYXRpbmcgYW5vdGhlciB0d2VlbidzIHRpbWVTY2FsZSBpbiB0aGUgc2FtZSByZW5kZXJpbmcgbG9vcCAoc2FtZSBwYXJlbnQpLCB0aHVzIGlmIHRoZSB0aW1lU2NhbGUgdHdlZW4gcmVuZGVycyBmaXJzdCwgaXQgd291bGQgYWx0ZXIgX3N0YXJ0IEJFRk9SRSBfdFRpbWUgd2FzIHNldCBvbiB0aGF0IHRpY2sgKGluIHRoZSByZW5kZXJpbmcgbG9vcCksIGVmZmVjdGl2ZWx5IGZyZWV6aW5nIGl0IHVudGlsIHRoZSB0aW1lU2NhbGUgdHdlZW4gZmluaXNoZXMuXG5cbiAgICB0aGlzLl9ydHMgPSArdmFsdWUgfHwgMDtcbiAgICB0aGlzLl90cyA9IHRoaXMuX3BzIHx8IHZhbHVlID09PSAtX3RpbnlOdW0gPyAwIDogdGhpcy5fcnRzOyAvLyBfdHMgaXMgdGhlIGZ1bmN0aW9uYWwgdGltZVNjYWxlIHdoaWNoIHdvdWxkIGJlIDAgaWYgdGhlIGFuaW1hdGlvbiBpcyBwYXVzZWQuXG5cbiAgICByZXR1cm4gX3JlY2FjaGVBbmNlc3RvcnModGhpcy50b3RhbFRpbWUoX2NsYW1wKC10aGlzLl9kZWxheSwgdGhpcy5fdER1ciwgdFRpbWUpLCB0cnVlKSk7XG4gIH07XG5cbiAgX3Byb3RvLnBhdXNlZCA9IGZ1bmN0aW9uIHBhdXNlZCh2YWx1ZSkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BzO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9wcyAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuX3BzID0gdmFsdWU7XG5cbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9wVGltZSA9IHRoaXMuX3RUaW1lIHx8IE1hdGgubWF4KC10aGlzLl9kZWxheSwgdGhpcy5yYXdUaW1lKCkpOyAvLyBpZiB0aGUgcGF1c2Ugb2NjdXJzIGR1cmluZyB0aGUgZGVsYXkgcGhhc2UsIG1ha2Ugc3VyZSB0aGF0J3MgZmFjdG9yZWQgaW4gd2hlbiByZXN1bWluZy5cblxuICAgICAgICB0aGlzLl90cyA9IHRoaXMuX2FjdCA9IDA7IC8vIF90cyBpcyB0aGUgZnVuY3Rpb25hbCB0aW1lU2NhbGUsIHNvIGEgcGF1c2VkIHR3ZWVuIHdvdWxkIGVmZmVjdGl2ZWx5IGhhdmUgYSB0aW1lU2NhbGUgb2YgMC4gV2UgcmVjb3JkIHRoZSBcInJlYWxcIiB0aW1lU2NhbGUgYXMgX3J0cyAocmVjb3JkZWQgdGltZSBzY2FsZSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF93YWtlKCk7XG5cbiAgICAgICAgdGhpcy5fdHMgPSB0aGlzLl9ydHM7IC8vb25seSBkZWZlciB0byBfcFRpbWUgKHBhdXNlVGltZSkgaWYgdFRpbWUgaXMgemVyby4gUmVtZW1iZXIsIHNvbWVvbmUgY291bGQgcGF1c2UoKSBhbiBhbmltYXRpb24sIHRoZW4gc2NydWIgdGhlIHBsYXloZWFkIGFuZCByZXN1bWUoKS4gSWYgdGhlIHBhcmVudCBkb2Vzbid0IGhhdmUgc21vb3RoQ2hpbGRUaW1pbmcsIHdlIHJlbmRlciBhdCB0aGUgcmF3VGltZSgpIGJlY2F1c2UgdGhlIHN0YXJ0VGltZSB3b24ndCBnZXQgdXBkYXRlZC5cblxuICAgICAgICB0aGlzLnRvdGFsVGltZSh0aGlzLnBhcmVudCAmJiAhdGhpcy5wYXJlbnQuc21vb3RoQ2hpbGRUaW1pbmcgPyB0aGlzLnJhd1RpbWUoKSA6IHRoaXMuX3RUaW1lIHx8IHRoaXMuX3BUaW1lLCB0aGlzLnByb2dyZXNzKCkgPT09IDEgJiYgKHRoaXMuX3RUaW1lIC09IF90aW55TnVtKSAmJiBNYXRoLmFicyh0aGlzLl96VGltZSkgIT09IF90aW55TnVtKTsgLy8gZWRnZSBjYXNlOiBhbmltYXRpb24ucHJvZ3Jlc3MoMSkucGF1c2UoKS5wbGF5KCkgd291bGRuJ3QgcmVuZGVyIGFnYWluIGJlY2F1c2UgdGhlIHBsYXloZWFkIGlzIGFscmVhZHkgYXQgdGhlIGVuZCwgYnV0IHRoZSBjYWxsIHRvIHRvdGFsVGltZSgpIGJlbG93IHdpbGwgYWRkIGl0IGJhY2sgdG8gaXRzIHBhcmVudC4uLmFuZCBub3QgcmVtb3ZlIGl0IGFnYWluIChzaW5jZSByZW1vdmluZyBvbmx5IGhhcHBlbnMgdXBvbiByZW5kZXJpbmcgYXQgYSBuZXcgdGltZSkuIE9mZnNldHRpbmcgdGhlIF90VGltZSBzbGlnaHRseSBpcyBkb25lIHNpbXBseSB0byBjYXVzZSB0aGUgZmluYWwgcmVuZGVyIGluIHRvdGFsVGltZSgpIHRoYXQnbGwgcG9wIGl0IG9mZiBpdHMgdGltZWxpbmUgKGlmIGF1dG9SZW1vdmVDaGlsZHJlbiBpcyB0cnVlLCBvZiBjb3Vyc2UpLiBDaGVjayB0byBtYWtlIHN1cmUgX3pUaW1lIGlzbid0IC1fdGlueU51bSB0byBhdm9pZCBhbiBlZGdlIGNhc2Ugd2hlcmUgdGhlIHBsYXloZWFkIGlzIHB1c2hlZCB0byB0aGUgZW5kIGJ1dCBJTlNJREUgYSB0d2Vlbi9jYWxsYmFjaywgdGhlIHRpbWVsaW5lIGl0c2VsZiBpcyBwYXVzZWQgdGh1cyBoYWx0aW5nIHJlbmRlcmluZyBhbmQgbGVhdmluZyBhIGZldyB1bnJlbmRlcmVkLiBXaGVuIHJlc3VtaW5nLCBpdCB3b3VsZG4ndCByZW5kZXIgdGhvc2Ugb3RoZXJ3aXNlLlxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5zdGFydFRpbWUgPSBmdW5jdGlvbiBzdGFydFRpbWUodmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdGhpcy5fc3RhcnQgPSB2YWx1ZTtcbiAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudCB8fCB0aGlzLl9kcDtcbiAgICAgIHBhcmVudCAmJiAocGFyZW50Ll9zb3J0IHx8ICF0aGlzLnBhcmVudCkgJiYgX2FkZFRvVGltZWxpbmUocGFyZW50LCB0aGlzLCB2YWx1ZSAtIHRoaXMuX2RlbGF5KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9zdGFydDtcbiAgfTtcblxuICBfcHJvdG8uZW5kVGltZSA9IGZ1bmN0aW9uIGVuZFRpbWUoaW5jbHVkZVJlcGVhdHMpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhcnQgKyAoX2lzTm90RmFsc2UoaW5jbHVkZVJlcGVhdHMpID8gdGhpcy50b3RhbER1cmF0aW9uKCkgOiB0aGlzLmR1cmF0aW9uKCkpIC8gTWF0aC5hYnModGhpcy5fdHMpO1xuICB9O1xuXG4gIF9wcm90by5yYXdUaW1lID0gZnVuY3Rpb24gcmF3VGltZSh3cmFwUmVwZWF0cykge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudCB8fCB0aGlzLl9kcDsgLy8gX2RwID0gZGV0YXRjaGVkIHBhcmVudFxuXG4gICAgcmV0dXJuICFwYXJlbnQgPyB0aGlzLl90VGltZSA6IHdyYXBSZXBlYXRzICYmICghdGhpcy5fdHMgfHwgdGhpcy5fcmVwZWF0ICYmIHRoaXMuX3RpbWUgJiYgdGhpcy50b3RhbFByb2dyZXNzKCkgPCAxKSA/IHRoaXMuX3RUaW1lICUgKHRoaXMuX2R1ciArIHRoaXMuX3JEZWxheSkgOiAhdGhpcy5fdHMgPyB0aGlzLl90VGltZSA6IF9wYXJlbnRUb0NoaWxkVG90YWxUaW1lKHBhcmVudC5yYXdUaW1lKHdyYXBSZXBlYXRzKSwgdGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLmdsb2JhbFRpbWUgPSBmdW5jdGlvbiBnbG9iYWxUaW1lKHJhd1RpbWUpIHtcbiAgICB2YXIgYW5pbWF0aW9uID0gdGhpcyxcbiAgICAgICAgdGltZSA9IGFyZ3VtZW50cy5sZW5ndGggPyByYXdUaW1lIDogYW5pbWF0aW9uLnJhd1RpbWUoKTtcblxuICAgIHdoaWxlIChhbmltYXRpb24pIHtcbiAgICAgIHRpbWUgPSBhbmltYXRpb24uX3N0YXJ0ICsgdGltZSAvIChhbmltYXRpb24uX3RzIHx8IDEpO1xuICAgICAgYW5pbWF0aW9uID0gYW5pbWF0aW9uLl9kcDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGltZTtcbiAgfTtcblxuICBfcHJvdG8ucmVwZWF0ID0gZnVuY3Rpb24gcmVwZWF0KHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3JlcGVhdCA9IHZhbHVlO1xuICAgICAgcmV0dXJuIF9vblVwZGF0ZVRvdGFsRHVyYXRpb24odGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JlcGVhdDtcbiAgfTtcblxuICBfcHJvdG8ucmVwZWF0RGVsYXkgPSBmdW5jdGlvbiByZXBlYXREZWxheSh2YWx1ZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9yRGVsYXkgPSB2YWx1ZTtcbiAgICAgIHJldHVybiBfb25VcGRhdGVUb3RhbER1cmF0aW9uKHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9yRGVsYXk7XG4gIH07XG5cbiAgX3Byb3RvLnlveW8gPSBmdW5jdGlvbiB5b3lvKHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3lveW8gPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl95b3lvO1xuICB9O1xuXG4gIF9wcm90by5zZWVrID0gZnVuY3Rpb24gc2Vlayhwb3NpdGlvbiwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICByZXR1cm4gdGhpcy50b3RhbFRpbWUoX3BhcnNlUG9zaXRpb24odGhpcywgcG9zaXRpb24pLCBfaXNOb3RGYWxzZShzdXBwcmVzc0V2ZW50cykpO1xuICB9O1xuXG4gIF9wcm90by5yZXN0YXJ0ID0gZnVuY3Rpb24gcmVzdGFydChpbmNsdWRlRGVsYXksIHN1cHByZXNzRXZlbnRzKSB7XG4gICAgcmV0dXJuIHRoaXMucGxheSgpLnRvdGFsVGltZShpbmNsdWRlRGVsYXkgPyAtdGhpcy5fZGVsYXkgOiAwLCBfaXNOb3RGYWxzZShzdXBwcmVzc0V2ZW50cykpO1xuICB9O1xuXG4gIF9wcm90by5wbGF5ID0gZnVuY3Rpb24gcGxheShmcm9tLCBzdXBwcmVzc0V2ZW50cykge1xuICAgIGlmIChmcm9tICE9IG51bGwpIHtcbiAgICAgIHRoaXMuc2Vlayhmcm9tLCBzdXBwcmVzc0V2ZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucmV2ZXJzZWQoZmFsc2UpLnBhdXNlZChmYWxzZSk7XG4gIH07XG5cbiAgX3Byb3RvLnJldmVyc2UgPSBmdW5jdGlvbiByZXZlcnNlKGZyb20sIHN1cHByZXNzRXZlbnRzKSB7XG4gICAgaWYgKGZyb20gIT0gbnVsbCkge1xuICAgICAgdGhpcy5zZWVrKGZyb20gfHwgdGhpcy50b3RhbER1cmF0aW9uKCksIHN1cHByZXNzRXZlbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5yZXZlcnNlZCh0cnVlKS5wYXVzZWQoZmFsc2UpO1xuICB9O1xuXG4gIF9wcm90by5wYXVzZSA9IGZ1bmN0aW9uIHBhdXNlKGF0VGltZSwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICBpZiAoYXRUaW1lICE9IG51bGwpIHtcbiAgICAgIHRoaXMuc2VlayhhdFRpbWUsIHN1cHByZXNzRXZlbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wYXVzZWQodHJ1ZSk7XG4gIH07XG5cbiAgX3Byb3RvLnJlc3VtZSA9IGZ1bmN0aW9uIHJlc3VtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXVzZWQoZmFsc2UpO1xuICB9O1xuXG4gIF9wcm90by5yZXZlcnNlZCA9IGZ1bmN0aW9uIHJldmVyc2VkKHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGlmICghIXZhbHVlICE9PSB0aGlzLnJldmVyc2VkKCkpIHtcbiAgICAgICAgdGhpcy50aW1lU2NhbGUoLXRoaXMuX3J0cyB8fCAodmFsdWUgPyAtX3RpbnlOdW0gOiAwKSk7IC8vIGluIGNhc2UgdGltZVNjYWxlIGlzIHplcm8sIHJldmVyc2luZyB3b3VsZCBoYXZlIG5vIGVmZmVjdCBzbyB3ZSB1c2UgX3RpbnlOdW0uXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9ydHMgPCAwO1xuICB9O1xuXG4gIF9wcm90by5pbnZhbGlkYXRlID0gZnVuY3Rpb24gaW52YWxpZGF0ZSgpIHtcbiAgICB0aGlzLl9pbml0dGVkID0gMDtcbiAgICB0aGlzLl96VGltZSA9IC1fdGlueU51bTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uaXNBY3RpdmUgPSBmdW5jdGlvbiBpc0FjdGl2ZSgpIHtcbiAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQgfHwgdGhpcy5fZHAsXG4gICAgICAgIHN0YXJ0ID0gdGhpcy5fc3RhcnQsXG4gICAgICAgIHJhd1RpbWU7XG4gICAgcmV0dXJuICEhKCFwYXJlbnQgfHwgdGhpcy5fdHMgJiYgdGhpcy5faW5pdHRlZCAmJiBwYXJlbnQuaXNBY3RpdmUoKSAmJiAocmF3VGltZSA9IHBhcmVudC5yYXdUaW1lKHRydWUpKSA+PSBzdGFydCAmJiByYXdUaW1lIDwgdGhpcy5lbmRUaW1lKHRydWUpIC0gX3RpbnlOdW0pO1xuICB9O1xuXG4gIF9wcm90by5ldmVudENhbGxiYWNrID0gZnVuY3Rpb24gZXZlbnRDYWxsYmFjayh0eXBlLCBjYWxsYmFjaywgcGFyYW1zKSB7XG4gICAgdmFyIHZhcnMgPSB0aGlzLnZhcnM7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgZGVsZXRlIHZhcnNbdHlwZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXJzW3R5cGVdID0gY2FsbGJhY2s7XG5cbiAgICAgICAgaWYgKHBhcmFtcykge1xuICAgICAgICAgIHZhcnNbdHlwZSArIFwiUGFyYW1zXCJdID0gcGFyYW1zO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUgPT09IFwib25VcGRhdGVcIikge1xuICAgICAgICAgIHRoaXMuX29uVXBkYXRlID0gY2FsbGJhY2s7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhcnNbdHlwZV07XG4gIH07XG5cbiAgX3Byb3RvLnRoZW4gPSBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgdmFyIGYgPSBfaXNGdW5jdGlvbihvbkZ1bGZpbGxlZCkgPyBvbkZ1bGZpbGxlZCA6IF9wYXNzVGhyb3VnaCxcbiAgICAgICAgICBfcmVzb2x2ZSA9IGZ1bmN0aW9uIF9yZXNvbHZlKCkge1xuICAgICAgICB2YXIgX3RoZW4gPSBzZWxmLnRoZW47XG4gICAgICAgIHNlbGYudGhlbiA9IG51bGw7IC8vIHRlbXBvcmFyaWx5IG51bGwgdGhlIHRoZW4oKSBtZXRob2QgdG8gYXZvaWQgYW4gaW5maW5pdGUgbG9vcCAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ncmVlbnNvY2svR1NBUC9pc3N1ZXMvMzIyKVxuXG4gICAgICAgIF9pc0Z1bmN0aW9uKGYpICYmIChmID0gZihzZWxmKSkgJiYgKGYudGhlbiB8fCBmID09PSBzZWxmKSAmJiAoc2VsZi50aGVuID0gX3RoZW4pO1xuICAgICAgICByZXNvbHZlKGYpO1xuICAgICAgICBzZWxmLnRoZW4gPSBfdGhlbjtcbiAgICAgIH07XG5cbiAgICAgIGlmIChzZWxmLl9pbml0dGVkICYmIHNlbGYudG90YWxQcm9ncmVzcygpID09PSAxICYmIHNlbGYuX3RzID49IDAgfHwgIXNlbGYuX3RUaW1lICYmIHNlbGYuX3RzIDwgMCkge1xuICAgICAgICBfcmVzb2x2ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5fcHJvbSA9IF9yZXNvbHZlO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5raWxsID0gZnVuY3Rpb24ga2lsbCgpIHtcbiAgICBfaW50ZXJydXB0KHRoaXMpO1xuICB9O1xuXG4gIHJldHVybiBBbmltYXRpb247XG59KCk7XG5cbl9zZXREZWZhdWx0cyhBbmltYXRpb24ucHJvdG90eXBlLCB7XG4gIF90aW1lOiAwLFxuICBfc3RhcnQ6IDAsXG4gIF9lbmQ6IDAsXG4gIF90VGltZTogMCxcbiAgX3REdXI6IDAsXG4gIF9kaXJ0eTogMCxcbiAgX3JlcGVhdDogMCxcbiAgX3lveW86IGZhbHNlLFxuICBwYXJlbnQ6IG51bGwsXG4gIF9pbml0dGVkOiBmYWxzZSxcbiAgX3JEZWxheTogMCxcbiAgX3RzOiAxLFxuICBfZHA6IDAsXG4gIHJhdGlvOiAwLFxuICBfelRpbWU6IC1fdGlueU51bSxcbiAgX3Byb206IDAsXG4gIF9wczogZmFsc2UsXG4gIF9ydHM6IDFcbn0pO1xuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFRJTUVMSU5FXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuXG5leHBvcnQgdmFyIFRpbWVsaW5lID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQW5pbWF0aW9uKSB7XG4gIF9pbmhlcml0c0xvb3NlKFRpbWVsaW5lLCBfQW5pbWF0aW9uKTtcblxuICBmdW5jdGlvbiBUaW1lbGluZSh2YXJzLCB0aW1lKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgaWYgKHZhcnMgPT09IHZvaWQgMCkge1xuICAgICAgdmFycyA9IHt9O1xuICAgIH1cblxuICAgIF90aGlzID0gX0FuaW1hdGlvbi5jYWxsKHRoaXMsIHZhcnMsIHRpbWUpIHx8IHRoaXM7XG4gICAgX3RoaXMubGFiZWxzID0ge307XG4gICAgX3RoaXMuc21vb3RoQ2hpbGRUaW1pbmcgPSAhIXZhcnMuc21vb3RoQ2hpbGRUaW1pbmc7XG4gICAgX3RoaXMuYXV0b1JlbW92ZUNoaWxkcmVuID0gISF2YXJzLmF1dG9SZW1vdmVDaGlsZHJlbjtcbiAgICBfdGhpcy5fc29ydCA9IF9pc05vdEZhbHNlKHZhcnMuc29ydENoaWxkcmVuKTtcbiAgICBfdGhpcy5wYXJlbnQgJiYgX3Bvc3RBZGRDaGVja3MoX3RoaXMucGFyZW50LCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgdmFycy5zY3JvbGxUcmlnZ2VyICYmIF9zY3JvbGxUcmlnZ2VyKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCB2YXJzLnNjcm9sbFRyaWdnZXIpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8yID0gVGltZWxpbmUucHJvdG90eXBlO1xuXG4gIF9wcm90bzIudG8gPSBmdW5jdGlvbiB0byh0YXJnZXRzLCB2YXJzLCBwb3NpdGlvbikge1xuICAgIG5ldyBUd2Vlbih0YXJnZXRzLCBfcGFyc2VWYXJzKGFyZ3VtZW50cywgMCwgdGhpcyksIF9wYXJzZVBvc2l0aW9uKHRoaXMsIF9pc051bWJlcih2YXJzKSA/IGFyZ3VtZW50c1szXSA6IHBvc2l0aW9uKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvMi5mcm9tID0gZnVuY3Rpb24gZnJvbSh0YXJnZXRzLCB2YXJzLCBwb3NpdGlvbikge1xuICAgIG5ldyBUd2Vlbih0YXJnZXRzLCBfcGFyc2VWYXJzKGFyZ3VtZW50cywgMSwgdGhpcyksIF9wYXJzZVBvc2l0aW9uKHRoaXMsIF9pc051bWJlcih2YXJzKSA/IGFyZ3VtZW50c1szXSA6IHBvc2l0aW9uKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvMi5mcm9tVG8gPSBmdW5jdGlvbiBmcm9tVG8odGFyZ2V0cywgZnJvbVZhcnMsIHRvVmFycywgcG9zaXRpb24pIHtcbiAgICBuZXcgVHdlZW4odGFyZ2V0cywgX3BhcnNlVmFycyhhcmd1bWVudHMsIDIsIHRoaXMpLCBfcGFyc2VQb3NpdGlvbih0aGlzLCBfaXNOdW1iZXIoZnJvbVZhcnMpID8gYXJndW1lbnRzWzRdIDogcG9zaXRpb24pKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8yLnNldCA9IGZ1bmN0aW9uIHNldCh0YXJnZXRzLCB2YXJzLCBwb3NpdGlvbikge1xuICAgIHZhcnMuZHVyYXRpb24gPSAwO1xuICAgIHZhcnMucGFyZW50ID0gdGhpcztcbiAgICBfaW5oZXJpdERlZmF1bHRzKHZhcnMpLnJlcGVhdERlbGF5IHx8ICh2YXJzLnJlcGVhdCA9IDApO1xuICAgIHZhcnMuaW1tZWRpYXRlUmVuZGVyID0gISF2YXJzLmltbWVkaWF0ZVJlbmRlcjtcbiAgICBuZXcgVHdlZW4odGFyZ2V0cywgdmFycywgX3BhcnNlUG9zaXRpb24odGhpcywgcG9zaXRpb24pLCAxKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8yLmNhbGwgPSBmdW5jdGlvbiBjYWxsKGNhbGxiYWNrLCBwYXJhbXMsIHBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIF9hZGRUb1RpbWVsaW5lKHRoaXMsIFR3ZWVuLmRlbGF5ZWRDYWxsKDAsIGNhbGxiYWNrLCBwYXJhbXMpLCBfcGFyc2VQb3NpdGlvbih0aGlzLCBwb3NpdGlvbikpO1xuICB9IC8vT05MWSBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSEgTWF5YmUgZGVsZXRlP1xuICA7XG5cbiAgX3Byb3RvMi5zdGFnZ2VyVG8gPSBmdW5jdGlvbiBzdGFnZ2VyVG8odGFyZ2V0cywgZHVyYXRpb24sIHZhcnMsIHN0YWdnZXIsIHBvc2l0aW9uLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zKSB7XG4gICAgdmFycy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgIHZhcnMuc3RhZ2dlciA9IHZhcnMuc3RhZ2dlciB8fCBzdGFnZ2VyO1xuICAgIHZhcnMub25Db21wbGV0ZSA9IG9uQ29tcGxldGVBbGw7XG4gICAgdmFycy5vbkNvbXBsZXRlUGFyYW1zID0gb25Db21wbGV0ZUFsbFBhcmFtcztcbiAgICB2YXJzLnBhcmVudCA9IHRoaXM7XG4gICAgbmV3IFR3ZWVuKHRhcmdldHMsIHZhcnMsIF9wYXJzZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvMi5zdGFnZ2VyRnJvbSA9IGZ1bmN0aW9uIHN0YWdnZXJGcm9tKHRhcmdldHMsIGR1cmF0aW9uLCB2YXJzLCBzdGFnZ2VyLCBwb3NpdGlvbiwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcykge1xuICAgIHZhcnMucnVuQmFja3dhcmRzID0gMTtcbiAgICBfaW5oZXJpdERlZmF1bHRzKHZhcnMpLmltbWVkaWF0ZVJlbmRlciA9IF9pc05vdEZhbHNlKHZhcnMuaW1tZWRpYXRlUmVuZGVyKTtcbiAgICByZXR1cm4gdGhpcy5zdGFnZ2VyVG8odGFyZ2V0cywgZHVyYXRpb24sIHZhcnMsIHN0YWdnZXIsIHBvc2l0aW9uLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zKTtcbiAgfTtcblxuICBfcHJvdG8yLnN0YWdnZXJGcm9tVG8gPSBmdW5jdGlvbiBzdGFnZ2VyRnJvbVRvKHRhcmdldHMsIGR1cmF0aW9uLCBmcm9tVmFycywgdG9WYXJzLCBzdGFnZ2VyLCBwb3NpdGlvbiwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcykge1xuICAgIHRvVmFycy5zdGFydEF0ID0gZnJvbVZhcnM7XG4gICAgX2luaGVyaXREZWZhdWx0cyh0b1ZhcnMpLmltbWVkaWF0ZVJlbmRlciA9IF9pc05vdEZhbHNlKHRvVmFycy5pbW1lZGlhdGVSZW5kZXIpO1xuICAgIHJldHVybiB0aGlzLnN0YWdnZXJUbyh0YXJnZXRzLCBkdXJhdGlvbiwgdG9WYXJzLCBzdGFnZ2VyLCBwb3NpdGlvbiwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcyk7XG4gIH07XG5cbiAgX3Byb3RvMi5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIodG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpIHtcbiAgICB2YXIgcHJldlRpbWUgPSB0aGlzLl90aW1lLFxuICAgICAgICB0RHVyID0gdGhpcy5fZGlydHkgPyB0aGlzLnRvdGFsRHVyYXRpb24oKSA6IHRoaXMuX3REdXIsXG4gICAgICAgIGR1ciA9IHRoaXMuX2R1cixcbiAgICAgICAgdFRpbWUgPSB0aGlzICE9PSBfZ2xvYmFsVGltZWxpbmUgJiYgdG90YWxUaW1lID4gdER1ciAtIF90aW55TnVtICYmIHRvdGFsVGltZSA+PSAwID8gdER1ciA6IHRvdGFsVGltZSA8IF90aW55TnVtID8gMCA6IHRvdGFsVGltZSxcbiAgICAgICAgY3Jvc3NpbmdTdGFydCA9IHRoaXMuX3pUaW1lIDwgMCAhPT0gdG90YWxUaW1lIDwgMCAmJiAodGhpcy5faW5pdHRlZCB8fCAhZHVyKSxcbiAgICAgICAgdGltZSxcbiAgICAgICAgY2hpbGQsXG4gICAgICAgIG5leHQsXG4gICAgICAgIGl0ZXJhdGlvbixcbiAgICAgICAgY3ljbGVEdXJhdGlvbixcbiAgICAgICAgcHJldlBhdXNlZCxcbiAgICAgICAgcGF1c2VUd2VlbixcbiAgICAgICAgdGltZVNjYWxlLFxuICAgICAgICBwcmV2U3RhcnQsXG4gICAgICAgIHByZXZJdGVyYXRpb24sXG4gICAgICAgIHlveW8sXG4gICAgICAgIGlzWW95bztcblxuICAgIGlmICh0VGltZSAhPT0gdGhpcy5fdFRpbWUgfHwgZm9yY2UgfHwgY3Jvc3NpbmdTdGFydCkge1xuICAgICAgaWYgKHByZXZUaW1lICE9PSB0aGlzLl90aW1lICYmIGR1cikge1xuICAgICAgICAvL2lmIHRvdGFsRHVyYXRpb24oKSBmaW5kcyBhIGNoaWxkIHdpdGggYSBuZWdhdGl2ZSBzdGFydFRpbWUgYW5kIHNtb290aENoaWxkVGltaW5nIGlzIHRydWUsIHRoaW5ncyBnZXQgc2hpZnRlZCBhcm91bmQgaW50ZXJuYWxseSBzbyB3ZSBuZWVkIHRvIGFkanVzdCB0aGUgdGltZSBhY2NvcmRpbmdseS4gRm9yIGV4YW1wbGUsIGlmIGEgdHdlZW4gc3RhcnRzIGF0IC0zMCB3ZSBtdXN0IHNoaWZ0IEVWRVJZVEhJTkcgZm9yd2FyZCAzMCBzZWNvbmRzIGFuZCBtb3ZlIHRoaXMgdGltZWxpbmUncyBzdGFydFRpbWUgYmFja3dhcmQgYnkgMzAgc2Vjb25kcyBzbyB0aGF0IHRoaW5ncyBhbGlnbiB3aXRoIHRoZSBwbGF5aGVhZCAobm8ganVtcCkuXG4gICAgICAgIHRUaW1lICs9IHRoaXMuX3RpbWUgLSBwcmV2VGltZTtcbiAgICAgICAgdG90YWxUaW1lICs9IHRoaXMuX3RpbWUgLSBwcmV2VGltZTtcbiAgICAgIH1cblxuICAgICAgdGltZSA9IHRUaW1lO1xuICAgICAgcHJldlN0YXJ0ID0gdGhpcy5fc3RhcnQ7XG4gICAgICB0aW1lU2NhbGUgPSB0aGlzLl90cztcbiAgICAgIHByZXZQYXVzZWQgPSAhdGltZVNjYWxlO1xuXG4gICAgICBpZiAoY3Jvc3NpbmdTdGFydCkge1xuICAgICAgICBkdXIgfHwgKHByZXZUaW1lID0gdGhpcy5felRpbWUpOyAvL3doZW4gdGhlIHBsYXloZWFkIGFycml2ZXMgYXQgRVhBQ1RMWSB0aW1lIDAgKHJpZ2h0IG9uIHRvcCkgb2YgYSB6ZXJvLWR1cmF0aW9uIHRpbWVsaW5lLCB3ZSBuZWVkIHRvIGRpc2Nlcm4gaWYgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIHNvIHRoYXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgYWdhaW4gKG5leHQgdGltZSksIGl0J2xsIHRyaWdnZXIgdGhlIGNhbGxiYWNrLiBJZiBldmVudHMgYXJlIE5PVCBzdXBwcmVzc2VkLCBvYnZpb3VzbHkgdGhlIGNhbGxiYWNrIHdvdWxkIGJlIHRyaWdnZXJlZCBpbiB0aGlzIHJlbmRlci4gQmFzaWNhbGx5LCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUgZWl0aGVyIHdoZW4gdGhlIHBsYXloZWFkIEFSUklWRVMgb3IgTEVBVkVTIHRoaXMgZXhhY3Qgc3BvdCwgbm90IGJvdGguIEltYWdpbmUgZG9pbmcgYSB0aW1lbGluZS5zZWVrKDApIGFuZCB0aGVyZSdzIGEgY2FsbGJhY2sgdGhhdCBzaXRzIGF0IDAuIFNpbmNlIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBvbiB0aGF0IHNlZWsoKSBieSBkZWZhdWx0LCBub3RoaW5nIHdpbGwgZmlyZSwgYnV0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIG9mZiBvZiB0aGF0IHBvc2l0aW9uLCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUuIFRoaXMgYmVoYXZpb3IgaXMgd2hhdCBwZW9wbGUgaW50dWl0aXZlbHkgZXhwZWN0LlxuXG4gICAgICAgICh0b3RhbFRpbWUgfHwgIXN1cHByZXNzRXZlbnRzKSAmJiAodGhpcy5felRpbWUgPSB0b3RhbFRpbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fcmVwZWF0KSB7XG4gICAgICAgIC8vYWRqdXN0IHRoZSB0aW1lIGZvciByZXBlYXRzIGFuZCB5b3lvc1xuICAgICAgICB5b3lvID0gdGhpcy5feW95bztcbiAgICAgICAgY3ljbGVEdXJhdGlvbiA9IGR1ciArIHRoaXMuX3JEZWxheTtcbiAgICAgICAgdGltZSA9IF9yb3VuZCh0VGltZSAlIGN5Y2xlRHVyYXRpb24pOyAvL3JvdW5kIHRvIGF2b2lkIGZsb2F0aW5nIHBvaW50IGVycm9ycy4gKDQgJSAwLjggc2hvdWxkIGJlIDAgYnV0IHNvbWUgYnJvd3NlcnMgcmVwb3J0IGl0IGFzIDAuNzk5OTk5OTkhKVxuXG4gICAgICAgIGlmICh0aW1lID4gZHVyIHx8IHREdXIgPT09IHRUaW1lKSB7XG4gICAgICAgICAgdGltZSA9IGR1cjtcbiAgICAgICAgfVxuXG4gICAgICAgIGl0ZXJhdGlvbiA9IH5+KHRUaW1lIC8gY3ljbGVEdXJhdGlvbik7XG5cbiAgICAgICAgaWYgKGl0ZXJhdGlvbiAmJiBpdGVyYXRpb24gPT09IHRUaW1lIC8gY3ljbGVEdXJhdGlvbikge1xuICAgICAgICAgIHRpbWUgPSBkdXI7XG4gICAgICAgICAgaXRlcmF0aW9uLS07XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2SXRlcmF0aW9uID0gX2FuaW1hdGlvbkN5Y2xlKHRoaXMuX3RUaW1lLCBjeWNsZUR1cmF0aW9uKTtcbiAgICAgICAgIXByZXZUaW1lICYmIHRoaXMuX3RUaW1lICYmIHByZXZJdGVyYXRpb24gIT09IGl0ZXJhdGlvbiAmJiAocHJldkl0ZXJhdGlvbiA9IGl0ZXJhdGlvbik7IC8vIGVkZ2UgY2FzZSAtIGlmIHNvbWVvbmUgZG9lcyBhZGRQYXVzZSgpIGF0IHRoZSB2ZXJ5IGJlZ2lubmluZyBvZiBhIHJlcGVhdGluZyB0aW1lbGluZSwgdGhhdCBwYXVzZSBpcyB0ZWNobmljYWxseSBhdCB0aGUgc2FtZSBzcG90IGFzIHRoZSBlbmQgd2hpY2ggY2F1c2VzIHRoaXMuX3RpbWUgdG8gZ2V0IHNldCB0byAwIHdoZW4gdGhlIHRvdGFsVGltZSB3b3VsZCBub3JtYWxseSBwbGFjZSB0aGUgcGxheWhlYWQgYXQgdGhlIGVuZC4gU2VlIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9mb3J1bXMvdG9waWMvMjM4MjMtY2xvc2luZy1uYXYtYW5pbWF0aW9uLW5vdC13b3JraW5nLW9uLWllLWFuZC1pcGhvbmUtNi1tYXliZS1vdGhlci1vbGRlci1icm93c2VyLz90YWI9Y29tbWVudHMjY29tbWVudC0xMTMwMDVcblxuICAgICAgICBpZiAoeW95byAmJiBpdGVyYXRpb24gJiAxKSB7XG4gICAgICAgICAgdGltZSA9IGR1ciAtIHRpbWU7XG4gICAgICAgICAgaXNZb3lvID0gMTtcbiAgICAgICAgfVxuICAgICAgICAvKlxuICAgICAgICBtYWtlIHN1cmUgY2hpbGRyZW4gYXQgdGhlIGVuZC9iZWdpbm5pbmcgb2YgdGhlIHRpbWVsaW5lIGFyZSByZW5kZXJlZCBwcm9wZXJseS4gSWYsIGZvciBleGFtcGxlLFxuICAgICAgICBhIDMtc2Vjb25kIGxvbmcgdGltZWxpbmUgcmVuZGVyZWQgYXQgMi45IHNlY29uZHMgcHJldmlvdXNseSwgYW5kIG5vdyByZW5kZXJzIGF0IDMuMiBzZWNvbmRzICh3aGljaFxuICAgICAgICB3b3VsZCBnZXQgdHJhbnNsYXRlZCB0byAyLjggc2Vjb25kcyBpZiB0aGUgdGltZWxpbmUgeW95b3Mgb3IgMC4yIHNlY29uZHMgaWYgaXQganVzdCByZXBlYXRzKSwgdGhlcmVcbiAgICAgICAgY291bGQgYmUgYSBjYWxsYmFjayBvciBhIHNob3J0IHR3ZWVuIHRoYXQncyBhdCAyLjk1IG9yIDMgc2Vjb25kcyBpbiB3aGljaCB3b3VsZG4ndCByZW5kZXIuIFNvXG4gICAgICAgIHdlIG5lZWQgdG8gcHVzaCB0aGUgdGltZWxpbmUgdG8gdGhlIGVuZCAoYW5kL29yIGJlZ2lubmluZyBkZXBlbmRpbmcgb24gaXRzIHlveW8gdmFsdWUpLiBBbHNvIHdlIG11c3RcbiAgICAgICAgZW5zdXJlIHRoYXQgemVyby1kdXJhdGlvbiB0d2VlbnMgYXQgdGhlIHZlcnkgYmVnaW5uaW5nIG9yIGVuZCBvZiB0aGUgVGltZWxpbmUgd29yay5cbiAgICAgICAgKi9cblxuXG4gICAgICAgIGlmIChpdGVyYXRpb24gIT09IHByZXZJdGVyYXRpb24gJiYgIXRoaXMuX2xvY2spIHtcbiAgICAgICAgICB2YXIgcmV3aW5kaW5nID0geW95byAmJiBwcmV2SXRlcmF0aW9uICYgMSxcbiAgICAgICAgICAgICAgZG9lc1dyYXAgPSByZXdpbmRpbmcgPT09ICh5b3lvICYmIGl0ZXJhdGlvbiAmIDEpO1xuXG4gICAgICAgICAgaWYgKGl0ZXJhdGlvbiA8IHByZXZJdGVyYXRpb24pIHtcbiAgICAgICAgICAgIHJld2luZGluZyA9ICFyZXdpbmRpbmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcHJldlRpbWUgPSByZXdpbmRpbmcgPyAwIDogZHVyO1xuICAgICAgICAgIHRoaXMuX2xvY2sgPSAxO1xuICAgICAgICAgIHRoaXMucmVuZGVyKHByZXZUaW1lIHx8IChpc1lveW8gPyAwIDogX3JvdW5kKGl0ZXJhdGlvbiAqIGN5Y2xlRHVyYXRpb24pKSwgc3VwcHJlc3NFdmVudHMsICFkdXIpLl9sb2NrID0gMDtcblxuICAgICAgICAgIGlmICghc3VwcHJlc3NFdmVudHMgJiYgdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIF9jYWxsYmFjayh0aGlzLCBcIm9uUmVwZWF0XCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMudmFycy5yZXBlYXRSZWZyZXNoICYmICFpc1lveW8gJiYgKHRoaXMuaW52YWxpZGF0ZSgpLl9sb2NrID0gMSk7XG5cbiAgICAgICAgICBpZiAocHJldlRpbWUgIT09IHRoaXMuX3RpbWUgfHwgcHJldlBhdXNlZCAhPT0gIXRoaXMuX3RzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZG9lc1dyYXApIHtcbiAgICAgICAgICAgIHRoaXMuX2xvY2sgPSAyO1xuICAgICAgICAgICAgcHJldlRpbWUgPSByZXdpbmRpbmcgPyBkdXIgKyAwLjAwMDEgOiAtMC4wMDAxO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXIocHJldlRpbWUsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy52YXJzLnJlcGVhdFJlZnJlc2ggJiYgIWlzWW95byAmJiB0aGlzLmludmFsaWRhdGUoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9sb2NrID0gMDtcblxuICAgICAgICAgIGlmICghdGhpcy5fdHMgJiYgIXByZXZQYXVzZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH0gLy9pbiBvcmRlciBmb3IgeW95b0Vhc2UgdG8gd29yayBwcm9wZXJseSB3aGVuIHRoZXJlJ3MgYSBzdGFnZ2VyLCB3ZSBtdXN0IHN3YXAgb3V0IHRoZSBlYXNlIGluIGVhY2ggc3ViLXR3ZWVuLlxuXG5cbiAgICAgICAgICBfcHJvcGFnYXRlWW95b0Vhc2UodGhpcywgaXNZb3lvKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5faGFzUGF1c2UgJiYgIXRoaXMuX2ZvcmNpbmcgJiYgdGhpcy5fbG9jayA8IDIpIHtcbiAgICAgICAgcGF1c2VUd2VlbiA9IF9maW5kTmV4dFBhdXNlVHdlZW4odGhpcywgX3JvdW5kKHByZXZUaW1lKSwgX3JvdW5kKHRpbWUpKTtcblxuICAgICAgICBpZiAocGF1c2VUd2Vlbikge1xuICAgICAgICAgIHRUaW1lIC09IHRpbWUgLSAodGltZSA9IHBhdXNlVHdlZW4uX3N0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl90VGltZSA9IHRUaW1lO1xuICAgICAgdGhpcy5fdGltZSA9IHRpbWU7XG4gICAgICB0aGlzLl9hY3QgPSAhdGltZVNjYWxlOyAvL2FzIGxvbmcgYXMgaXQncyBub3QgcGF1c2VkLCBmb3JjZSBpdCB0byBiZSBhY3RpdmUgc28gdGhhdCBpZiB0aGUgdXNlciByZW5kZXJzIGluZGVwZW5kZW50IG9mIHRoZSBwYXJlbnQgdGltZWxpbmUsIGl0J2xsIGJlIGZvcmNlZCB0byByZS1yZW5kZXIgb24gdGhlIG5leHQgdGljay5cblxuICAgICAgaWYgKCF0aGlzLl9pbml0dGVkKSB7XG4gICAgICAgIHRoaXMuX29uVXBkYXRlID0gdGhpcy52YXJzLm9uVXBkYXRlO1xuICAgICAgICB0aGlzLl9pbml0dGVkID0gMTtcbiAgICAgICAgdGhpcy5felRpbWUgPSB0b3RhbFRpbWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghcHJldlRpbWUgJiYgdGltZSAmJiAhc3VwcHJlc3NFdmVudHMpIHtcbiAgICAgICAgX2NhbGxiYWNrKHRoaXMsIFwib25TdGFydFwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRpbWUgPj0gcHJldlRpbWUgJiYgdG90YWxUaW1lID49IDApIHtcbiAgICAgICAgY2hpbGQgPSB0aGlzLl9maXJzdDtcblxuICAgICAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgICAgICBuZXh0ID0gY2hpbGQuX25leHQ7XG5cbiAgICAgICAgICBpZiAoKGNoaWxkLl9hY3QgfHwgdGltZSA+PSBjaGlsZC5fc3RhcnQpICYmIGNoaWxkLl90cyAmJiBwYXVzZVR3ZWVuICE9PSBjaGlsZCkge1xuICAgICAgICAgICAgaWYgKGNoaWxkLnBhcmVudCAhPT0gdGhpcykge1xuICAgICAgICAgICAgICAvLyBhbiBleHRyZW1lIGVkZ2UgY2FzZSAtIHRoZSBjaGlsZCdzIHJlbmRlciBjb3VsZCBkbyBzb21ldGhpbmcgbGlrZSBraWxsKCkgdGhlIFwibmV4dFwiIG9uZSBpbiB0aGUgbGlua2VkIGxpc3QsIG9yIHJlcGFyZW50IGl0LiBJbiB0aGF0IGNhc2Ugd2UgbXVzdCByZS1pbml0aWF0ZSB0aGUgd2hvbGUgcmVuZGVyIHRvIGJlIHNhZmUuXG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlcih0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNoaWxkLnJlbmRlcihjaGlsZC5fdHMgPiAwID8gKHRpbWUgLSBjaGlsZC5fc3RhcnQpICogY2hpbGQuX3RzIDogKGNoaWxkLl9kaXJ0eSA/IGNoaWxkLnRvdGFsRHVyYXRpb24oKSA6IGNoaWxkLl90RHVyKSArICh0aW1lIC0gY2hpbGQuX3N0YXJ0KSAqIGNoaWxkLl90cywgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblxuICAgICAgICAgICAgaWYgKHRpbWUgIT09IHRoaXMuX3RpbWUgfHwgIXRoaXMuX3RzICYmICFwcmV2UGF1c2VkKSB7XG4gICAgICAgICAgICAgIC8vaW4gY2FzZSBhIHR3ZWVuIHBhdXNlcyBvciBzZWVrcyB0aGUgdGltZWxpbmUgd2hlbiByZW5kZXJpbmcsIGxpa2UgaW5zaWRlIG9mIGFuIG9uVXBkYXRlL29uQ29tcGxldGVcbiAgICAgICAgICAgICAgcGF1c2VUd2VlbiA9IDA7XG4gICAgICAgICAgICAgIG5leHQgJiYgKHRUaW1lICs9IHRoaXMuX3pUaW1lID0gLV90aW55TnVtKTsgLy8gaXQgZGlkbid0IGZpbmlzaCByZW5kZXJpbmcsIHNvIGZsYWcgelRpbWUgYXMgbmVnYXRpdmUgc28gdGhhdCBzbyB0aGF0IHRoZSBuZXh0IHRpbWUgcmVuZGVyKCkgaXMgY2FsbGVkIGl0J2xsIGJlIGZvcmNlZCAodG8gcmVuZGVyIGFueSByZW1haW5pbmcgY2hpbGRyZW4pXG5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2hpbGQgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGlsZCA9IHRoaXMuX2xhc3Q7XG4gICAgICAgIHZhciBhZGp1c3RlZFRpbWUgPSB0b3RhbFRpbWUgPCAwID8gdG90YWxUaW1lIDogdGltZTsgLy93aGVuIHRoZSBwbGF5aGVhZCBnb2VzIGJhY2t3YXJkIGJleW9uZCB0aGUgc3RhcnQgb2YgdGhpcyB0aW1lbGluZSwgd2UgbXVzdCBwYXNzIHRoYXQgaW5mb3JtYXRpb24gZG93biB0byB0aGUgY2hpbGQgYW5pbWF0aW9ucyBzbyB0aGF0IHplcm8tZHVyYXRpb24gdHdlZW5zIGtub3cgd2hldGhlciB0byByZW5kZXIgdGhlaXIgc3RhcnRpbmcgb3IgZW5kaW5nIHZhbHVlcy5cblxuICAgICAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgICAgICBuZXh0ID0gY2hpbGQuX3ByZXY7XG5cbiAgICAgICAgICBpZiAoKGNoaWxkLl9hY3QgfHwgYWRqdXN0ZWRUaW1lIDw9IGNoaWxkLl9lbmQpICYmIGNoaWxkLl90cyAmJiBwYXVzZVR3ZWVuICE9PSBjaGlsZCkge1xuICAgICAgICAgICAgaWYgKGNoaWxkLnBhcmVudCAhPT0gdGhpcykge1xuICAgICAgICAgICAgICAvLyBhbiBleHRyZW1lIGVkZ2UgY2FzZSAtIHRoZSBjaGlsZCdzIHJlbmRlciBjb3VsZCBkbyBzb21ldGhpbmcgbGlrZSBraWxsKCkgdGhlIFwibmV4dFwiIG9uZSBpbiB0aGUgbGlua2VkIGxpc3QsIG9yIHJlcGFyZW50IGl0LiBJbiB0aGF0IGNhc2Ugd2UgbXVzdCByZS1pbml0aWF0ZSB0aGUgd2hvbGUgcmVuZGVyIHRvIGJlIHNhZmUuXG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlcih0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNoaWxkLnJlbmRlcihjaGlsZC5fdHMgPiAwID8gKGFkanVzdGVkVGltZSAtIGNoaWxkLl9zdGFydCkgKiBjaGlsZC5fdHMgOiAoY2hpbGQuX2RpcnR5ID8gY2hpbGQudG90YWxEdXJhdGlvbigpIDogY2hpbGQuX3REdXIpICsgKGFkanVzdGVkVGltZSAtIGNoaWxkLl9zdGFydCkgKiBjaGlsZC5fdHMsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cbiAgICAgICAgICAgIGlmICh0aW1lICE9PSB0aGlzLl90aW1lIHx8ICF0aGlzLl90cyAmJiAhcHJldlBhdXNlZCkge1xuICAgICAgICAgICAgICAvL2luIGNhc2UgYSB0d2VlbiBwYXVzZXMgb3Igc2Vla3MgdGhlIHRpbWVsaW5lIHdoZW4gcmVuZGVyaW5nLCBsaWtlIGluc2lkZSBvZiBhbiBvblVwZGF0ZS9vbkNvbXBsZXRlXG4gICAgICAgICAgICAgIHBhdXNlVHdlZW4gPSAwO1xuICAgICAgICAgICAgICBuZXh0ICYmICh0VGltZSArPSB0aGlzLl96VGltZSA9IGFkanVzdGVkVGltZSA/IC1fdGlueU51bSA6IF90aW55TnVtKTsgLy8gaXQgZGlkbid0IGZpbmlzaCByZW5kZXJpbmcsIHNvIGFkanVzdCB6VGltZSBzbyB0aGF0IHNvIHRoYXQgdGhlIG5leHQgdGltZSByZW5kZXIoKSBpcyBjYWxsZWQgaXQnbGwgYmUgZm9yY2VkICh0byByZW5kZXIgYW55IHJlbWFpbmluZyBjaGlsZHJlbilcblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjaGlsZCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHBhdXNlVHdlZW4gJiYgIXN1cHByZXNzRXZlbnRzKSB7XG4gICAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgICAgcGF1c2VUd2Vlbi5yZW5kZXIodGltZSA+PSBwcmV2VGltZSA/IDAgOiAtX3RpbnlOdW0pLl96VGltZSA9IHRpbWUgPj0gcHJldlRpbWUgPyAxIDogLTE7XG5cbiAgICAgICAgaWYgKHRoaXMuX3RzKSB7XG4gICAgICAgICAgLy90aGUgY2FsbGJhY2sgcmVzdW1lZCBwbGF5YmFjayEgU28gc2luY2Ugd2UgbWF5IGhhdmUgaGVsZCBiYWNrIHRoZSBwbGF5aGVhZCBkdWUgdG8gd2hlcmUgdGhlIHBhdXNlIGlzIHBvc2l0aW9uZWQsIGdvIGFoZWFkIGFuZCBqdW1wIHRvIHdoZXJlIGl0J3MgU1VQUE9TRUQgdG8gYmUgKGlmIG5vIHBhdXNlIGhhcHBlbmVkKS5cbiAgICAgICAgICB0aGlzLl9zdGFydCA9IHByZXZTdGFydDsgLy9pZiB0aGUgcGF1c2Ugd2FzIGF0IGFuIGVhcmxpZXIgdGltZSBhbmQgdGhlIHVzZXIgcmVzdW1lZCBpbiB0aGUgY2FsbGJhY2ssIGl0IGNvdWxkIHJlcG9zaXRpb24gdGhlIHRpbWVsaW5lIChjaGFuZ2luZyBpdHMgc3RhcnRUaW1lKSwgdGhyb3dpbmcgdGhpbmdzIG9mZiBzbGlnaHRseSwgc28gd2UgbWFrZSBzdXJlIHRoZSBfc3RhcnQgZG9lc24ndCBzaGlmdC5cblxuICAgICAgICAgIF9zZXRFbmQodGhpcyk7XG5cbiAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXIodG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX29uVXBkYXRlICYmICFzdXBwcmVzc0V2ZW50cyAmJiBfY2FsbGJhY2sodGhpcywgXCJvblVwZGF0ZVwiLCB0cnVlKTtcbiAgICAgIGlmICh0VGltZSA9PT0gdER1ciAmJiB0RHVyID49IHRoaXMudG90YWxEdXJhdGlvbigpIHx8ICF0VGltZSAmJiBwcmV2VGltZSkgaWYgKHByZXZTdGFydCA9PT0gdGhpcy5fc3RhcnQgfHwgTWF0aC5hYnModGltZVNjYWxlKSAhPT0gTWF0aC5hYnModGhpcy5fdHMpKSBpZiAoIXRoaXMuX2xvY2spIHtcbiAgICAgICAgKHRvdGFsVGltZSB8fCAhZHVyKSAmJiAodFRpbWUgPT09IHREdXIgJiYgdGhpcy5fdHMgPiAwIHx8ICF0VGltZSAmJiB0aGlzLl90cyA8IDApICYmIF9yZW1vdmVGcm9tUGFyZW50KHRoaXMsIDEpOyAvLyBkb24ndCByZW1vdmUgaWYgdGhlIHRpbWVsaW5lIGlzIHJldmVyc2VkIGFuZCB0aGUgcGxheWhlYWQgaXNuJ3QgYXQgMCwgb3RoZXJ3aXNlIHRsLnByb2dyZXNzKDEpLnJldmVyc2UoKSB3b24ndCB3b3JrLiBPbmx5IHJlbW92ZSBpZiB0aGUgcGxheWhlYWQgaXMgYXQgdGhlIGVuZCBhbmQgdGltZVNjYWxlIGlzIHBvc2l0aXZlLCBvciBpZiB0aGUgcGxheWhlYWQgaXMgYXQgMCBhbmQgdGhlIHRpbWVTY2FsZSBpcyBuZWdhdGl2ZS5cblxuICAgICAgICBpZiAoIXN1cHByZXNzRXZlbnRzICYmICEodG90YWxUaW1lIDwgMCAmJiAhcHJldlRpbWUpICYmICh0VGltZSB8fCBwcmV2VGltZSkpIHtcbiAgICAgICAgICBfY2FsbGJhY2sodGhpcywgdFRpbWUgPT09IHREdXIgPyBcIm9uQ29tcGxldGVcIiA6IFwib25SZXZlcnNlQ29tcGxldGVcIiwgdHJ1ZSk7XG5cbiAgICAgICAgICB0aGlzLl9wcm9tICYmICEodFRpbWUgPCB0RHVyICYmIHRoaXMudGltZVNjYWxlKCkgPiAwKSAmJiB0aGlzLl9wcm9tKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8yLmFkZCA9IGZ1bmN0aW9uIGFkZChjaGlsZCwgcG9zaXRpb24pIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIGlmICghX2lzTnVtYmVyKHBvc2l0aW9uKSkge1xuICAgICAgcG9zaXRpb24gPSBfcGFyc2VQb3NpdGlvbih0aGlzLCBwb3NpdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKCEoY2hpbGQgaW5zdGFuY2VvZiBBbmltYXRpb24pKSB7XG4gICAgICBpZiAoX2lzQXJyYXkoY2hpbGQpKSB7XG4gICAgICAgIGNoaWxkLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgIHJldHVybiBfdGhpczIuYWRkKG9iaiwgcG9zaXRpb24pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF91bmNhY2hlKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoX2lzU3RyaW5nKGNoaWxkKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRMYWJlbChjaGlsZCwgcG9zaXRpb24pO1xuICAgICAgfVxuXG4gICAgICBpZiAoX2lzRnVuY3Rpb24oY2hpbGQpKSB7XG4gICAgICAgIGNoaWxkID0gVHdlZW4uZGVsYXllZENhbGwoMCwgY2hpbGQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMgIT09IGNoaWxkID8gX2FkZFRvVGltZWxpbmUodGhpcywgY2hpbGQsIHBvc2l0aW9uKSA6IHRoaXM7IC8vZG9uJ3QgYWxsb3cgYSB0aW1lbGluZSB0byBiZSBhZGRlZCB0byBpdHNlbGYgYXMgYSBjaGlsZCFcbiAgfTtcblxuICBfcHJvdG8yLmdldENoaWxkcmVuID0gZnVuY3Rpb24gZ2V0Q2hpbGRyZW4obmVzdGVkLCB0d2VlbnMsIHRpbWVsaW5lcywgaWdub3JlQmVmb3JlVGltZSkge1xuICAgIGlmIChuZXN0ZWQgPT09IHZvaWQgMCkge1xuICAgICAgbmVzdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodHdlZW5zID09PSB2b2lkIDApIHtcbiAgICAgIHR3ZWVucyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRpbWVsaW5lcyA9PT0gdm9pZCAwKSB7XG4gICAgICB0aW1lbGluZXMgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChpZ25vcmVCZWZvcmVUaW1lID09PSB2b2lkIDApIHtcbiAgICAgIGlnbm9yZUJlZm9yZVRpbWUgPSAtX2JpZ051bTtcbiAgICB9XG5cbiAgICB2YXIgYSA9IFtdLFxuICAgICAgICBjaGlsZCA9IHRoaXMuX2ZpcnN0O1xuXG4gICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICBpZiAoY2hpbGQuX3N0YXJ0ID49IGlnbm9yZUJlZm9yZVRpbWUpIHtcbiAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgVHdlZW4pIHtcbiAgICAgICAgICB0d2VlbnMgJiYgYS5wdXNoKGNoaWxkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aW1lbGluZXMgJiYgYS5wdXNoKGNoaWxkKTtcbiAgICAgICAgICBuZXN0ZWQgJiYgYS5wdXNoLmFwcGx5KGEsIGNoaWxkLmdldENoaWxkcmVuKHRydWUsIHR3ZWVucywgdGltZWxpbmVzKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2hpbGQgPSBjaGlsZC5fbmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gYTtcbiAgfTtcblxuICBfcHJvdG8yLmdldEJ5SWQgPSBmdW5jdGlvbiBnZXRCeUlkKGlkKSB7XG4gICAgdmFyIGFuaW1hdGlvbnMgPSB0aGlzLmdldENoaWxkcmVuKDEsIDEsIDEpLFxuICAgICAgICBpID0gYW5pbWF0aW9ucy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBpZiAoYW5pbWF0aW9uc1tpXS52YXJzLmlkID09PSBpZCkge1xuICAgICAgICByZXR1cm4gYW5pbWF0aW9uc1tpXTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvMi5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoY2hpbGQpIHtcbiAgICBpZiAoX2lzU3RyaW5nKGNoaWxkKSkge1xuICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlTGFiZWwoY2hpbGQpO1xuICAgIH1cblxuICAgIGlmIChfaXNGdW5jdGlvbihjaGlsZCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmtpbGxUd2VlbnNPZihjaGlsZCk7XG4gICAgfVxuXG4gICAgX3JlbW92ZUxpbmtlZExpc3RJdGVtKHRoaXMsIGNoaWxkKTtcblxuICAgIGlmIChjaGlsZCA9PT0gdGhpcy5fcmVjZW50KSB7XG4gICAgICB0aGlzLl9yZWNlbnQgPSB0aGlzLl9sYXN0O1xuICAgIH1cblxuICAgIHJldHVybiBfdW5jYWNoZSh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8yLnRvdGFsVGltZSA9IGZ1bmN0aW9uIHRvdGFsVGltZShfdG90YWxUaW1lMiwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLl90VGltZTtcbiAgICB9XG5cbiAgICB0aGlzLl9mb3JjaW5nID0gMTtcblxuICAgIGlmICghdGhpcy5fZHAgJiYgdGhpcy5fdHMpIHtcbiAgICAgIC8vc3BlY2lhbCBjYXNlIGZvciB0aGUgZ2xvYmFsIHRpbWVsaW5lIChvciBhbnkgb3RoZXIgdGhhdCBoYXMgbm8gcGFyZW50IG9yIGRldGFjaGVkIHBhcmVudCkuXG4gICAgICB0aGlzLl9zdGFydCA9IF9yb3VuZChfdGlja2VyLnRpbWUgLSAodGhpcy5fdHMgPiAwID8gX3RvdGFsVGltZTIgLyB0aGlzLl90cyA6ICh0aGlzLnRvdGFsRHVyYXRpb24oKSAtIF90b3RhbFRpbWUyKSAvIC10aGlzLl90cykpO1xuICAgIH1cblxuICAgIF9BbmltYXRpb24ucHJvdG90eXBlLnRvdGFsVGltZS5jYWxsKHRoaXMsIF90b3RhbFRpbWUyLCBzdXBwcmVzc0V2ZW50cyk7XG5cbiAgICB0aGlzLl9mb3JjaW5nID0gMDtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8yLmFkZExhYmVsID0gZnVuY3Rpb24gYWRkTGFiZWwobGFiZWwsIHBvc2l0aW9uKSB7XG4gICAgdGhpcy5sYWJlbHNbbGFiZWxdID0gX3BhcnNlUG9zaXRpb24odGhpcywgcG9zaXRpb24pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzIucmVtb3ZlTGFiZWwgPSBmdW5jdGlvbiByZW1vdmVMYWJlbChsYWJlbCkge1xuICAgIGRlbGV0ZSB0aGlzLmxhYmVsc1tsYWJlbF07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvMi5hZGRQYXVzZSA9IGZ1bmN0aW9uIGFkZFBhdXNlKHBvc2l0aW9uLCBjYWxsYmFjaywgcGFyYW1zKSB7XG4gICAgdmFyIHQgPSBUd2Vlbi5kZWxheWVkQ2FsbCgwLCBjYWxsYmFjayB8fCBfZW1wdHlGdW5jLCBwYXJhbXMpO1xuICAgIHQuZGF0YSA9IFwiaXNQYXVzZVwiO1xuICAgIHRoaXMuX2hhc1BhdXNlID0gMTtcbiAgICByZXR1cm4gX2FkZFRvVGltZWxpbmUodGhpcywgdCwgX3BhcnNlUG9zaXRpb24odGhpcywgcG9zaXRpb24pKTtcbiAgfTtcblxuICBfcHJvdG8yLnJlbW92ZVBhdXNlID0gZnVuY3Rpb24gcmVtb3ZlUGF1c2UocG9zaXRpb24pIHtcbiAgICB2YXIgY2hpbGQgPSB0aGlzLl9maXJzdDtcbiAgICBwb3NpdGlvbiA9IF9wYXJzZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKTtcblxuICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgaWYgKGNoaWxkLl9zdGFydCA9PT0gcG9zaXRpb24gJiYgY2hpbGQuZGF0YSA9PT0gXCJpc1BhdXNlXCIpIHtcbiAgICAgICAgX3JlbW92ZUZyb21QYXJlbnQoY2hpbGQpO1xuICAgICAgfVxuXG4gICAgICBjaGlsZCA9IGNoaWxkLl9uZXh0O1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8yLmtpbGxUd2VlbnNPZiA9IGZ1bmN0aW9uIGtpbGxUd2VlbnNPZih0YXJnZXRzLCBwcm9wcywgb25seUFjdGl2ZSkge1xuICAgIHZhciB0d2VlbnMgPSB0aGlzLmdldFR3ZWVuc09mKHRhcmdldHMsIG9ubHlBY3RpdmUpLFxuICAgICAgICBpID0gdHdlZW5zLmxlbmd0aDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIF9vdmVyd3JpdGluZ1R3ZWVuICE9PSB0d2VlbnNbaV0gJiYgdHdlZW5zW2ldLmtpbGwodGFyZ2V0cywgcHJvcHMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzIuZ2V0VHdlZW5zT2YgPSBmdW5jdGlvbiBnZXRUd2VlbnNPZih0YXJnZXRzLCBvbmx5QWN0aXZlKSB7XG4gICAgdmFyIGEgPSBbXSxcbiAgICAgICAgcGFyc2VkVGFyZ2V0cyA9IHRvQXJyYXkodGFyZ2V0cyksXG4gICAgICAgIGNoaWxkID0gdGhpcy5fZmlyc3QsXG4gICAgICAgIGlzR2xvYmFsVGltZSA9IF9pc051bWJlcihvbmx5QWN0aXZlKSxcbiAgICAgICAgLy8gYSBudW1iZXIgaXMgaW50ZXJwcmV0ZWQgYXMgYSBnbG9iYWwgdGltZS4gSWYgdGhlIGFuaW1hdGlvbiBzcGFuc1xuICAgIGNoaWxkcmVuO1xuXG4gICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBUd2Vlbikge1xuICAgICAgICBpZiAoX2FycmF5Q29udGFpbnNBbnkoY2hpbGQuX3RhcmdldHMsIHBhcnNlZFRhcmdldHMpICYmIChpc0dsb2JhbFRpbWUgPyAoIV9vdmVyd3JpdGluZ1R3ZWVuIHx8IGNoaWxkLl9pbml0dGVkICYmIGNoaWxkLl90cykgJiYgY2hpbGQuZ2xvYmFsVGltZSgwKSA8PSBvbmx5QWN0aXZlICYmIGNoaWxkLmdsb2JhbFRpbWUoY2hpbGQudG90YWxEdXJhdGlvbigpKSA+IG9ubHlBY3RpdmUgOiAhb25seUFjdGl2ZSB8fCBjaGlsZC5pc0FjdGl2ZSgpKSkge1xuICAgICAgICAgIC8vIG5vdGU6IGlmIHRoaXMgaXMgZm9yIG92ZXJ3cml0aW5nLCBpdCBzaG91bGQgb25seSBiZSBmb3IgdHdlZW5zIHRoYXQgYXJlbid0IHBhdXNlZCBhbmQgYXJlIGluaXR0ZWQuXG4gICAgICAgICAgYS5wdXNoKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICgoY2hpbGRyZW4gPSBjaGlsZC5nZXRUd2VlbnNPZihwYXJzZWRUYXJnZXRzLCBvbmx5QWN0aXZlKSkubGVuZ3RoKSB7XG4gICAgICAgIGEucHVzaC5hcHBseShhLCBjaGlsZHJlbik7XG4gICAgICB9XG5cbiAgICAgIGNoaWxkID0gY2hpbGQuX25leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGE7XG4gIH07XG5cbiAgX3Byb3RvMi50d2VlblRvID0gZnVuY3Rpb24gdHdlZW5Ubyhwb3NpdGlvbiwgdmFycykge1xuICAgIHZhcnMgPSB2YXJzIHx8IHt9O1xuXG4gICAgdmFyIHRsID0gdGhpcyxcbiAgICAgICAgZW5kVGltZSA9IF9wYXJzZVBvc2l0aW9uKHRsLCBwb3NpdGlvbiksXG4gICAgICAgIF92YXJzID0gdmFycyxcbiAgICAgICAgc3RhcnRBdCA9IF92YXJzLnN0YXJ0QXQsXG4gICAgICAgIF9vblN0YXJ0ID0gX3ZhcnMub25TdGFydCxcbiAgICAgICAgb25TdGFydFBhcmFtcyA9IF92YXJzLm9uU3RhcnRQYXJhbXMsXG4gICAgICAgIHR3ZWVuID0gVHdlZW4udG8odGwsIF9zZXREZWZhdWx0cyh2YXJzLCB7XG4gICAgICBlYXNlOiBcIm5vbmVcIixcbiAgICAgIGxhenk6IGZhbHNlLFxuICAgICAgdGltZTogZW5kVGltZSxcbiAgICAgIGR1cmF0aW9uOiB2YXJzLmR1cmF0aW9uIHx8IE1hdGguYWJzKChlbmRUaW1lIC0gKHN0YXJ0QXQgJiYgXCJ0aW1lXCIgaW4gc3RhcnRBdCA/IHN0YXJ0QXQudGltZSA6IHRsLl90aW1lKSkgLyB0bC50aW1lU2NhbGUoKSkgfHwgX3RpbnlOdW0sXG4gICAgICBvblN0YXJ0OiBmdW5jdGlvbiBvblN0YXJ0KCkge1xuICAgICAgICB0bC5wYXVzZSgpO1xuICAgICAgICB2YXIgZHVyYXRpb24gPSB2YXJzLmR1cmF0aW9uIHx8IE1hdGguYWJzKChlbmRUaW1lIC0gdGwuX3RpbWUpIC8gdGwudGltZVNjYWxlKCkpO1xuICAgICAgICB0d2Vlbi5fZHVyICE9PSBkdXJhdGlvbiAmJiBfc2V0RHVyYXRpb24odHdlZW4sIGR1cmF0aW9uKS5yZW5kZXIodHdlZW4uX3RpbWUsIHRydWUsIHRydWUpO1xuICAgICAgICBfb25TdGFydCAmJiBfb25TdGFydC5hcHBseSh0d2Vlbiwgb25TdGFydFBhcmFtcyB8fCBbXSk7IC8vaW4gY2FzZSB0aGUgdXNlciBoYWQgYW4gb25TdGFydCBpbiB0aGUgdmFycyAtIHdlIGRvbid0IHdhbnQgdG8gb3ZlcndyaXRlIGl0LlxuICAgICAgfVxuICAgIH0pKTtcblxuICAgIHJldHVybiB0d2VlbjtcbiAgfTtcblxuICBfcHJvdG8yLnR3ZWVuRnJvbVRvID0gZnVuY3Rpb24gdHdlZW5Gcm9tVG8oZnJvbVBvc2l0aW9uLCB0b1Bvc2l0aW9uLCB2YXJzKSB7XG4gICAgcmV0dXJuIHRoaXMudHdlZW5Ubyh0b1Bvc2l0aW9uLCBfc2V0RGVmYXVsdHMoe1xuICAgICAgc3RhcnRBdDoge1xuICAgICAgICB0aW1lOiBfcGFyc2VQb3NpdGlvbih0aGlzLCBmcm9tUG9zaXRpb24pXG4gICAgICB9XG4gICAgfSwgdmFycykpO1xuICB9O1xuXG4gIF9wcm90bzIucmVjZW50ID0gZnVuY3Rpb24gcmVjZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9yZWNlbnQ7XG4gIH07XG5cbiAgX3Byb3RvMi5uZXh0TGFiZWwgPSBmdW5jdGlvbiBuZXh0TGFiZWwoYWZ0ZXJUaW1lKSB7XG4gICAgaWYgKGFmdGVyVGltZSA9PT0gdm9pZCAwKSB7XG4gICAgICBhZnRlclRpbWUgPSB0aGlzLl90aW1lO1xuICAgIH1cblxuICAgIHJldHVybiBfZ2V0TGFiZWxJbkRpcmVjdGlvbih0aGlzLCBfcGFyc2VQb3NpdGlvbih0aGlzLCBhZnRlclRpbWUpKTtcbiAgfTtcblxuICBfcHJvdG8yLnByZXZpb3VzTGFiZWwgPSBmdW5jdGlvbiBwcmV2aW91c0xhYmVsKGJlZm9yZVRpbWUpIHtcbiAgICBpZiAoYmVmb3JlVGltZSA9PT0gdm9pZCAwKSB7XG4gICAgICBiZWZvcmVUaW1lID0gdGhpcy5fdGltZTtcbiAgICB9XG5cbiAgICByZXR1cm4gX2dldExhYmVsSW5EaXJlY3Rpb24odGhpcywgX3BhcnNlUG9zaXRpb24odGhpcywgYmVmb3JlVGltZSksIDEpO1xuICB9O1xuXG4gIF9wcm90bzIuY3VycmVudExhYmVsID0gZnVuY3Rpb24gY3VycmVudExhYmVsKHZhbHVlKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLnNlZWsodmFsdWUsIHRydWUpIDogdGhpcy5wcmV2aW91c0xhYmVsKHRoaXMuX3RpbWUgKyBfdGlueU51bSk7XG4gIH07XG5cbiAgX3Byb3RvMi5zaGlmdENoaWxkcmVuID0gZnVuY3Rpb24gc2hpZnRDaGlsZHJlbihhbW91bnQsIGFkanVzdExhYmVscywgaWdub3JlQmVmb3JlVGltZSkge1xuICAgIGlmIChpZ25vcmVCZWZvcmVUaW1lID09PSB2b2lkIDApIHtcbiAgICAgIGlnbm9yZUJlZm9yZVRpbWUgPSAwO1xuICAgIH1cblxuICAgIHZhciBjaGlsZCA9IHRoaXMuX2ZpcnN0LFxuICAgICAgICBsYWJlbHMgPSB0aGlzLmxhYmVscyxcbiAgICAgICAgcDtcblxuICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgaWYgKGNoaWxkLl9zdGFydCA+PSBpZ25vcmVCZWZvcmVUaW1lKSB7XG4gICAgICAgIGNoaWxkLl9zdGFydCArPSBhbW91bnQ7XG4gICAgICB9XG5cbiAgICAgIGNoaWxkID0gY2hpbGQuX25leHQ7XG4gICAgfVxuXG4gICAgaWYgKGFkanVzdExhYmVscykge1xuICAgICAgZm9yIChwIGluIGxhYmVscykge1xuICAgICAgICBpZiAobGFiZWxzW3BdID49IGlnbm9yZUJlZm9yZVRpbWUpIHtcbiAgICAgICAgICBsYWJlbHNbcF0gKz0gYW1vdW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIF91bmNhY2hlKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90bzIuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uIGludmFsaWRhdGUoKSB7XG4gICAgdmFyIGNoaWxkID0gdGhpcy5fZmlyc3Q7XG4gICAgdGhpcy5fbG9jayA9IDA7XG5cbiAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgIGNoaWxkLmludmFsaWRhdGUoKTtcbiAgICAgIGNoaWxkID0gY2hpbGQuX25leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9BbmltYXRpb24ucHJvdG90eXBlLmludmFsaWRhdGUuY2FsbCh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8yLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoaW5jbHVkZUxhYmVscykge1xuICAgIGlmIChpbmNsdWRlTGFiZWxzID09PSB2b2lkIDApIHtcbiAgICAgIGluY2x1ZGVMYWJlbHMgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBjaGlsZCA9IHRoaXMuX2ZpcnN0LFxuICAgICAgICBuZXh0O1xuXG4gICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICBuZXh0ID0gY2hpbGQuX25leHQ7XG4gICAgICB0aGlzLnJlbW92ZShjaGlsZCk7XG4gICAgICBjaGlsZCA9IG5leHQ7XG4gICAgfVxuXG4gICAgdGhpcy5fdGltZSA9IHRoaXMuX3RUaW1lID0gdGhpcy5fcFRpbWUgPSAwO1xuXG4gICAgaWYgKGluY2x1ZGVMYWJlbHMpIHtcbiAgICAgIHRoaXMubGFiZWxzID0ge307XG4gICAgfVxuXG4gICAgcmV0dXJuIF91bmNhY2hlKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90bzIudG90YWxEdXJhdGlvbiA9IGZ1bmN0aW9uIHRvdGFsRHVyYXRpb24odmFsdWUpIHtcbiAgICB2YXIgbWF4ID0gMCxcbiAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgIGNoaWxkID0gc2VsZi5fbGFzdCxcbiAgICAgICAgcHJldlN0YXJ0ID0gX2JpZ051bSxcbiAgICAgICAgcHJldixcbiAgICAgICAgZW5kLFxuICAgICAgICBzdGFydCxcbiAgICAgICAgcGFyZW50O1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBzZWxmLnRpbWVTY2FsZSgoc2VsZi5fcmVwZWF0IDwgMCA/IHNlbGYuZHVyYXRpb24oKSA6IHNlbGYudG90YWxEdXJhdGlvbigpKSAvIChzZWxmLnJldmVyc2VkKCkgPyAtdmFsdWUgOiB2YWx1ZSkpO1xuICAgIH1cblxuICAgIGlmIChzZWxmLl9kaXJ0eSkge1xuICAgICAgcGFyZW50ID0gc2VsZi5wYXJlbnQ7XG5cbiAgICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgICBwcmV2ID0gY2hpbGQuX3ByZXY7IC8vcmVjb3JkIGl0IGhlcmUgaW4gY2FzZSB0aGUgdHdlZW4gY2hhbmdlcyBwb3NpdGlvbiBpbiB0aGUgc2VxdWVuY2UuLi5cblxuICAgICAgICBjaGlsZC5fZGlydHkgJiYgY2hpbGQudG90YWxEdXJhdGlvbigpOyAvL2NvdWxkIGNoYW5nZSB0aGUgdHdlZW4uX3N0YXJ0VGltZSwgc28gbWFrZSBzdXJlIHRoZSBhbmltYXRpb24ncyBjYWNoZSBpcyBjbGVhbiBiZWZvcmUgYW5hbHl6aW5nIGl0LlxuXG4gICAgICAgIHN0YXJ0ID0gY2hpbGQuX3N0YXJ0O1xuXG4gICAgICAgIGlmIChzdGFydCA+IHByZXZTdGFydCAmJiBzZWxmLl9zb3J0ICYmIGNoaWxkLl90cyAmJiAhc2VsZi5fbG9jaykge1xuICAgICAgICAgIC8vaW4gY2FzZSBvbmUgb2YgdGhlIHR3ZWVucyBzaGlmdGVkIG91dCBvZiBvcmRlciwgaXQgbmVlZHMgdG8gYmUgcmUtaW5zZXJ0ZWQgaW50byB0aGUgY29ycmVjdCBwb3NpdGlvbiBpbiB0aGUgc2VxdWVuY2VcbiAgICAgICAgICBzZWxmLl9sb2NrID0gMTsgLy9wcmV2ZW50IGVuZGxlc3MgcmVjdXJzaXZlIGNhbGxzIC0gdGhlcmUgYXJlIG1ldGhvZHMgdGhhdCBnZXQgdHJpZ2dlcmVkIHRoYXQgY2hlY2sgZHVyYXRpb24vdG90YWxEdXJhdGlvbiB3aGVuIHdlIGFkZCgpLlxuXG4gICAgICAgICAgX2FkZFRvVGltZWxpbmUoc2VsZiwgY2hpbGQsIHN0YXJ0IC0gY2hpbGQuX2RlbGF5LCAxKS5fbG9jayA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldlN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhcnQgPCAwICYmIGNoaWxkLl90cykge1xuICAgICAgICAgIC8vY2hpbGRyZW4gYXJlbid0IGFsbG93ZWQgdG8gaGF2ZSBuZWdhdGl2ZSBzdGFydFRpbWVzIHVubGVzcyBzbW9vdGhDaGlsZFRpbWluZyBpcyB0cnVlLCBzbyBhZGp1c3QgaGVyZSBpZiBvbmUgaXMgZm91bmQuXG4gICAgICAgICAgbWF4IC09IHN0YXJ0O1xuXG4gICAgICAgICAgaWYgKCFwYXJlbnQgJiYgIXNlbGYuX2RwIHx8IHBhcmVudCAmJiBwYXJlbnQuc21vb3RoQ2hpbGRUaW1pbmcpIHtcbiAgICAgICAgICAgIHNlbGYuX3N0YXJ0ICs9IHN0YXJ0IC8gc2VsZi5fdHM7XG4gICAgICAgICAgICBzZWxmLl90aW1lIC09IHN0YXJ0O1xuICAgICAgICAgICAgc2VsZi5fdFRpbWUgLT0gc3RhcnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VsZi5zaGlmdENoaWxkcmVuKC1zdGFydCwgZmFsc2UsIC0xZTk5OSk7XG4gICAgICAgICAgcHJldlN0YXJ0ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGVuZCA9IF9zZXRFbmQoY2hpbGQpO1xuXG4gICAgICAgIGlmIChlbmQgPiBtYXggJiYgY2hpbGQuX3RzKSB7XG4gICAgICAgICAgbWF4ID0gZW5kO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGQgPSBwcmV2O1xuICAgICAgfVxuXG4gICAgICBfc2V0RHVyYXRpb24oc2VsZiwgc2VsZiA9PT0gX2dsb2JhbFRpbWVsaW5lICYmIHNlbGYuX3RpbWUgPiBtYXggPyBzZWxmLl90aW1lIDogbWF4LCAxKTtcblxuICAgICAgc2VsZi5fZGlydHkgPSAwO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxmLl90RHVyO1xuICB9O1xuXG4gIFRpbWVsaW5lLnVwZGF0ZVJvb3QgPSBmdW5jdGlvbiB1cGRhdGVSb290KHRpbWUpIHtcbiAgICBpZiAoX2dsb2JhbFRpbWVsaW5lLl90cykge1xuICAgICAgX2xhenlTYWZlUmVuZGVyKF9nbG9iYWxUaW1lbGluZSwgX3BhcmVudFRvQ2hpbGRUb3RhbFRpbWUodGltZSwgX2dsb2JhbFRpbWVsaW5lKSk7XG5cbiAgICAgIF9sYXN0UmVuZGVyZWRGcmFtZSA9IF90aWNrZXIuZnJhbWU7XG4gICAgfVxuXG4gICAgaWYgKF90aWNrZXIuZnJhbWUgPj0gX25leHRHQ0ZyYW1lKSB7XG4gICAgICBfbmV4dEdDRnJhbWUgKz0gX2NvbmZpZy5hdXRvU2xlZXAgfHwgMTIwO1xuICAgICAgdmFyIGNoaWxkID0gX2dsb2JhbFRpbWVsaW5lLl9maXJzdDtcbiAgICAgIGlmICghY2hpbGQgfHwgIWNoaWxkLl90cykgaWYgKF9jb25maWcuYXV0b1NsZWVwICYmIF90aWNrZXIuX2xpc3RlbmVycy5sZW5ndGggPCAyKSB7XG4gICAgICAgIHdoaWxlIChjaGlsZCAmJiAhY2hpbGQuX3RzKSB7XG4gICAgICAgICAgY2hpbGQgPSBjaGlsZC5fbmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoaWxkIHx8IF90aWNrZXIuc2xlZXAoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFRpbWVsaW5lO1xufShBbmltYXRpb24pO1xuXG5fc2V0RGVmYXVsdHMoVGltZWxpbmUucHJvdG90eXBlLCB7XG4gIF9sb2NrOiAwLFxuICBfaGFzUGF1c2U6IDAsXG4gIF9mb3JjaW5nOiAwXG59KTtcblxudmFyIF9hZGRDb21wbGV4U3RyaW5nUHJvcFR3ZWVuID0gZnVuY3Rpb24gX2FkZENvbXBsZXhTdHJpbmdQcm9wVHdlZW4odGFyZ2V0LCBwcm9wLCBzdGFydCwgZW5kLCBzZXR0ZXIsIHN0cmluZ0ZpbHRlciwgZnVuY1BhcmFtKSB7XG4gIC8vbm90ZTogd2UgY2FsbCBfYWRkQ29tcGxleFN0cmluZ1Byb3BUd2Vlbi5jYWxsKHR3ZWVuSW5zdGFuY2UuLi4pIHRvIGVuc3VyZSB0aGF0IGl0J3Mgc2NvcGVkIHByb3Blcmx5LiBXZSBtYXkgY2FsbCBpdCBmcm9tIHdpdGhpbiBhIHBsdWdpbiB0b28sIHRodXMgXCJ0aGlzXCIgd291bGQgcmVmZXIgdG8gdGhlIHBsdWdpbi5cbiAgdmFyIHB0ID0gbmV3IFByb3BUd2Vlbih0aGlzLl9wdCwgdGFyZ2V0LCBwcm9wLCAwLCAxLCBfcmVuZGVyQ29tcGxleFN0cmluZywgbnVsbCwgc2V0dGVyKSxcbiAgICAgIGluZGV4ID0gMCxcbiAgICAgIG1hdGNoSW5kZXggPSAwLFxuICAgICAgcmVzdWx0LFxuICAgICAgc3RhcnROdW1zLFxuICAgICAgY29sb3IsXG4gICAgICBlbmROdW0sXG4gICAgICBjaHVuayxcbiAgICAgIHN0YXJ0TnVtLFxuICAgICAgaGFzUmFuZG9tLFxuICAgICAgYTtcbiAgcHQuYiA9IHN0YXJ0O1xuICBwdC5lID0gZW5kO1xuICBzdGFydCArPSBcIlwiOyAvL2Vuc3VyZSB2YWx1ZXMgYXJlIHN0cmluZ3NcblxuICBlbmQgKz0gXCJcIjtcblxuICBpZiAoaGFzUmFuZG9tID0gfmVuZC5pbmRleE9mKFwicmFuZG9tKFwiKSkge1xuICAgIGVuZCA9IF9yZXBsYWNlUmFuZG9tKGVuZCk7XG4gIH1cblxuICBpZiAoc3RyaW5nRmlsdGVyKSB7XG4gICAgYSA9IFtzdGFydCwgZW5kXTtcbiAgICBzdHJpbmdGaWx0ZXIoYSwgdGFyZ2V0LCBwcm9wKTsgLy9wYXNzIGFuIGFycmF5IHdpdGggdGhlIHN0YXJ0aW5nIGFuZCBlbmRpbmcgdmFsdWVzIGFuZCBsZXQgdGhlIGZpbHRlciBkbyB3aGF0ZXZlciBpdCBuZWVkcyB0byB0aGUgdmFsdWVzLlxuXG4gICAgc3RhcnQgPSBhWzBdO1xuICAgIGVuZCA9IGFbMV07XG4gIH1cblxuICBzdGFydE51bXMgPSBzdGFydC5tYXRjaChfY29tcGxleFN0cmluZ051bUV4cCkgfHwgW107XG5cbiAgd2hpbGUgKHJlc3VsdCA9IF9jb21wbGV4U3RyaW5nTnVtRXhwLmV4ZWMoZW5kKSkge1xuICAgIGVuZE51bSA9IHJlc3VsdFswXTtcbiAgICBjaHVuayA9IGVuZC5zdWJzdHJpbmcoaW5kZXgsIHJlc3VsdC5pbmRleCk7XG5cbiAgICBpZiAoY29sb3IpIHtcbiAgICAgIGNvbG9yID0gKGNvbG9yICsgMSkgJSA1O1xuICAgIH0gZWxzZSBpZiAoY2h1bmsuc3Vic3RyKC01KSA9PT0gXCJyZ2JhKFwiKSB7XG4gICAgICBjb2xvciA9IDE7XG4gICAgfVxuXG4gICAgaWYgKGVuZE51bSAhPT0gc3RhcnROdW1zW21hdGNoSW5kZXgrK10pIHtcbiAgICAgIHN0YXJ0TnVtID0gcGFyc2VGbG9hdChzdGFydE51bXNbbWF0Y2hJbmRleCAtIDFdKSB8fCAwOyAvL3RoZXNlIG5lc3RlZCBQcm9wVHdlZW5zIGFyZSBoYW5kbGVkIGluIGEgc3BlY2lhbCB3YXkgLSB3ZSdsbCBuZXZlciBhY3R1YWxseSBjYWxsIGEgcmVuZGVyIG9yIHNldHRlciBtZXRob2Qgb24gdGhlbS4gV2UnbGwganVzdCBsb29wIHRocm91Z2ggdGhlbSBpbiB0aGUgcGFyZW50IGNvbXBsZXggc3RyaW5nIFByb3BUd2VlbidzIHJlbmRlciBtZXRob2QuXG5cbiAgICAgIHB0Ll9wdCA9IHtcbiAgICAgICAgX25leHQ6IHB0Ll9wdCxcbiAgICAgICAgcDogY2h1bmsgfHwgbWF0Y2hJbmRleCA9PT0gMSA/IGNodW5rIDogXCIsXCIsXG4gICAgICAgIC8vbm90ZTogU1ZHIHNwZWMgYWxsb3dzIG9taXNzaW9uIG9mIGNvbW1hL3NwYWNlIHdoZW4gYSBuZWdhdGl2ZSBzaWduIGlzIHdlZGdlZCBiZXR3ZWVuIHR3byBudW1iZXJzLCBsaWtlIDIuNS01LjMgaW5zdGVhZCBvZiAyLjUsLTUuMyBidXQgd2hlbiB0d2VlbmluZywgdGhlIG5lZ2F0aXZlIHZhbHVlIG1heSBzd2l0Y2ggdG8gcG9zaXRpdmUsIHNvIHdlIGluc2VydCB0aGUgY29tbWEganVzdCBpbiBjYXNlLlxuICAgICAgICBzOiBzdGFydE51bSxcbiAgICAgICAgYzogZW5kTnVtLmNoYXJBdCgxKSA9PT0gXCI9XCIgPyBwYXJzZUZsb2F0KGVuZE51bS5zdWJzdHIoMikpICogKGVuZE51bS5jaGFyQXQoMCkgPT09IFwiLVwiID8gLTEgOiAxKSA6IHBhcnNlRmxvYXQoZW5kTnVtKSAtIHN0YXJ0TnVtLFxuICAgICAgICBtOiBjb2xvciAmJiBjb2xvciA8IDQgPyBNYXRoLnJvdW5kIDogMFxuICAgICAgfTtcbiAgICAgIGluZGV4ID0gX2NvbXBsZXhTdHJpbmdOdW1FeHAubGFzdEluZGV4O1xuICAgIH1cbiAgfVxuXG4gIHB0LmMgPSBpbmRleCA8IGVuZC5sZW5ndGggPyBlbmQuc3Vic3RyaW5nKGluZGV4LCBlbmQubGVuZ3RoKSA6IFwiXCI7IC8vd2UgdXNlIHRoZSBcImNcIiBvZiB0aGUgUHJvcFR3ZWVuIHRvIHN0b3JlIHRoZSBmaW5hbCBwYXJ0IG9mIHRoZSBzdHJpbmcgKGFmdGVyIHRoZSBsYXN0IG51bWJlcilcblxuICBwdC5mcCA9IGZ1bmNQYXJhbTtcblxuICBpZiAoX3JlbEV4cC50ZXN0KGVuZCkgfHwgaGFzUmFuZG9tKSB7XG4gICAgcHQuZSA9IDA7IC8vaWYgdGhlIGVuZCBzdHJpbmcgY29udGFpbnMgcmVsYXRpdmUgdmFsdWVzIG9yIGR5bmFtaWMgcmFuZG9tKC4uLikgdmFsdWVzLCBkZWxldGUgdGhlIGVuZCBpdCBzbyB0aGF0IG9uIHRoZSBmaW5hbCByZW5kZXIgd2UgZG9uJ3QgYWN0dWFsbHkgc2V0IGl0IHRvIHRoZSBzdHJpbmcgd2l0aCArPSBvciAtPSBjaGFyYWN0ZXJzIChmb3JjZXMgaXQgdG8gdXNlIHRoZSBjYWxjdWxhdGVkIHZhbHVlKS5cbiAgfVxuXG4gIHRoaXMuX3B0ID0gcHQ7IC8vc3RhcnQgdGhlIGxpbmtlZCBsaXN0IHdpdGggdGhpcyBuZXcgUHJvcFR3ZWVuLiBSZW1lbWJlciwgd2UgY2FsbCBfYWRkQ29tcGxleFN0cmluZ1Byb3BUd2Vlbi5jYWxsKHR3ZWVuSW5zdGFuY2UuLi4pIHRvIGVuc3VyZSB0aGF0IGl0J3Mgc2NvcGVkIHByb3Blcmx5LiBXZSBtYXkgY2FsbCBpdCBmcm9tIHdpdGhpbiBhIHBsdWdpbiB0b28sIHRodXMgXCJ0aGlzXCIgd291bGQgcmVmZXIgdG8gdGhlIHBsdWdpbi5cblxuICByZXR1cm4gcHQ7XG59LFxuICAgIF9hZGRQcm9wVHdlZW4gPSBmdW5jdGlvbiBfYWRkUHJvcFR3ZWVuKHRhcmdldCwgcHJvcCwgc3RhcnQsIGVuZCwgaW5kZXgsIHRhcmdldHMsIG1vZGlmaWVyLCBzdHJpbmdGaWx0ZXIsIGZ1bmNQYXJhbSkge1xuICBfaXNGdW5jdGlvbihlbmQpICYmIChlbmQgPSBlbmQoaW5kZXggfHwgMCwgdGFyZ2V0LCB0YXJnZXRzKSk7XG4gIHZhciBjdXJyZW50VmFsdWUgPSB0YXJnZXRbcHJvcF0sXG4gICAgICBwYXJzZWRTdGFydCA9IHN0YXJ0ICE9PSBcImdldFwiID8gc3RhcnQgOiAhX2lzRnVuY3Rpb24oY3VycmVudFZhbHVlKSA/IGN1cnJlbnRWYWx1ZSA6IGZ1bmNQYXJhbSA/IHRhcmdldFtwcm9wLmluZGV4T2YoXCJzZXRcIikgfHwgIV9pc0Z1bmN0aW9uKHRhcmdldFtcImdldFwiICsgcHJvcC5zdWJzdHIoMyldKSA/IHByb3AgOiBcImdldFwiICsgcHJvcC5zdWJzdHIoMyldKGZ1bmNQYXJhbSkgOiB0YXJnZXRbcHJvcF0oKSxcbiAgICAgIHNldHRlciA9ICFfaXNGdW5jdGlvbihjdXJyZW50VmFsdWUpID8gX3NldHRlclBsYWluIDogZnVuY1BhcmFtID8gX3NldHRlckZ1bmNXaXRoUGFyYW0gOiBfc2V0dGVyRnVuYyxcbiAgICAgIHB0O1xuXG4gIGlmIChfaXNTdHJpbmcoZW5kKSkge1xuICAgIGlmICh+ZW5kLmluZGV4T2YoXCJyYW5kb20oXCIpKSB7XG4gICAgICBlbmQgPSBfcmVwbGFjZVJhbmRvbShlbmQpO1xuICAgIH1cblxuICAgIGlmIChlbmQuY2hhckF0KDEpID09PSBcIj1cIikge1xuICAgICAgZW5kID0gcGFyc2VGbG9hdChwYXJzZWRTdGFydCkgKyBwYXJzZUZsb2F0KGVuZC5zdWJzdHIoMikpICogKGVuZC5jaGFyQXQoMCkgPT09IFwiLVwiID8gLTEgOiAxKSArIChnZXRVbml0KHBhcnNlZFN0YXJ0KSB8fCAwKTtcbiAgICB9XG4gIH1cblxuICBpZiAocGFyc2VkU3RhcnQgIT09IGVuZCkge1xuICAgIGlmICghaXNOYU4ocGFyc2VkU3RhcnQgKiBlbmQpKSB7XG4gICAgICBwdCA9IG5ldyBQcm9wVHdlZW4odGhpcy5fcHQsIHRhcmdldCwgcHJvcCwgK3BhcnNlZFN0YXJ0IHx8IDAsIGVuZCAtIChwYXJzZWRTdGFydCB8fCAwKSwgdHlwZW9mIGN1cnJlbnRWYWx1ZSA9PT0gXCJib29sZWFuXCIgPyBfcmVuZGVyQm9vbGVhbiA6IF9yZW5kZXJQbGFpbiwgMCwgc2V0dGVyKTtcbiAgICAgIGZ1bmNQYXJhbSAmJiAocHQuZnAgPSBmdW5jUGFyYW0pO1xuICAgICAgbW9kaWZpZXIgJiYgcHQubW9kaWZpZXIobW9kaWZpZXIsIHRoaXMsIHRhcmdldCk7XG4gICAgICByZXR1cm4gdGhpcy5fcHQgPSBwdDtcbiAgICB9XG5cbiAgICAhY3VycmVudFZhbHVlICYmICEocHJvcCBpbiB0YXJnZXQpICYmIF9taXNzaW5nUGx1Z2luKHByb3AsIGVuZCk7XG4gICAgcmV0dXJuIF9hZGRDb21wbGV4U3RyaW5nUHJvcFR3ZWVuLmNhbGwodGhpcywgdGFyZ2V0LCBwcm9wLCBwYXJzZWRTdGFydCwgZW5kLCBzZXR0ZXIsIHN0cmluZ0ZpbHRlciB8fCBfY29uZmlnLnN0cmluZ0ZpbHRlciwgZnVuY1BhcmFtKTtcbiAgfVxufSxcbiAgICAvL2NyZWF0ZXMgYSBjb3B5IG9mIHRoZSB2YXJzIG9iamVjdCBhbmQgcHJvY2Vzc2VzIGFueSBmdW5jdGlvbi1iYXNlZCB2YWx1ZXMgKHB1dHRpbmcgdGhlIHJlc3VsdGluZyB2YWx1ZXMgZGlyZWN0bHkgaW50byB0aGUgY29weSkgYXMgd2VsbCBhcyBzdHJpbmdzIHdpdGggXCJyYW5kb20oKVwiIGluIHRoZW0uIEl0IGRvZXMgTk9UIHByb2Nlc3MgcmVsYXRpdmUgdmFsdWVzLlxuX3Byb2Nlc3NWYXJzID0gZnVuY3Rpb24gX3Byb2Nlc3NWYXJzKHZhcnMsIGluZGV4LCB0YXJnZXQsIHRhcmdldHMsIHR3ZWVuKSB7XG4gIGlmIChfaXNGdW5jdGlvbih2YXJzKSkge1xuICAgIHZhcnMgPSBfcGFyc2VGdW5jT3JTdHJpbmcodmFycywgdHdlZW4sIGluZGV4LCB0YXJnZXQsIHRhcmdldHMpO1xuICB9XG5cbiAgaWYgKCFfaXNPYmplY3QodmFycykgfHwgdmFycy5zdHlsZSAmJiB2YXJzLm5vZGVUeXBlIHx8IF9pc0FycmF5KHZhcnMpKSB7XG4gICAgcmV0dXJuIF9pc1N0cmluZyh2YXJzKSA/IF9wYXJzZUZ1bmNPclN0cmluZyh2YXJzLCB0d2VlbiwgaW5kZXgsIHRhcmdldCwgdGFyZ2V0cykgOiB2YXJzO1xuICB9XG5cbiAgdmFyIGNvcHkgPSB7fSxcbiAgICAgIHA7XG5cbiAgZm9yIChwIGluIHZhcnMpIHtcbiAgICBjb3B5W3BdID0gX3BhcnNlRnVuY09yU3RyaW5nKHZhcnNbcF0sIHR3ZWVuLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKTtcbiAgfVxuXG4gIHJldHVybiBjb3B5O1xufSxcbiAgICBfY2hlY2tQbHVnaW4gPSBmdW5jdGlvbiBfY2hlY2tQbHVnaW4ocHJvcGVydHksIHZhcnMsIHR3ZWVuLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKSB7XG4gIHZhciBwbHVnaW4sIHB0LCBwdExvb2t1cCwgaTtcblxuICBpZiAoX3BsdWdpbnNbcHJvcGVydHldICYmIChwbHVnaW4gPSBuZXcgX3BsdWdpbnNbcHJvcGVydHldKCkpLmluaXQodGFyZ2V0LCBwbHVnaW4ucmF3VmFycyA/IHZhcnNbcHJvcGVydHldIDogX3Byb2Nlc3NWYXJzKHZhcnNbcHJvcGVydHldLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzLCB0d2VlbiksIHR3ZWVuLCBpbmRleCwgdGFyZ2V0cykgIT09IGZhbHNlKSB7XG4gICAgdHdlZW4uX3B0ID0gcHQgPSBuZXcgUHJvcFR3ZWVuKHR3ZWVuLl9wdCwgdGFyZ2V0LCBwcm9wZXJ0eSwgMCwgMSwgcGx1Z2luLnJlbmRlciwgcGx1Z2luLCAwLCBwbHVnaW4ucHJpb3JpdHkpO1xuXG4gICAgaWYgKHR3ZWVuICE9PSBfcXVpY2tUd2Vlbikge1xuICAgICAgcHRMb29rdXAgPSB0d2Vlbi5fcHRMb29rdXBbdHdlZW4uX3RhcmdldHMuaW5kZXhPZih0YXJnZXQpXTsgLy9ub3RlOiB3ZSBjYW4ndCB1c2UgdHdlZW4uX3B0TG9va3VwW2luZGV4XSBiZWNhdXNlIGZvciBzdGFnZ2VyZWQgdHdlZW5zLCB0aGUgaW5kZXggZnJvbSB0aGUgZnVsbFRhcmdldHMgYXJyYXkgd29uJ3QgbWF0Y2ggd2hhdCBpdCBpcyBpbiBlYWNoIGluZGl2aWR1YWwgdHdlZW4gdGhhdCBzcGF3bnMgZnJvbSB0aGUgc3RhZ2dlci5cblxuICAgICAgaSA9IHBsdWdpbi5fcHJvcHMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHB0TG9va3VwW3BsdWdpbi5fcHJvcHNbaV1dID0gcHQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBsdWdpbjtcbn0sXG4gICAgX292ZXJ3cml0aW5nVHdlZW4sXG4gICAgLy9zdG9yZSBhIHJlZmVyZW5jZSB0ZW1wb3JhcmlseSBzbyB3ZSBjYW4gYXZvaWQgb3ZlcndyaXRpbmcgaXRzZWxmLlxuX2luaXRUd2VlbiA9IGZ1bmN0aW9uIF9pbml0VHdlZW4odHdlZW4sIHRpbWUpIHtcbiAgdmFyIHZhcnMgPSB0d2Vlbi52YXJzLFxuICAgICAgZWFzZSA9IHZhcnMuZWFzZSxcbiAgICAgIHN0YXJ0QXQgPSB2YXJzLnN0YXJ0QXQsXG4gICAgICBpbW1lZGlhdGVSZW5kZXIgPSB2YXJzLmltbWVkaWF0ZVJlbmRlcixcbiAgICAgIGxhenkgPSB2YXJzLmxhenksXG4gICAgICBvblVwZGF0ZSA9IHZhcnMub25VcGRhdGUsXG4gICAgICBvblVwZGF0ZVBhcmFtcyA9IHZhcnMub25VcGRhdGVQYXJhbXMsXG4gICAgICBjYWxsYmFja1Njb3BlID0gdmFycy5jYWxsYmFja1Njb3BlLFxuICAgICAgcnVuQmFja3dhcmRzID0gdmFycy5ydW5CYWNrd2FyZHMsXG4gICAgICB5b3lvRWFzZSA9IHZhcnMueW95b0Vhc2UsXG4gICAgICBrZXlmcmFtZXMgPSB2YXJzLmtleWZyYW1lcyxcbiAgICAgIGF1dG9SZXZlcnQgPSB2YXJzLmF1dG9SZXZlcnQsXG4gICAgICBkdXIgPSB0d2Vlbi5fZHVyLFxuICAgICAgcHJldlN0YXJ0QXQgPSB0d2Vlbi5fc3RhcnRBdCxcbiAgICAgIHRhcmdldHMgPSB0d2Vlbi5fdGFyZ2V0cyxcbiAgICAgIHBhcmVudCA9IHR3ZWVuLnBhcmVudCxcbiAgICAgIGZ1bGxUYXJnZXRzID0gcGFyZW50ICYmIHBhcmVudC5kYXRhID09PSBcIm5lc3RlZFwiID8gcGFyZW50LnBhcmVudC5fdGFyZ2V0cyA6IHRhcmdldHMsXG4gICAgICBhdXRvT3ZlcndyaXRlID0gdHdlZW4uX292ZXJ3cml0ZSA9PT0gXCJhdXRvXCIsXG4gICAgICB0bCA9IHR3ZWVuLnRpbWVsaW5lLFxuICAgICAgY2xlYW5WYXJzLFxuICAgICAgaSxcbiAgICAgIHAsXG4gICAgICBwdCxcbiAgICAgIHRhcmdldCxcbiAgICAgIGhhc1ByaW9yaXR5LFxuICAgICAgZ3NEYXRhLFxuICAgICAgaGFybmVzcyxcbiAgICAgIHBsdWdpbixcbiAgICAgIHB0TG9va3VwLFxuICAgICAgaW5kZXgsXG4gICAgICBoYXJuZXNzVmFycyxcbiAgICAgIG92ZXJ3cml0dGVuO1xuICB0bCAmJiAoIWtleWZyYW1lcyB8fCAhZWFzZSkgJiYgKGVhc2UgPSBcIm5vbmVcIik7XG4gIHR3ZWVuLl9lYXNlID0gX3BhcnNlRWFzZShlYXNlLCBfZGVmYXVsdHMuZWFzZSk7XG4gIHR3ZWVuLl95RWFzZSA9IHlveW9FYXNlID8gX2ludmVydEVhc2UoX3BhcnNlRWFzZSh5b3lvRWFzZSA9PT0gdHJ1ZSA/IGVhc2UgOiB5b3lvRWFzZSwgX2RlZmF1bHRzLmVhc2UpKSA6IDA7XG5cbiAgaWYgKHlveW9FYXNlICYmIHR3ZWVuLl95b3lvICYmICF0d2Vlbi5fcmVwZWF0KSB7XG4gICAgLy90aGVyZSBtdXN0IGhhdmUgYmVlbiBhIHBhcmVudCB0aW1lbGluZSB3aXRoIHlveW86dHJ1ZSB0aGF0IGlzIGN1cnJlbnRseSBpbiBpdHMgeW95byBwaGFzZSwgc28gZmxpcCB0aGUgZWFzZXMuXG4gICAgeW95b0Vhc2UgPSB0d2Vlbi5feUVhc2U7XG4gICAgdHdlZW4uX3lFYXNlID0gdHdlZW4uX2Vhc2U7XG4gICAgdHdlZW4uX2Vhc2UgPSB5b3lvRWFzZTtcbiAgfVxuXG4gIGlmICghdGwpIHtcbiAgICAvL2lmIHRoZXJlJ3MgYW4gaW50ZXJuYWwgdGltZWxpbmUsIHNraXAgYWxsIHRoZSBwYXJzaW5nIGJlY2F1c2Ugd2UgcGFzc2VkIHRoYXQgdGFzayBkb3duIHRoZSBjaGFpbi5cbiAgICBoYXJuZXNzID0gdGFyZ2V0c1swXSA/IF9nZXRDYWNoZSh0YXJnZXRzWzBdKS5oYXJuZXNzIDogMDtcbiAgICBoYXJuZXNzVmFycyA9IGhhcm5lc3MgJiYgdmFyc1toYXJuZXNzLnByb3BdOyAvL3NvbWVvbmUgbWF5IG5lZWQgdG8gc3BlY2lmeSBDU1Mtc3BlY2lmaWMgdmFsdWVzIEFORCBub24tQ1NTIHZhbHVlcywgbGlrZSBpZiB0aGUgZWxlbWVudCBoYXMgYW4gXCJ4XCIgcHJvcGVydHkgcGx1cyBpdCdzIGEgc3RhbmRhcmQgRE9NIGVsZW1lbnQuIFdlIGFsbG93IHBlb3BsZSB0byBkaXN0aW5ndWlzaCBieSB3cmFwcGluZyBwbHVnaW4tc3BlY2lmaWMgc3R1ZmYgaW4gYSBjc3M6e30gb2JqZWN0IGZvciBleGFtcGxlLlxuXG4gICAgY2xlYW5WYXJzID0gX2NvcHlFeGNsdWRpbmcodmFycywgX3Jlc2VydmVkUHJvcHMpO1xuICAgIHByZXZTdGFydEF0ICYmIHByZXZTdGFydEF0LnJlbmRlcigtMSwgdHJ1ZSkua2lsbCgpO1xuXG4gICAgaWYgKHN0YXJ0QXQpIHtcbiAgICAgIF9yZW1vdmVGcm9tUGFyZW50KHR3ZWVuLl9zdGFydEF0ID0gVHdlZW4uc2V0KHRhcmdldHMsIF9zZXREZWZhdWx0cyh7XG4gICAgICAgIGRhdGE6IFwiaXNTdGFydFwiLFxuICAgICAgICBvdmVyd3JpdGU6IGZhbHNlLFxuICAgICAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICAgICAgaW1tZWRpYXRlUmVuZGVyOiB0cnVlLFxuICAgICAgICBsYXp5OiBfaXNOb3RGYWxzZShsYXp5KSxcbiAgICAgICAgc3RhcnRBdDogbnVsbCxcbiAgICAgICAgZGVsYXk6IDAsXG4gICAgICAgIG9uVXBkYXRlOiBvblVwZGF0ZSxcbiAgICAgICAgb25VcGRhdGVQYXJhbXM6IG9uVXBkYXRlUGFyYW1zLFxuICAgICAgICBjYWxsYmFja1Njb3BlOiBjYWxsYmFja1Njb3BlLFxuICAgICAgICBzdGFnZ2VyOiAwXG4gICAgICB9LCBzdGFydEF0KSkpOyAvL2NvcHkgdGhlIHByb3BlcnRpZXMvdmFsdWVzIGludG8gYSBuZXcgb2JqZWN0IHRvIGF2b2lkIGNvbGxpc2lvbnMsIGxpa2UgdmFyIHRvID0ge3g6MH0sIGZyb20gPSB7eDo1MDB9OyB0aW1lbGluZS5mcm9tVG8oZSwgZnJvbSwgdG8pLmZyb21UbyhlLCB0bywgZnJvbSk7XG5cblxuICAgICAgaWYgKGltbWVkaWF0ZVJlbmRlcikge1xuICAgICAgICBpZiAodGltZSA+IDApIHtcbiAgICAgICAgICAhYXV0b1JldmVydCAmJiAodHdlZW4uX3N0YXJ0QXQgPSAwKTsgLy90d2VlbnMgdGhhdCByZW5kZXIgaW1tZWRpYXRlbHkgKGxpa2UgbW9zdCBmcm9tKCkgYW5kIGZyb21UbygpIHR3ZWVucykgc2hvdWxkbid0IHJldmVydCB3aGVuIHRoZWlyIHBhcmVudCB0aW1lbGluZSdzIHBsYXloZWFkIGdvZXMgYmFja3dhcmQgcGFzdCB0aGUgc3RhcnRUaW1lIGJlY2F1c2UgdGhlIGluaXRpYWwgcmVuZGVyIGNvdWxkIGhhdmUgaGFwcGVuZWQgYW55dGltZSBhbmQgaXQgc2hvdWxkbid0IGJlIGRpcmVjdGx5IGNvcnJlbGF0ZWQgdG8gdGhpcyB0d2VlbidzIHN0YXJ0VGltZS4gSW1hZ2luZSBzZXR0aW5nIHVwIGEgY29tcGxleCBhbmltYXRpb24gd2hlcmUgdGhlIGJlZ2lubmluZyBzdGF0ZXMgb2YgdmFyaW91cyBvYmplY3RzIGFyZSByZW5kZXJlZCBpbW1lZGlhdGVseSBidXQgdGhlIHR3ZWVuIGRvZXNuJ3QgaGFwcGVuIGZvciBxdWl0ZSBzb21lIHRpbWUgLSBpZiB3ZSByZXZlcnQgdG8gdGhlIHN0YXJ0aW5nIHZhbHVlcyBhcyBzb29uIGFzIHRoZSBwbGF5aGVhZCBnb2VzIGJhY2t3YXJkIHBhc3QgdGhlIHR3ZWVuJ3Mgc3RhcnRUaW1lLCBpdCB3aWxsIHRocm93IHRoaW5ncyBvZmYgdmlzdWFsbHkuIFJldmVyc2lvbiBzaG91bGQgb25seSBoYXBwZW4gaW4gVGltZWxpbmUgaW5zdGFuY2VzIHdoZXJlIGltbWVkaWF0ZVJlbmRlciB3YXMgZmFsc2Ugb3Igd2hlbiBhdXRvUmV2ZXJ0IGlzIGV4cGxpY2l0bHkgc2V0IHRvIHRydWUuXG4gICAgICAgIH0gZWxzZSBpZiAoZHVyICYmICEodGltZSA8IDAgJiYgcHJldlN0YXJ0QXQpKSB7XG4gICAgICAgICAgdHdlZW4uX3pUaW1lID0gdGltZTtcbiAgICAgICAgICByZXR1cm47IC8vd2Ugc2tpcCBpbml0aWFsaXphdGlvbiBoZXJlIHNvIHRoYXQgb3ZlcndyaXRpbmcgZG9lc24ndCBvY2N1ciB1bnRpbCB0aGUgdHdlZW4gYWN0dWFsbHkgYmVnaW5zLiBPdGhlcndpc2UsIGlmIHlvdSBjcmVhdGUgc2V2ZXJhbCBpbW1lZGlhdGVSZW5kZXI6dHJ1ZSB0d2VlbnMgb2YgdGhlIHNhbWUgdGFyZ2V0L3Byb3BlcnRpZXMgdG8gZHJvcCBpbnRvIGEgVGltZWxpbmUsIHRoZSBsYXN0IG9uZSBjcmVhdGVkIHdvdWxkIG92ZXJ3cml0ZSB0aGUgZmlyc3Qgb25lcyBiZWNhdXNlIHRoZXkgZGlkbid0IGdldCBwbGFjZWQgaW50byB0aGUgdGltZWxpbmUgeWV0IGJlZm9yZSB0aGUgZmlyc3QgcmVuZGVyIG9jY3VycyBhbmQga2lja3MgaW4gb3ZlcndyaXRpbmcuXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJ1bkJhY2t3YXJkcyAmJiBkdXIpIHtcbiAgICAgIC8vZnJvbSgpIHR3ZWVucyBtdXN0IGJlIGhhbmRsZWQgdW5pcXVlbHk6IHRoZWlyIGJlZ2lubmluZyB2YWx1ZXMgbXVzdCBiZSByZW5kZXJlZCBidXQgd2UgZG9uJ3Qgd2FudCBvdmVyd3JpdGluZyB0byBvY2N1ciB5ZXQgKHdoZW4gdGltZSBpcyBzdGlsbCAwKS4gV2FpdCB1bnRpbCB0aGUgdHdlZW4gYWN0dWFsbHkgYmVnaW5zIGJlZm9yZSBkb2luZyBhbGwgdGhlIHJvdXRpbmVzIGxpa2Ugb3ZlcndyaXRpbmcuIEF0IHRoYXQgdGltZSwgd2Ugc2hvdWxkIHJlbmRlciBhdCB0aGUgRU5EIG9mIHRoZSB0d2VlbiB0byBlbnN1cmUgdGhhdCB0aGluZ3MgaW5pdGlhbGl6ZSBjb3JyZWN0bHkgKHJlbWVtYmVyLCBmcm9tKCkgdHdlZW5zIGdvIGJhY2t3YXJkcylcbiAgICAgIGlmIChwcmV2U3RhcnRBdCkge1xuICAgICAgICAhYXV0b1JldmVydCAmJiAodHdlZW4uX3N0YXJ0QXQgPSAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbWUgJiYgKGltbWVkaWF0ZVJlbmRlciA9IGZhbHNlKTsgLy9pbiByYXJlIGNhc2VzIChsaWtlIGlmIGEgZnJvbSgpIHR3ZWVuIHJ1bnMgYW5kIHRoZW4gaXMgaW52YWxpZGF0ZSgpLWVkKSwgaW1tZWRpYXRlUmVuZGVyIGNvdWxkIGJlIHRydWUgYnV0IHRoZSBpbml0aWFsIGZvcmNlZC1yZW5kZXIgZ2V0cyBza2lwcGVkLCBzbyB0aGVyZSdzIG5vIG5lZWQgdG8gZm9yY2UgdGhlIHJlbmRlciBpbiB0aGlzIGNvbnRleHQgd2hlbiB0aGUgX3RpbWUgaXMgZ3JlYXRlciB0aGFuIDBcblxuICAgICAgICBwID0gX3NldERlZmF1bHRzKHtcbiAgICAgICAgICBvdmVyd3JpdGU6IGZhbHNlLFxuICAgICAgICAgIGRhdGE6IFwiaXNGcm9tU3RhcnRcIixcbiAgICAgICAgICAvL3dlIHRhZyB0aGUgdHdlZW4gd2l0aCBhcyBcImlzRnJvbVN0YXJ0XCIgc28gdGhhdCBpZiBbaW5zaWRlIGEgcGx1Z2luXSB3ZSBuZWVkIHRvIG9ubHkgZG8gc29tZXRoaW5nIGF0IHRoZSB2ZXJ5IEVORCBvZiBhIHR3ZWVuLCB3ZSBoYXZlIGEgd2F5IG9mIGlkZW50aWZ5aW5nIHRoaXMgdHdlZW4gYXMgbWVyZWx5IHRoZSBvbmUgdGhhdCdzIHNldHRpbmcgdGhlIGJlZ2lubmluZyB2YWx1ZXMgZm9yIGEgXCJmcm9tKClcIiB0d2Vlbi4gRm9yIGV4YW1wbGUsIGNsZWFyUHJvcHMgaW4gQ1NTUGx1Z2luIHNob3VsZCBvbmx5IGdldCBhcHBsaWVkIGF0IHRoZSB2ZXJ5IEVORCBvZiBhIHR3ZWVuIGFuZCB3aXRob3V0IHRoaXMgdGFnLCBmcm9tKC4uLntoZWlnaHQ6MTAwLCBjbGVhclByb3BzOlwiaGVpZ2h0XCIsIGRlbGF5OjF9KSB3b3VsZCB3aXBlIHRoZSBoZWlnaHQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgdHdlZW4gYW5kIGFmdGVyIDEgc2Vjb25kLCBpdCdkIGtpY2sgYmFjayBpbi5cbiAgICAgICAgICBsYXp5OiBpbW1lZGlhdGVSZW5kZXIgJiYgX2lzTm90RmFsc2UobGF6eSksXG4gICAgICAgICAgaW1tZWRpYXRlUmVuZGVyOiBpbW1lZGlhdGVSZW5kZXIsXG4gICAgICAgICAgLy96ZXJvLWR1cmF0aW9uIHR3ZWVucyByZW5kZXIgaW1tZWRpYXRlbHkgYnkgZGVmYXVsdCwgYnV0IGlmIHdlJ3JlIG5vdCBzcGVjaWZpY2FsbHkgaW5zdHJ1Y3RlZCB0byByZW5kZXIgdGhpcyB0d2VlbiBpbW1lZGlhdGVseSwgd2Ugc2hvdWxkIHNraXAgdGhpcyBhbmQgbWVyZWx5IF9pbml0KCkgdG8gcmVjb3JkIHRoZSBzdGFydGluZyB2YWx1ZXMgKHJlbmRlcmluZyB0aGVtIGltbWVkaWF0ZWx5IHdvdWxkIHB1c2ggdGhlbSB0byBjb21wbGV0aW9uIHdoaWNoIGlzIHdhc3RlZnVsIGluIHRoYXQgY2FzZSAtIHdlJ2QgaGF2ZSB0byByZW5kZXIoLTEpIGltbWVkaWF0ZWx5IGFmdGVyKVxuICAgICAgICAgIHN0YWdnZXI6IDAsXG4gICAgICAgICAgcGFyZW50OiBwYXJlbnQgLy9lbnN1cmVzIHRoYXQgbmVzdGVkIHR3ZWVucyB0aGF0IGhhZCBhIHN0YWdnZXIgYXJlIGhhbmRsZWQgcHJvcGVybHksIGxpa2UgZ3NhcC5mcm9tKFwiLmNsYXNzXCIsIHt5OmdzYXAudXRpbHMud3JhcChbLTEwMCwxMDBdKX0pXG5cbiAgICAgICAgfSwgY2xlYW5WYXJzKTtcbiAgICAgICAgaGFybmVzc1ZhcnMgJiYgKHBbaGFybmVzcy5wcm9wXSA9IGhhcm5lc3NWYXJzKTsgLy8gaW4gY2FzZSBzb21lb25lIGRvZXMgc29tZXRoaW5nIGxpa2UgLmZyb20oLi4uLCB7Y3NzOnt9fSlcblxuICAgICAgICBfcmVtb3ZlRnJvbVBhcmVudCh0d2Vlbi5fc3RhcnRBdCA9IFR3ZWVuLnNldCh0YXJnZXRzLCBwKSk7XG5cbiAgICAgICAgaWYgKCFpbW1lZGlhdGVSZW5kZXIpIHtcbiAgICAgICAgICBfaW5pdFR3ZWVuKHR3ZWVuLl9zdGFydEF0LCBfdGlueU51bSk7IC8vZW5zdXJlcyB0aGF0IHRoZSBpbml0aWFsIHZhbHVlcyBhcmUgcmVjb3JkZWRcblxuICAgICAgICB9IGVsc2UgaWYgKCF0aW1lKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHdlZW4uX3B0ID0gMDtcbiAgICBsYXp5ID0gZHVyICYmIF9pc05vdEZhbHNlKGxhenkpIHx8IGxhenkgJiYgIWR1cjtcblxuICAgIGZvciAoaSA9IDA7IGkgPCB0YXJnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0YXJnZXQgPSB0YXJnZXRzW2ldO1xuICAgICAgZ3NEYXRhID0gdGFyZ2V0Ll9nc2FwIHx8IF9oYXJuZXNzKHRhcmdldHMpW2ldLl9nc2FwO1xuICAgICAgdHdlZW4uX3B0TG9va3VwW2ldID0gcHRMb29rdXAgPSB7fTtcbiAgICAgIF9sYXp5TG9va3VwW2dzRGF0YS5pZF0gJiYgX2xhenlSZW5kZXIoKTsgLy9pZiBvdGhlciB0d2VlbnMgb2YgdGhlIHNhbWUgdGFyZ2V0IGhhdmUgcmVjZW50bHkgaW5pdHRlZCBidXQgaGF2ZW4ndCByZW5kZXJlZCB5ZXQsIHdlJ3ZlIGdvdCB0byBmb3JjZSB0aGUgcmVuZGVyIHNvIHRoYXQgdGhlIHN0YXJ0aW5nIHZhbHVlcyBhcmUgY29ycmVjdCAoaW1hZ2luZSBwb3B1bGF0aW5nIGEgdGltZWxpbmUgd2l0aCBhIGJ1bmNoIG9mIHNlcXVlbnRpYWwgdHdlZW5zIGFuZCB0aGVuIGp1bXBpbmcgdG8gdGhlIGVuZClcblxuICAgICAgaW5kZXggPSBmdWxsVGFyZ2V0cyA9PT0gdGFyZ2V0cyA/IGkgOiBmdWxsVGFyZ2V0cy5pbmRleE9mKHRhcmdldCk7XG5cbiAgICAgIGlmIChoYXJuZXNzICYmIChwbHVnaW4gPSBuZXcgaGFybmVzcygpKS5pbml0KHRhcmdldCwgaGFybmVzc1ZhcnMgfHwgY2xlYW5WYXJzLCB0d2VlbiwgaW5kZXgsIGZ1bGxUYXJnZXRzKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgdHdlZW4uX3B0ID0gcHQgPSBuZXcgUHJvcFR3ZWVuKHR3ZWVuLl9wdCwgdGFyZ2V0LCBwbHVnaW4ubmFtZSwgMCwgMSwgcGx1Z2luLnJlbmRlciwgcGx1Z2luLCAwLCBwbHVnaW4ucHJpb3JpdHkpO1xuXG4gICAgICAgIHBsdWdpbi5fcHJvcHMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgIHB0TG9va3VwW25hbWVdID0gcHQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHBsdWdpbi5wcmlvcml0eSAmJiAoaGFzUHJpb3JpdHkgPSAxKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFoYXJuZXNzIHx8IGhhcm5lc3NWYXJzKSB7XG4gICAgICAgIGZvciAocCBpbiBjbGVhblZhcnMpIHtcbiAgICAgICAgICBpZiAoX3BsdWdpbnNbcF0gJiYgKHBsdWdpbiA9IF9jaGVja1BsdWdpbihwLCBjbGVhblZhcnMsIHR3ZWVuLCBpbmRleCwgdGFyZ2V0LCBmdWxsVGFyZ2V0cykpKSB7XG4gICAgICAgICAgICBwbHVnaW4ucHJpb3JpdHkgJiYgKGhhc1ByaW9yaXR5ID0gMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHB0TG9va3VwW3BdID0gcHQgPSBfYWRkUHJvcFR3ZWVuLmNhbGwodHdlZW4sIHRhcmdldCwgcCwgXCJnZXRcIiwgY2xlYW5WYXJzW3BdLCBpbmRleCwgZnVsbFRhcmdldHMsIDAsIHZhcnMuc3RyaW5nRmlsdGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdHdlZW4uX29wICYmIHR3ZWVuLl9vcFtpXSAmJiB0d2Vlbi5raWxsKHRhcmdldCwgdHdlZW4uX29wW2ldKTtcblxuICAgICAgaWYgKGF1dG9PdmVyd3JpdGUgJiYgdHdlZW4uX3B0KSB7XG4gICAgICAgIF9vdmVyd3JpdGluZ1R3ZWVuID0gdHdlZW47XG5cbiAgICAgICAgX2dsb2JhbFRpbWVsaW5lLmtpbGxUd2VlbnNPZih0YXJnZXQsIHB0TG9va3VwLCB0d2Vlbi5nbG9iYWxUaW1lKDApKTsgLy9BbHNvIG1ha2Ugc3VyZSB0aGUgb3ZlcndyaXRpbmcgZG9lc24ndCBvdmVyd3JpdGUgVEhJUyB0d2VlbiEhIVxuXG5cbiAgICAgICAgb3ZlcndyaXR0ZW4gPSAhdHdlZW4ucGFyZW50O1xuICAgICAgICBfb3ZlcndyaXRpbmdUd2VlbiA9IDA7XG4gICAgICB9XG5cbiAgICAgIHR3ZWVuLl9wdCAmJiBsYXp5ICYmIChfbGF6eUxvb2t1cFtnc0RhdGEuaWRdID0gMSk7XG4gICAgfVxuXG4gICAgaGFzUHJpb3JpdHkgJiYgX3NvcnRQcm9wVHdlZW5zQnlQcmlvcml0eSh0d2Vlbik7XG4gICAgdHdlZW4uX29uSW5pdCAmJiB0d2Vlbi5fb25Jbml0KHR3ZWVuKTsgLy9wbHVnaW5zIGxpa2UgUm91bmRQcm9wcyBtdXN0IHdhaXQgdW50aWwgQUxMIG9mIHRoZSBQcm9wVHdlZW5zIGFyZSBpbnN0YW50aWF0ZWQuIEluIHRoZSBwbHVnaW4ncyBpbml0KCkgZnVuY3Rpb24sIGl0IHNldHMgdGhlIF9vbkluaXQgb24gdGhlIHR3ZWVuIGluc3RhbmNlLiBNYXkgbm90IGJlIHByZXR0eS9pbnR1aXRpdmUsIGJ1dCBpdCdzIGZhc3QgYW5kIGtlZXBzIGZpbGUgc2l6ZSBkb3duLlxuICB9XG5cbiAgdHdlZW4uX2Zyb20gPSAhdGwgJiYgISF2YXJzLnJ1bkJhY2t3YXJkczsgLy9uZXN0ZWQgdGltZWxpbmVzIHNob3VsZCBuZXZlciBydW4gYmFja3dhcmRzIC0gdGhlIGJhY2t3YXJkcy1uZXNzIGlzIGluIHRoZSBjaGlsZCB0d2VlbnMuXG5cbiAgdHdlZW4uX29uVXBkYXRlID0gb25VcGRhdGU7XG4gIHR3ZWVuLl9pbml0dGVkID0gKCF0d2Vlbi5fb3AgfHwgdHdlZW4uX3B0KSAmJiAhb3ZlcndyaXR0ZW47IC8vIGlmIG92ZXJ3cml0dGVuUHJvcHMgcmVzdWx0ZWQgaW4gdGhlIGVudGlyZSB0d2VlbiBiZWluZyBraWxsZWQsIGRvIE5PVCBmbGFnIGl0IGFzIGluaXR0ZWQgb3IgZWxzZSBpdCBtYXkgcmVuZGVyIGZvciBvbmUgdGljay5cbn0sXG4gICAgX2FkZEFsaWFzZXNUb1ZhcnMgPSBmdW5jdGlvbiBfYWRkQWxpYXNlc1RvVmFycyh0YXJnZXRzLCB2YXJzKSB7XG4gIHZhciBoYXJuZXNzID0gdGFyZ2V0c1swXSA/IF9nZXRDYWNoZSh0YXJnZXRzWzBdKS5oYXJuZXNzIDogMCxcbiAgICAgIHByb3BlcnR5QWxpYXNlcyA9IGhhcm5lc3MgJiYgaGFybmVzcy5hbGlhc2VzLFxuICAgICAgY29weSxcbiAgICAgIHAsXG4gICAgICBpLFxuICAgICAgYWxpYXNlcztcblxuICBpZiAoIXByb3BlcnR5QWxpYXNlcykge1xuICAgIHJldHVybiB2YXJzO1xuICB9XG5cbiAgY29weSA9IF9tZXJnZSh7fSwgdmFycyk7XG5cbiAgZm9yIChwIGluIHByb3BlcnR5QWxpYXNlcykge1xuICAgIGlmIChwIGluIGNvcHkpIHtcbiAgICAgIGFsaWFzZXMgPSBwcm9wZXJ0eUFsaWFzZXNbcF0uc3BsaXQoXCIsXCIpO1xuICAgICAgaSA9IGFsaWFzZXMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGNvcHlbYWxpYXNlc1tpXV0gPSBjb3B5W3BdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb3B5O1xufSxcbiAgICBfcGFyc2VGdW5jT3JTdHJpbmcgPSBmdW5jdGlvbiBfcGFyc2VGdW5jT3JTdHJpbmcodmFsdWUsIHR3ZWVuLCBpLCB0YXJnZXQsIHRhcmdldHMpIHtcbiAgcmV0dXJuIF9pc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlLmNhbGwodHdlZW4sIGksIHRhcmdldCwgdGFyZ2V0cykgOiBfaXNTdHJpbmcodmFsdWUpICYmIH52YWx1ZS5pbmRleE9mKFwicmFuZG9tKFwiKSA/IF9yZXBsYWNlUmFuZG9tKHZhbHVlKSA6IHZhbHVlO1xufSxcbiAgICBfc3RhZ2dlclR3ZWVuUHJvcHMgPSBfY2FsbGJhY2tOYW1lcyArIFwicmVwZWF0LHJlcGVhdERlbGF5LHlveW8scmVwZWF0UmVmcmVzaCx5b3lvRWFzZVwiLFxuICAgIF9zdGFnZ2VyUHJvcHNUb1NraXAgPSAoX3N0YWdnZXJUd2VlblByb3BzICsgXCIsaWQsc3RhZ2dlcixkZWxheSxkdXJhdGlvbixwYXVzZWQsc2Nyb2xsVHJpZ2dlclwiKS5zcGxpdChcIixcIik7XG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFRXRUVOXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cblxuZXhwb3J0IHZhciBUd2VlbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0FuaW1hdGlvbjIpIHtcbiAgX2luaGVyaXRzTG9vc2UoVHdlZW4sIF9BbmltYXRpb24yKTtcblxuICBmdW5jdGlvbiBUd2Vlbih0YXJnZXRzLCB2YXJzLCB0aW1lLCBza2lwSW5oZXJpdCkge1xuICAgIHZhciBfdGhpczM7XG5cbiAgICBpZiAodHlwZW9mIHZhcnMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRpbWUuZHVyYXRpb24gPSB2YXJzO1xuICAgICAgdmFycyA9IHRpbWU7XG4gICAgICB0aW1lID0gbnVsbDtcbiAgICB9XG5cbiAgICBfdGhpczMgPSBfQW5pbWF0aW9uMi5jYWxsKHRoaXMsIHNraXBJbmhlcml0ID8gdmFycyA6IF9pbmhlcml0RGVmYXVsdHModmFycyksIHRpbWUpIHx8IHRoaXM7XG4gICAgdmFyIF90aGlzMyR2YXJzID0gX3RoaXMzLnZhcnMsXG4gICAgICAgIGR1cmF0aW9uID0gX3RoaXMzJHZhcnMuZHVyYXRpb24sXG4gICAgICAgIGRlbGF5ID0gX3RoaXMzJHZhcnMuZGVsYXksXG4gICAgICAgIGltbWVkaWF0ZVJlbmRlciA9IF90aGlzMyR2YXJzLmltbWVkaWF0ZVJlbmRlcixcbiAgICAgICAgc3RhZ2dlciA9IF90aGlzMyR2YXJzLnN0YWdnZXIsXG4gICAgICAgIG92ZXJ3cml0ZSA9IF90aGlzMyR2YXJzLm92ZXJ3cml0ZSxcbiAgICAgICAga2V5ZnJhbWVzID0gX3RoaXMzJHZhcnMua2V5ZnJhbWVzLFxuICAgICAgICBkZWZhdWx0cyA9IF90aGlzMyR2YXJzLmRlZmF1bHRzLFxuICAgICAgICBzY3JvbGxUcmlnZ2VyID0gX3RoaXMzJHZhcnMuc2Nyb2xsVHJpZ2dlcixcbiAgICAgICAgeW95b0Vhc2UgPSBfdGhpczMkdmFycy55b3lvRWFzZSxcbiAgICAgICAgcGFyZW50ID0gX3RoaXMzLnBhcmVudCxcbiAgICAgICAgcGFyc2VkVGFyZ2V0cyA9IChfaXNBcnJheSh0YXJnZXRzKSA/IF9pc051bWJlcih0YXJnZXRzWzBdKSA6IFwibGVuZ3RoXCIgaW4gdmFycykgPyBbdGFyZ2V0c10gOiB0b0FycmF5KHRhcmdldHMpLFxuICAgICAgICB0bCxcbiAgICAgICAgaSxcbiAgICAgICAgY29weSxcbiAgICAgICAgbCxcbiAgICAgICAgcCxcbiAgICAgICAgY3VyVGFyZ2V0LFxuICAgICAgICBzdGFnZ2VyRnVuYyxcbiAgICAgICAgc3RhZ2dlclZhcnNUb01lcmdlO1xuICAgIF90aGlzMy5fdGFyZ2V0cyA9IHBhcnNlZFRhcmdldHMubGVuZ3RoID8gX2hhcm5lc3MocGFyc2VkVGFyZ2V0cykgOiBfd2FybihcIkdTQVAgdGFyZ2V0IFwiICsgdGFyZ2V0cyArIFwiIG5vdCBmb3VuZC4gaHR0cHM6Ly9ncmVlbnNvY2suY29tXCIsICFfY29uZmlnLm51bGxUYXJnZXRXYXJuKSB8fCBbXTtcbiAgICBfdGhpczMuX3B0TG9va3VwID0gW107IC8vUHJvcFR3ZWVuIGxvb2t1cC4gQW4gYXJyYXkgY29udGFpbmluZyBhbiBvYmplY3QgZm9yIGVhY2ggdGFyZ2V0LCBoYXZpbmcga2V5cyBmb3IgZWFjaCB0d2VlbmluZyBwcm9wZXJ0eVxuXG4gICAgX3RoaXMzLl9vdmVyd3JpdGUgPSBvdmVyd3JpdGU7XG5cbiAgICBpZiAoa2V5ZnJhbWVzIHx8IHN0YWdnZXIgfHwgX2lzRnVuY09yU3RyaW5nKGR1cmF0aW9uKSB8fCBfaXNGdW5jT3JTdHJpbmcoZGVsYXkpKSB7XG4gICAgICB2YXJzID0gX3RoaXMzLnZhcnM7XG4gICAgICB0bCA9IF90aGlzMy50aW1lbGluZSA9IG5ldyBUaW1lbGluZSh7XG4gICAgICAgIGRhdGE6IFwibmVzdGVkXCIsXG4gICAgICAgIGRlZmF1bHRzOiBkZWZhdWx0cyB8fCB7fVxuICAgICAgfSk7XG4gICAgICB0bC5raWxsKCk7XG4gICAgICB0bC5wYXJlbnQgPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzMyk7XG5cbiAgICAgIGlmIChrZXlmcmFtZXMpIHtcbiAgICAgICAgX3NldERlZmF1bHRzKHRsLnZhcnMuZGVmYXVsdHMsIHtcbiAgICAgICAgICBlYXNlOiBcIm5vbmVcIlxuICAgICAgICB9KTtcblxuICAgICAgICBrZXlmcmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoZnJhbWUpIHtcbiAgICAgICAgICByZXR1cm4gdGwudG8ocGFyc2VkVGFyZ2V0cywgZnJhbWUsIFwiPlwiKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsID0gcGFyc2VkVGFyZ2V0cy5sZW5ndGg7XG4gICAgICAgIHN0YWdnZXJGdW5jID0gc3RhZ2dlciA/IGRpc3RyaWJ1dGUoc3RhZ2dlcikgOiBfZW1wdHlGdW5jO1xuXG4gICAgICAgIGlmIChfaXNPYmplY3Qoc3RhZ2dlcikpIHtcbiAgICAgICAgICAvL3VzZXJzIGNhbiBwYXNzIGluIGNhbGxiYWNrcyBsaWtlIG9uU3RhcnQvb25Db21wbGV0ZSBpbiB0aGUgc3RhZ2dlciBvYmplY3QuIFRoZXNlIHNob3VsZCBmaXJlIHdpdGggZWFjaCBpbmRpdmlkdWFsIHR3ZWVuLlxuICAgICAgICAgIGZvciAocCBpbiBzdGFnZ2VyKSB7XG4gICAgICAgICAgICBpZiAofl9zdGFnZ2VyVHdlZW5Qcm9wcy5pbmRleE9mKHApKSB7XG4gICAgICAgICAgICAgIHN0YWdnZXJWYXJzVG9NZXJnZSB8fCAoc3RhZ2dlclZhcnNUb01lcmdlID0ge30pO1xuICAgICAgICAgICAgICBzdGFnZ2VyVmFyc1RvTWVyZ2VbcF0gPSBzdGFnZ2VyW3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBjb3B5ID0ge307XG5cbiAgICAgICAgICBmb3IgKHAgaW4gdmFycykge1xuICAgICAgICAgICAgaWYgKF9zdGFnZ2VyUHJvcHNUb1NraXAuaW5kZXhPZihwKSA8IDApIHtcbiAgICAgICAgICAgICAgY29weVtwXSA9IHZhcnNbcF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29weS5zdGFnZ2VyID0gMDtcbiAgICAgICAgICB5b3lvRWFzZSAmJiAoY29weS55b3lvRWFzZSA9IHlveW9FYXNlKTtcbiAgICAgICAgICBzdGFnZ2VyVmFyc1RvTWVyZ2UgJiYgX21lcmdlKGNvcHksIHN0YWdnZXJWYXJzVG9NZXJnZSk7XG4gICAgICAgICAgY3VyVGFyZ2V0ID0gcGFyc2VkVGFyZ2V0c1tpXTsgLy9kb24ndCBqdXN0IGNvcHkgZHVyYXRpb24gb3IgZGVsYXkgYmVjYXVzZSBpZiB0aGV5J3JlIGEgc3RyaW5nIG9yIGZ1bmN0aW9uLCB3ZSdkIGVuZCB1cCBpbiBhbiBpbmZpbml0ZSBsb29wIGJlY2F1c2UgX2lzRnVuY09yU3RyaW5nKCkgd291bGQgZXZhbHVhdGUgYXMgdHJ1ZSBpbiB0aGUgY2hpbGQgdHdlZW5zLCBlbnRlcmluZyB0aGlzIGxvb3AsIGV0Yy4gU28gd2UgcGFyc2UgdGhlIHZhbHVlIHN0cmFpZ2h0IGZyb20gdmFycyBhbmQgZGVmYXVsdCB0byAwLlxuXG4gICAgICAgICAgY29weS5kdXJhdGlvbiA9ICtfcGFyc2VGdW5jT3JTdHJpbmcoZHVyYXRpb24sIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMzKSwgaSwgY3VyVGFyZ2V0LCBwYXJzZWRUYXJnZXRzKTtcbiAgICAgICAgICBjb3B5LmRlbGF5ID0gKCtfcGFyc2VGdW5jT3JTdHJpbmcoZGVsYXksIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMzKSwgaSwgY3VyVGFyZ2V0LCBwYXJzZWRUYXJnZXRzKSB8fCAwKSAtIF90aGlzMy5fZGVsYXk7XG5cbiAgICAgICAgICBpZiAoIXN0YWdnZXIgJiYgbCA9PT0gMSAmJiBjb3B5LmRlbGF5KSB7XG4gICAgICAgICAgICAvLyBpZiBzb21lb25lIGRvZXMgZGVsYXk6XCJyYW5kb20oMSwgNSlcIiwgcmVwZWF0Oi0xLCBmb3IgZXhhbXBsZSwgdGhlIGRlbGF5IHNob3VsZG4ndCBiZSBpbnNpZGUgdGhlIHJlcGVhdC5cbiAgICAgICAgICAgIF90aGlzMy5fZGVsYXkgPSBkZWxheSA9IGNvcHkuZGVsYXk7XG4gICAgICAgICAgICBfdGhpczMuX3N0YXJ0ICs9IGRlbGF5O1xuICAgICAgICAgICAgY29weS5kZWxheSA9IDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGwudG8oY3VyVGFyZ2V0LCBjb3B5LCBzdGFnZ2VyRnVuYyhpLCBjdXJUYXJnZXQsIHBhcnNlZFRhcmdldHMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRsLmR1cmF0aW9uKCkgPyBkdXJhdGlvbiA9IGRlbGF5ID0gMCA6IF90aGlzMy50aW1lbGluZSA9IDA7IC8vIGlmIHRoZSB0aW1lbGluZSdzIGR1cmF0aW9uIGlzIDAsIHdlIGRvbid0IG5lZWQgYSB0aW1lbGluZSBpbnRlcm5hbGx5IVxuICAgICAgfVxuXG4gICAgICBkdXJhdGlvbiB8fCBfdGhpczMuZHVyYXRpb24oZHVyYXRpb24gPSB0bC5kdXJhdGlvbigpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3RoaXMzLnRpbWVsaW5lID0gMDsgLy9zcGVlZCBvcHRpbWl6YXRpb24sIGZhc3RlciBsb29rdXBzIChubyBnb2luZyB1cCB0aGUgcHJvdG90eXBlIGNoYWluKVxuICAgIH1cblxuICAgIGlmIChvdmVyd3JpdGUgPT09IHRydWUpIHtcbiAgICAgIF9vdmVyd3JpdGluZ1R3ZWVuID0gX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczMpO1xuXG4gICAgICBfZ2xvYmFsVGltZWxpbmUua2lsbFR3ZWVuc09mKHBhcnNlZFRhcmdldHMpO1xuXG4gICAgICBfb3ZlcndyaXRpbmdUd2VlbiA9IDA7XG4gICAgfVxuXG4gICAgcGFyZW50ICYmIF9wb3N0QWRkQ2hlY2tzKHBhcmVudCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczMpKTtcblxuICAgIGlmIChpbW1lZGlhdGVSZW5kZXIgfHwgIWR1cmF0aW9uICYmICFrZXlmcmFtZXMgJiYgX3RoaXMzLl9zdGFydCA9PT0gX3JvdW5kKHBhcmVudC5fdGltZSkgJiYgX2lzTm90RmFsc2UoaW1tZWRpYXRlUmVuZGVyKSAmJiBfaGFzTm9QYXVzZWRBbmNlc3RvcnMoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczMpKSAmJiBwYXJlbnQuZGF0YSAhPT0gXCJuZXN0ZWRcIikge1xuICAgICAgX3RoaXMzLl90VGltZSA9IC1fdGlueU51bTsgLy9mb3JjZXMgYSByZW5kZXIgd2l0aG91dCBoYXZpbmcgdG8gc2V0IHRoZSByZW5kZXIoKSBcImZvcmNlXCIgcGFyYW1ldGVyIHRvIHRydWUgYmVjYXVzZSB3ZSB3YW50IHRvIGFsbG93IGxhenlpbmcgYnkgZGVmYXVsdCAodXNpbmcgdGhlIFwiZm9yY2VcIiBwYXJhbWV0ZXIgYWx3YXlzIGZvcmNlcyBhbiBpbW1lZGlhdGUgZnVsbCByZW5kZXIpXG5cbiAgICAgIF90aGlzMy5yZW5kZXIoTWF0aC5tYXgoMCwgLWRlbGF5KSk7IC8vaW4gY2FzZSBkZWxheSBpcyBuZWdhdGl2ZVxuXG4gICAgfVxuXG4gICAgc2Nyb2xsVHJpZ2dlciAmJiBfc2Nyb2xsVHJpZ2dlcihfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzMyksIHNjcm9sbFRyaWdnZXIpO1xuICAgIHJldHVybiBfdGhpczM7XG4gIH1cblxuICB2YXIgX3Byb3RvMyA9IFR3ZWVuLnByb3RvdHlwZTtcblxuICBfcHJvdG8zLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcih0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSkge1xuICAgIHZhciBwcmV2VGltZSA9IHRoaXMuX3RpbWUsXG4gICAgICAgIHREdXIgPSB0aGlzLl90RHVyLFxuICAgICAgICBkdXIgPSB0aGlzLl9kdXIsXG4gICAgICAgIHRUaW1lID0gdG90YWxUaW1lID4gdER1ciAtIF90aW55TnVtICYmIHRvdGFsVGltZSA+PSAwID8gdER1ciA6IHRvdGFsVGltZSA8IF90aW55TnVtID8gMCA6IHRvdGFsVGltZSxcbiAgICAgICAgdGltZSxcbiAgICAgICAgcHQsXG4gICAgICAgIGl0ZXJhdGlvbixcbiAgICAgICAgY3ljbGVEdXJhdGlvbixcbiAgICAgICAgcHJldkl0ZXJhdGlvbixcbiAgICAgICAgaXNZb3lvLFxuICAgICAgICByYXRpbyxcbiAgICAgICAgdGltZWxpbmUsXG4gICAgICAgIHlveW9FYXNlO1xuXG4gICAgaWYgKCFkdXIpIHtcbiAgICAgIF9yZW5kZXJaZXJvRHVyYXRpb25Ud2Vlbih0aGlzLCB0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG4gICAgfSBlbHNlIGlmICh0VGltZSAhPT0gdGhpcy5fdFRpbWUgfHwgIXRvdGFsVGltZSB8fCBmb3JjZSB8fCB0aGlzLl9zdGFydEF0ICYmIHRoaXMuX3pUaW1lIDwgMCAhPT0gdG90YWxUaW1lIDwgMCkge1xuICAgICAgLy90aGlzIHNlbnNlcyBpZiB3ZSdyZSBjcm9zc2luZyBvdmVyIHRoZSBzdGFydCB0aW1lLCBpbiB3aGljaCBjYXNlIHdlIG11c3QgcmVjb3JkIF96VGltZSBhbmQgZm9yY2UgdGhlIHJlbmRlciwgYnV0IHdlIGRvIGl0IGluIHRoaXMgbGVuZ3RoeSBjb25kaXRpb25hbCB3YXkgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMgKHVzdWFsbHkgd2UgY2FuIHNraXAgdGhlIGNhbGN1bGF0aW9ucyk6IHRoaXMuX2luaXR0ZWQgJiYgKHRoaXMuX3pUaW1lIDwgMCkgIT09ICh0b3RhbFRpbWUgPCAwKVxuICAgICAgdGltZSA9IHRUaW1lO1xuICAgICAgdGltZWxpbmUgPSB0aGlzLnRpbWVsaW5lO1xuXG4gICAgICBpZiAodGhpcy5fcmVwZWF0KSB7XG4gICAgICAgIC8vYWRqdXN0IHRoZSB0aW1lIGZvciByZXBlYXRzIGFuZCB5b3lvc1xuICAgICAgICBjeWNsZUR1cmF0aW9uID0gZHVyICsgdGhpcy5fckRlbGF5O1xuICAgICAgICB0aW1lID0gX3JvdW5kKHRUaW1lICUgY3ljbGVEdXJhdGlvbik7IC8vcm91bmQgdG8gYXZvaWQgZmxvYXRpbmcgcG9pbnQgZXJyb3JzLiAoNCAlIDAuOCBzaG91bGQgYmUgMCBidXQgc29tZSBicm93c2VycyByZXBvcnQgaXQgYXMgMC43OTk5OTk5OSEpXG5cbiAgICAgICAgaWYgKHRpbWUgPiBkdXIgfHwgdER1ciA9PT0gdFRpbWUpIHtcbiAgICAgICAgICAvLyB0aGUgdER1ciA9PT0gdFRpbWUgaXMgZm9yIGVkZ2UgY2FzZXMgd2hlcmUgdGhlcmUncyBhIGxlbmd0aHkgZGVjaW1hbCBvbiB0aGUgZHVyYXRpb24gYW5kIGl0IG1heSByZWFjaCB0aGUgdmVyeSBlbmQgYnV0IHRoZSB0aW1lIGlzIHJlbmRlcmVkIGFzIG5vdC1xdWl0ZS10aGVyZSAocmVtZW1iZXIsIHREdXIgaXMgcm91bmRlZCB0byA0IGRlY2ltYWxzIHdoZXJlYXMgZHVyIGlzbid0KVxuICAgICAgICAgIHRpbWUgPSBkdXI7XG4gICAgICAgIH1cblxuICAgICAgICBpdGVyYXRpb24gPSB+fih0VGltZSAvIGN5Y2xlRHVyYXRpb24pO1xuXG4gICAgICAgIGlmIChpdGVyYXRpb24gJiYgaXRlcmF0aW9uID09PSB0VGltZSAvIGN5Y2xlRHVyYXRpb24pIHtcbiAgICAgICAgICB0aW1lID0gZHVyO1xuICAgICAgICAgIGl0ZXJhdGlvbi0tO1xuICAgICAgICB9XG5cbiAgICAgICAgaXNZb3lvID0gdGhpcy5feW95byAmJiBpdGVyYXRpb24gJiAxO1xuXG4gICAgICAgIGlmIChpc1lveW8pIHtcbiAgICAgICAgICB5b3lvRWFzZSA9IHRoaXMuX3lFYXNlO1xuICAgICAgICAgIHRpbWUgPSBkdXIgLSB0aW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJldkl0ZXJhdGlvbiA9IF9hbmltYXRpb25DeWNsZSh0aGlzLl90VGltZSwgY3ljbGVEdXJhdGlvbik7XG5cbiAgICAgICAgaWYgKHRpbWUgPT09IHByZXZUaW1lICYmICFmb3JjZSAmJiB0aGlzLl9pbml0dGVkKSB7XG4gICAgICAgICAgLy9jb3VsZCBiZSBkdXJpbmcgdGhlIHJlcGVhdERlbGF5IHBhcnQuIE5vIG5lZWQgdG8gcmVuZGVyIGFuZCBmaXJlIGNhbGxiYWNrcy5cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpdGVyYXRpb24gIT09IHByZXZJdGVyYXRpb24pIHtcbiAgICAgICAgICB0aW1lbGluZSAmJiB0aGlzLl95RWFzZSAmJiBfcHJvcGFnYXRlWW95b0Vhc2UodGltZWxpbmUsIGlzWW95byk7IC8vcmVwZWF0UmVmcmVzaCBmdW5jdGlvbmFsaXR5XG5cbiAgICAgICAgICBpZiAodGhpcy52YXJzLnJlcGVhdFJlZnJlc2ggJiYgIWlzWW95byAmJiAhdGhpcy5fbG9jaykge1xuICAgICAgICAgICAgdGhpcy5fbG9jayA9IGZvcmNlID0gMTsgLy9mb3JjZSwgb3RoZXJ3aXNlIGlmIGxhenkgaXMgdHJ1ZSwgdGhlIF9hdHRlbXB0SW5pdFR3ZWVuKCkgd2lsbCByZXR1cm4gYW5kIHdlJ2xsIGp1bXAgb3V0IGFuZCBnZXQgY2F1Z2h0IGJvdW5jaW5nIG9uIGVhY2ggdGljay5cblxuICAgICAgICAgICAgdGhpcy5yZW5kZXIoX3JvdW5kKGN5Y2xlRHVyYXRpb24gKiBpdGVyYXRpb24pLCB0cnVlKS5pbnZhbGlkYXRlKCkuX2xvY2sgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuX2luaXR0ZWQpIHtcbiAgICAgICAgaWYgKF9hdHRlbXB0SW5pdFR3ZWVuKHRoaXMsIHRvdGFsVGltZSA8IDAgPyB0b3RhbFRpbWUgOiB0aW1lLCBmb3JjZSwgc3VwcHJlc3NFdmVudHMpKSB7XG4gICAgICAgICAgdGhpcy5fdFRpbWUgPSAwOyAvLyBpbiBjb25zdHJ1Y3RvciBpZiBpbW1lZGlhdGVSZW5kZXIgaXMgdHJ1ZSwgd2Ugc2V0IF90VGltZSB0byAtX3RpbnlOdW0gdG8gaGF2ZSB0aGUgcGxheWhlYWQgY3Jvc3MgdGhlIHN0YXJ0aW5nIHBvaW50IGJ1dCB3ZSBjYW4ndCBsZWF2ZSBfdFRpbWUgYXMgYSBuZWdhdGl2ZSBudW1iZXIuXG5cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkdXIgIT09IHRoaXMuX2R1cikge1xuICAgICAgICAgIC8vIHdoaWxlIGluaXR0aW5nLCBhIHBsdWdpbiBsaWtlIEluZXJ0aWFQbHVnaW4gbWlnaHQgYWx0ZXIgdGhlIGR1cmF0aW9uLCBzbyByZXJ1biBmcm9tIHRoZSBzdGFydCB0byBlbnN1cmUgZXZlcnl0aGluZyByZW5kZXJzIGFzIGl0IHNob3VsZC5cbiAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXIodG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3RUaW1lID0gdFRpbWU7XG4gICAgICB0aGlzLl90aW1lID0gdGltZTtcblxuICAgICAgaWYgKCF0aGlzLl9hY3QgJiYgdGhpcy5fdHMpIHtcbiAgICAgICAgdGhpcy5fYWN0ID0gMTsgLy9hcyBsb25nIGFzIGl0J3Mgbm90IHBhdXNlZCwgZm9yY2UgaXQgdG8gYmUgYWN0aXZlIHNvIHRoYXQgaWYgdGhlIHVzZXIgcmVuZGVycyBpbmRlcGVuZGVudCBvZiB0aGUgcGFyZW50IHRpbWVsaW5lLCBpdCdsbCBiZSBmb3JjZWQgdG8gcmUtcmVuZGVyIG9uIHRoZSBuZXh0IHRpY2suXG5cbiAgICAgICAgdGhpcy5fbGF6eSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmF0aW8gPSByYXRpbyA9ICh5b3lvRWFzZSB8fCB0aGlzLl9lYXNlKSh0aW1lIC8gZHVyKTtcblxuICAgICAgaWYgKHRoaXMuX2Zyb20pIHtcbiAgICAgICAgdGhpcy5yYXRpbyA9IHJhdGlvID0gMSAtIHJhdGlvO1xuICAgICAgfVxuXG4gICAgICB0aW1lICYmICFwcmV2VGltZSAmJiAhc3VwcHJlc3NFdmVudHMgJiYgX2NhbGxiYWNrKHRoaXMsIFwib25TdGFydFwiKTtcbiAgICAgIHB0ID0gdGhpcy5fcHQ7XG5cbiAgICAgIHdoaWxlIChwdCkge1xuICAgICAgICBwdC5yKHJhdGlvLCBwdC5kKTtcbiAgICAgICAgcHQgPSBwdC5fbmV4dDtcbiAgICAgIH1cblxuICAgICAgdGltZWxpbmUgJiYgdGltZWxpbmUucmVuZGVyKHRvdGFsVGltZSA8IDAgPyB0b3RhbFRpbWUgOiAhdGltZSAmJiBpc1lveW8gPyAtX3RpbnlOdW0gOiB0aW1lbGluZS5fZHVyICogcmF0aW8sIHN1cHByZXNzRXZlbnRzLCBmb3JjZSkgfHwgdGhpcy5fc3RhcnRBdCAmJiAodGhpcy5felRpbWUgPSB0b3RhbFRpbWUpO1xuXG4gICAgICBpZiAodGhpcy5fb25VcGRhdGUgJiYgIXN1cHByZXNzRXZlbnRzKSB7XG4gICAgICAgIGlmICh0b3RhbFRpbWUgPCAwICYmIHRoaXMuX3N0YXJ0QXQpIHtcbiAgICAgICAgICB0aGlzLl9zdGFydEF0LnJlbmRlcih0b3RhbFRpbWUsIHRydWUsIGZvcmNlKTsgLy9ub3RlOiBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgd2UgdHVjayB0aGlzIGNvbmRpdGlvbmFsIGxvZ2ljIGluc2lkZSBsZXNzIHRyYXZlbGVkIGFyZWFzIChtb3N0IHR3ZWVucyBkb24ndCBoYXZlIGFuIG9uVXBkYXRlKS4gV2UnZCBqdXN0IGhhdmUgaXQgYXQgdGhlIGVuZCBiZWZvcmUgdGhlIG9uQ29tcGxldGUsIGJ1dCB0aGUgdmFsdWVzIHNob3VsZCBiZSB1cGRhdGVkIGJlZm9yZSBhbnkgb25VcGRhdGUgaXMgY2FsbGVkLCBzbyB3ZSBBTFNPIHB1dCBpdCBoZXJlIGFuZCB0aGVuIGlmIGl0J3Mgbm90IGNhbGxlZCwgd2UgZG8gc28gbGF0ZXIgbmVhciB0aGUgb25Db21wbGV0ZS5cblxuICAgICAgICB9XG5cbiAgICAgICAgX2NhbGxiYWNrKHRoaXMsIFwib25VcGRhdGVcIik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3JlcGVhdCAmJiBpdGVyYXRpb24gIT09IHByZXZJdGVyYXRpb24gJiYgdGhpcy52YXJzLm9uUmVwZWF0ICYmICFzdXBwcmVzc0V2ZW50cyAmJiB0aGlzLnBhcmVudCAmJiBfY2FsbGJhY2sodGhpcywgXCJvblJlcGVhdFwiKTtcblxuICAgICAgaWYgKCh0VGltZSA9PT0gdGhpcy5fdER1ciB8fCAhdFRpbWUpICYmIHRoaXMuX3RUaW1lID09PSB0VGltZSkge1xuICAgICAgICB0b3RhbFRpbWUgPCAwICYmIHRoaXMuX3N0YXJ0QXQgJiYgIXRoaXMuX29uVXBkYXRlICYmIHRoaXMuX3N0YXJ0QXQucmVuZGVyKHRvdGFsVGltZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICh0b3RhbFRpbWUgfHwgIWR1cikgJiYgKHRUaW1lID09PSB0aGlzLl90RHVyICYmIHRoaXMuX3RzID4gMCB8fCAhdFRpbWUgJiYgdGhpcy5fdHMgPCAwKSAmJiBfcmVtb3ZlRnJvbVBhcmVudCh0aGlzLCAxKTsgLy8gZG9uJ3QgcmVtb3ZlIGlmIHdlJ3JlIHJlbmRlcmluZyBhdCBleGFjdGx5IGEgdGltZSBvZiAwLCBhcyB0aGVyZSBjb3VsZCBiZSBhdXRvUmV2ZXJ0IHZhbHVlcyB0aGF0IHNob3VsZCBnZXQgc2V0IG9uIHRoZSBuZXh0IHRpY2sgKGlmIHRoZSBwbGF5aGVhZCBnb2VzIGJhY2t3YXJkIGJleW9uZCB0aGUgc3RhcnRUaW1lLCBuZWdhdGl2ZSB0b3RhbFRpbWUpLiBEb24ndCByZW1vdmUgaWYgdGhlIHRpbWVsaW5lIGlzIHJldmVyc2VkIGFuZCB0aGUgcGxheWhlYWQgaXNuJ3QgYXQgMCwgb3RoZXJ3aXNlIHRsLnByb2dyZXNzKDEpLnJldmVyc2UoKSB3b24ndCB3b3JrLiBPbmx5IHJlbW92ZSBpZiB0aGUgcGxheWhlYWQgaXMgYXQgdGhlIGVuZCBhbmQgdGltZVNjYWxlIGlzIHBvc2l0aXZlLCBvciBpZiB0aGUgcGxheWhlYWQgaXMgYXQgMCBhbmQgdGhlIHRpbWVTY2FsZSBpcyBuZWdhdGl2ZS5cblxuICAgICAgICBpZiAoIXN1cHByZXNzRXZlbnRzICYmICEodG90YWxUaW1lIDwgMCAmJiAhcHJldlRpbWUpICYmICh0VGltZSB8fCBwcmV2VGltZSkpIHtcbiAgICAgICAgICAvLyBpZiBwcmV2VGltZSBhbmQgdFRpbWUgYXJlIHplcm8sIHdlIHNob3VsZG4ndCBmaXJlIHRoZSBvblJldmVyc2VDb21wbGV0ZS4gVGhpcyBjb3VsZCBoYXBwZW4gaWYgeW91IGdzYXAudG8oLi4uIHtwYXVzZWQ6dHJ1ZX0pLnBsYXkoKTtcbiAgICAgICAgICBfY2FsbGJhY2sodGhpcywgdFRpbWUgPT09IHREdXIgPyBcIm9uQ29tcGxldGVcIiA6IFwib25SZXZlcnNlQ29tcGxldGVcIiwgdHJ1ZSk7XG5cbiAgICAgICAgICB0aGlzLl9wcm9tICYmICEodFRpbWUgPCB0RHVyICYmIHRoaXMudGltZVNjYWxlKCkgPiAwKSAmJiB0aGlzLl9wcm9tKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8zLnRhcmdldHMgPSBmdW5jdGlvbiB0YXJnZXRzKCkge1xuICAgIHJldHVybiB0aGlzLl90YXJnZXRzO1xuICB9O1xuXG4gIF9wcm90bzMuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uIGludmFsaWRhdGUoKSB7XG4gICAgdGhpcy5fcHQgPSB0aGlzLl9vcCA9IHRoaXMuX3N0YXJ0QXQgPSB0aGlzLl9vblVwZGF0ZSA9IHRoaXMuX2FjdCA9IHRoaXMuX2xhenkgPSAwO1xuICAgIHRoaXMuX3B0TG9va3VwID0gW107XG4gICAgdGhpcy50aW1lbGluZSAmJiB0aGlzLnRpbWVsaW5lLmludmFsaWRhdGUoKTtcbiAgICByZXR1cm4gX0FuaW1hdGlvbjIucHJvdG90eXBlLmludmFsaWRhdGUuY2FsbCh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8zLmtpbGwgPSBmdW5jdGlvbiBraWxsKHRhcmdldHMsIHZhcnMpIHtcbiAgICBpZiAodmFycyA9PT0gdm9pZCAwKSB7XG4gICAgICB2YXJzID0gXCJhbGxcIjtcbiAgICB9XG5cbiAgICBpZiAoIXRhcmdldHMgJiYgKCF2YXJzIHx8IHZhcnMgPT09IFwiYWxsXCIpKSB7XG4gICAgICB0aGlzLl9sYXp5ID0gMDtcblxuICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgIHJldHVybiBfaW50ZXJydXB0KHRoaXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLnRpbWVsaW5lKSB7XG4gICAgICB2YXIgdER1ciA9IHRoaXMudGltZWxpbmUudG90YWxEdXJhdGlvbigpO1xuICAgICAgdGhpcy50aW1lbGluZS5raWxsVHdlZW5zT2YodGFyZ2V0cywgdmFycywgX292ZXJ3cml0aW5nVHdlZW4gJiYgX292ZXJ3cml0aW5nVHdlZW4udmFycy5vdmVyd3JpdGUgIT09IHRydWUpLl9maXJzdCB8fCBfaW50ZXJydXB0KHRoaXMpOyAvLyBpZiBub3RoaW5nIGlzIGxlZnQgdHdlZW5uZywgaW50ZXJydXB0LlxuXG4gICAgICB0aGlzLnBhcmVudCAmJiB0RHVyICE9PSB0aGlzLnRpbWVsaW5lLnRvdGFsRHVyYXRpb24oKSAmJiBfc2V0RHVyYXRpb24odGhpcywgdGhpcy5fZHVyICogdGhpcy50aW1lbGluZS5fdER1ciAvIHREdXIpOyAvLyBpZiBhIG5lc3RlZCB0d2VlbiBpcyBraWxsZWQgdGhhdCBjaGFuZ2VzIHRoZSBkdXJhdGlvbiwgaXQgc2hvdWxkIGFmZmVjdCB0aGlzIHR3ZWVuJ3MgZHVyYXRpb24uIFdlIG11c3QgdXNlIHRoZSByYXRpbywgdGhvdWdoLCBiZWNhdXNlIHNvbWV0aW1lcyB0aGUgaW50ZXJuYWwgdGltZWxpbmUgaXMgc3RyZXRjaGVkIGxpa2UgZm9yIGtleWZyYW1lcyB3aGVyZSB0aGV5IGRvbid0IGFsbCBhZGQgdXAgdG8gd2hhdGV2ZXIgdGhlIHBhcmVudCB0d2VlbidzIGR1cmF0aW9uIHdhcyBzZXQgdG8uXG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBwYXJzZWRUYXJnZXRzID0gdGhpcy5fdGFyZ2V0cyxcbiAgICAgICAga2lsbGluZ1RhcmdldHMgPSB0YXJnZXRzID8gdG9BcnJheSh0YXJnZXRzKSA6IHBhcnNlZFRhcmdldHMsXG4gICAgICAgIHByb3BUd2Vlbkxvb2t1cCA9IHRoaXMuX3B0TG9va3VwLFxuICAgICAgICBmaXJzdFBUID0gdGhpcy5fcHQsXG4gICAgICAgIG92ZXJ3cml0dGVuUHJvcHMsXG4gICAgICAgIGN1ckxvb2t1cCxcbiAgICAgICAgY3VyT3ZlcndyaXRlUHJvcHMsXG4gICAgICAgIHByb3BzLFxuICAgICAgICBwLFxuICAgICAgICBwdCxcbiAgICAgICAgaTtcblxuICAgIGlmICgoIXZhcnMgfHwgdmFycyA9PT0gXCJhbGxcIikgJiYgX2FycmF5c01hdGNoKHBhcnNlZFRhcmdldHMsIGtpbGxpbmdUYXJnZXRzKSkge1xuICAgICAgdmFycyA9PT0gXCJhbGxcIiAmJiAodGhpcy5fcHQgPSAwKTtcbiAgICAgIHJldHVybiBfaW50ZXJydXB0KHRoaXMpO1xuICAgIH1cblxuICAgIG92ZXJ3cml0dGVuUHJvcHMgPSB0aGlzLl9vcCA9IHRoaXMuX29wIHx8IFtdO1xuXG4gICAgaWYgKHZhcnMgIT09IFwiYWxsXCIpIHtcbiAgICAgIC8vc28gcGVvcGxlIGNhbiBwYXNzIGluIGEgY29tbWEtZGVsaW1pdGVkIGxpc3Qgb2YgcHJvcGVydHkgbmFtZXNcbiAgICAgIGlmIChfaXNTdHJpbmcodmFycykpIHtcbiAgICAgICAgcCA9IHt9O1xuXG4gICAgICAgIF9mb3JFYWNoTmFtZSh2YXJzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgIHJldHVybiBwW25hbWVdID0gMTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFycyA9IHA7XG4gICAgICB9XG5cbiAgICAgIHZhcnMgPSBfYWRkQWxpYXNlc1RvVmFycyhwYXJzZWRUYXJnZXRzLCB2YXJzKTtcbiAgICB9XG5cbiAgICBpID0gcGFyc2VkVGFyZ2V0cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBpZiAofmtpbGxpbmdUYXJnZXRzLmluZGV4T2YocGFyc2VkVGFyZ2V0c1tpXSkpIHtcbiAgICAgICAgY3VyTG9va3VwID0gcHJvcFR3ZWVuTG9va3VwW2ldO1xuXG4gICAgICAgIGlmICh2YXJzID09PSBcImFsbFwiKSB7XG4gICAgICAgICAgb3ZlcndyaXR0ZW5Qcm9wc1tpXSA9IHZhcnM7XG4gICAgICAgICAgcHJvcHMgPSBjdXJMb29rdXA7XG4gICAgICAgICAgY3VyT3ZlcndyaXRlUHJvcHMgPSB7fTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJPdmVyd3JpdGVQcm9wcyA9IG92ZXJ3cml0dGVuUHJvcHNbaV0gPSBvdmVyd3JpdHRlblByb3BzW2ldIHx8IHt9O1xuICAgICAgICAgIHByb3BzID0gdmFycztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAocCBpbiBwcm9wcykge1xuICAgICAgICAgIHB0ID0gY3VyTG9va3VwICYmIGN1ckxvb2t1cFtwXTtcblxuICAgICAgICAgIGlmIChwdCkge1xuICAgICAgICAgICAgaWYgKCEoXCJraWxsXCIgaW4gcHQuZCkgfHwgcHQuZC5raWxsKHApID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIF9yZW1vdmVMaW5rZWRMaXN0SXRlbSh0aGlzLCBwdCwgXCJfcHRcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlbGV0ZSBjdXJMb29rdXBbcF07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGN1ck92ZXJ3cml0ZVByb3BzICE9PSBcImFsbFwiKSB7XG4gICAgICAgICAgICBjdXJPdmVyd3JpdGVQcm9wc1twXSA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5faW5pdHRlZCAmJiAhdGhpcy5fcHQgJiYgZmlyc3RQVCAmJiBfaW50ZXJydXB0KHRoaXMpOyAvL2lmIGFsbCB0d2VlbmluZyBwcm9wZXJ0aWVzIGFyZSBraWxsZWQsIGtpbGwgdGhlIHR3ZWVuLiBXaXRob3V0IHRoaXMgbGluZSwgaWYgdGhlcmUncyBhIHR3ZWVuIHdpdGggbXVsdGlwbGUgdGFyZ2V0cyBhbmQgdGhlbiB5b3Uga2lsbFR3ZWVuc09mKCkgZWFjaCB0YXJnZXQgaW5kaXZpZHVhbGx5LCB0aGUgdHdlZW4gd291bGQgdGVjaG5pY2FsbHkgc3RpbGwgcmVtYWluIGFjdGl2ZSBhbmQgZmlyZSBpdHMgb25Db21wbGV0ZSBldmVuIHRob3VnaCB0aGVyZSBhcmVuJ3QgYW55IG1vcmUgcHJvcGVydGllcyB0d2VlbmluZy5cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIFR3ZWVuLnRvID0gZnVuY3Rpb24gdG8odGFyZ2V0cywgdmFycykge1xuICAgIHJldHVybiBuZXcgVHdlZW4odGFyZ2V0cywgdmFycywgYXJndW1lbnRzWzJdKTtcbiAgfTtcblxuICBUd2Vlbi5mcm9tID0gZnVuY3Rpb24gZnJvbSh0YXJnZXRzLCB2YXJzKSB7XG4gICAgcmV0dXJuIG5ldyBUd2Vlbih0YXJnZXRzLCBfcGFyc2VWYXJzKGFyZ3VtZW50cywgMSkpO1xuICB9O1xuXG4gIFR3ZWVuLmRlbGF5ZWRDYWxsID0gZnVuY3Rpb24gZGVsYXllZENhbGwoZGVsYXksIGNhbGxiYWNrLCBwYXJhbXMsIHNjb3BlKSB7XG4gICAgcmV0dXJuIG5ldyBUd2VlbihjYWxsYmFjaywgMCwge1xuICAgICAgaW1tZWRpYXRlUmVuZGVyOiBmYWxzZSxcbiAgICAgIGxhenk6IGZhbHNlLFxuICAgICAgb3ZlcndyaXRlOiBmYWxzZSxcbiAgICAgIGRlbGF5OiBkZWxheSxcbiAgICAgIG9uQ29tcGxldGU6IGNhbGxiYWNrLFxuICAgICAgb25SZXZlcnNlQ29tcGxldGU6IGNhbGxiYWNrLFxuICAgICAgb25Db21wbGV0ZVBhcmFtczogcGFyYW1zLFxuICAgICAgb25SZXZlcnNlQ29tcGxldGVQYXJhbXM6IHBhcmFtcyxcbiAgICAgIGNhbGxiYWNrU2NvcGU6IHNjb3BlXG4gICAgfSk7XG4gIH07XG5cbiAgVHdlZW4uZnJvbVRvID0gZnVuY3Rpb24gZnJvbVRvKHRhcmdldHMsIGZyb21WYXJzLCB0b1ZhcnMpIHtcbiAgICByZXR1cm4gbmV3IFR3ZWVuKHRhcmdldHMsIF9wYXJzZVZhcnMoYXJndW1lbnRzLCAyKSk7XG4gIH07XG5cbiAgVHdlZW4uc2V0ID0gZnVuY3Rpb24gc2V0KHRhcmdldHMsIHZhcnMpIHtcbiAgICB2YXJzLmR1cmF0aW9uID0gMDtcbiAgICB2YXJzLnJlcGVhdERlbGF5IHx8ICh2YXJzLnJlcGVhdCA9IDApO1xuICAgIHJldHVybiBuZXcgVHdlZW4odGFyZ2V0cywgdmFycyk7XG4gIH07XG5cbiAgVHdlZW4ua2lsbFR3ZWVuc09mID0gZnVuY3Rpb24ga2lsbFR3ZWVuc09mKHRhcmdldHMsIHByb3BzLCBvbmx5QWN0aXZlKSB7XG4gICAgcmV0dXJuIF9nbG9iYWxUaW1lbGluZS5raWxsVHdlZW5zT2YodGFyZ2V0cywgcHJvcHMsIG9ubHlBY3RpdmUpO1xuICB9O1xuXG4gIHJldHVybiBUd2Vlbjtcbn0oQW5pbWF0aW9uKTtcblxuX3NldERlZmF1bHRzKFR3ZWVuLnByb3RvdHlwZSwge1xuICBfdGFyZ2V0czogW10sXG4gIF9sYXp5OiAwLFxuICBfc3RhcnRBdDogMCxcbiAgX29wOiAwLFxuICBfb25Jbml0OiAwXG59KTsgLy9hZGQgdGhlIHBlcnRpbmVudCB0aW1lbGluZSBtZXRob2RzIHRvIFR3ZWVuIGluc3RhbmNlcyBzbyB0aGF0IHVzZXJzIGNhbiBjaGFpbiBjb252ZW5pZW50bHkgYW5kIGNyZWF0ZSBhIHRpbWVsaW5lIGF1dG9tYXRpY2FsbHkuIChyZW1vdmVkIGR1ZSB0byBjb25jZXJucyB0aGF0IGl0J2QgdWx0aW1hdGVseSBhZGQgdG8gbW9yZSBjb25mdXNpb24gZXNwZWNpYWxseSBmb3IgYmVnaW5uZXJzKVxuLy8gX2ZvckVhY2hOYW1lKFwidG8sZnJvbSxmcm9tVG8sc2V0LGNhbGwsYWRkLGFkZExhYmVsLGFkZFBhdXNlXCIsIG5hbWUgPT4ge1xuLy8gXHRUd2Vlbi5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbi8vIFx0XHRsZXQgdGwgPSBuZXcgVGltZWxpbmUoKTtcbi8vIFx0XHRyZXR1cm4gX2FkZFRvVGltZWxpbmUodGwsIHRoaXMpW25hbWVdLmFwcGx5KHRsLCB0b0FycmF5KGFyZ3VtZW50cykpO1xuLy8gXHR9XG4vLyB9KTtcbi8vZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuIExldmVyYWdlIHRoZSB0aW1lbGluZSBjYWxscy5cblxuXG5fZm9yRWFjaE5hbWUoXCJzdGFnZ2VyVG8sc3RhZ2dlckZyb20sc3RhZ2dlckZyb21Ub1wiLCBmdW5jdGlvbiAobmFtZSkge1xuICBUd2VlbltuYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGwgPSBuZXcgVGltZWxpbmUoKSxcbiAgICAgICAgcGFyYW1zID0gX3NsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgIHBhcmFtcy5zcGxpY2UobmFtZSA9PT0gXCJzdGFnZ2VyRnJvbVRvXCIgPyA1IDogNCwgMCwgMCk7XG4gICAgcmV0dXJuIHRsW25hbWVdLmFwcGx5KHRsLCBwYXJhbXMpO1xuICB9O1xufSk7XG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFBST1BUV0VFTlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5cbnZhciBfc2V0dGVyUGxhaW4gPSBmdW5jdGlvbiBfc2V0dGVyUGxhaW4odGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgcmV0dXJuIHRhcmdldFtwcm9wZXJ0eV0gPSB2YWx1ZTtcbn0sXG4gICAgX3NldHRlckZ1bmMgPSBmdW5jdGlvbiBfc2V0dGVyRnVuYyh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICByZXR1cm4gdGFyZ2V0W3Byb3BlcnR5XSh2YWx1ZSk7XG59LFxuICAgIF9zZXR0ZXJGdW5jV2l0aFBhcmFtID0gZnVuY3Rpb24gX3NldHRlckZ1bmNXaXRoUGFyYW0odGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIGRhdGEpIHtcbiAgcmV0dXJuIHRhcmdldFtwcm9wZXJ0eV0oZGF0YS5mcCwgdmFsdWUpO1xufSxcbiAgICBfc2V0dGVyQXR0cmlidXRlID0gZnVuY3Rpb24gX3NldHRlckF0dHJpYnV0ZSh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICByZXR1cm4gdGFyZ2V0LnNldEF0dHJpYnV0ZShwcm9wZXJ0eSwgdmFsdWUpO1xufSxcbiAgICBfZ2V0U2V0dGVyID0gZnVuY3Rpb24gX2dldFNldHRlcih0YXJnZXQsIHByb3BlcnR5KSB7XG4gIHJldHVybiBfaXNGdW5jdGlvbih0YXJnZXRbcHJvcGVydHldKSA/IF9zZXR0ZXJGdW5jIDogX2lzVW5kZWZpbmVkKHRhcmdldFtwcm9wZXJ0eV0pICYmIHRhcmdldC5zZXRBdHRyaWJ1dGUgPyBfc2V0dGVyQXR0cmlidXRlIDogX3NldHRlclBsYWluO1xufSxcbiAgICBfcmVuZGVyUGxhaW4gPSBmdW5jdGlvbiBfcmVuZGVyUGxhaW4ocmF0aW8sIGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEuc2V0KGRhdGEudCwgZGF0YS5wLCBNYXRoLnJvdW5kKChkYXRhLnMgKyBkYXRhLmMgKiByYXRpbykgKiAxMDAwMCkgLyAxMDAwMCwgZGF0YSk7XG59LFxuICAgIF9yZW5kZXJCb29sZWFuID0gZnVuY3Rpb24gX3JlbmRlckJvb2xlYW4ocmF0aW8sIGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEuc2V0KGRhdGEudCwgZGF0YS5wLCAhIShkYXRhLnMgKyBkYXRhLmMgKiByYXRpbyksIGRhdGEpO1xufSxcbiAgICBfcmVuZGVyQ29tcGxleFN0cmluZyA9IGZ1bmN0aW9uIF9yZW5kZXJDb21wbGV4U3RyaW5nKHJhdGlvLCBkYXRhKSB7XG4gIHZhciBwdCA9IGRhdGEuX3B0LFxuICAgICAgcyA9IFwiXCI7XG5cbiAgaWYgKCFyYXRpbyAmJiBkYXRhLmIpIHtcbiAgICAvL2IgPSBiZWdpbm5pbmcgc3RyaW5nXG4gICAgcyA9IGRhdGEuYjtcbiAgfSBlbHNlIGlmIChyYXRpbyA9PT0gMSAmJiBkYXRhLmUpIHtcbiAgICAvL2UgPSBlbmRpbmcgc3RyaW5nXG4gICAgcyA9IGRhdGEuZTtcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAocHQpIHtcbiAgICAgIHMgPSBwdC5wICsgKHB0Lm0gPyBwdC5tKHB0LnMgKyBwdC5jICogcmF0aW8pIDogTWF0aC5yb3VuZCgocHQucyArIHB0LmMgKiByYXRpbykgKiAxMDAwMCkgLyAxMDAwMCkgKyBzOyAvL3dlIHVzZSB0aGUgXCJwXCIgcHJvcGVydHkgZm9yIHRoZSB0ZXh0IGluYmV0d2VlbiAobGlrZSBhIHN1ZmZpeCkuIEFuZCBpbiB0aGUgY29udGV4dCBvZiBhIGNvbXBsZXggc3RyaW5nLCB0aGUgbW9kaWZpZXIgKG0pIGlzIHR5cGljYWxseSBqdXN0IE1hdGgucm91bmQoKSwgbGlrZSBmb3IgUkdCIGNvbG9ycy5cblxuICAgICAgcHQgPSBwdC5fbmV4dDtcbiAgICB9XG5cbiAgICBzICs9IGRhdGEuYzsgLy93ZSB1c2UgdGhlIFwiY1wiIG9mIHRoZSBQcm9wVHdlZW4gdG8gc3RvcmUgdGhlIGZpbmFsIGNodW5rIG9mIG5vbi1udW1lcmljIHRleHQuXG4gIH1cblxuICBkYXRhLnNldChkYXRhLnQsIGRhdGEucCwgcywgZGF0YSk7XG59LFxuICAgIF9yZW5kZXJQcm9wVHdlZW5zID0gZnVuY3Rpb24gX3JlbmRlclByb3BUd2VlbnMocmF0aW8sIGRhdGEpIHtcbiAgdmFyIHB0ID0gZGF0YS5fcHQ7XG5cbiAgd2hpbGUgKHB0KSB7XG4gICAgcHQucihyYXRpbywgcHQuZCk7XG4gICAgcHQgPSBwdC5fbmV4dDtcbiAgfVxufSxcbiAgICBfYWRkUGx1Z2luTW9kaWZpZXIgPSBmdW5jdGlvbiBfYWRkUGx1Z2luTW9kaWZpZXIobW9kaWZpZXIsIHR3ZWVuLCB0YXJnZXQsIHByb3BlcnR5KSB7XG4gIHZhciBwdCA9IHRoaXMuX3B0LFxuICAgICAgbmV4dDtcblxuICB3aGlsZSAocHQpIHtcbiAgICBuZXh0ID0gcHQuX25leHQ7XG5cbiAgICBpZiAocHQucCA9PT0gcHJvcGVydHkpIHtcbiAgICAgIHB0Lm1vZGlmaWVyKG1vZGlmaWVyLCB0d2VlbiwgdGFyZ2V0KTtcbiAgICB9XG5cbiAgICBwdCA9IG5leHQ7XG4gIH1cbn0sXG4gICAgX2tpbGxQcm9wVHdlZW5zT2YgPSBmdW5jdGlvbiBfa2lsbFByb3BUd2VlbnNPZihwcm9wZXJ0eSkge1xuICB2YXIgcHQgPSB0aGlzLl9wdCxcbiAgICAgIGhhc05vbkRlcGVuZGVudFJlbWFpbmluZyxcbiAgICAgIG5leHQ7XG5cbiAgd2hpbGUgKHB0KSB7XG4gICAgbmV4dCA9IHB0Ll9uZXh0O1xuXG4gICAgaWYgKHB0LnAgPT09IHByb3BlcnR5ICYmICFwdC5vcCB8fCBwdC5vcCA9PT0gcHJvcGVydHkpIHtcbiAgICAgIF9yZW1vdmVMaW5rZWRMaXN0SXRlbSh0aGlzLCBwdCwgXCJfcHRcIik7XG4gICAgfSBlbHNlIGlmICghcHQuZGVwKSB7XG4gICAgICBoYXNOb25EZXBlbmRlbnRSZW1haW5pbmcgPSAxO1xuICAgIH1cblxuICAgIHB0ID0gbmV4dDtcbiAgfVxuXG4gIHJldHVybiAhaGFzTm9uRGVwZW5kZW50UmVtYWluaW5nO1xufSxcbiAgICBfc2V0dGVyV2l0aE1vZGlmaWVyID0gZnVuY3Rpb24gX3NldHRlcldpdGhNb2RpZmllcih0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgZGF0YSkge1xuICBkYXRhLm1TZXQodGFyZ2V0LCBwcm9wZXJ0eSwgZGF0YS5tLmNhbGwoZGF0YS50d2VlbiwgdmFsdWUsIGRhdGEubXQpLCBkYXRhKTtcbn0sXG4gICAgX3NvcnRQcm9wVHdlZW5zQnlQcmlvcml0eSA9IGZ1bmN0aW9uIF9zb3J0UHJvcFR3ZWVuc0J5UHJpb3JpdHkocGFyZW50KSB7XG4gIHZhciBwdCA9IHBhcmVudC5fcHQsXG4gICAgICBuZXh0LFxuICAgICAgcHQyLFxuICAgICAgZmlyc3QsXG4gICAgICBsYXN0OyAvL3NvcnRzIHRoZSBQcm9wVHdlZW4gbGlua2VkIGxpc3QgaW4gb3JkZXIgb2YgcHJpb3JpdHkgYmVjYXVzZSBzb21lIHBsdWdpbnMgbmVlZCB0byBkbyB0aGVpciB3b3JrIGFmdGVyIEFMTCBvZiB0aGUgUHJvcFR3ZWVucyB3ZXJlIGNyZWF0ZWQgKGxpa2UgUm91bmRQcm9wc1BsdWdpbiBhbmQgTW9kaWZpZXJzUGx1Z2luKVxuXG4gIHdoaWxlIChwdCkge1xuICAgIG5leHQgPSBwdC5fbmV4dDtcbiAgICBwdDIgPSBmaXJzdDtcblxuICAgIHdoaWxlIChwdDIgJiYgcHQyLnByID4gcHQucHIpIHtcbiAgICAgIHB0MiA9IHB0Mi5fbmV4dDtcbiAgICB9XG5cbiAgICBpZiAocHQuX3ByZXYgPSBwdDIgPyBwdDIuX3ByZXYgOiBsYXN0KSB7XG4gICAgICBwdC5fcHJldi5fbmV4dCA9IHB0O1xuICAgIH0gZWxzZSB7XG4gICAgICBmaXJzdCA9IHB0O1xuICAgIH1cblxuICAgIGlmIChwdC5fbmV4dCA9IHB0Mikge1xuICAgICAgcHQyLl9wcmV2ID0gcHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhc3QgPSBwdDtcbiAgICB9XG5cbiAgICBwdCA9IG5leHQ7XG4gIH1cblxuICBwYXJlbnQuX3B0ID0gZmlyc3Q7XG59OyAvL1Byb3BUd2VlbiBrZXk6IHQgPSB0YXJnZXQsIHAgPSBwcm9wLCByID0gcmVuZGVyZXIsIGQgPSBkYXRhLCBzID0gc3RhcnQsIGMgPSBjaGFuZ2UsIG9wID0gb3ZlcndyaXRlUHJvcGVydHkgKE9OTFkgcG9wdWxhdGVkIHdoZW4gaXQncyBkaWZmZXJlbnQgdGhhbiBwKSwgcHIgPSBwcmlvcml0eSwgX25leHQvX3ByZXYgZm9yIHRoZSBsaW5rZWQgbGlzdCBzaWJsaW5ncywgc2V0ID0gc2V0dGVyLCBtID0gbW9kaWZpZXIsIG1TZXQgPSBtb2RpZmllclNldHRlciAodGhlIG9yaWdpbmFsIHNldHRlciwgYmVmb3JlIGEgbW9kaWZpZXIgd2FzIGFkZGVkKVxuXG5cbmV4cG9ydCB2YXIgUHJvcFR3ZWVuID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUHJvcFR3ZWVuKG5leHQsIHRhcmdldCwgcHJvcCwgc3RhcnQsIGNoYW5nZSwgcmVuZGVyZXIsIGRhdGEsIHNldHRlciwgcHJpb3JpdHkpIHtcbiAgICB0aGlzLnQgPSB0YXJnZXQ7XG4gICAgdGhpcy5zID0gc3RhcnQ7XG4gICAgdGhpcy5jID0gY2hhbmdlO1xuICAgIHRoaXMucCA9IHByb3A7XG4gICAgdGhpcy5yID0gcmVuZGVyZXIgfHwgX3JlbmRlclBsYWluO1xuICAgIHRoaXMuZCA9IGRhdGEgfHwgdGhpcztcbiAgICB0aGlzLnNldCA9IHNldHRlciB8fCBfc2V0dGVyUGxhaW47XG4gICAgdGhpcy5wciA9IHByaW9yaXR5IHx8IDA7XG4gICAgdGhpcy5fbmV4dCA9IG5leHQ7XG5cbiAgICBpZiAobmV4dCkge1xuICAgICAgbmV4dC5fcHJldiA9IHRoaXM7XG4gICAgfVxuICB9XG5cbiAgdmFyIF9wcm90bzQgPSBQcm9wVHdlZW4ucHJvdG90eXBlO1xuXG4gIF9wcm90bzQubW9kaWZpZXIgPSBmdW5jdGlvbiBtb2RpZmllcihmdW5jLCB0d2VlbiwgdGFyZ2V0KSB7XG4gICAgdGhpcy5tU2V0ID0gdGhpcy5tU2V0IHx8IHRoaXMuc2V0OyAvL2luIGNhc2UgaXQgd2FzIGFscmVhZHkgc2V0IChhIFByb3BUd2VlbiBjYW4gb25seSBoYXZlIG9uZSBtb2RpZmllcilcblxuICAgIHRoaXMuc2V0ID0gX3NldHRlcldpdGhNb2RpZmllcjtcbiAgICB0aGlzLm0gPSBmdW5jO1xuICAgIHRoaXMubXQgPSB0YXJnZXQ7IC8vbW9kaWZpZXIgdGFyZ2V0XG5cbiAgICB0aGlzLnR3ZWVuID0gdHdlZW47XG4gIH07XG5cbiAgcmV0dXJuIFByb3BUd2Vlbjtcbn0oKTsgLy9Jbml0aWFsaXphdGlvbiB0YXNrc1xuXG5fZm9yRWFjaE5hbWUoX2NhbGxiYWNrTmFtZXMgKyBcInBhcmVudCxkdXJhdGlvbixlYXNlLGRlbGF5LG92ZXJ3cml0ZSxydW5CYWNrd2FyZHMsc3RhcnRBdCx5b3lvLGltbWVkaWF0ZVJlbmRlcixyZXBlYXQscmVwZWF0RGVsYXksZGF0YSxwYXVzZWQscmV2ZXJzZWQsbGF6eSxjYWxsYmFja1Njb3BlLHN0cmluZ0ZpbHRlcixpZCx5b3lvRWFzZSxzdGFnZ2VyLGluaGVyaXQscmVwZWF0UmVmcmVzaCxrZXlmcmFtZXMsYXV0b1JldmVydCxzY3JvbGxUcmlnZ2VyXCIsIGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBfcmVzZXJ2ZWRQcm9wc1tuYW1lXSA9IDE7XG59KTtcblxuX2dsb2JhbHMuVHdlZW5NYXggPSBfZ2xvYmFscy5Ud2VlbkxpdGUgPSBUd2Vlbjtcbl9nbG9iYWxzLlRpbWVsaW5lTGl0ZSA9IF9nbG9iYWxzLlRpbWVsaW5lTWF4ID0gVGltZWxpbmU7XG5fZ2xvYmFsVGltZWxpbmUgPSBuZXcgVGltZWxpbmUoe1xuICBzb3J0Q2hpbGRyZW46IGZhbHNlLFxuICBkZWZhdWx0czogX2RlZmF1bHRzLFxuICBhdXRvUmVtb3ZlQ2hpbGRyZW46IHRydWUsXG4gIGlkOiBcInJvb3RcIixcbiAgc21vb3RoQ2hpbGRUaW1pbmc6IHRydWVcbn0pO1xuX2NvbmZpZy5zdHJpbmdGaWx0ZXIgPSBfY29sb3JTdHJpbmdGaWx0ZXI7XG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEdTQVBcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxudmFyIF9nc2FwID0ge1xuICByZWdpc3RlclBsdWdpbjogZnVuY3Rpb24gcmVnaXN0ZXJQbHVnaW4oKSB7XG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgYXJncy5mb3JFYWNoKGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgIHJldHVybiBfY3JlYXRlUGx1Z2luKGNvbmZpZyk7XG4gICAgfSk7XG4gIH0sXG4gIHRpbWVsaW5lOiBmdW5jdGlvbiB0aW1lbGluZSh2YXJzKSB7XG4gICAgcmV0dXJuIG5ldyBUaW1lbGluZSh2YXJzKTtcbiAgfSxcbiAgZ2V0VHdlZW5zT2Y6IGZ1bmN0aW9uIGdldFR3ZWVuc09mKHRhcmdldHMsIG9ubHlBY3RpdmUpIHtcbiAgICByZXR1cm4gX2dsb2JhbFRpbWVsaW5lLmdldFR3ZWVuc09mKHRhcmdldHMsIG9ubHlBY3RpdmUpO1xuICB9LFxuICBnZXRQcm9wZXJ0eTogZnVuY3Rpb24gZ2V0UHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwgdW5pdCwgdW5jYWNoZSkge1xuICAgIGlmIChfaXNTdHJpbmcodGFyZ2V0KSkge1xuICAgICAgLy9pbiBjYXNlIHNlbGVjdG9yIHRleHQgb3IgYW4gYXJyYXkgaXMgcGFzc2VkIGluXG4gICAgICB0YXJnZXQgPSB0b0FycmF5KHRhcmdldClbMF07XG4gICAgfVxuXG4gICAgdmFyIGdldHRlciA9IF9nZXRDYWNoZSh0YXJnZXQgfHwge30pLmdldCxcbiAgICAgICAgZm9ybWF0ID0gdW5pdCA/IF9wYXNzVGhyb3VnaCA6IF9udW1lcmljSWZQb3NzaWJsZTtcblxuICAgIGlmICh1bml0ID09PSBcIm5hdGl2ZVwiKSB7XG4gICAgICB1bml0ID0gXCJcIjtcbiAgICB9XG5cbiAgICByZXR1cm4gIXRhcmdldCA/IHRhcmdldCA6ICFwcm9wZXJ0eSA/IGZ1bmN0aW9uIChwcm9wZXJ0eSwgdW5pdCwgdW5jYWNoZSkge1xuICAgICAgcmV0dXJuIGZvcm1hdCgoX3BsdWdpbnNbcHJvcGVydHldICYmIF9wbHVnaW5zW3Byb3BlcnR5XS5nZXQgfHwgZ2V0dGVyKSh0YXJnZXQsIHByb3BlcnR5LCB1bml0LCB1bmNhY2hlKSk7XG4gICAgfSA6IGZvcm1hdCgoX3BsdWdpbnNbcHJvcGVydHldICYmIF9wbHVnaW5zW3Byb3BlcnR5XS5nZXQgfHwgZ2V0dGVyKSh0YXJnZXQsIHByb3BlcnR5LCB1bml0LCB1bmNhY2hlKSk7XG4gIH0sXG4gIHF1aWNrU2V0dGVyOiBmdW5jdGlvbiBxdWlja1NldHRlcih0YXJnZXQsIHByb3BlcnR5LCB1bml0KSB7XG4gICAgdGFyZ2V0ID0gdG9BcnJheSh0YXJnZXQpO1xuXG4gICAgaWYgKHRhcmdldC5sZW5ndGggPiAxKSB7XG4gICAgICB2YXIgc2V0dGVycyA9IHRhcmdldC5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIGdzYXAucXVpY2tTZXR0ZXIodCwgcHJvcGVydHksIHVuaXQpO1xuICAgICAgfSksXG4gICAgICAgICAgbCA9IHNldHRlcnMubGVuZ3RoO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgaSA9IGw7XG5cbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgIHNldHRlcnNbaV0odmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIHRhcmdldCA9IHRhcmdldFswXSB8fCB7fTtcblxuICAgIHZhciBQbHVnaW4gPSBfcGx1Z2luc1twcm9wZXJ0eV0sXG4gICAgICAgIGNhY2hlID0gX2dldENhY2hlKHRhcmdldCksXG4gICAgICAgIHAgPSBjYWNoZS5oYXJuZXNzICYmIChjYWNoZS5oYXJuZXNzLmFsaWFzZXMgfHwge30pW3Byb3BlcnR5XSB8fCBwcm9wZXJ0eSxcbiAgICAgICAgLy8gaW4gY2FzZSBpdCdzIGFuIGFsaWFzLCBsaWtlIFwicm90YXRlXCIgZm9yIFwicm90YXRpb25cIi5cbiAgICBzZXR0ZXIgPSBQbHVnaW4gPyBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHZhciBwID0gbmV3IFBsdWdpbigpO1xuICAgICAgX3F1aWNrVHdlZW4uX3B0ID0gMDtcbiAgICAgIHAuaW5pdCh0YXJnZXQsIHVuaXQgPyB2YWx1ZSArIHVuaXQgOiB2YWx1ZSwgX3F1aWNrVHdlZW4sIDAsIFt0YXJnZXRdKTtcbiAgICAgIHAucmVuZGVyKDEsIHApO1xuICAgICAgX3F1aWNrVHdlZW4uX3B0ICYmIF9yZW5kZXJQcm9wVHdlZW5zKDEsIF9xdWlja1R3ZWVuKTtcbiAgICB9IDogY2FjaGUuc2V0KHRhcmdldCwgcCk7XG5cbiAgICByZXR1cm4gUGx1Z2luID8gc2V0dGVyIDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gc2V0dGVyKHRhcmdldCwgcCwgdW5pdCA/IHZhbHVlICsgdW5pdCA6IHZhbHVlLCBjYWNoZSwgMSk7XG4gICAgfTtcbiAgfSxcbiAgaXNUd2VlbmluZzogZnVuY3Rpb24gaXNUd2VlbmluZyh0YXJnZXRzKSB7XG4gICAgcmV0dXJuIF9nbG9iYWxUaW1lbGluZS5nZXRUd2VlbnNPZih0YXJnZXRzLCB0cnVlKS5sZW5ndGggPiAwO1xuICB9LFxuICBkZWZhdWx0czogZnVuY3Rpb24gZGVmYXVsdHModmFsdWUpIHtcbiAgICBpZiAodmFsdWUgJiYgdmFsdWUuZWFzZSkge1xuICAgICAgdmFsdWUuZWFzZSA9IF9wYXJzZUVhc2UodmFsdWUuZWFzZSwgX2RlZmF1bHRzLmVhc2UpO1xuICAgIH1cblxuICAgIHJldHVybiBfbWVyZ2VEZWVwKF9kZWZhdWx0cywgdmFsdWUgfHwge30pO1xuICB9LFxuICBjb25maWc6IGZ1bmN0aW9uIGNvbmZpZyh2YWx1ZSkge1xuICAgIHJldHVybiBfbWVyZ2VEZWVwKF9jb25maWcsIHZhbHVlIHx8IHt9KTtcbiAgfSxcbiAgcmVnaXN0ZXJFZmZlY3Q6IGZ1bmN0aW9uIHJlZ2lzdGVyRWZmZWN0KF9yZWYpIHtcbiAgICB2YXIgbmFtZSA9IF9yZWYubmFtZSxcbiAgICAgICAgZWZmZWN0ID0gX3JlZi5lZmZlY3QsXG4gICAgICAgIHBsdWdpbnMgPSBfcmVmLnBsdWdpbnMsXG4gICAgICAgIGRlZmF1bHRzID0gX3JlZi5kZWZhdWx0cyxcbiAgICAgICAgZXh0ZW5kVGltZWxpbmUgPSBfcmVmLmV4dGVuZFRpbWVsaW5lO1xuICAgIChwbHVnaW5zIHx8IFwiXCIpLnNwbGl0KFwiLFwiKS5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW5OYW1lKSB7XG4gICAgICByZXR1cm4gcGx1Z2luTmFtZSAmJiAhX3BsdWdpbnNbcGx1Z2luTmFtZV0gJiYgIV9nbG9iYWxzW3BsdWdpbk5hbWVdICYmIF93YXJuKG5hbWUgKyBcIiBlZmZlY3QgcmVxdWlyZXMgXCIgKyBwbHVnaW5OYW1lICsgXCIgcGx1Z2luLlwiKTtcbiAgICB9KTtcblxuICAgIF9lZmZlY3RzW25hbWVdID0gZnVuY3Rpb24gKHRhcmdldHMsIHZhcnMsIHRsKSB7XG4gICAgICByZXR1cm4gZWZmZWN0KHRvQXJyYXkodGFyZ2V0cyksIF9zZXREZWZhdWx0cyh2YXJzIHx8IHt9LCBkZWZhdWx0cyksIHRsKTtcbiAgICB9O1xuXG4gICAgaWYgKGV4dGVuZFRpbWVsaW5lKSB7XG4gICAgICBUaW1lbGluZS5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbiAodGFyZ2V0cywgdmFycywgcG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKF9lZmZlY3RzW25hbWVdKHRhcmdldHMsIF9pc09iamVjdCh2YXJzKSA/IHZhcnMgOiAocG9zaXRpb24gPSB2YXJzKSAmJiB7fSwgdGhpcyksIHBvc2l0aW9uKTtcbiAgICAgIH07XG4gICAgfVxuICB9LFxuICByZWdpc3RlckVhc2U6IGZ1bmN0aW9uIHJlZ2lzdGVyRWFzZShuYW1lLCBlYXNlKSB7XG4gICAgX2Vhc2VNYXBbbmFtZV0gPSBfcGFyc2VFYXNlKGVhc2UpO1xuICB9LFxuICBwYXJzZUVhc2U6IGZ1bmN0aW9uIHBhcnNlRWFzZShlYXNlLCBkZWZhdWx0RWFzZSkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gX3BhcnNlRWFzZShlYXNlLCBkZWZhdWx0RWFzZSkgOiBfZWFzZU1hcDtcbiAgfSxcbiAgZ2V0QnlJZDogZnVuY3Rpb24gZ2V0QnlJZChpZCkge1xuICAgIHJldHVybiBfZ2xvYmFsVGltZWxpbmUuZ2V0QnlJZChpZCk7XG4gIH0sXG4gIGV4cG9ydFJvb3Q6IGZ1bmN0aW9uIGV4cG9ydFJvb3QodmFycywgaW5jbHVkZURlbGF5ZWRDYWxscykge1xuICAgIGlmICh2YXJzID09PSB2b2lkIDApIHtcbiAgICAgIHZhcnMgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgdGwgPSBuZXcgVGltZWxpbmUodmFycyksXG4gICAgICAgIGNoaWxkLFxuICAgICAgICBuZXh0O1xuICAgIHRsLnNtb290aENoaWxkVGltaW5nID0gX2lzTm90RmFsc2UodmFycy5zbW9vdGhDaGlsZFRpbWluZyk7XG5cbiAgICBfZ2xvYmFsVGltZWxpbmUucmVtb3ZlKHRsKTtcblxuICAgIHRsLl9kcCA9IDA7IC8vb3RoZXJ3aXNlIGl0J2xsIGdldCByZS1hY3RpdmF0ZWQgd2hlbiBhZGRpbmcgY2hpbGRyZW4gYW5kIGJlIHJlLWludHJvZHVjZWQgaW50byBfZ2xvYmFsVGltZWxpbmUncyBsaW5rZWQgbGlzdCAodGhlbiBhZGRlZCB0byBpdHNlbGYpLlxuXG4gICAgdGwuX3RpbWUgPSB0bC5fdFRpbWUgPSBfZ2xvYmFsVGltZWxpbmUuX3RpbWU7XG4gICAgY2hpbGQgPSBfZ2xvYmFsVGltZWxpbmUuX2ZpcnN0O1xuXG4gICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICBuZXh0ID0gY2hpbGQuX25leHQ7XG5cbiAgICAgIGlmIChpbmNsdWRlRGVsYXllZENhbGxzIHx8ICEoIWNoaWxkLl9kdXIgJiYgY2hpbGQgaW5zdGFuY2VvZiBUd2VlbiAmJiBjaGlsZC52YXJzLm9uQ29tcGxldGUgPT09IGNoaWxkLl90YXJnZXRzWzBdKSkge1xuICAgICAgICBfYWRkVG9UaW1lbGluZSh0bCwgY2hpbGQsIGNoaWxkLl9zdGFydCAtIGNoaWxkLl9kZWxheSk7XG4gICAgICB9XG5cbiAgICAgIGNoaWxkID0gbmV4dDtcbiAgICB9XG5cbiAgICBfYWRkVG9UaW1lbGluZShfZ2xvYmFsVGltZWxpbmUsIHRsLCAwKTtcblxuICAgIHJldHVybiB0bDtcbiAgfSxcbiAgdXRpbHM6IHtcbiAgICB3cmFwOiB3cmFwLFxuICAgIHdyYXBZb3lvOiB3cmFwWW95byxcbiAgICBkaXN0cmlidXRlOiBkaXN0cmlidXRlLFxuICAgIHJhbmRvbTogcmFuZG9tLFxuICAgIHNuYXA6IHNuYXAsXG4gICAgbm9ybWFsaXplOiBub3JtYWxpemUsXG4gICAgZ2V0VW5pdDogZ2V0VW5pdCxcbiAgICBjbGFtcDogY2xhbXAsXG4gICAgc3BsaXRDb2xvcjogc3BsaXRDb2xvcixcbiAgICB0b0FycmF5OiB0b0FycmF5LFxuICAgIG1hcFJhbmdlOiBtYXBSYW5nZSxcbiAgICBwaXBlOiBwaXBlLFxuICAgIHVuaXRpemU6IHVuaXRpemUsXG4gICAgaW50ZXJwb2xhdGU6IGludGVycG9sYXRlLFxuICAgIHNodWZmbGU6IHNodWZmbGVcbiAgfSxcbiAgaW5zdGFsbDogX2luc3RhbGwsXG4gIGVmZmVjdHM6IF9lZmZlY3RzLFxuICB0aWNrZXI6IF90aWNrZXIsXG4gIHVwZGF0ZVJvb3Q6IFRpbWVsaW5lLnVwZGF0ZVJvb3QsXG4gIHBsdWdpbnM6IF9wbHVnaW5zLFxuICBnbG9iYWxUaW1lbGluZTogX2dsb2JhbFRpbWVsaW5lLFxuICBjb3JlOiB7XG4gICAgUHJvcFR3ZWVuOiBQcm9wVHdlZW4sXG4gICAgZ2xvYmFsczogX2FkZEdsb2JhbCxcbiAgICBUd2VlbjogVHdlZW4sXG4gICAgVGltZWxpbmU6IFRpbWVsaW5lLFxuICAgIEFuaW1hdGlvbjogQW5pbWF0aW9uLFxuICAgIGdldENhY2hlOiBfZ2V0Q2FjaGUsXG4gICAgX3JlbW92ZUxpbmtlZExpc3RJdGVtOiBfcmVtb3ZlTGlua2VkTGlzdEl0ZW1cbiAgfVxufTtcblxuX2ZvckVhY2hOYW1lKFwidG8sZnJvbSxmcm9tVG8sZGVsYXllZENhbGwsc2V0LGtpbGxUd2VlbnNPZlwiLCBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gX2dzYXBbbmFtZV0gPSBUd2VlbltuYW1lXTtcbn0pO1xuXG5fdGlja2VyLmFkZChUaW1lbGluZS51cGRhdGVSb290KTtcblxuX3F1aWNrVHdlZW4gPSBfZ3NhcC50byh7fSwge1xuICBkdXJhdGlvbjogMFxufSk7IC8vIC0tLS0gRVhUUkEgUExVR0lOUyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgX2dldFBsdWdpblByb3BUd2VlbiA9IGZ1bmN0aW9uIF9nZXRQbHVnaW5Qcm9wVHdlZW4ocGx1Z2luLCBwcm9wKSB7XG4gIHZhciBwdCA9IHBsdWdpbi5fcHQ7XG5cbiAgd2hpbGUgKHB0ICYmIHB0LnAgIT09IHByb3AgJiYgcHQub3AgIT09IHByb3AgJiYgcHQuZnAgIT09IHByb3ApIHtcbiAgICBwdCA9IHB0Ll9uZXh0O1xuICB9XG5cbiAgcmV0dXJuIHB0O1xufSxcbiAgICBfYWRkTW9kaWZpZXJzID0gZnVuY3Rpb24gX2FkZE1vZGlmaWVycyh0d2VlbiwgbW9kaWZpZXJzKSB7XG4gIHZhciB0YXJnZXRzID0gdHdlZW4uX3RhcmdldHMsXG4gICAgICBwLFxuICAgICAgaSxcbiAgICAgIHB0O1xuXG4gIGZvciAocCBpbiBtb2RpZmllcnMpIHtcbiAgICBpID0gdGFyZ2V0cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBwdCA9IHR3ZWVuLl9wdExvb2t1cFtpXVtwXTtcblxuICAgICAgaWYgKHB0ICYmIChwdCA9IHB0LmQpKSB7XG4gICAgICAgIGlmIChwdC5fcHQpIHtcbiAgICAgICAgICAvLyBpcyBhIHBsdWdpblxuICAgICAgICAgIHB0ID0gX2dldFBsdWdpblByb3BUd2VlbihwdCwgcCk7XG4gICAgICAgIH1cblxuICAgICAgICBwdCAmJiBwdC5tb2RpZmllciAmJiBwdC5tb2RpZmllcihtb2RpZmllcnNbcF0sIHR3ZWVuLCB0YXJnZXRzW2ldLCBwKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0sXG4gICAgX2J1aWxkTW9kaWZpZXJQbHVnaW4gPSBmdW5jdGlvbiBfYnVpbGRNb2RpZmllclBsdWdpbihuYW1lLCBtb2RpZmllcikge1xuICByZXR1cm4ge1xuICAgIG5hbWU6IG5hbWUsXG4gICAgcmF3VmFyczogMSxcbiAgICAvL2Rvbid0IHByZS1wcm9jZXNzIGZ1bmN0aW9uLWJhc2VkIHZhbHVlcyBvciBcInJhbmRvbSgpXCIgc3RyaW5ncy5cbiAgICBpbml0OiBmdW5jdGlvbiBpbml0KHRhcmdldCwgdmFycywgdHdlZW4pIHtcbiAgICAgIHR3ZWVuLl9vbkluaXQgPSBmdW5jdGlvbiAodHdlZW4pIHtcbiAgICAgICAgdmFyIHRlbXAsIHA7XG5cbiAgICAgICAgaWYgKF9pc1N0cmluZyh2YXJzKSkge1xuICAgICAgICAgIHRlbXAgPSB7fTtcblxuICAgICAgICAgIF9mb3JFYWNoTmFtZSh2YXJzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRlbXBbbmFtZV0gPSAxO1xuICAgICAgICAgIH0pOyAvL2lmIHRoZSB1c2VyIHBhc3NlcyBpbiBhIGNvbW1hLWRlbGltaXRlZCBsaXN0IG9mIHByb3BlcnR5IG5hbWVzIHRvIHJvdW5kUHJvcHMsIGxpa2UgXCJ4LHlcIiwgd2Ugcm91bmQgdG8gd2hvbGUgbnVtYmVycy5cblxuXG4gICAgICAgICAgdmFycyA9IHRlbXA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW9kaWZpZXIpIHtcbiAgICAgICAgICB0ZW1wID0ge307XG5cbiAgICAgICAgICBmb3IgKHAgaW4gdmFycykge1xuICAgICAgICAgICAgdGVtcFtwXSA9IG1vZGlmaWVyKHZhcnNbcF0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhcnMgPSB0ZW1wO1xuICAgICAgICB9XG5cbiAgICAgICAgX2FkZE1vZGlmaWVycyh0d2VlbiwgdmFycyk7XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn07IC8vcmVnaXN0ZXIgY29yZSBwbHVnaW5zXG5cblxuZXhwb3J0IHZhciBnc2FwID0gX2dzYXAucmVnaXN0ZXJQbHVnaW4oe1xuICBuYW1lOiBcImF0dHJcIixcbiAgaW5pdDogZnVuY3Rpb24gaW5pdCh0YXJnZXQsIHZhcnMsIHR3ZWVuLCBpbmRleCwgdGFyZ2V0cykge1xuICAgIHZhciBwLCBwdDtcblxuICAgIGZvciAocCBpbiB2YXJzKSB7XG4gICAgICBwdCA9IHRoaXMuYWRkKHRhcmdldCwgXCJzZXRBdHRyaWJ1dGVcIiwgKHRhcmdldC5nZXRBdHRyaWJ1dGUocCkgfHwgMCkgKyBcIlwiLCB2YXJzW3BdLCBpbmRleCwgdGFyZ2V0cywgMCwgMCwgcCk7XG4gICAgICBwdCAmJiAocHQub3AgPSBwKTsgLy90aGlzLmFkZCh0YXJnZXQsIFwic2V0QXR0cmlidXRlXCIsICh0YXJnZXQuZ2V0QXR0cmlidXRlKChwIGluIHRhcmdldC5kYXRhc2V0ID8gKHAgPSBcImRhdGEtXCIgKyBwKSA6IHApKSB8fCAwKSArIFwiXCIsIHZhcnNbcF0sIGluZGV4LCB0YXJnZXRzLCAwLCAwLCBwKTtcblxuICAgICAgdGhpcy5fcHJvcHMucHVzaChwKTtcbiAgICB9XG4gIH1cbn0sIHtcbiAgbmFtZTogXCJlbmRBcnJheVwiLFxuICBpbml0OiBmdW5jdGlvbiBpbml0KHRhcmdldCwgdmFsdWUpIHtcbiAgICB2YXIgaSA9IHZhbHVlLmxlbmd0aDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHRoaXMuYWRkKHRhcmdldCwgaSwgdGFyZ2V0W2ldIHx8IDAsIHZhbHVlW2ldKTtcbiAgICB9XG4gIH1cbn0sIF9idWlsZE1vZGlmaWVyUGx1Z2luKFwicm91bmRQcm9wc1wiLCBfcm91bmRNb2RpZmllciksIF9idWlsZE1vZGlmaWVyUGx1Z2luKFwibW9kaWZpZXJzXCIpLCBfYnVpbGRNb2RpZmllclBsdWdpbihcInNuYXBcIiwgc25hcCkpIHx8IF9nc2FwOyAvL3RvIHByZXZlbnQgdGhlIGNvcmUgcGx1Z2lucyBmcm9tIGJlaW5nIGRyb3BwZWQgdmlhIGFnZ3Jlc3NpdmUgdHJlZSBzaGFraW5nLCB3ZSBtdXN0IGluY2x1ZGUgdGhlbSBpbiB0aGUgdmFyaWFibGUgZGVjbGFyYXRpb24gaW4gdGhpcyB3YXkuXG5cblR3ZWVuLnZlcnNpb24gPSBUaW1lbGluZS52ZXJzaW9uID0gZ3NhcC52ZXJzaW9uID0gXCIzLjQuMlwiO1xuX2NvcmVSZWFkeSA9IDE7XG5cbmlmIChfd2luZG93RXhpc3RzKCkpIHtcbiAgX3dha2UoKTtcbn1cblxudmFyIFBvd2VyMCA9IF9lYXNlTWFwLlBvd2VyMCxcbiAgICBQb3dlcjEgPSBfZWFzZU1hcC5Qb3dlcjEsXG4gICAgUG93ZXIyID0gX2Vhc2VNYXAuUG93ZXIyLFxuICAgIFBvd2VyMyA9IF9lYXNlTWFwLlBvd2VyMyxcbiAgICBQb3dlcjQgPSBfZWFzZU1hcC5Qb3dlcjQsXG4gICAgTGluZWFyID0gX2Vhc2VNYXAuTGluZWFyLFxuICAgIFF1YWQgPSBfZWFzZU1hcC5RdWFkLFxuICAgIEN1YmljID0gX2Vhc2VNYXAuQ3ViaWMsXG4gICAgUXVhcnQgPSBfZWFzZU1hcC5RdWFydCxcbiAgICBRdWludCA9IF9lYXNlTWFwLlF1aW50LFxuICAgIFN0cm9uZyA9IF9lYXNlTWFwLlN0cm9uZyxcbiAgICBFbGFzdGljID0gX2Vhc2VNYXAuRWxhc3RpYyxcbiAgICBCYWNrID0gX2Vhc2VNYXAuQmFjayxcbiAgICBTdGVwcGVkRWFzZSA9IF9lYXNlTWFwLlN0ZXBwZWRFYXNlLFxuICAgIEJvdW5jZSA9IF9lYXNlTWFwLkJvdW5jZSxcbiAgICBTaW5lID0gX2Vhc2VNYXAuU2luZSxcbiAgICBFeHBvID0gX2Vhc2VNYXAuRXhwbyxcbiAgICBDaXJjID0gX2Vhc2VNYXAuQ2lyYztcbmV4cG9ydCB7IFBvd2VyMCwgUG93ZXIxLCBQb3dlcjIsIFBvd2VyMywgUG93ZXI0LCBMaW5lYXIsIFF1YWQsIEN1YmljLCBRdWFydCwgUXVpbnQsIFN0cm9uZywgRWxhc3RpYywgQmFjaywgU3RlcHBlZEVhc2UsIEJvdW5jZSwgU2luZSwgRXhwbywgQ2lyYyB9O1xuZXhwb3J0IHsgVHdlZW4gYXMgVHdlZW5NYXgsIFR3ZWVuIGFzIFR3ZWVuTGl0ZSwgVGltZWxpbmUgYXMgVGltZWxpbmVNYXgsIFRpbWVsaW5lIGFzIFRpbWVsaW5lTGl0ZSwgZ3NhcCBhcyBkZWZhdWx0LCB3cmFwLCB3cmFwWW95bywgZGlzdHJpYnV0ZSwgcmFuZG9tLCBzbmFwLCBub3JtYWxpemUsIGdldFVuaXQsIGNsYW1wLCBzcGxpdENvbG9yLCB0b0FycmF5LCBtYXBSYW5nZSwgcGlwZSwgdW5pdGl6ZSwgaW50ZXJwb2xhdGUsIHNodWZmbGUgfTsgLy9leHBvcnQgc29tZSBpbnRlcm5hbCBtZXRob2RzL29yb2plY3RzIGZvciB1c2UgaW4gQ1NTUGx1Z2luIHNvIHRoYXQgd2UgY2FuIGV4dGVybmFsaXplIHRoYXQgZmlsZSBhbmQgYWxsb3cgY3VzdG9tIGJ1aWxkcyB0aGF0IGV4Y2x1ZGUgaXQuXG5cbmV4cG9ydCB7IF9nZXRQcm9wZXJ0eSwgX251bUV4cCwgX251bVdpdGhVbml0RXhwLCBfaXNTdHJpbmcsIF9pc1VuZGVmaW5lZCwgX3JlbmRlckNvbXBsZXhTdHJpbmcsIF9yZWxFeHAsIF9zZXREZWZhdWx0cywgX3JlbW92ZUxpbmtlZExpc3RJdGVtLCBfZm9yRWFjaE5hbWUsIF9zb3J0UHJvcFR3ZWVuc0J5UHJpb3JpdHksIF9jb2xvclN0cmluZ0ZpbHRlciwgX3JlcGxhY2VSYW5kb20sIF9jaGVja1BsdWdpbiwgX3BsdWdpbnMsIF90aWNrZXIsIF9jb25maWcsIF9yb3VuZE1vZGlmaWVyLCBfcm91bmQsIF9taXNzaW5nUGx1Z2luLCBfZ2V0U2V0dGVyLCBfZ2V0Q2FjaGUgfTsiLCIvKiFcbiAqIENTU1BsdWdpbiAzLjQuMlxuICogaHR0cHM6Ly9ncmVlbnNvY2suY29tXG4gKlxuICogQ29weXJpZ2h0IDIwMDgtMjAyMCwgR3JlZW5Tb2NrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogU3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cHM6Ly9ncmVlbnNvY2suY29tL3N0YW5kYXJkLWxpY2Vuc2Ugb3IgZm9yXG4gKiBDbHViIEdyZWVuU29jayBtZW1iZXJzLCB0aGUgYWdyZWVtZW50IGlzc3VlZCB3aXRoIHRoYXQgbWVtYmVyc2hpcC5cbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuKi9cblxuLyogZXNsaW50LWRpc2FibGUgKi9cbmltcG9ydCB7IGdzYXAsIF9nZXRQcm9wZXJ0eSwgX251bUV4cCwgX251bVdpdGhVbml0RXhwLCBnZXRVbml0LCBfaXNTdHJpbmcsIF9pc1VuZGVmaW5lZCwgX3JlbmRlckNvbXBsZXhTdHJpbmcsIF9yZWxFeHAsIF9mb3JFYWNoTmFtZSwgX3NvcnRQcm9wVHdlZW5zQnlQcmlvcml0eSwgX2NvbG9yU3RyaW5nRmlsdGVyLCBfY2hlY2tQbHVnaW4sIF9yZXBsYWNlUmFuZG9tLCBfcGx1Z2lucywgR1NDYWNoZSwgUHJvcFR3ZWVuLCBfY29uZmlnLCBfdGlja2VyLCBfcm91bmQsIF9taXNzaW5nUGx1Z2luLCBfZ2V0U2V0dGVyLCBfZ2V0Q2FjaGUsIF9zZXREZWZhdWx0cywgX3JlbW92ZUxpbmtlZExpc3RJdGVtIC8vZm9yIHRoZSBjb21tZW50ZWQtb3V0IGNsYXNzTmFtZSBmZWF0dXJlLlxufSBmcm9tIFwiLi9nc2FwLWNvcmUuanNcIjtcblxudmFyIF93aW4sXG4gICAgX2RvYyxcbiAgICBfZG9jRWxlbWVudCxcbiAgICBfcGx1Z2luSW5pdHRlZCxcbiAgICBfdGVtcERpdixcbiAgICBfdGVtcERpdlN0eWxlcixcbiAgICBfcmVjZW50U2V0dGVyUGx1Z2luLFxuICAgIF93aW5kb3dFeGlzdHMgPSBmdW5jdGlvbiBfd2luZG93RXhpc3RzKCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIjtcbn0sXG4gICAgX3RyYW5zZm9ybVByb3BzID0ge30sXG4gICAgX1JBRDJERUcgPSAxODAgLyBNYXRoLlBJLFxuICAgIF9ERUcyUkFEID0gTWF0aC5QSSAvIDE4MCxcbiAgICBfYXRhbjIgPSBNYXRoLmF0YW4yLFxuICAgIF9iaWdOdW0gPSAxZTgsXG4gICAgX2NhcHNFeHAgPSAvKFtBLVpdKS9nLFxuICAgIF9ob3Jpem9udGFsRXhwID0gLyg/OmxlZnR8cmlnaHR8d2lkdGh8bWFyZ2lufHBhZGRpbmd8eCkvaSxcbiAgICBfY29tcGxleEV4cCA9IC9bXFxzLFxcKF1cXFMvLFxuICAgIF9wcm9wZXJ0eUFsaWFzZXMgPSB7XG4gIGF1dG9BbHBoYTogXCJvcGFjaXR5LHZpc2liaWxpdHlcIixcbiAgc2NhbGU6IFwic2NhbGVYLHNjYWxlWVwiLFxuICBhbHBoYTogXCJvcGFjaXR5XCJcbn0sXG4gICAgX3JlbmRlckNTU1Byb3AgPSBmdW5jdGlvbiBfcmVuZGVyQ1NTUHJvcChyYXRpbywgZGF0YSkge1xuICByZXR1cm4gZGF0YS5zZXQoZGF0YS50LCBkYXRhLnAsIE1hdGgucm91bmQoKGRhdGEucyArIGRhdGEuYyAqIHJhdGlvKSAqIDEwMDAwKSAvIDEwMDAwICsgZGF0YS51LCBkYXRhKTtcbn0sXG4gICAgX3JlbmRlclByb3BXaXRoRW5kID0gZnVuY3Rpb24gX3JlbmRlclByb3BXaXRoRW5kKHJhdGlvLCBkYXRhKSB7XG4gIHJldHVybiBkYXRhLnNldChkYXRhLnQsIGRhdGEucCwgcmF0aW8gPT09IDEgPyBkYXRhLmUgOiBNYXRoLnJvdW5kKChkYXRhLnMgKyBkYXRhLmMgKiByYXRpbykgKiAxMDAwMCkgLyAxMDAwMCArIGRhdGEudSwgZGF0YSk7XG59LFxuICAgIF9yZW5kZXJDU1NQcm9wV2l0aEJlZ2lubmluZyA9IGZ1bmN0aW9uIF9yZW5kZXJDU1NQcm9wV2l0aEJlZ2lubmluZyhyYXRpbywgZGF0YSkge1xuICByZXR1cm4gZGF0YS5zZXQoZGF0YS50LCBkYXRhLnAsIHJhdGlvID8gTWF0aC5yb3VuZCgoZGF0YS5zICsgZGF0YS5jICogcmF0aW8pICogMTAwMDApIC8gMTAwMDAgKyBkYXRhLnUgOiBkYXRhLmIsIGRhdGEpO1xufSxcbiAgICAvL2lmIHVuaXRzIGNoYW5nZSwgd2UgbmVlZCBhIHdheSB0byByZW5kZXIgdGhlIG9yaWdpbmFsIHVuaXQvdmFsdWUgd2hlbiB0aGUgdHdlZW4gZ29lcyBhbGwgdGhlIHdheSBiYWNrIHRvIHRoZSBiZWdpbm5pbmcgKHJhdGlvOjApXG5fcmVuZGVyUm91bmRlZENTU1Byb3AgPSBmdW5jdGlvbiBfcmVuZGVyUm91bmRlZENTU1Byb3AocmF0aW8sIGRhdGEpIHtcbiAgdmFyIHZhbHVlID0gZGF0YS5zICsgZGF0YS5jICogcmF0aW87XG4gIGRhdGEuc2V0KGRhdGEudCwgZGF0YS5wLCB+fih2YWx1ZSArICh2YWx1ZSA8IDAgPyAtLjUgOiAuNSkpICsgZGF0YS51LCBkYXRhKTtcbn0sXG4gICAgX3JlbmRlck5vblR3ZWVuaW5nVmFsdWUgPSBmdW5jdGlvbiBfcmVuZGVyTm9uVHdlZW5pbmdWYWx1ZShyYXRpbywgZGF0YSkge1xuICByZXR1cm4gZGF0YS5zZXQoZGF0YS50LCBkYXRhLnAsIHJhdGlvID8gZGF0YS5lIDogZGF0YS5iLCBkYXRhKTtcbn0sXG4gICAgX3JlbmRlck5vblR3ZWVuaW5nVmFsdWVPbmx5QXRFbmQgPSBmdW5jdGlvbiBfcmVuZGVyTm9uVHdlZW5pbmdWYWx1ZU9ubHlBdEVuZChyYXRpbywgZGF0YSkge1xuICByZXR1cm4gZGF0YS5zZXQoZGF0YS50LCBkYXRhLnAsIHJhdGlvICE9PSAxID8gZGF0YS5iIDogZGF0YS5lLCBkYXRhKTtcbn0sXG4gICAgX3NldHRlckNTU1N0eWxlID0gZnVuY3Rpb24gX3NldHRlckNTU1N0eWxlKHRhcmdldCwgcHJvcGVydHksIHZhbHVlKSB7XG4gIHJldHVybiB0YXJnZXQuc3R5bGVbcHJvcGVydHldID0gdmFsdWU7XG59LFxuICAgIF9zZXR0ZXJDU1NQcm9wID0gZnVuY3Rpb24gX3NldHRlckNTU1Byb3AodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgcmV0dXJuIHRhcmdldC5zdHlsZS5zZXRQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUpO1xufSxcbiAgICBfc2V0dGVyVHJhbnNmb3JtID0gZnVuY3Rpb24gX3NldHRlclRyYW5zZm9ybSh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICByZXR1cm4gdGFyZ2V0Ll9nc2FwW3Byb3BlcnR5XSA9IHZhbHVlO1xufSxcbiAgICBfc2V0dGVyU2NhbGUgPSBmdW5jdGlvbiBfc2V0dGVyU2NhbGUodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgcmV0dXJuIHRhcmdldC5fZ3NhcC5zY2FsZVggPSB0YXJnZXQuX2dzYXAuc2NhbGVZID0gdmFsdWU7XG59LFxuICAgIF9zZXR0ZXJTY2FsZVdpdGhSZW5kZXIgPSBmdW5jdGlvbiBfc2V0dGVyU2NhbGVXaXRoUmVuZGVyKHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCBkYXRhLCByYXRpbykge1xuICB2YXIgY2FjaGUgPSB0YXJnZXQuX2dzYXA7XG4gIGNhY2hlLnNjYWxlWCA9IGNhY2hlLnNjYWxlWSA9IHZhbHVlO1xuICBjYWNoZS5yZW5kZXJUcmFuc2Zvcm0ocmF0aW8sIGNhY2hlKTtcbn0sXG4gICAgX3NldHRlclRyYW5zZm9ybVdpdGhSZW5kZXIgPSBmdW5jdGlvbiBfc2V0dGVyVHJhbnNmb3JtV2l0aFJlbmRlcih0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgZGF0YSwgcmF0aW8pIHtcbiAgdmFyIGNhY2hlID0gdGFyZ2V0Ll9nc2FwO1xuICBjYWNoZVtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgY2FjaGUucmVuZGVyVHJhbnNmb3JtKHJhdGlvLCBjYWNoZSk7XG59LFxuICAgIF90cmFuc2Zvcm1Qcm9wID0gXCJ0cmFuc2Zvcm1cIixcbiAgICBfdHJhbnNmb3JtT3JpZ2luUHJvcCA9IF90cmFuc2Zvcm1Qcm9wICsgXCJPcmlnaW5cIixcbiAgICBfc3VwcG9ydHMzRCxcbiAgICBfY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIF9jcmVhdGVFbGVtZW50KHR5cGUsIG5zKSB7XG4gIHZhciBlID0gX2RvYy5jcmVhdGVFbGVtZW50TlMgPyBfZG9jLmNyZWF0ZUVsZW1lbnROUygobnMgfHwgXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCIpLnJlcGxhY2UoL15odHRwcy8sIFwiaHR0cFwiKSwgdHlwZSkgOiBfZG9jLmNyZWF0ZUVsZW1lbnQodHlwZSk7IC8vc29tZSBzZXJ2ZXJzIHN3YXAgaW4gaHR0cHMgZm9yIGh0dHAgaW4gdGhlIG5hbWVzcGFjZSB3aGljaCBjYW4gYnJlYWsgdGhpbmdzLCBtYWtpbmcgXCJzdHlsZVwiIGluYWNjZXNzaWJsZS5cblxuICByZXR1cm4gZS5zdHlsZSA/IGUgOiBfZG9jLmNyZWF0ZUVsZW1lbnQodHlwZSk7IC8vc29tZSBlbnZpcm9ubWVudHMgd29uJ3QgYWxsb3cgYWNjZXNzIHRvIHRoZSBlbGVtZW50J3Mgc3R5bGUgd2hlbiBjcmVhdGVkIHdpdGggYSBuYW1lc3BhY2UgaW4gd2hpY2ggY2FzZSB3ZSBkZWZhdWx0IHRvIHRoZSBzdGFuZGFyZCBjcmVhdGVFbGVtZW50KCkgdG8gd29yayBhcm91bmQgdGhlIGlzc3VlLiBBbHNvIG5vdGUgdGhhdCB3aGVuIEdTQVAgaXMgZW1iZWRkZWQgZGlyZWN0bHkgaW5zaWRlIGFuIFNWRyBmaWxlLCBjcmVhdGVFbGVtZW50KCkgd29uJ3QgYWxsb3cgYWNjZXNzIHRvIHRoZSBzdHlsZSBvYmplY3QgaW4gRmlyZWZveCAoc2VlIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9mb3J1bXMvdG9waWMvMjAyMTUtcHJvYmxlbS11c2luZy10d2Vlbm1heC1pbi1zdGFuZGFsb25lLXNlbGYtY29udGFpbmluZy1zdmctZmlsZS1lcnItY2Fubm90LXNldC1wcm9wZXJ0eS1jc3N0ZXh0LW9mLXVuZGVmaW5lZC8pLlxufSxcbiAgICBfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSA9IGZ1bmN0aW9uIF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIHNraXBQcmVmaXhGYWxsYmFjaykge1xuICB2YXIgY3MgPSBnZXRDb21wdXRlZFN0eWxlKHRhcmdldCk7XG4gIHJldHVybiBjc1twcm9wZXJ0eV0gfHwgY3MuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eS5yZXBsYWNlKF9jYXBzRXhwLCBcIi0kMVwiKS50b0xvd2VyQ2FzZSgpKSB8fCBjcy5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KSB8fCAhc2tpcFByZWZpeEZhbGxiYWNrICYmIF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgX2NoZWNrUHJvcFByZWZpeChwcm9wZXJ0eSkgfHwgcHJvcGVydHksIDEpIHx8IFwiXCI7IC8vY3NzIHZhcmlhYmxlcyBtYXkgbm90IG5lZWQgY2FwcyBzd2FwcGVkIG91dCBmb3IgZGFzaGVzIGFuZCBsb3dlcmNhc2UuXG59LFxuICAgIF9wcmVmaXhlcyA9IFwiTyxNb3osbXMsTXMsV2Via2l0XCIuc3BsaXQoXCIsXCIpLFxuICAgIF9jaGVja1Byb3BQcmVmaXggPSBmdW5jdGlvbiBfY2hlY2tQcm9wUHJlZml4KHByb3BlcnR5LCBlbGVtZW50LCBwcmVmZXJQcmVmaXgpIHtcbiAgdmFyIGUgPSBlbGVtZW50IHx8IF90ZW1wRGl2LFxuICAgICAgcyA9IGUuc3R5bGUsXG4gICAgICBpID0gNTtcblxuICBpZiAocHJvcGVydHkgaW4gcyAmJiAhcHJlZmVyUHJlZml4KSB7XG4gICAgcmV0dXJuIHByb3BlcnR5O1xuICB9XG5cbiAgcHJvcGVydHkgPSBwcm9wZXJ0eS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3BlcnR5LnN1YnN0cigxKTtcblxuICB3aGlsZSAoaS0tICYmICEoX3ByZWZpeGVzW2ldICsgcHJvcGVydHkgaW4gcykpIHt9XG5cbiAgcmV0dXJuIGkgPCAwID8gbnVsbCA6IChpID09PSAzID8gXCJtc1wiIDogaSA+PSAwID8gX3ByZWZpeGVzW2ldIDogXCJcIikgKyBwcm9wZXJ0eTtcbn0sXG4gICAgX2luaXRDb3JlID0gZnVuY3Rpb24gX2luaXRDb3JlKCkge1xuICBpZiAoX3dpbmRvd0V4aXN0cygpICYmIHdpbmRvdy5kb2N1bWVudCkge1xuICAgIF93aW4gPSB3aW5kb3c7XG4gICAgX2RvYyA9IF93aW4uZG9jdW1lbnQ7XG4gICAgX2RvY0VsZW1lbnQgPSBfZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICBfdGVtcERpdiA9IF9jcmVhdGVFbGVtZW50KFwiZGl2XCIpIHx8IHtcbiAgICAgIHN0eWxlOiB7fVxuICAgIH07XG4gICAgX3RlbXBEaXZTdHlsZXIgPSBfY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBfdHJhbnNmb3JtUHJvcCA9IF9jaGVja1Byb3BQcmVmaXgoX3RyYW5zZm9ybVByb3ApO1xuICAgIF90cmFuc2Zvcm1PcmlnaW5Qcm9wID0gX3RyYW5zZm9ybVByb3AgKyBcIk9yaWdpblwiO1xuICAgIF90ZW1wRGl2LnN0eWxlLmNzc1RleHQgPSBcImJvcmRlci13aWR0aDowO2xpbmUtaGVpZ2h0OjA7cG9zaXRpb246YWJzb2x1dGU7cGFkZGluZzowXCI7IC8vbWFrZSBzdXJlIHRvIG92ZXJyaWRlIGNlcnRhaW4gcHJvcGVydGllcyB0aGF0IG1heSBjb250YW1pbmF0ZSBtZWFzdXJlbWVudHMsIGluIGNhc2UgdGhlIHVzZXIgaGFzIG92ZXJyZWFjaGluZyBzdHlsZSBzaGVldHMuXG5cbiAgICBfc3VwcG9ydHMzRCA9ICEhX2NoZWNrUHJvcFByZWZpeChcInBlcnNwZWN0aXZlXCIpO1xuICAgIF9wbHVnaW5Jbml0dGVkID0gMTtcbiAgfVxufSxcbiAgICBfZ2V0QkJveEhhY2sgPSBmdW5jdGlvbiBfZ2V0QkJveEhhY2soc3dhcElmUG9zc2libGUpIHtcbiAgLy93b3JrcyBhcm91bmQgaXNzdWVzIGluIHNvbWUgYnJvd3NlcnMgKGxpa2UgRmlyZWZveCkgdGhhdCBkb24ndCBjb3JyZWN0bHkgcmVwb3J0IGdldEJCb3goKSBvbiBTVkcgZWxlbWVudHMgaW5zaWRlIGEgPGRlZnM+IGVsZW1lbnQgYW5kL29yIDxtYXNrPi4gV2UgdHJ5IGNyZWF0aW5nIGFuIFNWRywgYWRkaW5nIGl0IHRvIHRoZSBkb2N1bWVudEVsZW1lbnQgYW5kIHRvc3MgdGhlIGVsZW1lbnQgaW4gdGhlcmUgc28gdGhhdCBpdCdzIGRlZmluaXRlbHkgcGFydCBvZiB0aGUgcmVuZGVyaW5nIHRyZWUsIHRoZW4gZ3JhYiB0aGUgYmJveCBhbmQgaWYgaXQgd29ya3MsIHdlIGFjdHVhbGx5IHN3YXAgb3V0IHRoZSBvcmlnaW5hbCBnZXRCQm94KCkgbWV0aG9kIGZvciBvdXIgb3duIHRoYXQgZG9lcyB0aGVzZSBleHRyYSBzdGVwcyB3aGVuZXZlciBnZXRCQm94IGlzIG5lZWRlZC4gVGhpcyBoZWxwcyBlbnN1cmUgdGhhdCBwZXJmb3JtYW5jZSBpcyBvcHRpbWFsIChvbmx5IGRvIGFsbCB0aGVzZSBleHRyYSBzdGVwcyB3aGVuIGFic29sdXRlbHkgbmVjZXNzYXJ5Li4ubW9zdCBlbGVtZW50cyBkb24ndCBuZWVkIGl0KS5cbiAgdmFyIHN2ZyA9IF9jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHRoaXMub3duZXJTVkdFbGVtZW50ICYmIHRoaXMub3duZXJTVkdFbGVtZW50LmdldEF0dHJpYnV0ZShcInhtbG5zXCIpIHx8IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiksXG4gICAgICBvbGRQYXJlbnQgPSB0aGlzLnBhcmVudE5vZGUsXG4gICAgICBvbGRTaWJsaW5nID0gdGhpcy5uZXh0U2libGluZyxcbiAgICAgIG9sZENTUyA9IHRoaXMuc3R5bGUuY3NzVGV4dCxcbiAgICAgIGJib3g7XG5cbiAgX2RvY0VsZW1lbnQuYXBwZW5kQ2hpbGQoc3ZnKTtcblxuICBzdmcuYXBwZW5kQ2hpbGQodGhpcyk7XG4gIHRoaXMuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcblxuICBpZiAoc3dhcElmUG9zc2libGUpIHtcbiAgICB0cnkge1xuICAgICAgYmJveCA9IHRoaXMuZ2V0QkJveCgpO1xuICAgICAgdGhpcy5fZ3NhcEJCb3ggPSB0aGlzLmdldEJCb3g7IC8vc3RvcmUgdGhlIG9yaWdpbmFsXG5cbiAgICAgIHRoaXMuZ2V0QkJveCA9IF9nZXRCQm94SGFjaztcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9IGVsc2UgaWYgKHRoaXMuX2dzYXBCQm94KSB7XG4gICAgYmJveCA9IHRoaXMuX2dzYXBCQm94KCk7XG4gIH1cblxuICBpZiAob2xkUGFyZW50KSB7XG4gICAgaWYgKG9sZFNpYmxpbmcpIHtcbiAgICAgIG9sZFBhcmVudC5pbnNlcnRCZWZvcmUodGhpcywgb2xkU2libGluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9sZFBhcmVudC5hcHBlbmRDaGlsZCh0aGlzKTtcbiAgICB9XG4gIH1cblxuICBfZG9jRWxlbWVudC5yZW1vdmVDaGlsZChzdmcpO1xuXG4gIHRoaXMuc3R5bGUuY3NzVGV4dCA9IG9sZENTUztcbiAgcmV0dXJuIGJib3g7XG59LFxuICAgIF9nZXRBdHRyaWJ1dGVGYWxsYmFja3MgPSBmdW5jdGlvbiBfZ2V0QXR0cmlidXRlRmFsbGJhY2tzKHRhcmdldCwgYXR0cmlidXRlc0FycmF5KSB7XG4gIHZhciBpID0gYXR0cmlidXRlc0FycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKHRhcmdldC5oYXNBdHRyaWJ1dGUoYXR0cmlidXRlc0FycmF5W2ldKSkge1xuICAgICAgcmV0dXJuIHRhcmdldC5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlc0FycmF5W2ldKTtcbiAgICB9XG4gIH1cbn0sXG4gICAgX2dldEJCb3ggPSBmdW5jdGlvbiBfZ2V0QkJveCh0YXJnZXQpIHtcbiAgdmFyIGJvdW5kcztcblxuICB0cnkge1xuICAgIGJvdW5kcyA9IHRhcmdldC5nZXRCQm94KCk7IC8vRmlyZWZveCB0aHJvd3MgZXJyb3JzIGlmIHlvdSB0cnkgY2FsbGluZyBnZXRCQm94KCkgb24gYW4gU1ZHIGVsZW1lbnQgdGhhdCdzIG5vdCByZW5kZXJlZCAobGlrZSBpbiBhIDxzeW1ib2w+IG9yIDxkZWZzPikuIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTYxMjExOFxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGJvdW5kcyA9IF9nZXRCQm94SGFjay5jYWxsKHRhcmdldCwgdHJ1ZSk7XG4gIH1cblxuICBib3VuZHMgJiYgKGJvdW5kcy53aWR0aCB8fCBib3VuZHMuaGVpZ2h0KSB8fCB0YXJnZXQuZ2V0QkJveCA9PT0gX2dldEJCb3hIYWNrIHx8IChib3VuZHMgPSBfZ2V0QkJveEhhY2suY2FsbCh0YXJnZXQsIHRydWUpKTsgLy9zb21lIGJyb3dzZXJzIChsaWtlIEZpcmVmb3gpIG1pc3JlcG9ydCB0aGUgYm91bmRzIGlmIHRoZSBlbGVtZW50IGhhcyB6ZXJvIHdpZHRoIGFuZCBoZWlnaHQgKGl0IGp1c3QgYXNzdW1lcyBpdCdzIGF0IHg6MCwgeTowKSwgdGh1cyB3ZSBuZWVkIHRvIG1hbnVhbGx5IGdyYWIgdGhlIHBvc2l0aW9uIGluIHRoYXQgY2FzZS5cblxuICByZXR1cm4gYm91bmRzICYmICFib3VuZHMud2lkdGggJiYgIWJvdW5kcy54ICYmICFib3VuZHMueSA/IHtcbiAgICB4OiArX2dldEF0dHJpYnV0ZUZhbGxiYWNrcyh0YXJnZXQsIFtcInhcIiwgXCJjeFwiLCBcIngxXCJdKSB8fCAwLFxuICAgIHk6ICtfZ2V0QXR0cmlidXRlRmFsbGJhY2tzKHRhcmdldCwgW1wieVwiLCBcImN5XCIsIFwieTFcIl0pIHx8IDAsXG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiAwXG4gIH0gOiBib3VuZHM7XG59LFxuICAgIF9pc1NWRyA9IGZ1bmN0aW9uIF9pc1NWRyhlKSB7XG4gIHJldHVybiAhIShlLmdldENUTSAmJiAoIWUucGFyZW50Tm9kZSB8fCBlLm93bmVyU1ZHRWxlbWVudCkgJiYgX2dldEJCb3goZSkpO1xufSxcbiAgICAvL3JlcG9ydHMgaWYgdGhlIGVsZW1lbnQgaXMgYW4gU1ZHIG9uIHdoaWNoIGdldEJCb3goKSBhY3R1YWxseSB3b3Jrc1xuX3JlbW92ZVByb3BlcnR5ID0gZnVuY3Rpb24gX3JlbW92ZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHkpIHtcbiAgaWYgKHByb3BlcnR5KSB7XG4gICAgdmFyIHN0eWxlID0gdGFyZ2V0LnN0eWxlO1xuXG4gICAgaWYgKHByb3BlcnR5IGluIF90cmFuc2Zvcm1Qcm9wcyAmJiBwcm9wZXJ0eSAhPT0gX3RyYW5zZm9ybU9yaWdpblByb3ApIHtcbiAgICAgIHByb3BlcnR5ID0gX3RyYW5zZm9ybVByb3A7XG4gICAgfVxuXG4gICAgaWYgKHN0eWxlLnJlbW92ZVByb3BlcnR5KSB7XG4gICAgICBpZiAocHJvcGVydHkuc3Vic3RyKDAsIDIpID09PSBcIm1zXCIgfHwgcHJvcGVydHkuc3Vic3RyKDAsIDYpID09PSBcIndlYmtpdFwiKSB7XG4gICAgICAgIC8vTWljcm9zb2Z0IGFuZCBzb21lIFdlYmtpdCBicm93c2VycyBkb24ndCBjb25mb3JtIHRvIHRoZSBzdGFuZGFyZCBvZiBjYXBpdGFsaXppbmcgdGhlIGZpcnN0IHByZWZpeCBjaGFyYWN0ZXIsIHNvIHdlIGFkanVzdCBzbyB0aGF0IHdoZW4gd2UgcHJlZml4IHRoZSBjYXBzIHdpdGggYSBkYXNoLCBpdCdzIGNvcnJlY3QgKG90aGVyd2lzZSBpdCdkIGJlIFwibXMtdHJhbnNmb3JtXCIgaW5zdGVhZCBvZiBcIi1tcy10cmFuc2Zvcm1cIiBmb3IgSUU5LCBmb3IgZXhhbXBsZSlcbiAgICAgICAgcHJvcGVydHkgPSBcIi1cIiArIHByb3BlcnR5O1xuICAgICAgfVxuXG4gICAgICBzdHlsZS5yZW1vdmVQcm9wZXJ0eShwcm9wZXJ0eS5yZXBsYWNlKF9jYXBzRXhwLCBcIi0kMVwiKS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy9ub3RlOiBvbGQgdmVyc2lvbnMgb2YgSUUgdXNlIFwicmVtb3ZlQXR0cmlidXRlKClcIiBpbnN0ZWFkIG9mIFwicmVtb3ZlUHJvcGVydHkoKVwiXG4gICAgICBzdHlsZS5yZW1vdmVBdHRyaWJ1dGUocHJvcGVydHkpO1xuICAgIH1cbiAgfVxufSxcbiAgICBfYWRkTm9uVHdlZW5pbmdQVCA9IGZ1bmN0aW9uIF9hZGROb25Ud2VlbmluZ1BUKHBsdWdpbiwgdGFyZ2V0LCBwcm9wZXJ0eSwgYmVnaW5uaW5nLCBlbmQsIG9ubHlTZXRBdEVuZCkge1xuICB2YXIgcHQgPSBuZXcgUHJvcFR3ZWVuKHBsdWdpbi5fcHQsIHRhcmdldCwgcHJvcGVydHksIDAsIDEsIG9ubHlTZXRBdEVuZCA/IF9yZW5kZXJOb25Ud2VlbmluZ1ZhbHVlT25seUF0RW5kIDogX3JlbmRlck5vblR3ZWVuaW5nVmFsdWUpO1xuICBwbHVnaW4uX3B0ID0gcHQ7XG4gIHB0LmIgPSBiZWdpbm5pbmc7XG4gIHB0LmUgPSBlbmQ7XG5cbiAgcGx1Z2luLl9wcm9wcy5wdXNoKHByb3BlcnR5KTtcblxuICByZXR1cm4gcHQ7XG59LFxuICAgIF9ub25Db252ZXJ0aWJsZVVuaXRzID0ge1xuICBkZWc6IDEsXG4gIHJhZDogMSxcbiAgdHVybjogMVxufSxcbiAgICAvL3Rha2VzIGEgc2luZ2xlIHZhbHVlIGxpa2UgMjBweCBhbmQgY29udmVydHMgaXQgdG8gdGhlIHVuaXQgc3BlY2lmaWVkLCBsaWtlIFwiJVwiLCByZXR1cm5pbmcgb25seSB0aGUgbnVtZXJpYyBhbW91bnQuXG5fY29udmVydFRvVW5pdCA9IGZ1bmN0aW9uIF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCB1bml0KSB7XG4gIHZhciBjdXJWYWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpIHx8IDAsXG4gICAgICBjdXJVbml0ID0gKHZhbHVlICsgXCJcIikudHJpbSgpLnN1YnN0cigoY3VyVmFsdWUgKyBcIlwiKS5sZW5ndGgpIHx8IFwicHhcIixcbiAgICAgIC8vIHNvbWUgYnJvd3NlcnMgbGVhdmUgZXh0cmEgd2hpdGVzcGFjZSBhdCB0aGUgYmVnaW5uaW5nIG9mIENTUyB2YXJpYWJsZXMsIGhlbmNlIHRoZSBuZWVkIHRvIHRyaW0oKVxuICBzdHlsZSA9IF90ZW1wRGl2LnN0eWxlLFxuICAgICAgaG9yaXpvbnRhbCA9IF9ob3Jpem9udGFsRXhwLnRlc3QocHJvcGVydHkpLFxuICAgICAgaXNSb290U1ZHID0gdGFyZ2V0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJzdmdcIixcbiAgICAgIG1lYXN1cmVQcm9wZXJ0eSA9IChpc1Jvb3RTVkcgPyBcImNsaWVudFwiIDogXCJvZmZzZXRcIikgKyAoaG9yaXpvbnRhbCA/IFwiV2lkdGhcIiA6IFwiSGVpZ2h0XCIpLFxuICAgICAgYW1vdW50ID0gMTAwLFxuICAgICAgdG9QaXhlbHMgPSB1bml0ID09PSBcInB4XCIsXG4gICAgICB0b1BlcmNlbnQgPSB1bml0ID09PSBcIiVcIixcbiAgICAgIHB4LFxuICAgICAgcGFyZW50LFxuICAgICAgY2FjaGUsXG4gICAgICBpc1NWRztcblxuICBpZiAodW5pdCA9PT0gY3VyVW5pdCB8fCAhY3VyVmFsdWUgfHwgX25vbkNvbnZlcnRpYmxlVW5pdHNbdW5pdF0gfHwgX25vbkNvbnZlcnRpYmxlVW5pdHNbY3VyVW5pdF0pIHtcbiAgICByZXR1cm4gY3VyVmFsdWU7XG4gIH1cblxuICBjdXJVbml0ICE9PSBcInB4XCIgJiYgIXRvUGl4ZWxzICYmIChjdXJWYWx1ZSA9IF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCBcInB4XCIpKTtcbiAgaXNTVkcgPSB0YXJnZXQuZ2V0Q1RNICYmIF9pc1NWRyh0YXJnZXQpO1xuXG4gIGlmICh0b1BlcmNlbnQgJiYgKF90cmFuc2Zvcm1Qcm9wc1twcm9wZXJ0eV0gfHwgfnByb3BlcnR5LmluZGV4T2YoXCJhZGl1c1wiKSkpIHtcbiAgICAvL3RyYW5zZm9ybXMgYW5kIGJvcmRlclJhZGl1cyBhcmUgcmVsYXRpdmUgdG8gdGhlIHNpemUgb2YgdGhlIGVsZW1lbnQgaXRzZWxmIVxuICAgIHJldHVybiBfcm91bmQoY3VyVmFsdWUgLyAoaXNTVkcgPyB0YXJnZXQuZ2V0QkJveCgpW2hvcml6b250YWwgPyBcIndpZHRoXCIgOiBcImhlaWdodFwiXSA6IHRhcmdldFttZWFzdXJlUHJvcGVydHldKSAqIGFtb3VudCk7XG4gIH1cblxuICBzdHlsZVtob3Jpem9udGFsID8gXCJ3aWR0aFwiIDogXCJoZWlnaHRcIl0gPSBhbW91bnQgKyAodG9QaXhlbHMgPyBjdXJVbml0IDogdW5pdCk7XG4gIHBhcmVudCA9IH5wcm9wZXJ0eS5pbmRleE9mKFwiYWRpdXNcIikgfHwgdW5pdCA9PT0gXCJlbVwiICYmIHRhcmdldC5hcHBlbmRDaGlsZCAmJiAhaXNSb290U1ZHID8gdGFyZ2V0IDogdGFyZ2V0LnBhcmVudE5vZGU7XG5cbiAgaWYgKGlzU1ZHKSB7XG4gICAgcGFyZW50ID0gKHRhcmdldC5vd25lclNWR0VsZW1lbnQgfHwge30pLnBhcmVudE5vZGU7XG4gIH1cblxuICBpZiAoIXBhcmVudCB8fCBwYXJlbnQgPT09IF9kb2MgfHwgIXBhcmVudC5hcHBlbmRDaGlsZCkge1xuICAgIHBhcmVudCA9IF9kb2MuYm9keTtcbiAgfVxuXG4gIGNhY2hlID0gcGFyZW50Ll9nc2FwO1xuXG4gIGlmIChjYWNoZSAmJiB0b1BlcmNlbnQgJiYgY2FjaGUud2lkdGggJiYgaG9yaXpvbnRhbCAmJiBjYWNoZS50aW1lID09PSBfdGlja2VyLnRpbWUpIHtcbiAgICByZXR1cm4gX3JvdW5kKGN1clZhbHVlIC8gY2FjaGUud2lkdGggKiBhbW91bnQpO1xuICB9IGVsc2Uge1xuICAgICh0b1BlcmNlbnQgfHwgY3VyVW5pdCA9PT0gXCIlXCIpICYmIChzdHlsZS5wb3NpdGlvbiA9IF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgXCJwb3NpdGlvblwiKSk7XG4gICAgcGFyZW50ID09PSB0YXJnZXQgJiYgKHN0eWxlLnBvc2l0aW9uID0gXCJzdGF0aWNcIik7IC8vIGxpa2UgZm9yIGJvcmRlclJhZGl1cywgaWYgaXQncyBhICUgd2UgbXVzdCBoYXZlIGl0IHJlbGF0aXZlIHRvIHRoZSB0YXJnZXQgaXRzZWxmIGJ1dCB0aGF0IG1heSBub3QgaGF2ZSBwb3NpdGlvbjogcmVsYXRpdmUgb3IgcG9zaXRpb246IGFic29sdXRlIGluIHdoaWNoIGNhc2UgaXQnZCBnbyB1cCB0aGUgY2hhaW4gdW50aWwgaXQgZmluZHMgaXRzIG9mZnNldFBhcmVudCAoYmFkKS4gcG9zaXRpb246IHN0YXRpYyBwcm90ZWN0cyBhZ2FpbnN0IHRoYXQuXG5cbiAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoX3RlbXBEaXYpO1xuICAgIHB4ID0gX3RlbXBEaXZbbWVhc3VyZVByb3BlcnR5XTtcbiAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoX3RlbXBEaXYpO1xuICAgIHN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuXG4gICAgaWYgKGhvcml6b250YWwgJiYgdG9QZXJjZW50KSB7XG4gICAgICBjYWNoZSA9IF9nZXRDYWNoZShwYXJlbnQpO1xuICAgICAgY2FjaGUudGltZSA9IF90aWNrZXIudGltZTtcbiAgICAgIGNhY2hlLndpZHRoID0gcGFyZW50W21lYXN1cmVQcm9wZXJ0eV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9yb3VuZCh0b1BpeGVscyA/IHB4ICogY3VyVmFsdWUgLyBhbW91bnQgOiBweCAmJiBjdXJWYWx1ZSA/IGFtb3VudCAvIHB4ICogY3VyVmFsdWUgOiAwKTtcbn0sXG4gICAgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgdW5pdCwgdW5jYWNoZSkge1xuICB2YXIgdmFsdWU7XG4gIF9wbHVnaW5Jbml0dGVkIHx8IF9pbml0Q29yZSgpO1xuXG4gIGlmIChwcm9wZXJ0eSBpbiBfcHJvcGVydHlBbGlhc2VzICYmIHByb3BlcnR5ICE9PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgcHJvcGVydHkgPSBfcHJvcGVydHlBbGlhc2VzW3Byb3BlcnR5XTtcblxuICAgIGlmICh+cHJvcGVydHkuaW5kZXhPZihcIixcIikpIHtcbiAgICAgIHByb3BlcnR5ID0gcHJvcGVydHkuc3BsaXQoXCIsXCIpWzBdO1xuICAgIH1cbiAgfVxuXG4gIGlmIChfdHJhbnNmb3JtUHJvcHNbcHJvcGVydHldICYmIHByb3BlcnR5ICE9PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgdmFsdWUgPSBfcGFyc2VUcmFuc2Zvcm0odGFyZ2V0LCB1bmNhY2hlKTtcbiAgICB2YWx1ZSA9IHByb3BlcnR5ICE9PSBcInRyYW5zZm9ybU9yaWdpblwiID8gdmFsdWVbcHJvcGVydHldIDogX2ZpcnN0VHdvT25seShfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSh0YXJnZXQsIF90cmFuc2Zvcm1PcmlnaW5Qcm9wKSkgKyBcIiBcIiArIHZhbHVlLnpPcmlnaW4gKyBcInB4XCI7XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSB0YXJnZXQuc3R5bGVbcHJvcGVydHldO1xuXG4gICAgaWYgKCF2YWx1ZSB8fCB2YWx1ZSA9PT0gXCJhdXRvXCIgfHwgdW5jYWNoZSB8fCB+KHZhbHVlICsgXCJcIikuaW5kZXhPZihcImNhbGMoXCIpKSB7XG4gICAgICB2YWx1ZSA9IF9zcGVjaWFsUHJvcHNbcHJvcGVydHldICYmIF9zcGVjaWFsUHJvcHNbcHJvcGVydHldKHRhcmdldCwgcHJvcGVydHksIHVuaXQpIHx8IF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgcHJvcGVydHkpIHx8IF9nZXRQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5KSB8fCAocHJvcGVydHkgPT09IFwib3BhY2l0eVwiID8gMSA6IDApOyAvLyBub3RlOiBzb21lIGJyb3dzZXJzLCBsaWtlIEZpcmVmb3gsIGRvbid0IHJlcG9ydCBib3JkZXJSYWRpdXMgY29ycmVjdGx5ISBJbnN0ZWFkLCBpdCBvbmx5IHJlcG9ydHMgZXZlcnkgY29ybmVyIGxpa2UgIGJvcmRlclRvcExlZnRSYWRpdXNcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5pdCAmJiAhfih2YWx1ZSArIFwiXCIpLmluZGV4T2YoXCIgXCIpID8gX2NvbnZlcnRUb1VuaXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIHVuaXQpICsgdW5pdCA6IHZhbHVlO1xufSxcbiAgICBfdHdlZW5Db21wbGV4Q1NTU3RyaW5nID0gZnVuY3Rpb24gX3R3ZWVuQ29tcGxleENTU1N0cmluZyh0YXJnZXQsIHByb3AsIHN0YXJ0LCBlbmQpIHtcbiAgLy9ub3RlOiB3ZSBjYWxsIF90d2VlbkNvbXBsZXhDU1NTdHJpbmcuY2FsbChwbHVnaW5JbnN0YW5jZS4uLikgdG8gZW5zdXJlIHRoYXQgaXQncyBzY29wZWQgcHJvcGVybHkuIFdlIG1heSBjYWxsIGl0IGZyb20gd2l0aGluIGEgcGx1Z2luIHRvbywgdGh1cyBcInRoaXNcIiB3b3VsZCByZWZlciB0byB0aGUgcGx1Z2luLlxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0ID09PSBcIm5vbmVcIikge1xuICAgIC8vIHNvbWUgYnJvd3NlcnMgbGlrZSBTYWZhcmkgYWN0dWFsbHkgUFJFRkVSIHRoZSBwcmVmaXhlZCBwcm9wZXJ0eSBhbmQgbWlzLXJlcG9ydCB0aGUgdW5wcmVmaXhlZCB2YWx1ZSBsaWtlIGNsaXBQYXRoIChCVUcpLiBJbiBvdGhlciB3b3JkcywgZXZlbiB0aG91Z2ggY2xpcFBhdGggZXhpc3RzIGluIHRoZSBzdHlsZSAoXCJjbGlwUGF0aFwiIGluIHRhcmdldC5zdHlsZSkgYW5kIGl0J3Mgc2V0IGluIHRoZSBDU1MgcHJvcGVybHkgKGFsb25nIHdpdGggLXdlYmtpdC1jbGlwLXBhdGgpLCBTYWZhcmkgcmVwb3J0cyBjbGlwUGF0aCBhcyBcIm5vbmVcIiB3aGVyZWFzIFdlYmtpdENsaXBQYXRoIHJlcG9ydHMgYWNjdXJhdGVseSBsaWtlIFwiZWxsaXBzZSgxMDAlIDAlIGF0IDUwJSAwJSlcIiwgc28gaW4gdGhpcyBjYXNlIHdlIG11c3QgU1dJVENIIHRvIHVzaW5nIHRoZSBwcmVmaXhlZCBwcm9wZXJ0eSBpbnN0ZWFkLiBTZWUgaHR0cHM6Ly9ncmVlbnNvY2suY29tL2ZvcnVtcy90b3BpYy8xODMxMC1jbGlwcGF0aC1kb2VzbnQtd29yay1vbi1pb3MvXG4gICAgdmFyIHAgPSBfY2hlY2tQcm9wUHJlZml4KHByb3AsIHRhcmdldCwgMSksXG4gICAgICAgIHMgPSBwICYmIF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgcCwgMSk7XG5cbiAgICBpZiAocyAmJiBzICE9PSBzdGFydCkge1xuICAgICAgcHJvcCA9IHA7XG4gICAgICBzdGFydCA9IHM7XG4gICAgfSBlbHNlIGlmIChwcm9wID09PSBcImJvcmRlckNvbG9yXCIpIHtcbiAgICAgIHN0YXJ0ID0gX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBcImJvcmRlclRvcENvbG9yXCIpOyAvLyBGaXJlZm94IGJ1ZzogYWx3YXlzIHJlcG9ydHMgXCJib3JkZXJDb2xvclwiIGFzIFwiXCIsIHNvIHdlIG11c3QgZmFsbCBiYWNrIHRvIGJvcmRlclRvcENvbG9yLiBTZWUgaHR0cHM6Ly9ncmVlbnNvY2suY29tL2ZvcnVtcy90b3BpYy8yNDU4My1ob3ctdG8tcmV0dXJuLWNvbG9ycy10aGF0LWktaGFkLWFmdGVyLXJldmVyc2UvXG4gICAgfVxuICB9XG5cbiAgdmFyIHB0ID0gbmV3IFByb3BUd2Vlbih0aGlzLl9wdCwgdGFyZ2V0LnN0eWxlLCBwcm9wLCAwLCAxLCBfcmVuZGVyQ29tcGxleFN0cmluZyksXG4gICAgICBpbmRleCA9IDAsXG4gICAgICBtYXRjaEluZGV4ID0gMCxcbiAgICAgIGEsXG4gICAgICByZXN1bHQsXG4gICAgICBzdGFydFZhbHVlcyxcbiAgICAgIHN0YXJ0TnVtLFxuICAgICAgY29sb3IsXG4gICAgICBzdGFydFZhbHVlLFxuICAgICAgZW5kVmFsdWUsXG4gICAgICBlbmROdW0sXG4gICAgICBjaHVuayxcbiAgICAgIGVuZFVuaXQsXG4gICAgICBzdGFydFVuaXQsXG4gICAgICByZWxhdGl2ZSxcbiAgICAgIGVuZFZhbHVlcztcbiAgcHQuYiA9IHN0YXJ0O1xuICBwdC5lID0gZW5kO1xuICBzdGFydCArPSBcIlwiOyAvL2Vuc3VyZSB2YWx1ZXMgYXJlIHN0cmluZ3NcblxuICBlbmQgKz0gXCJcIjtcblxuICBpZiAoZW5kID09PSBcImF1dG9cIikge1xuICAgIHRhcmdldC5zdHlsZVtwcm9wXSA9IGVuZDtcbiAgICBlbmQgPSBfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSh0YXJnZXQsIHByb3ApIHx8IGVuZDtcbiAgICB0YXJnZXQuc3R5bGVbcHJvcF0gPSBzdGFydDtcbiAgfVxuXG4gIGEgPSBbc3RhcnQsIGVuZF07XG5cbiAgX2NvbG9yU3RyaW5nRmlsdGVyKGEpOyAvL3Bhc3MgYW4gYXJyYXkgd2l0aCB0aGUgc3RhcnRpbmcgYW5kIGVuZGluZyB2YWx1ZXMgYW5kIGxldCB0aGUgZmlsdGVyIGRvIHdoYXRldmVyIGl0IG5lZWRzIHRvIHRoZSB2YWx1ZXMuIElmIGNvbG9ycyBhcmUgZm91bmQsIGl0IHJldHVybnMgdHJ1ZSBhbmQgdGhlbiB3ZSBtdXN0IG1hdGNoIHdoZXJlIHRoZSBjb2xvciBzaG93cyB1cCBvcmRlci13aXNlIGJlY2F1c2UgZm9yIHRoaW5ncyBsaWtlIGJveFNoYWRvdywgc29tZXRpbWVzIHRoZSBicm93c2VyIHByb3ZpZGVzIHRoZSBjb21wdXRlZCB2YWx1ZXMgd2l0aCB0aGUgY29sb3IgRklSU1QsIGJ1dCB0aGUgdXNlciBwcm92aWRlcyBpdCB3aXRoIHRoZSBjb2xvciBMQVNULCBzbyBmbGlwIHRoZW0gaWYgbmVjZXNzYXJ5LiBTYW1lIGZvciBkcm9wLXNoYWRvdygpLlxuXG5cbiAgc3RhcnQgPSBhWzBdO1xuICBlbmQgPSBhWzFdO1xuICBzdGFydFZhbHVlcyA9IHN0YXJ0Lm1hdGNoKF9udW1XaXRoVW5pdEV4cCkgfHwgW107XG4gIGVuZFZhbHVlcyA9IGVuZC5tYXRjaChfbnVtV2l0aFVuaXRFeHApIHx8IFtdO1xuXG4gIGlmIChlbmRWYWx1ZXMubGVuZ3RoKSB7XG4gICAgd2hpbGUgKHJlc3VsdCA9IF9udW1XaXRoVW5pdEV4cC5leGVjKGVuZCkpIHtcbiAgICAgIGVuZFZhbHVlID0gcmVzdWx0WzBdO1xuICAgICAgY2h1bmsgPSBlbmQuc3Vic3RyaW5nKGluZGV4LCByZXN1bHQuaW5kZXgpO1xuXG4gICAgICBpZiAoY29sb3IpIHtcbiAgICAgICAgY29sb3IgPSAoY29sb3IgKyAxKSAlIDU7XG4gICAgICB9IGVsc2UgaWYgKGNodW5rLnN1YnN0cigtNSkgPT09IFwicmdiYShcIiB8fCBjaHVuay5zdWJzdHIoLTUpID09PSBcImhzbGEoXCIpIHtcbiAgICAgICAgY29sb3IgPSAxO1xuICAgICAgfVxuXG4gICAgICBpZiAoZW5kVmFsdWUgIT09IChzdGFydFZhbHVlID0gc3RhcnRWYWx1ZXNbbWF0Y2hJbmRleCsrXSB8fCBcIlwiKSkge1xuICAgICAgICBzdGFydE51bSA9IHBhcnNlRmxvYXQoc3RhcnRWYWx1ZSkgfHwgMDtcbiAgICAgICAgc3RhcnRVbml0ID0gc3RhcnRWYWx1ZS5zdWJzdHIoKHN0YXJ0TnVtICsgXCJcIikubGVuZ3RoKTtcbiAgICAgICAgcmVsYXRpdmUgPSBlbmRWYWx1ZS5jaGFyQXQoMSkgPT09IFwiPVwiID8gKyhlbmRWYWx1ZS5jaGFyQXQoMCkgKyBcIjFcIikgOiAwO1xuXG4gICAgICAgIGlmIChyZWxhdGl2ZSkge1xuICAgICAgICAgIGVuZFZhbHVlID0gZW5kVmFsdWUuc3Vic3RyKDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZW5kTnVtID0gcGFyc2VGbG9hdChlbmRWYWx1ZSk7XG4gICAgICAgIGVuZFVuaXQgPSBlbmRWYWx1ZS5zdWJzdHIoKGVuZE51bSArIFwiXCIpLmxlbmd0aCk7XG4gICAgICAgIGluZGV4ID0gX251bVdpdGhVbml0RXhwLmxhc3RJbmRleCAtIGVuZFVuaXQubGVuZ3RoO1xuXG4gICAgICAgIGlmICghZW5kVW5pdCkge1xuICAgICAgICAgIC8vaWYgc29tZXRoaW5nIGxpa2UgXCJwZXJzcGVjdGl2ZTozMDBcIiBpcyBwYXNzZWQgaW4gYW5kIHdlIG11c3QgYWRkIGEgdW5pdCB0byB0aGUgZW5kXG4gICAgICAgICAgZW5kVW5pdCA9IGVuZFVuaXQgfHwgX2NvbmZpZy51bml0c1twcm9wXSB8fCBzdGFydFVuaXQ7XG5cbiAgICAgICAgICBpZiAoaW5kZXggPT09IGVuZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGVuZCArPSBlbmRVbml0O1xuICAgICAgICAgICAgcHQuZSArPSBlbmRVbml0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGFydFVuaXQgIT09IGVuZFVuaXQpIHtcbiAgICAgICAgICBzdGFydE51bSA9IF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgcHJvcCwgc3RhcnRWYWx1ZSwgZW5kVW5pdCkgfHwgMDtcbiAgICAgICAgfSAvL3RoZXNlIG5lc3RlZCBQcm9wVHdlZW5zIGFyZSBoYW5kbGVkIGluIGEgc3BlY2lhbCB3YXkgLSB3ZSdsbCBuZXZlciBhY3R1YWxseSBjYWxsIGEgcmVuZGVyIG9yIHNldHRlciBtZXRob2Qgb24gdGhlbS4gV2UnbGwganVzdCBsb29wIHRocm91Z2ggdGhlbSBpbiB0aGUgcGFyZW50IGNvbXBsZXggc3RyaW5nIFByb3BUd2VlbidzIHJlbmRlciBtZXRob2QuXG5cblxuICAgICAgICBwdC5fcHQgPSB7XG4gICAgICAgICAgX25leHQ6IHB0Ll9wdCxcbiAgICAgICAgICBwOiBjaHVuayB8fCBtYXRjaEluZGV4ID09PSAxID8gY2h1bmsgOiBcIixcIixcbiAgICAgICAgICAvL25vdGU6IFNWRyBzcGVjIGFsbG93cyBvbWlzc2lvbiBvZiBjb21tYS9zcGFjZSB3aGVuIGEgbmVnYXRpdmUgc2lnbiBpcyB3ZWRnZWQgYmV0d2VlbiB0d28gbnVtYmVycywgbGlrZSAyLjUtNS4zIGluc3RlYWQgb2YgMi41LC01LjMgYnV0IHdoZW4gdHdlZW5pbmcsIHRoZSBuZWdhdGl2ZSB2YWx1ZSBtYXkgc3dpdGNoIHRvIHBvc2l0aXZlLCBzbyB3ZSBpbnNlcnQgdGhlIGNvbW1hIGp1c3QgaW4gY2FzZS5cbiAgICAgICAgICBzOiBzdGFydE51bSxcbiAgICAgICAgICBjOiByZWxhdGl2ZSA/IHJlbGF0aXZlICogZW5kTnVtIDogZW5kTnVtIC0gc3RhcnROdW0sXG4gICAgICAgICAgbTogY29sb3IgJiYgY29sb3IgPCA0ID8gTWF0aC5yb3VuZCA6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwdC5jID0gaW5kZXggPCBlbmQubGVuZ3RoID8gZW5kLnN1YnN0cmluZyhpbmRleCwgZW5kLmxlbmd0aCkgOiBcIlwiOyAvL3dlIHVzZSB0aGUgXCJjXCIgb2YgdGhlIFByb3BUd2VlbiB0byBzdG9yZSB0aGUgZmluYWwgcGFydCBvZiB0aGUgc3RyaW5nIChhZnRlciB0aGUgbGFzdCBudW1iZXIpXG4gIH0gZWxzZSB7XG4gICAgcHQuciA9IHByb3AgPT09IFwiZGlzcGxheVwiICYmIGVuZCA9PT0gXCJub25lXCIgPyBfcmVuZGVyTm9uVHdlZW5pbmdWYWx1ZU9ubHlBdEVuZCA6IF9yZW5kZXJOb25Ud2VlbmluZ1ZhbHVlO1xuICB9XG5cbiAgaWYgKF9yZWxFeHAudGVzdChlbmQpKSB7XG4gICAgcHQuZSA9IDA7IC8vaWYgdGhlIGVuZCBzdHJpbmcgY29udGFpbnMgcmVsYXRpdmUgdmFsdWVzIG9yIGR5bmFtaWMgcmFuZG9tKC4uLikgdmFsdWVzLCBkZWxldGUgdGhlIGVuZCBpdCBzbyB0aGF0IG9uIHRoZSBmaW5hbCByZW5kZXIgd2UgZG9uJ3QgYWN0dWFsbHkgc2V0IGl0IHRvIHRoZSBzdHJpbmcgd2l0aCArPSBvciAtPSBjaGFyYWN0ZXJzIChmb3JjZXMgaXQgdG8gdXNlIHRoZSBjYWxjdWxhdGVkIHZhbHVlKS5cbiAgfVxuXG4gIHRoaXMuX3B0ID0gcHQ7IC8vc3RhcnQgdGhlIGxpbmtlZCBsaXN0IHdpdGggdGhpcyBuZXcgUHJvcFR3ZWVuLiBSZW1lbWJlciwgd2UgY2FsbCBfdHdlZW5Db21wbGV4Q1NTU3RyaW5nLmNhbGwocGx1Z2luSW5zdGFuY2UuLi4pIHRvIGVuc3VyZSB0aGF0IGl0J3Mgc2NvcGVkIHByb3Blcmx5LiBXZSBtYXkgY2FsbCBpdCBmcm9tIHdpdGhpbiBhbm90aGVyIHBsdWdpbiB0b28sIHRodXMgXCJ0aGlzXCIgd291bGQgcmVmZXIgdG8gdGhlIHBsdWdpbi5cblxuICByZXR1cm4gcHQ7XG59LFxuICAgIF9rZXl3b3JkVG9QZXJjZW50ID0ge1xuICB0b3A6IFwiMCVcIixcbiAgYm90dG9tOiBcIjEwMCVcIixcbiAgbGVmdDogXCIwJVwiLFxuICByaWdodDogXCIxMDAlXCIsXG4gIGNlbnRlcjogXCI1MCVcIlxufSxcbiAgICBfY29udmVydEtleXdvcmRzVG9QZXJjZW50YWdlcyA9IGZ1bmN0aW9uIF9jb252ZXJ0S2V5d29yZHNUb1BlcmNlbnRhZ2VzKHZhbHVlKSB7XG4gIHZhciBzcGxpdCA9IHZhbHVlLnNwbGl0KFwiIFwiKSxcbiAgICAgIHggPSBzcGxpdFswXSxcbiAgICAgIHkgPSBzcGxpdFsxXSB8fCBcIjUwJVwiO1xuXG4gIGlmICh4ID09PSBcInRvcFwiIHx8IHggPT09IFwiYm90dG9tXCIgfHwgeSA9PT0gXCJsZWZ0XCIgfHwgeSA9PT0gXCJyaWdodFwiKSB7XG4gICAgLy90aGUgdXNlciBwcm92aWRlZCB0aGVtIGluIHRoZSB3cm9uZyBvcmRlciwgc28gZmxpcCB0aGVtXG4gICAgdmFsdWUgPSB4O1xuICAgIHggPSB5O1xuICAgIHkgPSB2YWx1ZTtcbiAgfVxuXG4gIHNwbGl0WzBdID0gX2tleXdvcmRUb1BlcmNlbnRbeF0gfHwgeDtcbiAgc3BsaXRbMV0gPSBfa2V5d29yZFRvUGVyY2VudFt5XSB8fCB5O1xuICByZXR1cm4gc3BsaXQuam9pbihcIiBcIik7XG59LFxuICAgIF9yZW5kZXJDbGVhclByb3BzID0gZnVuY3Rpb24gX3JlbmRlckNsZWFyUHJvcHMocmF0aW8sIGRhdGEpIHtcbiAgaWYgKGRhdGEudHdlZW4gJiYgZGF0YS50d2Vlbi5fdGltZSA9PT0gZGF0YS50d2Vlbi5fZHVyKSB7XG4gICAgdmFyIHRhcmdldCA9IGRhdGEudCxcbiAgICAgICAgc3R5bGUgPSB0YXJnZXQuc3R5bGUsXG4gICAgICAgIHByb3BzID0gZGF0YS51LFxuICAgICAgICBjYWNoZSA9IHRhcmdldC5fZ3NhcCxcbiAgICAgICAgcHJvcCxcbiAgICAgICAgY2xlYXJUcmFuc2Zvcm1zLFxuICAgICAgICBpO1xuXG4gICAgaWYgKHByb3BzID09PSBcImFsbFwiIHx8IHByb3BzID09PSB0cnVlKSB7XG4gICAgICBzdHlsZS5jc3NUZXh0ID0gXCJcIjtcbiAgICAgIGNsZWFyVHJhbnNmb3JtcyA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb3BzID0gcHJvcHMuc3BsaXQoXCIsXCIpO1xuICAgICAgaSA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKC0taSA+IC0xKSB7XG4gICAgICAgIHByb3AgPSBwcm9wc1tpXTtcblxuICAgICAgICBpZiAoX3RyYW5zZm9ybVByb3BzW3Byb3BdKSB7XG4gICAgICAgICAgY2xlYXJUcmFuc2Zvcm1zID0gMTtcbiAgICAgICAgICBwcm9wID0gcHJvcCA9PT0gXCJ0cmFuc2Zvcm1PcmlnaW5cIiA/IF90cmFuc2Zvcm1PcmlnaW5Qcm9wIDogX3RyYW5zZm9ybVByb3A7XG4gICAgICAgIH1cblxuICAgICAgICBfcmVtb3ZlUHJvcGVydHkodGFyZ2V0LCBwcm9wKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2xlYXJUcmFuc2Zvcm1zKSB7XG4gICAgICBfcmVtb3ZlUHJvcGVydHkodGFyZ2V0LCBfdHJhbnNmb3JtUHJvcCk7XG5cbiAgICAgIGlmIChjYWNoZSkge1xuICAgICAgICBjYWNoZS5zdmcgJiYgdGFyZ2V0LnJlbW92ZUF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKTtcblxuICAgICAgICBfcGFyc2VUcmFuc2Zvcm0odGFyZ2V0LCAxKTsgLy8gZm9yY2UgYWxsIHRoZSBjYWNoZWQgdmFsdWVzIGJhY2sgdG8gXCJub3JtYWxcIi9pZGVudGl0eSwgb3RoZXJ3aXNlIGlmIHRoZXJlJ3MgYW5vdGhlciB0d2VlbiB0aGF0J3MgYWxyZWFkeSBzZXQgdG8gcmVuZGVyIHRyYW5zZm9ybXMgb24gdGhpcyBlbGVtZW50LCBpdCBjb3VsZCBkaXNwbGF5IHRoZSB3cm9uZyB2YWx1ZXMuXG5cblxuICAgICAgICBjYWNoZS51bmNhY2hlID0gMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0sXG4gICAgLy8gbm90ZTogc3BlY2lhbFByb3BzIHNob3VsZCByZXR1cm4gMSBpZiAoYW5kIG9ubHkgaWYpIHRoZXkgaGF2ZSBhIG5vbi16ZXJvIHByaW9yaXR5LiBJdCBpbmRpY2F0ZXMgd2UgbmVlZCB0byBzb3J0IHRoZSBsaW5rZWQgbGlzdC5cbl9zcGVjaWFsUHJvcHMgPSB7XG4gIGNsZWFyUHJvcHM6IGZ1bmN0aW9uIGNsZWFyUHJvcHMocGx1Z2luLCB0YXJnZXQsIHByb3BlcnR5LCBlbmRWYWx1ZSwgdHdlZW4pIHtcbiAgICBpZiAodHdlZW4uZGF0YSAhPT0gXCJpc0Zyb21TdGFydFwiKSB7XG4gICAgICB2YXIgcHQgPSBwbHVnaW4uX3B0ID0gbmV3IFByb3BUd2VlbihwbHVnaW4uX3B0LCB0YXJnZXQsIHByb3BlcnR5LCAwLCAwLCBfcmVuZGVyQ2xlYXJQcm9wcyk7XG4gICAgICBwdC51ID0gZW5kVmFsdWU7XG4gICAgICBwdC5wciA9IC0xMDtcbiAgICAgIHB0LnR3ZWVuID0gdHdlZW47XG5cbiAgICAgIHBsdWdpbi5fcHJvcHMucHVzaChwcm9wZXJ0eSk7XG5cbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgfVxuICAvKiBjbGFzc05hbWUgZmVhdHVyZSAoYWJvdXQgMC40a2IgZ3ppcHBlZCkuXG4gICwgY2xhc3NOYW1lKHBsdWdpbiwgdGFyZ2V0LCBwcm9wZXJ0eSwgZW5kVmFsdWUsIHR3ZWVuKSB7XG4gIFx0bGV0IF9yZW5kZXJDbGFzc05hbWUgPSAocmF0aW8sIGRhdGEpID0+IHtcbiAgXHRcdFx0ZGF0YS5jc3MucmVuZGVyKHJhdGlvLCBkYXRhLmNzcyk7XG4gIFx0XHRcdGlmICghcmF0aW8gfHwgcmF0aW8gPT09IDEpIHtcbiAgXHRcdFx0XHRsZXQgaW5saW5lID0gZGF0YS5ybXYsXG4gIFx0XHRcdFx0XHR0YXJnZXQgPSBkYXRhLnQsXG4gIFx0XHRcdFx0XHRwO1xuICBcdFx0XHRcdHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCByYXRpbyA/IGRhdGEuZSA6IGRhdGEuYik7XG4gIFx0XHRcdFx0Zm9yIChwIGluIGlubGluZSkge1xuICBcdFx0XHRcdFx0X3JlbW92ZVByb3BlcnR5KHRhcmdldCwgcCk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9LFxuICBcdFx0X2dldEFsbFN0eWxlcyA9ICh0YXJnZXQpID0+IHtcbiAgXHRcdFx0bGV0IHN0eWxlcyA9IHt9LFxuICBcdFx0XHRcdGNvbXB1dGVkID0gZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpLFxuICBcdFx0XHRcdHA7XG4gIFx0XHRcdGZvciAocCBpbiBjb21wdXRlZCkge1xuICBcdFx0XHRcdGlmIChpc05hTihwKSAmJiBwICE9PSBcImNzc1RleHRcIiAmJiBwICE9PSBcImxlbmd0aFwiKSB7XG4gIFx0XHRcdFx0XHRzdHlsZXNbcF0gPSBjb21wdXRlZFtwXTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdFx0X3NldERlZmF1bHRzKHN0eWxlcywgX3BhcnNlVHJhbnNmb3JtKHRhcmdldCwgMSkpO1xuICBcdFx0XHRyZXR1cm4gc3R5bGVzO1xuICBcdFx0fSxcbiAgXHRcdHN0YXJ0Q2xhc3NMaXN0ID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcImNsYXNzXCIpLFxuICBcdFx0c3R5bGUgPSB0YXJnZXQuc3R5bGUsXG4gIFx0XHRjc3NUZXh0ID0gc3R5bGUuY3NzVGV4dCxcbiAgXHRcdGNhY2hlID0gdGFyZ2V0Ll9nc2FwLFxuICBcdFx0Y2xhc3NQVCA9IGNhY2hlLmNsYXNzUFQsXG4gIFx0XHRpbmxpbmVUb1JlbW92ZUF0RW5kID0ge30sXG4gIFx0XHRkYXRhID0ge3Q6dGFyZ2V0LCBwbHVnaW46cGx1Z2luLCBybXY6aW5saW5lVG9SZW1vdmVBdEVuZCwgYjpzdGFydENsYXNzTGlzdCwgZTooZW5kVmFsdWUuY2hhckF0KDEpICE9PSBcIj1cIikgPyBlbmRWYWx1ZSA6IHN0YXJ0Q2xhc3NMaXN0LnJlcGxhY2UobmV3IFJlZ0V4cChcIig/OlxcXFxzfF4pXCIgKyBlbmRWYWx1ZS5zdWJzdHIoMikgKyBcIig/IVtcXFxcdy1dKVwiKSwgXCJcIikgKyAoKGVuZFZhbHVlLmNoYXJBdCgwKSA9PT0gXCIrXCIpID8gXCIgXCIgKyBlbmRWYWx1ZS5zdWJzdHIoMikgOiBcIlwiKX0sXG4gIFx0XHRjaGFuZ2luZ1ZhcnMgPSB7fSxcbiAgXHRcdHN0YXJ0VmFycyA9IF9nZXRBbGxTdHlsZXModGFyZ2V0KSxcbiAgXHRcdHRyYW5zZm9ybVJlbGF0ZWQgPSAvKHRyYW5zZm9ybXxwZXJzcGVjdGl2ZSkvaSxcbiAgXHRcdGVuZFZhcnMsIHA7XG4gIFx0aWYgKGNsYXNzUFQpIHtcbiAgXHRcdGNsYXNzUFQucigxLCBjbGFzc1BULmQpO1xuICBcdFx0X3JlbW92ZUxpbmtlZExpc3RJdGVtKGNsYXNzUFQuZC5wbHVnaW4sIGNsYXNzUFQsIFwiX3B0XCIpO1xuICBcdH1cbiAgXHR0YXJnZXQuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgZGF0YS5lKTtcbiAgXHRlbmRWYXJzID0gX2dldEFsbFN0eWxlcyh0YXJnZXQsIHRydWUpO1xuICBcdHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBzdGFydENsYXNzTGlzdCk7XG4gIFx0Zm9yIChwIGluIGVuZFZhcnMpIHtcbiAgXHRcdGlmIChlbmRWYXJzW3BdICE9PSBzdGFydFZhcnNbcF0gJiYgIXRyYW5zZm9ybVJlbGF0ZWQudGVzdChwKSkge1xuICBcdFx0XHRjaGFuZ2luZ1ZhcnNbcF0gPSBlbmRWYXJzW3BdO1xuICBcdFx0XHRpZiAoIXN0eWxlW3BdICYmIHN0eWxlW3BdICE9PSBcIjBcIikge1xuICBcdFx0XHRcdGlubGluZVRvUmVtb3ZlQXRFbmRbcF0gPSAxO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuICBcdGNhY2hlLmNsYXNzUFQgPSBwbHVnaW4uX3B0ID0gbmV3IFByb3BUd2VlbihwbHVnaW4uX3B0LCB0YXJnZXQsIFwiY2xhc3NOYW1lXCIsIDAsIDAsIF9yZW5kZXJDbGFzc05hbWUsIGRhdGEsIDAsIC0xMSk7XG4gIFx0aWYgKHN0eWxlLmNzc1RleHQgIT09IGNzc1RleHQpIHsgLy9vbmx5IGFwcGx5IGlmIHRoaW5ncyBjaGFuZ2UuIE90aGVyd2lzZSwgaW4gY2FzZXMgbGlrZSBhIGJhY2tncm91bmQtaW1hZ2UgdGhhdCdzIHB1bGxlZCBkeW5hbWljYWxseSwgaXQgY291bGQgY2F1c2UgYSByZWZyZXNoLiBTZWUgaHR0cHM6Ly9ncmVlbnNvY2suY29tL2ZvcnVtcy90b3BpYy8yMDM2OC1wb3NzaWJsZS1nc2FwLWJ1Zy1zd2l0Y2hpbmctY2xhc3NuYW1lcy1pbi1jaHJvbWUvLlxuICBcdFx0c3R5bGUuY3NzVGV4dCA9IGNzc1RleHQ7IC8vd2UgcmVjb3JkZWQgY3NzVGV4dCBiZWZvcmUgd2Ugc3dhcHBlZCBjbGFzc2VzIGFuZCByYW4gX2dldEFsbFN0eWxlcygpIGJlY2F1c2UgaW4gY2FzZXMgd2hlbiBhIGNsYXNzTmFtZSB0d2VlbiBpcyBvdmVyd3JpdHRlbiwgd2UgcmVtb3ZlIGFsbCB0aGUgcmVsYXRlZCB0d2VlbmluZyBwcm9wZXJ0aWVzIGZyb20gdGhhdCBjbGFzcyBjaGFuZ2UgKG90aGVyd2lzZSBjbGFzcy1zcGVjaWZpYyBzdHVmZiBjYW4ndCBvdmVycmlkZSBwcm9wZXJ0aWVzIHdlJ3ZlIGRpcmVjdGx5IHNldCBvbiB0aGUgdGFyZ2V0J3Mgc3R5bGUgb2JqZWN0IGR1ZSB0byBzcGVjaWZpY2l0eSkuXG4gIFx0fVxuICBcdF9wYXJzZVRyYW5zZm9ybSh0YXJnZXQsIHRydWUpOyAvL3RvIGNsZWFyIHRoZSBjYWNoaW5nIG9mIHRyYW5zZm9ybXNcbiAgXHRkYXRhLmNzcyA9IG5ldyBnc2FwLnBsdWdpbnMuY3NzKCk7XG4gIFx0ZGF0YS5jc3MuaW5pdCh0YXJnZXQsIGNoYW5naW5nVmFycywgdHdlZW4pO1xuICBcdHBsdWdpbi5fcHJvcHMucHVzaCguLi5kYXRhLmNzcy5fcHJvcHMpO1xuICBcdHJldHVybiAxO1xuICB9XG4gICovXG5cbn0sXG5cbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogVFJBTlNGT1JNU1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuX2lkZW50aXR5MkRNYXRyaXggPSBbMSwgMCwgMCwgMSwgMCwgMF0sXG4gICAgX3JvdGF0aW9uYWxQcm9wZXJ0aWVzID0ge30sXG4gICAgX2lzTnVsbFRyYW5zZm9ybSA9IGZ1bmN0aW9uIF9pc051bGxUcmFuc2Zvcm0odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBcIm1hdHJpeCgxLCAwLCAwLCAxLCAwLCAwKVwiIHx8IHZhbHVlID09PSBcIm5vbmVcIiB8fCAhdmFsdWU7XG59LFxuICAgIF9nZXRDb21wdXRlZFRyYW5zZm9ybU1hdHJpeEFzQXJyYXkgPSBmdW5jdGlvbiBfZ2V0Q29tcHV0ZWRUcmFuc2Zvcm1NYXRyaXhBc0FycmF5KHRhcmdldCkge1xuICB2YXIgbWF0cml4U3RyaW5nID0gX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBfdHJhbnNmb3JtUHJvcCk7XG5cbiAgcmV0dXJuIF9pc051bGxUcmFuc2Zvcm0obWF0cml4U3RyaW5nKSA/IF9pZGVudGl0eTJETWF0cml4IDogbWF0cml4U3RyaW5nLnN1YnN0cig3KS5tYXRjaChfbnVtRXhwKS5tYXAoX3JvdW5kKTtcbn0sXG4gICAgX2dldE1hdHJpeCA9IGZ1bmN0aW9uIF9nZXRNYXRyaXgodGFyZ2V0LCBmb3JjZTJEKSB7XG4gIHZhciBjYWNoZSA9IHRhcmdldC5fZ3NhcCB8fCBfZ2V0Q2FjaGUodGFyZ2V0KSxcbiAgICAgIHN0eWxlID0gdGFyZ2V0LnN0eWxlLFxuICAgICAgbWF0cml4ID0gX2dldENvbXB1dGVkVHJhbnNmb3JtTWF0cml4QXNBcnJheSh0YXJnZXQpLFxuICAgICAgcGFyZW50LFxuICAgICAgbmV4dFNpYmxpbmcsXG4gICAgICB0ZW1wLFxuICAgICAgYWRkZWRUb0RPTTtcblxuICBpZiAoY2FjaGUuc3ZnICYmIHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIikpIHtcbiAgICB0ZW1wID0gdGFyZ2V0LnRyYW5zZm9ybS5iYXNlVmFsLmNvbnNvbGlkYXRlKCkubWF0cml4OyAvL2Vuc3VyZXMgdGhhdCBldmVuIGNvbXBsZXggdmFsdWVzIGxpa2UgXCJ0cmFuc2xhdGUoNTAsNjApIHJvdGF0ZSgxMzUsMCwwKVwiIGFyZSBwYXJzZWQgYmVjYXVzZSBpdCBtYXNoZXMgaXQgaW50byBhIG1hdHJpeC5cblxuICAgIG1hdHJpeCA9IFt0ZW1wLmEsIHRlbXAuYiwgdGVtcC5jLCB0ZW1wLmQsIHRlbXAuZSwgdGVtcC5mXTtcbiAgICByZXR1cm4gbWF0cml4LmpvaW4oXCIsXCIpID09PSBcIjEsMCwwLDEsMCwwXCIgPyBfaWRlbnRpdHkyRE1hdHJpeCA6IG1hdHJpeDtcbiAgfSBlbHNlIGlmIChtYXRyaXggPT09IF9pZGVudGl0eTJETWF0cml4ICYmICF0YXJnZXQub2Zmc2V0UGFyZW50ICYmIHRhcmdldCAhPT0gX2RvY0VsZW1lbnQgJiYgIWNhY2hlLnN2Zykge1xuICAgIC8vbm90ZTogaWYgb2Zmc2V0UGFyZW50IGlzIG51bGwsIHRoYXQgbWVhbnMgdGhlIGVsZW1lbnQgaXNuJ3QgaW4gdGhlIG5vcm1hbCBkb2N1bWVudCBmbG93LCBsaWtlIGlmIGl0IGhhcyBkaXNwbGF5Om5vbmUgb3Igb25lIG9mIGl0cyBhbmNlc3RvcnMgaGFzIGRpc3BsYXk6bm9uZSkuIEZpcmVmb3ggcmV0dXJucyBudWxsIGZvciBnZXRDb21wdXRlZFN0eWxlKCkgaWYgdGhlIGVsZW1lbnQgaXMgaW4gYW4gaWZyYW1lIHRoYXQgaGFzIGRpc3BsYXk6bm9uZS4gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NTQ4Mzk3XG4gICAgLy9icm93c2VycyBkb24ndCByZXBvcnQgdHJhbnNmb3JtcyBhY2N1cmF0ZWx5IHVubGVzcyB0aGUgZWxlbWVudCBpcyBpbiB0aGUgRE9NIGFuZCBoYXMgYSBkaXNwbGF5IHZhbHVlIHRoYXQncyBub3QgXCJub25lXCIuIEZpcmVmb3ggYW5kIE1pY3Jvc29mdCBicm93c2VycyBoYXZlIGEgcGFydGlhbCBidWcgd2hlcmUgdGhleSdsbCByZXBvcnQgdHJhbnNmb3JtcyBldmVuIGlmIGRpc3BsYXk6bm9uZSBCVVQgbm90IGFueSBwZXJjZW50YWdlLWJhc2VkIHZhbHVlcyBsaWtlIHRyYW5zbGF0ZSgtNTAlLCA4cHgpIHdpbGwgYmUgcmVwb3J0ZWQgYXMgaWYgaXQncyB0cmFuc2xhdGUoMCwgOHB4KS5cbiAgICB0ZW1wID0gc3R5bGUuZGlzcGxheTtcbiAgICBzdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgIHBhcmVudCA9IHRhcmdldC5wYXJlbnROb2RlO1xuXG4gICAgaWYgKCFwYXJlbnQgfHwgIXRhcmdldC5vZmZzZXRQYXJlbnQpIHtcbiAgICAgIC8vIG5vdGU6IGluIDMuMy4wIHdlIHN3aXRjaGVkIHRhcmdldC5vZmZzZXRQYXJlbnQgdG8gX2RvYy5ib2R5LmNvbnRhaW5zKHRhcmdldCkgdG8gYXZvaWQgW3NvbWV0aW1lcyB1bm5lY2Vzc2FyeV0gTXV0YXRpb25PYnNlcnZlciBjYWxscyBidXQgdGhhdCB3YXNuJ3QgYWRlcXVhdGUgYmVjYXVzZSB0aGVyZSBhcmUgZWRnZSBjYXNlcyB3aGVyZSBuZXN0ZWQgcG9zaXRpb246IGZpeGVkIGVsZW1lbnRzIG5lZWQgdG8gZ2V0IHJlcGFyZW50ZWQgdG8gYWNjdXJhdGVseSBzZW5zZSB0cmFuc2Zvcm1zLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2dyZWVuc29jay9HU0FQL2lzc3Vlcy8zODggYW5kIGh0dHBzOi8vZ2l0aHViLmNvbS9ncmVlbnNvY2svR1NBUC9pc3N1ZXMvMzc1XG4gICAgICBhZGRlZFRvRE9NID0gMTsgLy9mbGFnXG5cbiAgICAgIG5leHRTaWJsaW5nID0gdGFyZ2V0Lm5leHRTaWJsaW5nO1xuXG4gICAgICBfZG9jRWxlbWVudC5hcHBlbmRDaGlsZCh0YXJnZXQpOyAvL3dlIG11c3QgYWRkIGl0IHRvIHRoZSBET00gaW4gb3JkZXIgdG8gZ2V0IHZhbHVlcyBwcm9wZXJseVxuXG4gICAgfVxuXG4gICAgbWF0cml4ID0gX2dldENvbXB1dGVkVHJhbnNmb3JtTWF0cml4QXNBcnJheSh0YXJnZXQpO1xuICAgIHRlbXAgPyBzdHlsZS5kaXNwbGF5ID0gdGVtcCA6IF9yZW1vdmVQcm9wZXJ0eSh0YXJnZXQsIFwiZGlzcGxheVwiKTtcblxuICAgIGlmIChhZGRlZFRvRE9NKSB7XG4gICAgICBuZXh0U2libGluZyA/IHBhcmVudC5pbnNlcnRCZWZvcmUodGFyZ2V0LCBuZXh0U2libGluZykgOiBwYXJlbnQgPyBwYXJlbnQuYXBwZW5kQ2hpbGQodGFyZ2V0KSA6IF9kb2NFbGVtZW50LnJlbW92ZUNoaWxkKHRhcmdldCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZvcmNlMkQgJiYgbWF0cml4Lmxlbmd0aCA+IDYgPyBbbWF0cml4WzBdLCBtYXRyaXhbMV0sIG1hdHJpeFs0XSwgbWF0cml4WzVdLCBtYXRyaXhbMTJdLCBtYXRyaXhbMTNdXSA6IG1hdHJpeDtcbn0sXG4gICAgX2FwcGx5U1ZHT3JpZ2luID0gZnVuY3Rpb24gX2FwcGx5U1ZHT3JpZ2luKHRhcmdldCwgb3JpZ2luLCBvcmlnaW5Jc0Fic29sdXRlLCBzbW9vdGgsIG1hdHJpeEFycmF5LCBwbHVnaW5Ub0FkZFByb3BUd2VlbnNUbykge1xuICB2YXIgY2FjaGUgPSB0YXJnZXQuX2dzYXAsXG4gICAgICBtYXRyaXggPSBtYXRyaXhBcnJheSB8fCBfZ2V0TWF0cml4KHRhcmdldCwgdHJ1ZSksXG4gICAgICB4T3JpZ2luT2xkID0gY2FjaGUueE9yaWdpbiB8fCAwLFxuICAgICAgeU9yaWdpbk9sZCA9IGNhY2hlLnlPcmlnaW4gfHwgMCxcbiAgICAgIHhPZmZzZXRPbGQgPSBjYWNoZS54T2Zmc2V0IHx8IDAsXG4gICAgICB5T2Zmc2V0T2xkID0gY2FjaGUueU9mZnNldCB8fCAwLFxuICAgICAgYSA9IG1hdHJpeFswXSxcbiAgICAgIGIgPSBtYXRyaXhbMV0sXG4gICAgICBjID0gbWF0cml4WzJdLFxuICAgICAgZCA9IG1hdHJpeFszXSxcbiAgICAgIHR4ID0gbWF0cml4WzRdLFxuICAgICAgdHkgPSBtYXRyaXhbNV0sXG4gICAgICBvcmlnaW5TcGxpdCA9IG9yaWdpbi5zcGxpdChcIiBcIiksXG4gICAgICB4T3JpZ2luID0gcGFyc2VGbG9hdChvcmlnaW5TcGxpdFswXSkgfHwgMCxcbiAgICAgIHlPcmlnaW4gPSBwYXJzZUZsb2F0KG9yaWdpblNwbGl0WzFdKSB8fCAwLFxuICAgICAgYm91bmRzLFxuICAgICAgZGV0ZXJtaW5hbnQsXG4gICAgICB4LFxuICAgICAgeTtcblxuICBpZiAoIW9yaWdpbklzQWJzb2x1dGUpIHtcbiAgICBib3VuZHMgPSBfZ2V0QkJveCh0YXJnZXQpO1xuICAgIHhPcmlnaW4gPSBib3VuZHMueCArICh+b3JpZ2luU3BsaXRbMF0uaW5kZXhPZihcIiVcIikgPyB4T3JpZ2luIC8gMTAwICogYm91bmRzLndpZHRoIDogeE9yaWdpbik7XG4gICAgeU9yaWdpbiA9IGJvdW5kcy55ICsgKH4ob3JpZ2luU3BsaXRbMV0gfHwgb3JpZ2luU3BsaXRbMF0pLmluZGV4T2YoXCIlXCIpID8geU9yaWdpbiAvIDEwMCAqIGJvdW5kcy5oZWlnaHQgOiB5T3JpZ2luKTtcbiAgfSBlbHNlIGlmIChtYXRyaXggIT09IF9pZGVudGl0eTJETWF0cml4ICYmIChkZXRlcm1pbmFudCA9IGEgKiBkIC0gYiAqIGMpKSB7XG4gICAgLy9pZiBpdCdzIHplcm8gKGxpa2UgaWYgc2NhbGVYIGFuZCBzY2FsZVkgYXJlIHplcm8pLCBza2lwIGl0IHRvIGF2b2lkIGVycm9ycyB3aXRoIGRpdmlkaW5nIGJ5IHplcm8uXG4gICAgeCA9IHhPcmlnaW4gKiAoZCAvIGRldGVybWluYW50KSArIHlPcmlnaW4gKiAoLWMgLyBkZXRlcm1pbmFudCkgKyAoYyAqIHR5IC0gZCAqIHR4KSAvIGRldGVybWluYW50O1xuICAgIHkgPSB4T3JpZ2luICogKC1iIC8gZGV0ZXJtaW5hbnQpICsgeU9yaWdpbiAqIChhIC8gZGV0ZXJtaW5hbnQpIC0gKGEgKiB0eSAtIGIgKiB0eCkgLyBkZXRlcm1pbmFudDtcbiAgICB4T3JpZ2luID0geDtcbiAgICB5T3JpZ2luID0geTtcbiAgfVxuXG4gIGlmIChzbW9vdGggfHwgc21vb3RoICE9PSBmYWxzZSAmJiBjYWNoZS5zbW9vdGgpIHtcbiAgICB0eCA9IHhPcmlnaW4gLSB4T3JpZ2luT2xkO1xuICAgIHR5ID0geU9yaWdpbiAtIHlPcmlnaW5PbGQ7XG4gICAgY2FjaGUueE9mZnNldCA9IHhPZmZzZXRPbGQgKyAodHggKiBhICsgdHkgKiBjKSAtIHR4O1xuICAgIGNhY2hlLnlPZmZzZXQgPSB5T2Zmc2V0T2xkICsgKHR4ICogYiArIHR5ICogZCkgLSB0eTtcbiAgfSBlbHNlIHtcbiAgICBjYWNoZS54T2Zmc2V0ID0gY2FjaGUueU9mZnNldCA9IDA7XG4gIH1cblxuICBjYWNoZS54T3JpZ2luID0geE9yaWdpbjtcbiAgY2FjaGUueU9yaWdpbiA9IHlPcmlnaW47XG4gIGNhY2hlLnNtb290aCA9ICEhc21vb3RoO1xuICBjYWNoZS5vcmlnaW4gPSBvcmlnaW47XG4gIGNhY2hlLm9yaWdpbklzQWJzb2x1dGUgPSAhIW9yaWdpbklzQWJzb2x1dGU7XG4gIHRhcmdldC5zdHlsZVtfdHJhbnNmb3JtT3JpZ2luUHJvcF0gPSBcIjBweCAwcHhcIjsgLy9vdGhlcndpc2UsIGlmIHNvbWVvbmUgc2V0cyAgYW4gb3JpZ2luIHZpYSBDU1MsIGl0IHdpbGwgbGlrZWx5IGludGVyZmVyZSB3aXRoIHRoZSBTVkcgdHJhbnNmb3JtIGF0dHJpYnV0ZSBvbmVzIChiZWNhdXNlIHJlbWVtYmVyLCB3ZSdyZSBiYWtpbmcgdGhlIG9yaWdpbiBpbnRvIHRoZSBtYXRyaXgoKSB2YWx1ZSkuXG5cbiAgaWYgKHBsdWdpblRvQWRkUHJvcFR3ZWVuc1RvKSB7XG4gICAgX2FkZE5vblR3ZWVuaW5nUFQocGx1Z2luVG9BZGRQcm9wVHdlZW5zVG8sIGNhY2hlLCBcInhPcmlnaW5cIiwgeE9yaWdpbk9sZCwgeE9yaWdpbik7XG5cbiAgICBfYWRkTm9uVHdlZW5pbmdQVChwbHVnaW5Ub0FkZFByb3BUd2VlbnNUbywgY2FjaGUsIFwieU9yaWdpblwiLCB5T3JpZ2luT2xkLCB5T3JpZ2luKTtcblxuICAgIF9hZGROb25Ud2VlbmluZ1BUKHBsdWdpblRvQWRkUHJvcFR3ZWVuc1RvLCBjYWNoZSwgXCJ4T2Zmc2V0XCIsIHhPZmZzZXRPbGQsIGNhY2hlLnhPZmZzZXQpO1xuXG4gICAgX2FkZE5vblR3ZWVuaW5nUFQocGx1Z2luVG9BZGRQcm9wVHdlZW5zVG8sIGNhY2hlLCBcInlPZmZzZXRcIiwgeU9mZnNldE9sZCwgY2FjaGUueU9mZnNldCk7XG4gIH1cblxuICB0YXJnZXQuc2V0QXR0cmlidXRlKFwiZGF0YS1zdmctb3JpZ2luXCIsIHhPcmlnaW4gKyBcIiBcIiArIHlPcmlnaW4pO1xufSxcbiAgICBfcGFyc2VUcmFuc2Zvcm0gPSBmdW5jdGlvbiBfcGFyc2VUcmFuc2Zvcm0odGFyZ2V0LCB1bmNhY2hlKSB7XG4gIHZhciBjYWNoZSA9IHRhcmdldC5fZ3NhcCB8fCBuZXcgR1NDYWNoZSh0YXJnZXQpO1xuXG4gIGlmIChcInhcIiBpbiBjYWNoZSAmJiAhdW5jYWNoZSAmJiAhY2FjaGUudW5jYWNoZSkge1xuICAgIHJldHVybiBjYWNoZTtcbiAgfVxuXG4gIHZhciBzdHlsZSA9IHRhcmdldC5zdHlsZSxcbiAgICAgIGludmVydGVkU2NhbGVYID0gY2FjaGUuc2NhbGVYIDwgMCxcbiAgICAgIHB4ID0gXCJweFwiLFxuICAgICAgZGVnID0gXCJkZWdcIixcbiAgICAgIG9yaWdpbiA9IF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgX3RyYW5zZm9ybU9yaWdpblByb3ApIHx8IFwiMFwiLFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB6LFxuICAgICAgc2NhbGVYLFxuICAgICAgc2NhbGVZLFxuICAgICAgcm90YXRpb24sXG4gICAgICByb3RhdGlvblgsXG4gICAgICByb3RhdGlvblksXG4gICAgICBza2V3WCxcbiAgICAgIHNrZXdZLFxuICAgICAgcGVyc3BlY3RpdmUsXG4gICAgICB4T3JpZ2luLFxuICAgICAgeU9yaWdpbixcbiAgICAgIG1hdHJpeCxcbiAgICAgIGFuZ2xlLFxuICAgICAgY29zLFxuICAgICAgc2luLFxuICAgICAgYSxcbiAgICAgIGIsXG4gICAgICBjLFxuICAgICAgZCxcbiAgICAgIGExMixcbiAgICAgIGEyMixcbiAgICAgIHQxLFxuICAgICAgdDIsXG4gICAgICB0MyxcbiAgICAgIGExMyxcbiAgICAgIGEyMyxcbiAgICAgIGEzMyxcbiAgICAgIGE0MixcbiAgICAgIGE0MyxcbiAgICAgIGEzMjtcbiAgeCA9IHkgPSB6ID0gcm90YXRpb24gPSByb3RhdGlvblggPSByb3RhdGlvblkgPSBza2V3WCA9IHNrZXdZID0gcGVyc3BlY3RpdmUgPSAwO1xuICBzY2FsZVggPSBzY2FsZVkgPSAxO1xuICBjYWNoZS5zdmcgPSAhISh0YXJnZXQuZ2V0Q1RNICYmIF9pc1NWRyh0YXJnZXQpKTtcbiAgbWF0cml4ID0gX2dldE1hdHJpeCh0YXJnZXQsIGNhY2hlLnN2Zyk7XG5cbiAgaWYgKGNhY2hlLnN2Zykge1xuICAgIHQxID0gIWNhY2hlLnVuY2FjaGUgJiYgdGFyZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtc3ZnLW9yaWdpblwiKTtcblxuICAgIF9hcHBseVNWR09yaWdpbih0YXJnZXQsIHQxIHx8IG9yaWdpbiwgISF0MSB8fCBjYWNoZS5vcmlnaW5Jc0Fic29sdXRlLCBjYWNoZS5zbW9vdGggIT09IGZhbHNlLCBtYXRyaXgpO1xuICB9XG5cbiAgeE9yaWdpbiA9IGNhY2hlLnhPcmlnaW4gfHwgMDtcbiAgeU9yaWdpbiA9IGNhY2hlLnlPcmlnaW4gfHwgMDtcblxuICBpZiAobWF0cml4ICE9PSBfaWRlbnRpdHkyRE1hdHJpeCkge1xuICAgIGEgPSBtYXRyaXhbMF07IC8vYTExXG5cbiAgICBiID0gbWF0cml4WzFdOyAvL2EyMVxuXG4gICAgYyA9IG1hdHJpeFsyXTsgLy9hMzFcblxuICAgIGQgPSBtYXRyaXhbM107IC8vYTQxXG5cbiAgICB4ID0gYTEyID0gbWF0cml4WzRdO1xuICAgIHkgPSBhMjIgPSBtYXRyaXhbNV07IC8vMkQgbWF0cml4XG5cbiAgICBpZiAobWF0cml4Lmxlbmd0aCA9PT0gNikge1xuICAgICAgc2NhbGVYID0gTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpO1xuICAgICAgc2NhbGVZID0gTWF0aC5zcXJ0KGQgKiBkICsgYyAqIGMpO1xuICAgICAgcm90YXRpb24gPSBhIHx8IGIgPyBfYXRhbjIoYiwgYSkgKiBfUkFEMkRFRyA6IDA7IC8vbm90ZTogaWYgc2NhbGVYIGlzIDAsIHdlIGNhbm5vdCBhY2N1cmF0ZWx5IG1lYXN1cmUgcm90YXRpb24uIFNhbWUgZm9yIHNrZXdYIHdpdGggYSBzY2FsZVkgb2YgMC4gVGhlcmVmb3JlLCB3ZSBkZWZhdWx0IHRvIHRoZSBwcmV2aW91c2x5IHJlY29yZGVkIHZhbHVlIChvciB6ZXJvIGlmIHRoYXQgZG9lc24ndCBleGlzdCkuXG5cbiAgICAgIHNrZXdYID0gYyB8fCBkID8gX2F0YW4yKGMsIGQpICogX1JBRDJERUcgKyByb3RhdGlvbiA6IDA7XG4gICAgICBza2V3WCAmJiAoc2NhbGVZICo9IE1hdGguY29zKHNrZXdYICogX0RFRzJSQUQpKTtcblxuICAgICAgaWYgKGNhY2hlLnN2Zykge1xuICAgICAgICB4IC09IHhPcmlnaW4gLSAoeE9yaWdpbiAqIGEgKyB5T3JpZ2luICogYyk7XG4gICAgICAgIHkgLT0geU9yaWdpbiAtICh4T3JpZ2luICogYiArIHlPcmlnaW4gKiBkKTtcbiAgICAgIH0gLy8zRCBtYXRyaXhcblxuICAgIH0gZWxzZSB7XG4gICAgICBhMzIgPSBtYXRyaXhbNl07XG4gICAgICBhNDIgPSBtYXRyaXhbN107XG4gICAgICBhMTMgPSBtYXRyaXhbOF07XG4gICAgICBhMjMgPSBtYXRyaXhbOV07XG4gICAgICBhMzMgPSBtYXRyaXhbMTBdO1xuICAgICAgYTQzID0gbWF0cml4WzExXTtcbiAgICAgIHggPSBtYXRyaXhbMTJdO1xuICAgICAgeSA9IG1hdHJpeFsxM107XG4gICAgICB6ID0gbWF0cml4WzE0XTtcbiAgICAgIGFuZ2xlID0gX2F0YW4yKGEzMiwgYTMzKTtcbiAgICAgIHJvdGF0aW9uWCA9IGFuZ2xlICogX1JBRDJERUc7IC8vcm90YXRpb25YXG5cbiAgICAgIGlmIChhbmdsZSkge1xuICAgICAgICBjb3MgPSBNYXRoLmNvcygtYW5nbGUpO1xuICAgICAgICBzaW4gPSBNYXRoLnNpbigtYW5nbGUpO1xuICAgICAgICB0MSA9IGExMiAqIGNvcyArIGExMyAqIHNpbjtcbiAgICAgICAgdDIgPSBhMjIgKiBjb3MgKyBhMjMgKiBzaW47XG4gICAgICAgIHQzID0gYTMyICogY29zICsgYTMzICogc2luO1xuICAgICAgICBhMTMgPSBhMTIgKiAtc2luICsgYTEzICogY29zO1xuICAgICAgICBhMjMgPSBhMjIgKiAtc2luICsgYTIzICogY29zO1xuICAgICAgICBhMzMgPSBhMzIgKiAtc2luICsgYTMzICogY29zO1xuICAgICAgICBhNDMgPSBhNDIgKiAtc2luICsgYTQzICogY29zO1xuICAgICAgICBhMTIgPSB0MTtcbiAgICAgICAgYTIyID0gdDI7XG4gICAgICAgIGEzMiA9IHQzO1xuICAgICAgfSAvL3JvdGF0aW9uWVxuXG5cbiAgICAgIGFuZ2xlID0gX2F0YW4yKC1jLCBhMzMpO1xuICAgICAgcm90YXRpb25ZID0gYW5nbGUgKiBfUkFEMkRFRztcblxuICAgICAgaWYgKGFuZ2xlKSB7XG4gICAgICAgIGNvcyA9IE1hdGguY29zKC1hbmdsZSk7XG4gICAgICAgIHNpbiA9IE1hdGguc2luKC1hbmdsZSk7XG4gICAgICAgIHQxID0gYSAqIGNvcyAtIGExMyAqIHNpbjtcbiAgICAgICAgdDIgPSBiICogY29zIC0gYTIzICogc2luO1xuICAgICAgICB0MyA9IGMgKiBjb3MgLSBhMzMgKiBzaW47XG4gICAgICAgIGE0MyA9IGQgKiBzaW4gKyBhNDMgKiBjb3M7XG4gICAgICAgIGEgPSB0MTtcbiAgICAgICAgYiA9IHQyO1xuICAgICAgICBjID0gdDM7XG4gICAgICB9IC8vcm90YXRpb25aXG5cblxuICAgICAgYW5nbGUgPSBfYXRhbjIoYiwgYSk7XG4gICAgICByb3RhdGlvbiA9IGFuZ2xlICogX1JBRDJERUc7XG5cbiAgICAgIGlmIChhbmdsZSkge1xuICAgICAgICBjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICAgIHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICAgICAgdDEgPSBhICogY29zICsgYiAqIHNpbjtcbiAgICAgICAgdDIgPSBhMTIgKiBjb3MgKyBhMjIgKiBzaW47XG4gICAgICAgIGIgPSBiICogY29zIC0gYSAqIHNpbjtcbiAgICAgICAgYTIyID0gYTIyICogY29zIC0gYTEyICogc2luO1xuICAgICAgICBhID0gdDE7XG4gICAgICAgIGExMiA9IHQyO1xuICAgICAgfVxuXG4gICAgICBpZiAocm90YXRpb25YICYmIE1hdGguYWJzKHJvdGF0aW9uWCkgKyBNYXRoLmFicyhyb3RhdGlvbikgPiAzNTkuOSkge1xuICAgICAgICAvL3doZW4gcm90YXRpb25ZIGlzIHNldCwgaXQgd2lsbCBvZnRlbiBiZSBwYXJzZWQgYXMgMTgwIGRlZ3JlZXMgZGlmZmVyZW50IHRoYW4gaXQgc2hvdWxkIGJlLCBhbmQgcm90YXRpb25YIGFuZCByb3RhdGlvbiBib3RoIGJlaW5nIDE4MCAoaXQgbG9va3MgdGhlIHNhbWUpLCBzbyB3ZSBhZGp1c3QgZm9yIHRoYXQgaGVyZS5cbiAgICAgICAgcm90YXRpb25YID0gcm90YXRpb24gPSAwO1xuICAgICAgICByb3RhdGlvblkgPSAxODAgLSByb3RhdGlvblk7XG4gICAgICB9XG5cbiAgICAgIHNjYWxlWCA9IF9yb3VuZChNYXRoLnNxcnQoYSAqIGEgKyBiICogYiArIGMgKiBjKSk7XG4gICAgICBzY2FsZVkgPSBfcm91bmQoTWF0aC5zcXJ0KGEyMiAqIGEyMiArIGEzMiAqIGEzMikpO1xuICAgICAgYW5nbGUgPSBfYXRhbjIoYTEyLCBhMjIpO1xuICAgICAgc2tld1ggPSBNYXRoLmFicyhhbmdsZSkgPiAwLjAwMDIgPyBhbmdsZSAqIF9SQUQyREVHIDogMDtcbiAgICAgIHBlcnNwZWN0aXZlID0gYTQzID8gMSAvIChhNDMgPCAwID8gLWE0MyA6IGE0MykgOiAwO1xuICAgIH1cblxuICAgIGlmIChjYWNoZS5zdmcpIHtcbiAgICAgIC8vc2Vuc2UgaWYgdGhlcmUgYXJlIENTUyB0cmFuc2Zvcm1zIGFwcGxpZWQgb24gYW4gU1ZHIGVsZW1lbnQgaW4gd2hpY2ggY2FzZSB3ZSBtdXN0IG92ZXJ3cml0ZSB0aGVtIHdoZW4gcmVuZGVyaW5nLiBUaGUgdHJhbnNmb3JtIGF0dHJpYnV0ZSBpcyBtb3JlIHJlbGlhYmxlIGNyb3NzLWJyb3dzZXIsIGJ1dCB3ZSBjYW4ndCBqdXN0IHJlbW92ZSB0aGUgQ1NTIG9uZXMgYmVjYXVzZSB0aGV5IG1heSBiZSBhcHBsaWVkIGluIGEgQ1NTIHJ1bGUgc29tZXdoZXJlIChub3QganVzdCBpbmxpbmUpLlxuICAgICAgdDEgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIpO1xuICAgICAgY2FjaGUuZm9yY2VDU1MgPSB0YXJnZXQuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIFwiXCIpIHx8ICFfaXNOdWxsVHJhbnNmb3JtKF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgX3RyYW5zZm9ybVByb3ApKTtcbiAgICAgIHQxICYmIHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgdDEpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChNYXRoLmFicyhza2V3WCkgPiA5MCAmJiBNYXRoLmFicyhza2V3WCkgPCAyNzApIHtcbiAgICBpZiAoaW52ZXJ0ZWRTY2FsZVgpIHtcbiAgICAgIHNjYWxlWCAqPSAtMTtcbiAgICAgIHNrZXdYICs9IHJvdGF0aW9uIDw9IDAgPyAxODAgOiAtMTgwO1xuICAgICAgcm90YXRpb24gKz0gcm90YXRpb24gPD0gMCA/IDE4MCA6IC0xODA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjYWxlWSAqPSAtMTtcbiAgICAgIHNrZXdYICs9IHNrZXdYIDw9IDAgPyAxODAgOiAtMTgwO1xuICAgIH1cbiAgfVxuXG4gIGNhY2hlLnggPSAoKGNhY2hlLnhQZXJjZW50ID0geCAmJiBNYXRoLnJvdW5kKHRhcmdldC5vZmZzZXRXaWR0aCAvIDIpID09PSBNYXRoLnJvdW5kKC14KSA/IC01MCA6IDApID8gMCA6IHgpICsgcHg7XG4gIGNhY2hlLnkgPSAoKGNhY2hlLnlQZXJjZW50ID0geSAmJiBNYXRoLnJvdW5kKHRhcmdldC5vZmZzZXRIZWlnaHQgLyAyKSA9PT0gTWF0aC5yb3VuZCgteSkgPyAtNTAgOiAwKSA/IDAgOiB5KSArIHB4O1xuICBjYWNoZS56ID0geiArIHB4O1xuICBjYWNoZS5zY2FsZVggPSBfcm91bmQoc2NhbGVYKTtcbiAgY2FjaGUuc2NhbGVZID0gX3JvdW5kKHNjYWxlWSk7XG4gIGNhY2hlLnJvdGF0aW9uID0gX3JvdW5kKHJvdGF0aW9uKSArIGRlZztcbiAgY2FjaGUucm90YXRpb25YID0gX3JvdW5kKHJvdGF0aW9uWCkgKyBkZWc7XG4gIGNhY2hlLnJvdGF0aW9uWSA9IF9yb3VuZChyb3RhdGlvblkpICsgZGVnO1xuICBjYWNoZS5za2V3WCA9IHNrZXdYICsgZGVnO1xuICBjYWNoZS5za2V3WSA9IHNrZXdZICsgZGVnO1xuICBjYWNoZS50cmFuc2Zvcm1QZXJzcGVjdGl2ZSA9IHBlcnNwZWN0aXZlICsgcHg7XG5cbiAgaWYgKGNhY2hlLnpPcmlnaW4gPSBwYXJzZUZsb2F0KG9yaWdpbi5zcGxpdChcIiBcIilbMl0pIHx8IDApIHtcbiAgICBzdHlsZVtfdHJhbnNmb3JtT3JpZ2luUHJvcF0gPSBfZmlyc3RUd29Pbmx5KG9yaWdpbik7XG4gIH1cblxuICBjYWNoZS54T2Zmc2V0ID0gY2FjaGUueU9mZnNldCA9IDA7XG4gIGNhY2hlLmZvcmNlM0QgPSBfY29uZmlnLmZvcmNlM0Q7XG4gIGNhY2hlLnJlbmRlclRyYW5zZm9ybSA9IGNhY2hlLnN2ZyA/IF9yZW5kZXJTVkdUcmFuc2Zvcm1zIDogX3N1cHBvcnRzM0QgPyBfcmVuZGVyQ1NTVHJhbnNmb3JtcyA6IF9yZW5kZXJOb24zRFRyYW5zZm9ybXM7XG4gIGNhY2hlLnVuY2FjaGUgPSAwO1xuICByZXR1cm4gY2FjaGU7XG59LFxuICAgIF9maXJzdFR3b09ubHkgPSBmdW5jdGlvbiBfZmlyc3RUd29Pbmx5KHZhbHVlKSB7XG4gIHJldHVybiAodmFsdWUgPSB2YWx1ZS5zcGxpdChcIiBcIikpWzBdICsgXCIgXCIgKyB2YWx1ZVsxXTtcbn0sXG4gICAgLy9mb3IgaGFuZGxpbmcgdHJhbnNmb3JtT3JpZ2luIHZhbHVlcywgc3RyaXBwaW5nIG91dCB0aGUgM3JkIGRpbWVuc2lvblxuX2FkZFB4VHJhbnNsYXRlID0gZnVuY3Rpb24gX2FkZFB4VHJhbnNsYXRlKHRhcmdldCwgc3RhcnQsIHZhbHVlKSB7XG4gIHZhciB1bml0ID0gZ2V0VW5pdChzdGFydCk7XG4gIHJldHVybiBfcm91bmQocGFyc2VGbG9hdChzdGFydCkgKyBwYXJzZUZsb2F0KF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgXCJ4XCIsIHZhbHVlICsgXCJweFwiLCB1bml0KSkpICsgdW5pdDtcbn0sXG4gICAgX3JlbmRlck5vbjNEVHJhbnNmb3JtcyA9IGZ1bmN0aW9uIF9yZW5kZXJOb24zRFRyYW5zZm9ybXMocmF0aW8sIGNhY2hlKSB7XG4gIGNhY2hlLnogPSBcIjBweFwiO1xuICBjYWNoZS5yb3RhdGlvblkgPSBjYWNoZS5yb3RhdGlvblggPSBcIjBkZWdcIjtcbiAgY2FjaGUuZm9yY2UzRCA9IDA7XG5cbiAgX3JlbmRlckNTU1RyYW5zZm9ybXMocmF0aW8sIGNhY2hlKTtcbn0sXG4gICAgX3plcm9EZWcgPSBcIjBkZWdcIixcbiAgICBfemVyb1B4ID0gXCIwcHhcIixcbiAgICBfZW5kUGFyZW50aGVzaXMgPSBcIikgXCIsXG4gICAgX3JlbmRlckNTU1RyYW5zZm9ybXMgPSBmdW5jdGlvbiBfcmVuZGVyQ1NTVHJhbnNmb3JtcyhyYXRpbywgY2FjaGUpIHtcbiAgdmFyIF9yZWYgPSBjYWNoZSB8fCB0aGlzLFxuICAgICAgeFBlcmNlbnQgPSBfcmVmLnhQZXJjZW50LFxuICAgICAgeVBlcmNlbnQgPSBfcmVmLnlQZXJjZW50LFxuICAgICAgeCA9IF9yZWYueCxcbiAgICAgIHkgPSBfcmVmLnksXG4gICAgICB6ID0gX3JlZi56LFxuICAgICAgcm90YXRpb24gPSBfcmVmLnJvdGF0aW9uLFxuICAgICAgcm90YXRpb25ZID0gX3JlZi5yb3RhdGlvblksXG4gICAgICByb3RhdGlvblggPSBfcmVmLnJvdGF0aW9uWCxcbiAgICAgIHNrZXdYID0gX3JlZi5za2V3WCxcbiAgICAgIHNrZXdZID0gX3JlZi5za2V3WSxcbiAgICAgIHNjYWxlWCA9IF9yZWYuc2NhbGVYLFxuICAgICAgc2NhbGVZID0gX3JlZi5zY2FsZVksXG4gICAgICB0cmFuc2Zvcm1QZXJzcGVjdGl2ZSA9IF9yZWYudHJhbnNmb3JtUGVyc3BlY3RpdmUsXG4gICAgICBmb3JjZTNEID0gX3JlZi5mb3JjZTNELFxuICAgICAgdGFyZ2V0ID0gX3JlZi50YXJnZXQsXG4gICAgICB6T3JpZ2luID0gX3JlZi56T3JpZ2luLFxuICAgICAgdHJhbnNmb3JtcyA9IFwiXCIsXG4gICAgICB1c2UzRCA9IGZvcmNlM0QgPT09IFwiYXV0b1wiICYmIHJhdGlvICYmIHJhdGlvICE9PSAxIHx8IGZvcmNlM0QgPT09IHRydWU7IC8vIFNhZmFyaSBoYXMgYSBidWcgdGhhdCBjYXVzZXMgaXQgbm90IHRvIHJlbmRlciAzRCB0cmFuc2Zvcm0tb3JpZ2luIHZhbHVlcyBwcm9wZXJseSwgc28gd2UgZm9yY2UgdGhlIHogb3JpZ2luIHRvIDAsIHJlY29yZCBpdCBpbiB0aGUgY2FjaGUsIGFuZCB0aGVuIGRvIHRoZSBtYXRoIGhlcmUgdG8gb2Zmc2V0IHRoZSB0cmFuc2xhdGUgdmFsdWVzIGFjY29yZGluZ2x5IChiYXNpY2FsbHkgZG8gdGhlIDNEIHRyYW5zZm9ybS1vcmlnaW4gcGFydCBtYW51YWxseSlcblxuXG4gIGlmICh6T3JpZ2luICYmIChyb3RhdGlvblggIT09IF96ZXJvRGVnIHx8IHJvdGF0aW9uWSAhPT0gX3plcm9EZWcpKSB7XG4gICAgdmFyIGFuZ2xlID0gcGFyc2VGbG9hdChyb3RhdGlvblkpICogX0RFRzJSQUQsXG4gICAgICAgIGExMyA9IE1hdGguc2luKGFuZ2xlKSxcbiAgICAgICAgYTMzID0gTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICBjb3M7XG5cbiAgICBhbmdsZSA9IHBhcnNlRmxvYXQocm90YXRpb25YKSAqIF9ERUcyUkFEO1xuICAgIGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICB4ID0gX2FkZFB4VHJhbnNsYXRlKHRhcmdldCwgeCwgYTEzICogY29zICogLXpPcmlnaW4pO1xuICAgIHkgPSBfYWRkUHhUcmFuc2xhdGUodGFyZ2V0LCB5LCAtTWF0aC5zaW4oYW5nbGUpICogLXpPcmlnaW4pO1xuICAgIHogPSBfYWRkUHhUcmFuc2xhdGUodGFyZ2V0LCB6LCBhMzMgKiBjb3MgKiAtek9yaWdpbiArIHpPcmlnaW4pO1xuICB9XG5cbiAgaWYgKHRyYW5zZm9ybVBlcnNwZWN0aXZlICE9PSBfemVyb1B4KSB7XG4gICAgdHJhbnNmb3JtcyArPSBcInBlcnNwZWN0aXZlKFwiICsgdHJhbnNmb3JtUGVyc3BlY3RpdmUgKyBfZW5kUGFyZW50aGVzaXM7XG4gIH1cblxuICBpZiAoeFBlcmNlbnQgfHwgeVBlcmNlbnQpIHtcbiAgICB0cmFuc2Zvcm1zICs9IFwidHJhbnNsYXRlKFwiICsgeFBlcmNlbnQgKyBcIiUsIFwiICsgeVBlcmNlbnQgKyBcIiUpIFwiO1xuICB9XG5cbiAgaWYgKHVzZTNEIHx8IHggIT09IF96ZXJvUHggfHwgeSAhPT0gX3plcm9QeCB8fCB6ICE9PSBfemVyb1B4KSB7XG4gICAgdHJhbnNmb3JtcyArPSB6ICE9PSBfemVyb1B4IHx8IHVzZTNEID8gXCJ0cmFuc2xhdGUzZChcIiArIHggKyBcIiwgXCIgKyB5ICsgXCIsIFwiICsgeiArIFwiKSBcIiA6IFwidHJhbnNsYXRlKFwiICsgeCArIFwiLCBcIiArIHkgKyBfZW5kUGFyZW50aGVzaXM7XG4gIH1cblxuICBpZiAocm90YXRpb24gIT09IF96ZXJvRGVnKSB7XG4gICAgdHJhbnNmb3JtcyArPSBcInJvdGF0ZShcIiArIHJvdGF0aW9uICsgX2VuZFBhcmVudGhlc2lzO1xuICB9XG5cbiAgaWYgKHJvdGF0aW9uWSAhPT0gX3plcm9EZWcpIHtcbiAgICB0cmFuc2Zvcm1zICs9IFwicm90YXRlWShcIiArIHJvdGF0aW9uWSArIF9lbmRQYXJlbnRoZXNpcztcbiAgfVxuXG4gIGlmIChyb3RhdGlvblggIT09IF96ZXJvRGVnKSB7XG4gICAgdHJhbnNmb3JtcyArPSBcInJvdGF0ZVgoXCIgKyByb3RhdGlvblggKyBfZW5kUGFyZW50aGVzaXM7XG4gIH1cblxuICBpZiAoc2tld1ggIT09IF96ZXJvRGVnIHx8IHNrZXdZICE9PSBfemVyb0RlZykge1xuICAgIHRyYW5zZm9ybXMgKz0gXCJza2V3KFwiICsgc2tld1ggKyBcIiwgXCIgKyBza2V3WSArIF9lbmRQYXJlbnRoZXNpcztcbiAgfVxuXG4gIGlmIChzY2FsZVggIT09IDEgfHwgc2NhbGVZICE9PSAxKSB7XG4gICAgdHJhbnNmb3JtcyArPSBcInNjYWxlKFwiICsgc2NhbGVYICsgXCIsIFwiICsgc2NhbGVZICsgX2VuZFBhcmVudGhlc2lzO1xuICB9XG5cbiAgdGFyZ2V0LnN0eWxlW190cmFuc2Zvcm1Qcm9wXSA9IHRyYW5zZm9ybXMgfHwgXCJ0cmFuc2xhdGUoMCwgMClcIjtcbn0sXG4gICAgX3JlbmRlclNWR1RyYW5zZm9ybXMgPSBmdW5jdGlvbiBfcmVuZGVyU1ZHVHJhbnNmb3JtcyhyYXRpbywgY2FjaGUpIHtcbiAgdmFyIF9yZWYyID0gY2FjaGUgfHwgdGhpcyxcbiAgICAgIHhQZXJjZW50ID0gX3JlZjIueFBlcmNlbnQsXG4gICAgICB5UGVyY2VudCA9IF9yZWYyLnlQZXJjZW50LFxuICAgICAgeCA9IF9yZWYyLngsXG4gICAgICB5ID0gX3JlZjIueSxcbiAgICAgIHJvdGF0aW9uID0gX3JlZjIucm90YXRpb24sXG4gICAgICBza2V3WCA9IF9yZWYyLnNrZXdYLFxuICAgICAgc2tld1kgPSBfcmVmMi5za2V3WSxcbiAgICAgIHNjYWxlWCA9IF9yZWYyLnNjYWxlWCxcbiAgICAgIHNjYWxlWSA9IF9yZWYyLnNjYWxlWSxcbiAgICAgIHRhcmdldCA9IF9yZWYyLnRhcmdldCxcbiAgICAgIHhPcmlnaW4gPSBfcmVmMi54T3JpZ2luLFxuICAgICAgeU9yaWdpbiA9IF9yZWYyLnlPcmlnaW4sXG4gICAgICB4T2Zmc2V0ID0gX3JlZjIueE9mZnNldCxcbiAgICAgIHlPZmZzZXQgPSBfcmVmMi55T2Zmc2V0LFxuICAgICAgZm9yY2VDU1MgPSBfcmVmMi5mb3JjZUNTUyxcbiAgICAgIHR4ID0gcGFyc2VGbG9hdCh4KSxcbiAgICAgIHR5ID0gcGFyc2VGbG9hdCh5KSxcbiAgICAgIGExMSxcbiAgICAgIGEyMSxcbiAgICAgIGExMixcbiAgICAgIGEyMixcbiAgICAgIHRlbXA7XG5cbiAgcm90YXRpb24gPSBwYXJzZUZsb2F0KHJvdGF0aW9uKTtcbiAgc2tld1ggPSBwYXJzZUZsb2F0KHNrZXdYKTtcbiAgc2tld1kgPSBwYXJzZUZsb2F0KHNrZXdZKTtcblxuICBpZiAoc2tld1kpIHtcbiAgICAvL2ZvciBwZXJmb3JtYW5jZSByZWFzb25zLCB3ZSBjb21iaW5lIGFsbCBza2V3aW5nIGludG8gdGhlIHNrZXdYIGFuZCByb3RhdGlvbiB2YWx1ZXMuIFJlbWVtYmVyLCBhIHNrZXdZIG9mIDEwIGRlZ3JlZXMgbG9va3MgdGhlIHNhbWUgYXMgYSByb3RhdGlvbiBvZiAxMCBkZWdyZWVzIHBsdXMgYSBza2V3WCBvZiAxMCBkZWdyZWVzLlxuICAgIHNrZXdZID0gcGFyc2VGbG9hdChza2V3WSk7XG4gICAgc2tld1ggKz0gc2tld1k7XG4gICAgcm90YXRpb24gKz0gc2tld1k7XG4gIH1cblxuICBpZiAocm90YXRpb24gfHwgc2tld1gpIHtcbiAgICByb3RhdGlvbiAqPSBfREVHMlJBRDtcbiAgICBza2V3WCAqPSBfREVHMlJBRDtcbiAgICBhMTEgPSBNYXRoLmNvcyhyb3RhdGlvbikgKiBzY2FsZVg7XG4gICAgYTIxID0gTWF0aC5zaW4ocm90YXRpb24pICogc2NhbGVYO1xuICAgIGExMiA9IE1hdGguc2luKHJvdGF0aW9uIC0gc2tld1gpICogLXNjYWxlWTtcbiAgICBhMjIgPSBNYXRoLmNvcyhyb3RhdGlvbiAtIHNrZXdYKSAqIHNjYWxlWTtcblxuICAgIGlmIChza2V3WCkge1xuICAgICAgc2tld1kgKj0gX0RFRzJSQUQ7XG4gICAgICB0ZW1wID0gTWF0aC50YW4oc2tld1ggLSBza2V3WSk7XG4gICAgICB0ZW1wID0gTWF0aC5zcXJ0KDEgKyB0ZW1wICogdGVtcCk7XG4gICAgICBhMTIgKj0gdGVtcDtcbiAgICAgIGEyMiAqPSB0ZW1wO1xuXG4gICAgICBpZiAoc2tld1kpIHtcbiAgICAgICAgdGVtcCA9IE1hdGgudGFuKHNrZXdZKTtcbiAgICAgICAgdGVtcCA9IE1hdGguc3FydCgxICsgdGVtcCAqIHRlbXApO1xuICAgICAgICBhMTEgKj0gdGVtcDtcbiAgICAgICAgYTIxICo9IHRlbXA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYTExID0gX3JvdW5kKGExMSk7XG4gICAgYTIxID0gX3JvdW5kKGEyMSk7XG4gICAgYTEyID0gX3JvdW5kKGExMik7XG4gICAgYTIyID0gX3JvdW5kKGEyMik7XG4gIH0gZWxzZSB7XG4gICAgYTExID0gc2NhbGVYO1xuICAgIGEyMiA9IHNjYWxlWTtcbiAgICBhMjEgPSBhMTIgPSAwO1xuICB9XG5cbiAgaWYgKHR4ICYmICF+KHggKyBcIlwiKS5pbmRleE9mKFwicHhcIikgfHwgdHkgJiYgIX4oeSArIFwiXCIpLmluZGV4T2YoXCJweFwiKSkge1xuICAgIHR4ID0gX2NvbnZlcnRUb1VuaXQodGFyZ2V0LCBcInhcIiwgeCwgXCJweFwiKTtcbiAgICB0eSA9IF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgXCJ5XCIsIHksIFwicHhcIik7XG4gIH1cblxuICBpZiAoeE9yaWdpbiB8fCB5T3JpZ2luIHx8IHhPZmZzZXQgfHwgeU9mZnNldCkge1xuICAgIHR4ID0gX3JvdW5kKHR4ICsgeE9yaWdpbiAtICh4T3JpZ2luICogYTExICsgeU9yaWdpbiAqIGExMikgKyB4T2Zmc2V0KTtcbiAgICB0eSA9IF9yb3VuZCh0eSArIHlPcmlnaW4gLSAoeE9yaWdpbiAqIGEyMSArIHlPcmlnaW4gKiBhMjIpICsgeU9mZnNldCk7XG4gIH1cblxuICBpZiAoeFBlcmNlbnQgfHwgeVBlcmNlbnQpIHtcbiAgICAvL1RoZSBTVkcgc3BlYyBkb2Vzbid0IHN1cHBvcnQgcGVyY2VudGFnZS1iYXNlZCB0cmFuc2xhdGlvbiBpbiB0aGUgXCJ0cmFuc2Zvcm1cIiBhdHRyaWJ1dGUsIHNvIHdlIG1lcmdlIGl0IGludG8gdGhlIHRyYW5zbGF0aW9uIHRvIHNpbXVsYXRlIGl0LlxuICAgIHRlbXAgPSB0YXJnZXQuZ2V0QkJveCgpO1xuICAgIHR4ID0gX3JvdW5kKHR4ICsgeFBlcmNlbnQgLyAxMDAgKiB0ZW1wLndpZHRoKTtcbiAgICB0eSA9IF9yb3VuZCh0eSArIHlQZXJjZW50IC8gMTAwICogdGVtcC5oZWlnaHQpO1xuICB9XG5cbiAgdGVtcCA9IFwibWF0cml4KFwiICsgYTExICsgXCIsXCIgKyBhMjEgKyBcIixcIiArIGExMiArIFwiLFwiICsgYTIyICsgXCIsXCIgKyB0eCArIFwiLFwiICsgdHkgKyBcIilcIjtcbiAgdGFyZ2V0LnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCB0ZW1wKTtcblxuICBpZiAoZm9yY2VDU1MpIHtcbiAgICAvL3NvbWUgYnJvd3NlcnMgcHJpb3JpdGl6ZSBDU1MgdHJhbnNmb3JtcyBvdmVyIHRoZSB0cmFuc2Zvcm0gYXR0cmlidXRlLiBXaGVuIHdlIHNlbnNlIHRoYXQgdGhlIHVzZXIgaGFzIENTUyB0cmFuc2Zvcm1zIGFwcGxpZWQsIHdlIG11c3Qgb3ZlcndyaXRlIHRoZW0gdGhpcyB3YXkgKG90aGVyd2lzZSBzb21lIGJyb3dzZXIgc2ltcGx5IHdvbid0IHJlbmRlciB0aGUgIHRyYW5zZm9ybSBhdHRyaWJ1dGUgY2hhbmdlcyEpXG4gICAgdGFyZ2V0LnN0eWxlW190cmFuc2Zvcm1Qcm9wXSA9IHRlbXA7XG4gIH1cbn0sXG4gICAgX2FkZFJvdGF0aW9uYWxQcm9wVHdlZW4gPSBmdW5jdGlvbiBfYWRkUm90YXRpb25hbFByb3BUd2VlbihwbHVnaW4sIHRhcmdldCwgcHJvcGVydHksIHN0YXJ0TnVtLCBlbmRWYWx1ZSwgcmVsYXRpdmUpIHtcbiAgdmFyIGNhcCA9IDM2MCxcbiAgICAgIGlzU3RyaW5nID0gX2lzU3RyaW5nKGVuZFZhbHVlKSxcbiAgICAgIGVuZE51bSA9IHBhcnNlRmxvYXQoZW5kVmFsdWUpICogKGlzU3RyaW5nICYmIH5lbmRWYWx1ZS5pbmRleE9mKFwicmFkXCIpID8gX1JBRDJERUcgOiAxKSxcbiAgICAgIGNoYW5nZSA9IHJlbGF0aXZlID8gZW5kTnVtICogcmVsYXRpdmUgOiBlbmROdW0gLSBzdGFydE51bSxcbiAgICAgIGZpbmFsVmFsdWUgPSBzdGFydE51bSArIGNoYW5nZSArIFwiZGVnXCIsXG4gICAgICBkaXJlY3Rpb24sXG4gICAgICBwdDtcblxuICBpZiAoaXNTdHJpbmcpIHtcbiAgICBkaXJlY3Rpb24gPSBlbmRWYWx1ZS5zcGxpdChcIl9cIilbMV07XG5cbiAgICBpZiAoZGlyZWN0aW9uID09PSBcInNob3J0XCIpIHtcbiAgICAgIGNoYW5nZSAlPSBjYXA7XG5cbiAgICAgIGlmIChjaGFuZ2UgIT09IGNoYW5nZSAlIChjYXAgLyAyKSkge1xuICAgICAgICBjaGFuZ2UgKz0gY2hhbmdlIDwgMCA/IGNhcCA6IC1jYXA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJjd1wiICYmIGNoYW5nZSA8IDApIHtcbiAgICAgIGNoYW5nZSA9IChjaGFuZ2UgKyBjYXAgKiBfYmlnTnVtKSAlIGNhcCAtIH5+KGNoYW5nZSAvIGNhcCkgKiBjYXA7XG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09IFwiY2N3XCIgJiYgY2hhbmdlID4gMCkge1xuICAgICAgY2hhbmdlID0gKGNoYW5nZSAtIGNhcCAqIF9iaWdOdW0pICUgY2FwIC0gfn4oY2hhbmdlIC8gY2FwKSAqIGNhcDtcbiAgICB9XG4gIH1cblxuICBwbHVnaW4uX3B0ID0gcHQgPSBuZXcgUHJvcFR3ZWVuKHBsdWdpbi5fcHQsIHRhcmdldCwgcHJvcGVydHksIHN0YXJ0TnVtLCBjaGFuZ2UsIF9yZW5kZXJQcm9wV2l0aEVuZCk7XG4gIHB0LmUgPSBmaW5hbFZhbHVlO1xuICBwdC51ID0gXCJkZWdcIjtcblxuICBwbHVnaW4uX3Byb3BzLnB1c2gocHJvcGVydHkpO1xuXG4gIHJldHVybiBwdDtcbn0sXG4gICAgX2FkZFJhd1RyYW5zZm9ybVBUcyA9IGZ1bmN0aW9uIF9hZGRSYXdUcmFuc2Zvcm1QVHMocGx1Z2luLCB0cmFuc2Zvcm1zLCB0YXJnZXQpIHtcbiAgLy9mb3IgaGFuZGxpbmcgY2FzZXMgd2hlcmUgc29tZW9uZSBwYXNzZXMgaW4gYSB3aG9sZSB0cmFuc2Zvcm0gc3RyaW5nLCBsaWtlIHRyYW5zZm9ybTogXCJzY2FsZSgyLCAzKSByb3RhdGUoMjBkZWcpIHRyYW5zbGF0ZVkoMzBlbSlcIlxuICB2YXIgc3R5bGUgPSBfdGVtcERpdlN0eWxlci5zdHlsZSxcbiAgICAgIHN0YXJ0Q2FjaGUgPSB0YXJnZXQuX2dzYXAsXG4gICAgICBleGNsdWRlID0gXCJwZXJzcGVjdGl2ZSxmb3JjZTNELHRyYW5zZm9ybU9yaWdpbixzdmdPcmlnaW5cIixcbiAgICAgIGVuZENhY2hlLFxuICAgICAgcCxcbiAgICAgIHN0YXJ0VmFsdWUsXG4gICAgICBlbmRWYWx1ZSxcbiAgICAgIHN0YXJ0TnVtLFxuICAgICAgZW5kTnVtLFxuICAgICAgc3RhcnRVbml0LFxuICAgICAgZW5kVW5pdDtcbiAgc3R5bGUuY3NzVGV4dCA9IGdldENvbXB1dGVkU3R5bGUodGFyZ2V0KS5jc3NUZXh0ICsgXCI7cG9zaXRpb246YWJzb2x1dGU7ZGlzcGxheTpibG9jaztcIjsgLy8lLWJhc2VkIHRyYW5zbGF0aW9ucyB3aWxsIGZhaWwgdW5sZXNzIHdlIHNldCB0aGUgd2lkdGgvaGVpZ2h0IHRvIG1hdGNoIHRoZSBvcmlnaW5hbCB0YXJnZXQgKGFuZCBwYWRkaW5nL2JvcmRlcnMgY2FuIGFmZmVjdCBpdClcblxuICBzdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSB0cmFuc2Zvcm1zO1xuXG4gIF9kb2MuYm9keS5hcHBlbmRDaGlsZChfdGVtcERpdlN0eWxlcik7XG5cbiAgZW5kQ2FjaGUgPSBfcGFyc2VUcmFuc2Zvcm0oX3RlbXBEaXZTdHlsZXIsIDEpO1xuXG4gIGZvciAocCBpbiBfdHJhbnNmb3JtUHJvcHMpIHtcbiAgICBzdGFydFZhbHVlID0gc3RhcnRDYWNoZVtwXTtcbiAgICBlbmRWYWx1ZSA9IGVuZENhY2hlW3BdO1xuXG4gICAgaWYgKHN0YXJ0VmFsdWUgIT09IGVuZFZhbHVlICYmIGV4Y2x1ZGUuaW5kZXhPZihwKSA8IDApIHtcbiAgICAgIC8vdHdlZW5pbmcgdG8gbm8gcGVyc3BlY3RpdmUgZ2l2ZXMgdmVyeSB1bmludHVpdGl2ZSByZXN1bHRzIC0ganVzdCBrZWVwIHRoZSBzYW1lIHBlcnNwZWN0aXZlIGluIHRoYXQgY2FzZS5cbiAgICAgIHN0YXJ0VW5pdCA9IGdldFVuaXQoc3RhcnRWYWx1ZSk7XG4gICAgICBlbmRVbml0ID0gZ2V0VW5pdChlbmRWYWx1ZSk7XG4gICAgICBzdGFydE51bSA9IHN0YXJ0VW5pdCAhPT0gZW5kVW5pdCA/IF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgcCwgc3RhcnRWYWx1ZSwgZW5kVW5pdCkgOiBwYXJzZUZsb2F0KHN0YXJ0VmFsdWUpO1xuICAgICAgZW5kTnVtID0gcGFyc2VGbG9hdChlbmRWYWx1ZSk7XG4gICAgICBwbHVnaW4uX3B0ID0gbmV3IFByb3BUd2VlbihwbHVnaW4uX3B0LCBzdGFydENhY2hlLCBwLCBzdGFydE51bSwgZW5kTnVtIC0gc3RhcnROdW0sIF9yZW5kZXJDU1NQcm9wKTtcbiAgICAgIHBsdWdpbi5fcHQudSA9IGVuZFVuaXQgfHwgMDtcblxuICAgICAgcGx1Z2luLl9wcm9wcy5wdXNoKHApO1xuICAgIH1cbiAgfVxuXG4gIF9kb2MuYm9keS5yZW1vdmVDaGlsZChfdGVtcERpdlN0eWxlcik7XG59OyAvLyBoYW5kbGUgc3BsaXR0aW5nIGFwYXJ0IHBhZGRpbmcsIG1hcmdpbiwgYm9yZGVyV2lkdGgsIGFuZCBib3JkZXJSYWRpdXMgaW50byB0aGVpciA0IGNvbXBvbmVudHMuIEZpcmVmb3gsIGZvciBleGFtcGxlLCB3b24ndCByZXBvcnQgYm9yZGVyUmFkaXVzIGNvcnJlY3RseSAtIGl0IHdpbGwgb25seSBkbyBib3JkZXJUb3BMZWZ0UmFkaXVzIGFuZCB0aGUgb3RoZXIgY29ybmVycy4gV2UgYWxzbyB3YW50IHRvIGhhbmRsZSBwYWRkaW5nVG9wLCBtYXJnaW5MZWZ0LCBib3JkZXJSaWdodFdpZHRoLCBldGMuXG5cblxuX2ZvckVhY2hOYW1lKFwicGFkZGluZyxtYXJnaW4sV2lkdGgsUmFkaXVzXCIsIGZ1bmN0aW9uIChuYW1lLCBpbmRleCkge1xuICB2YXIgdCA9IFwiVG9wXCIsXG4gICAgICByID0gXCJSaWdodFwiLFxuICAgICAgYiA9IFwiQm90dG9tXCIsXG4gICAgICBsID0gXCJMZWZ0XCIsXG4gICAgICBwcm9wcyA9IChpbmRleCA8IDMgPyBbdCwgciwgYiwgbF0gOiBbdCArIGwsIHQgKyByLCBiICsgciwgYiArIGxdKS5tYXAoZnVuY3Rpb24gKHNpZGUpIHtcbiAgICByZXR1cm4gaW5kZXggPCAyID8gbmFtZSArIHNpZGUgOiBcImJvcmRlclwiICsgc2lkZSArIG5hbWU7XG4gIH0pO1xuXG4gIF9zcGVjaWFsUHJvcHNbaW5kZXggPiAxID8gXCJib3JkZXJcIiArIG5hbWUgOiBuYW1lXSA9IGZ1bmN0aW9uIChwbHVnaW4sIHRhcmdldCwgcHJvcGVydHksIGVuZFZhbHVlLCB0d2Vlbikge1xuICAgIHZhciBhLCB2YXJzO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCA0KSB7XG4gICAgICAvLyBnZXR0ZXIsIHBhc3NlZCB0YXJnZXQsIHByb3BlcnR5LCBhbmQgdW5pdCAoZnJvbSBfZ2V0KCkpXG4gICAgICBhID0gcHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgIHJldHVybiBfZ2V0KHBsdWdpbiwgcHJvcCwgcHJvcGVydHkpO1xuICAgICAgfSk7XG4gICAgICB2YXJzID0gYS5qb2luKFwiIFwiKTtcbiAgICAgIHJldHVybiB2YXJzLnNwbGl0KGFbMF0pLmxlbmd0aCA9PT0gNSA/IGFbMF0gOiB2YXJzO1xuICAgIH1cblxuICAgIGEgPSAoZW5kVmFsdWUgKyBcIlwiKS5zcGxpdChcIiBcIik7XG4gICAgdmFycyA9IHt9O1xuICAgIHByb3BzLmZvckVhY2goZnVuY3Rpb24gKHByb3AsIGkpIHtcbiAgICAgIHJldHVybiB2YXJzW3Byb3BdID0gYVtpXSA9IGFbaV0gfHwgYVsoaSAtIDEpIC8gMiB8IDBdO1xuICAgIH0pO1xuICAgIHBsdWdpbi5pbml0KHRhcmdldCwgdmFycywgdHdlZW4pO1xuICB9O1xufSk7XG5cbmV4cG9ydCB2YXIgQ1NTUGx1Z2luID0ge1xuICBuYW1lOiBcImNzc1wiLFxuICByZWdpc3RlcjogX2luaXRDb3JlLFxuICB0YXJnZXRUZXN0OiBmdW5jdGlvbiB0YXJnZXRUZXN0KHRhcmdldCkge1xuICAgIHJldHVybiB0YXJnZXQuc3R5bGUgJiYgdGFyZ2V0Lm5vZGVUeXBlO1xuICB9LFxuICBpbml0OiBmdW5jdGlvbiBpbml0KHRhcmdldCwgdmFycywgdHdlZW4sIGluZGV4LCB0YXJnZXRzKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5fcHJvcHMsXG4gICAgICAgIHN0eWxlID0gdGFyZ2V0LnN0eWxlLFxuICAgICAgICBzdGFydFZhbHVlLFxuICAgICAgICBlbmRWYWx1ZSxcbiAgICAgICAgZW5kTnVtLFxuICAgICAgICBzdGFydE51bSxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgc3BlY2lhbFByb3AsXG4gICAgICAgIHAsXG4gICAgICAgIHN0YXJ0VW5pdCxcbiAgICAgICAgZW5kVW5pdCxcbiAgICAgICAgcmVsYXRpdmUsXG4gICAgICAgIGlzVHJhbnNmb3JtUmVsYXRlZCxcbiAgICAgICAgdHJhbnNmb3JtUHJvcFR3ZWVuLFxuICAgICAgICBjYWNoZSxcbiAgICAgICAgc21vb3RoLFxuICAgICAgICBoYXNQcmlvcml0eTtcblxuICAgIGlmICghX3BsdWdpbkluaXR0ZWQpIHtcbiAgICAgIF9pbml0Q29yZSgpO1xuICAgIH1cblxuICAgIGZvciAocCBpbiB2YXJzKSB7XG4gICAgICBpZiAocCA9PT0gXCJhdXRvUm91bmRcIikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgZW5kVmFsdWUgPSB2YXJzW3BdO1xuXG4gICAgICBpZiAoX3BsdWdpbnNbcF0gJiYgX2NoZWNrUGx1Z2luKHAsIHZhcnMsIHR3ZWVuLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKSkge1xuICAgICAgICAvL3BsdWdpbnNcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHR5cGUgPSB0eXBlb2YgZW5kVmFsdWU7XG4gICAgICBzcGVjaWFsUHJvcCA9IF9zcGVjaWFsUHJvcHNbcF07XG5cbiAgICAgIGlmICh0eXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgZW5kVmFsdWUgPSBlbmRWYWx1ZS5jYWxsKHR3ZWVuLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKTtcbiAgICAgICAgdHlwZSA9IHR5cGVvZiBlbmRWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgPT09IFwic3RyaW5nXCIgJiYgfmVuZFZhbHVlLmluZGV4T2YoXCJyYW5kb20oXCIpKSB7XG4gICAgICAgIGVuZFZhbHVlID0gX3JlcGxhY2VSYW5kb20oZW5kVmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3BlY2lhbFByb3ApIHtcbiAgICAgICAgaWYgKHNwZWNpYWxQcm9wKHRoaXMsIHRhcmdldCwgcCwgZW5kVmFsdWUsIHR3ZWVuKSkge1xuICAgICAgICAgIGhhc1ByaW9yaXR5ID0gMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwLnN1YnN0cigwLCAyKSA9PT0gXCItLVwiKSB7XG4gICAgICAgIC8vQ1NTIHZhcmlhYmxlXG4gICAgICAgIHRoaXMuYWRkKHN0eWxlLCBcInNldFByb3BlcnR5XCIsIGdldENvbXB1dGVkU3R5bGUodGFyZ2V0KS5nZXRQcm9wZXJ0eVZhbHVlKHApICsgXCJcIiwgZW5kVmFsdWUgKyBcIlwiLCBpbmRleCwgdGFyZ2V0cywgMCwgMCwgcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFydFZhbHVlID0gX2dldCh0YXJnZXQsIHApO1xuICAgICAgICBzdGFydE51bSA9IHBhcnNlRmxvYXQoc3RhcnRWYWx1ZSk7XG4gICAgICAgIHJlbGF0aXZlID0gdHlwZSA9PT0gXCJzdHJpbmdcIiAmJiBlbmRWYWx1ZS5jaGFyQXQoMSkgPT09IFwiPVwiID8gKyhlbmRWYWx1ZS5jaGFyQXQoMCkgKyBcIjFcIikgOiAwO1xuXG4gICAgICAgIGlmIChyZWxhdGl2ZSkge1xuICAgICAgICAgIGVuZFZhbHVlID0gZW5kVmFsdWUuc3Vic3RyKDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZW5kTnVtID0gcGFyc2VGbG9hdChlbmRWYWx1ZSk7XG5cbiAgICAgICAgaWYgKHAgaW4gX3Byb3BlcnR5QWxpYXNlcykge1xuICAgICAgICAgIGlmIChwID09PSBcImF1dG9BbHBoYVwiKSB7XG4gICAgICAgICAgICAvL3NwZWNpYWwgY2FzZSB3aGVyZSB3ZSBjb250cm9sIHRoZSB2aXNpYmlsaXR5IGFsb25nIHdpdGggb3BhY2l0eS4gV2Ugc3RpbGwgYWxsb3cgdGhlIG9wYWNpdHkgdmFsdWUgdG8gcGFzcyB0aHJvdWdoIGFuZCBnZXQgdHdlZW5lZC5cbiAgICAgICAgICAgIGlmIChzdGFydE51bSA9PT0gMSAmJiBfZ2V0KHRhcmdldCwgXCJ2aXNpYmlsaXR5XCIpID09PSBcImhpZGRlblwiICYmIGVuZE51bSkge1xuICAgICAgICAgICAgICAvL2lmIHZpc2liaWxpdHkgaXMgaW5pdGlhbGx5IHNldCB0byBcImhpZGRlblwiLCB3ZSBzaG91bGQgaW50ZXJwcmV0IHRoYXQgYXMgaW50ZW50IHRvIG1ha2Ugb3BhY2l0eSAwIChhIGNvbnZlbmllbmNlKVxuICAgICAgICAgICAgICBzdGFydE51bSA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9hZGROb25Ud2VlbmluZ1BUKHRoaXMsIHN0eWxlLCBcInZpc2liaWxpdHlcIiwgc3RhcnROdW0gPyBcImluaGVyaXRcIiA6IFwiaGlkZGVuXCIsIGVuZE51bSA/IFwiaW5oZXJpdFwiIDogXCJoaWRkZW5cIiwgIWVuZE51bSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHAgIT09IFwic2NhbGVcIiAmJiBwICE9PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgICAgICAgICBwID0gX3Byb3BlcnR5QWxpYXNlc1twXTtcblxuICAgICAgICAgICAgaWYgKH5wLmluZGV4T2YoXCIsXCIpKSB7XG4gICAgICAgICAgICAgIHAgPSBwLnNwbGl0KFwiLFwiKVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpc1RyYW5zZm9ybVJlbGF0ZWQgPSBwIGluIF90cmFuc2Zvcm1Qcm9wczsgLy8tLS0gVFJBTlNGT1JNLVJFTEFURUQgLS0tXG5cbiAgICAgICAgaWYgKGlzVHJhbnNmb3JtUmVsYXRlZCkge1xuICAgICAgICAgIGlmICghdHJhbnNmb3JtUHJvcFR3ZWVuKSB7XG4gICAgICAgICAgICBjYWNoZSA9IHRhcmdldC5fZ3NhcDtcbiAgICAgICAgICAgIGNhY2hlLnJlbmRlclRyYW5zZm9ybSB8fCBfcGFyc2VUcmFuc2Zvcm0odGFyZ2V0KTsgLy8gaWYsIGZvciBleGFtcGxlLCBnc2FwLnNldCguLi4ge3RyYW5zZm9ybTpcInRyYW5zbGF0ZVgoNTB2dylcIn0pLCB0aGUgX2dldCgpIGNhbGwgZG9lc24ndCBwYXJzZSB0aGUgdHJhbnNmb3JtLCB0aHVzIGNhY2hlLnJlbmRlclRyYW5zZm9ybSB3b24ndCBiZSBzZXQgeWV0IHNvIGZvcmNlIHRoZSBwYXJzaW5nIG9mIHRoZSB0cmFuc2Zvcm0gaGVyZS5cblxuICAgICAgICAgICAgc21vb3RoID0gdmFycy5zbW9vdGhPcmlnaW4gIT09IGZhbHNlICYmIGNhY2hlLnNtb290aDtcbiAgICAgICAgICAgIHRyYW5zZm9ybVByb3BUd2VlbiA9IHRoaXMuX3B0ID0gbmV3IFByb3BUd2Vlbih0aGlzLl9wdCwgc3R5bGUsIF90cmFuc2Zvcm1Qcm9wLCAwLCAxLCBjYWNoZS5yZW5kZXJUcmFuc2Zvcm0sIGNhY2hlLCAwLCAtMSk7IC8vdGhlIGZpcnN0IHRpbWUgdGhyb3VnaCwgY3JlYXRlIHRoZSByZW5kZXJpbmcgUHJvcFR3ZWVuIHNvIHRoYXQgaXQgcnVucyBMQVNUIChpbiB0aGUgbGlua2VkIGxpc3QsIHdlIGtlZXAgYWRkaW5nIHRvIHRoZSBiZWdpbm5pbmcpXG5cbiAgICAgICAgICAgIHRyYW5zZm9ybVByb3BUd2Vlbi5kZXAgPSAxOyAvL2ZsYWcgaXQgYXMgZGVwZW5kZW50IHNvIHRoYXQgaWYgdGhpbmdzIGdldCBraWxsZWQvb3ZlcndyaXR0ZW4gYW5kIHRoaXMgaXMgdGhlIG9ubHkgUHJvcFR3ZWVuIGxlZnQsIHdlIGNhbiBzYWZlbHkga2lsbCB0aGUgd2hvbGUgdHdlZW4uXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHAgPT09IFwic2NhbGVcIikge1xuICAgICAgICAgICAgdGhpcy5fcHQgPSBuZXcgUHJvcFR3ZWVuKHRoaXMuX3B0LCBjYWNoZSwgXCJzY2FsZVlcIiwgY2FjaGUuc2NhbGVZLCByZWxhdGl2ZSA/IHJlbGF0aXZlICogZW5kTnVtIDogZW5kTnVtIC0gY2FjaGUuc2NhbGVZKTtcbiAgICAgICAgICAgIHByb3BzLnB1c2goXCJzY2FsZVlcIiwgcCk7XG4gICAgICAgICAgICBwICs9IFwiWFwiO1xuICAgICAgICAgIH0gZWxzZSBpZiAocCA9PT0gXCJ0cmFuc2Zvcm1PcmlnaW5cIikge1xuICAgICAgICAgICAgZW5kVmFsdWUgPSBfY29udmVydEtleXdvcmRzVG9QZXJjZW50YWdlcyhlbmRWYWx1ZSk7IC8vaW4gY2FzZSBzb21ldGhpbmcgbGlrZSBcImxlZnQgdG9wXCIgb3IgXCJib3R0b20gcmlnaHRcIiBpcyBwYXNzZWQgaW4uIENvbnZlcnQgdG8gcGVyY2VudGFnZXMuXG5cbiAgICAgICAgICAgIGlmIChjYWNoZS5zdmcpIHtcbiAgICAgICAgICAgICAgX2FwcGx5U1ZHT3JpZ2luKHRhcmdldCwgZW5kVmFsdWUsIDAsIHNtb290aCwgMCwgdGhpcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbmRVbml0ID0gcGFyc2VGbG9hdChlbmRWYWx1ZS5zcGxpdChcIiBcIilbMl0pIHx8IDA7IC8vaGFuZGxlIHRoZSB6T3JpZ2luIHNlcGFyYXRlbHkhXG5cbiAgICAgICAgICAgICAgaWYgKGVuZFVuaXQgIT09IGNhY2hlLnpPcmlnaW4pIHtcbiAgICAgICAgICAgICAgICBfYWRkTm9uVHdlZW5pbmdQVCh0aGlzLCBjYWNoZSwgXCJ6T3JpZ2luXCIsIGNhY2hlLnpPcmlnaW4sIGVuZFVuaXQpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgX2FkZE5vblR3ZWVuaW5nUFQodGhpcywgc3R5bGUsIHAsIF9maXJzdFR3b09ubHkoc3RhcnRWYWx1ZSksIF9maXJzdFR3b09ubHkoZW5kVmFsdWUpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChwID09PSBcInN2Z09yaWdpblwiKSB7XG4gICAgICAgICAgICBfYXBwbHlTVkdPcmlnaW4odGFyZ2V0LCBlbmRWYWx1ZSwgMSwgc21vb3RoLCAwLCB0aGlzKTtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChwIGluIF9yb3RhdGlvbmFsUHJvcGVydGllcykge1xuICAgICAgICAgICAgX2FkZFJvdGF0aW9uYWxQcm9wVHdlZW4odGhpcywgY2FjaGUsIHAsIHN0YXJ0TnVtLCBlbmRWYWx1ZSwgcmVsYXRpdmUpO1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHAgPT09IFwic21vb3RoT3JpZ2luXCIpIHtcbiAgICAgICAgICAgIF9hZGROb25Ud2VlbmluZ1BUKHRoaXMsIGNhY2hlLCBcInNtb290aFwiLCBjYWNoZS5zbW9vdGgsIGVuZFZhbHVlKTtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChwID09PSBcImZvcmNlM0RcIikge1xuICAgICAgICAgICAgY2FjaGVbcF0gPSBlbmRWYWx1ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAocCA9PT0gXCJ0cmFuc2Zvcm1cIikge1xuICAgICAgICAgICAgX2FkZFJhd1RyYW5zZm9ybVBUcyh0aGlzLCBlbmRWYWx1ZSwgdGFyZ2V0KTtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCEocCBpbiBzdHlsZSkpIHtcbiAgICAgICAgICBwID0gX2NoZWNrUHJvcFByZWZpeChwKSB8fCBwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzVHJhbnNmb3JtUmVsYXRlZCB8fCAoZW5kTnVtIHx8IGVuZE51bSA9PT0gMCkgJiYgKHN0YXJ0TnVtIHx8IHN0YXJ0TnVtID09PSAwKSAmJiAhX2NvbXBsZXhFeHAudGVzdChlbmRWYWx1ZSkgJiYgcCBpbiBzdHlsZSkge1xuICAgICAgICAgIHN0YXJ0VW5pdCA9IChzdGFydFZhbHVlICsgXCJcIikuc3Vic3RyKChzdGFydE51bSArIFwiXCIpLmxlbmd0aCk7XG4gICAgICAgICAgZW5kTnVtIHx8IChlbmROdW0gPSAwKTsgLy8gcHJvdGVjdCBhZ2FpbnN0IE5hTlxuXG4gICAgICAgICAgZW5kVW5pdCA9IChlbmRWYWx1ZSArIFwiXCIpLnN1YnN0cigoZW5kTnVtICsgXCJcIikubGVuZ3RoKSB8fCAocCBpbiBfY29uZmlnLnVuaXRzID8gX2NvbmZpZy51bml0c1twXSA6IHN0YXJ0VW5pdCk7XG5cbiAgICAgICAgICBpZiAoc3RhcnRVbml0ICE9PSBlbmRVbml0KSB7XG4gICAgICAgICAgICBzdGFydE51bSA9IF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgcCwgc3RhcnRWYWx1ZSwgZW5kVW5pdCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fcHQgPSBuZXcgUHJvcFR3ZWVuKHRoaXMuX3B0LCBpc1RyYW5zZm9ybVJlbGF0ZWQgPyBjYWNoZSA6IHN0eWxlLCBwLCBzdGFydE51bSwgcmVsYXRpdmUgPyByZWxhdGl2ZSAqIGVuZE51bSA6IGVuZE51bSAtIHN0YXJ0TnVtLCBlbmRVbml0ID09PSBcInB4XCIgJiYgdmFycy5hdXRvUm91bmQgIT09IGZhbHNlICYmICFpc1RyYW5zZm9ybVJlbGF0ZWQgPyBfcmVuZGVyUm91bmRlZENTU1Byb3AgOiBfcmVuZGVyQ1NTUHJvcCk7XG4gICAgICAgICAgdGhpcy5fcHQudSA9IGVuZFVuaXQgfHwgMDtcblxuICAgICAgICAgIGlmIChzdGFydFVuaXQgIT09IGVuZFVuaXQpIHtcbiAgICAgICAgICAgIC8vd2hlbiB0aGUgdHdlZW4gZ29lcyBhbGwgdGhlIHdheSBiYWNrIHRvIHRoZSBiZWdpbm5pbmcsIHdlIG5lZWQgdG8gcmV2ZXJ0IGl0IHRvIHRoZSBPTEQvT1JJR0lOQUwgdmFsdWUgKHdpdGggdGhvc2UgdW5pdHMpLiBXZSByZWNvcmQgdGhhdCBhcyBhIFwiYlwiIChiZWdpbm5pbmcpIHByb3BlcnR5IGFuZCBwb2ludCB0byBhIHJlbmRlciBtZXRob2QgdGhhdCBoYW5kbGVzIHRoYXQuIChwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24pXG4gICAgICAgICAgICB0aGlzLl9wdC5iID0gc3RhcnRWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX3B0LnIgPSBfcmVuZGVyQ1NTUHJvcFdpdGhCZWdpbm5pbmc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCEocCBpbiBzdHlsZSkpIHtcbiAgICAgICAgICBpZiAocCBpbiB0YXJnZXQpIHtcbiAgICAgICAgICAgIC8vbWF5YmUgaXQncyBub3QgYSBzdHlsZSAtIGl0IGNvdWxkIGJlIGEgcHJvcGVydHkgYWRkZWQgZGlyZWN0bHkgdG8gYW4gZWxlbWVudCBpbiB3aGljaCBjYXNlIHdlJ2xsIHRyeSB0byBhbmltYXRlIHRoYXQuXG4gICAgICAgICAgICB0aGlzLmFkZCh0YXJnZXQsIHAsIHRhcmdldFtwXSwgZW5kVmFsdWUsIGluZGV4LCB0YXJnZXRzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX21pc3NpbmdQbHVnaW4ocCwgZW5kVmFsdWUpO1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3R3ZWVuQ29tcGxleENTU1N0cmluZy5jYWxsKHRoaXMsIHRhcmdldCwgcCwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvcHMucHVzaChwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGFzUHJpb3JpdHkpIHtcbiAgICAgIF9zb3J0UHJvcFR3ZWVuc0J5UHJpb3JpdHkodGhpcyk7XG4gICAgfVxuICB9LFxuICBnZXQ6IF9nZXQsXG4gIGFsaWFzZXM6IF9wcm9wZXJ0eUFsaWFzZXMsXG4gIGdldFNldHRlcjogZnVuY3Rpb24gZ2V0U2V0dGVyKHRhcmdldCwgcHJvcGVydHksIHBsdWdpbikge1xuICAgIC8vcmV0dXJucyBhIHNldHRlciBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgdGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUgYW5kIGFwcGxpZXMgaXQgYWNjb3JkaW5nbHkuIFJlbWVtYmVyLCBwcm9wZXJ0aWVzIGxpa2UgXCJ4XCIgYXJlbid0IGFzIHNpbXBsZSBhcyB0YXJnZXQuc3R5bGUucHJvcGVydHkgPSB2YWx1ZSBiZWNhdXNlIHRoZXkndmUgZ290IHRvIGJlIGFwcGxpZWQgdG8gYSBwcm94eSBvYmplY3QgYW5kIHRoZW4gbWVyZ2VkIGludG8gYSB0cmFuc2Zvcm0gc3RyaW5nIGluIGEgcmVuZGVyZXIuXG4gICAgdmFyIHAgPSBfcHJvcGVydHlBbGlhc2VzW3Byb3BlcnR5XTtcbiAgICBwICYmIHAuaW5kZXhPZihcIixcIikgPCAwICYmIChwcm9wZXJ0eSA9IHApO1xuICAgIHJldHVybiBwcm9wZXJ0eSBpbiBfdHJhbnNmb3JtUHJvcHMgJiYgcHJvcGVydHkgIT09IF90cmFuc2Zvcm1PcmlnaW5Qcm9wICYmICh0YXJnZXQuX2dzYXAueCB8fCBfZ2V0KHRhcmdldCwgXCJ4XCIpKSA/IHBsdWdpbiAmJiBfcmVjZW50U2V0dGVyUGx1Z2luID09PSBwbHVnaW4gPyBwcm9wZXJ0eSA9PT0gXCJzY2FsZVwiID8gX3NldHRlclNjYWxlIDogX3NldHRlclRyYW5zZm9ybSA6IChfcmVjZW50U2V0dGVyUGx1Z2luID0gcGx1Z2luIHx8IHt9KSAmJiAocHJvcGVydHkgPT09IFwic2NhbGVcIiA/IF9zZXR0ZXJTY2FsZVdpdGhSZW5kZXIgOiBfc2V0dGVyVHJhbnNmb3JtV2l0aFJlbmRlcikgOiB0YXJnZXQuc3R5bGUgJiYgIV9pc1VuZGVmaW5lZCh0YXJnZXQuc3R5bGVbcHJvcGVydHldKSA/IF9zZXR0ZXJDU1NTdHlsZSA6IH5wcm9wZXJ0eS5pbmRleE9mKFwiLVwiKSA/IF9zZXR0ZXJDU1NQcm9wIDogX2dldFNldHRlcih0YXJnZXQsIHByb3BlcnR5KTtcbiAgfSxcbiAgY29yZToge1xuICAgIF9yZW1vdmVQcm9wZXJ0eTogX3JlbW92ZVByb3BlcnR5LFxuICAgIF9nZXRNYXRyaXg6IF9nZXRNYXRyaXhcbiAgfVxufTtcbmdzYXAudXRpbHMuY2hlY2tQcmVmaXggPSBfY2hlY2tQcm9wUHJlZml4O1xuXG4oZnVuY3Rpb24gKHBvc2l0aW9uQW5kU2NhbGUsIHJvdGF0aW9uLCBvdGhlcnMsIGFsaWFzZXMpIHtcbiAgdmFyIGFsbCA9IF9mb3JFYWNoTmFtZShwb3NpdGlvbkFuZFNjYWxlICsgXCIsXCIgKyByb3RhdGlvbiArIFwiLFwiICsgb3RoZXJzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIF90cmFuc2Zvcm1Qcm9wc1tuYW1lXSA9IDE7XG4gIH0pO1xuXG4gIF9mb3JFYWNoTmFtZShyb3RhdGlvbiwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBfY29uZmlnLnVuaXRzW25hbWVdID0gXCJkZWdcIjtcbiAgICBfcm90YXRpb25hbFByb3BlcnRpZXNbbmFtZV0gPSAxO1xuICB9KTtcblxuICBfcHJvcGVydHlBbGlhc2VzW2FsbFsxM11dID0gcG9zaXRpb25BbmRTY2FsZSArIFwiLFwiICsgcm90YXRpb247XG5cbiAgX2ZvckVhY2hOYW1lKGFsaWFzZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIHNwbGl0ID0gbmFtZS5zcGxpdChcIjpcIik7XG4gICAgX3Byb3BlcnR5QWxpYXNlc1tzcGxpdFsxXV0gPSBhbGxbc3BsaXRbMF1dO1xuICB9KTtcbn0pKFwieCx5LHosc2NhbGUsc2NhbGVYLHNjYWxlWSx4UGVyY2VudCx5UGVyY2VudFwiLCBcInJvdGF0aW9uLHJvdGF0aW9uWCxyb3RhdGlvblksc2tld1gsc2tld1lcIiwgXCJ0cmFuc2Zvcm0sdHJhbnNmb3JtT3JpZ2luLHN2Z09yaWdpbixmb3JjZTNELHNtb290aE9yaWdpbix0cmFuc2Zvcm1QZXJzcGVjdGl2ZVwiLCBcIjA6dHJhbnNsYXRlWCwxOnRyYW5zbGF0ZVksMjp0cmFuc2xhdGVaLDg6cm90YXRlLDg6cm90YXRpb25aLDg6cm90YXRlWiw5OnJvdGF0ZVgsMTA6cm90YXRlWVwiKTtcblxuX2ZvckVhY2hOYW1lKFwieCx5LHosdG9wLHJpZ2h0LGJvdHRvbSxsZWZ0LHdpZHRoLGhlaWdodCxmb250U2l6ZSxwYWRkaW5nLG1hcmdpbixwZXJzcGVjdGl2ZVwiLCBmdW5jdGlvbiAobmFtZSkge1xuICBfY29uZmlnLnVuaXRzW25hbWVdID0gXCJweFwiO1xufSk7XG5cbmdzYXAucmVnaXN0ZXJQbHVnaW4oQ1NTUGx1Z2luKTtcbmV4cG9ydCB7IENTU1BsdWdpbiBhcyBkZWZhdWx0LCBfZ2V0QkJveCwgX2NyZWF0ZUVsZW1lbnQsIF9jaGVja1Byb3BQcmVmaXggYXMgY2hlY2tQcmVmaXggfTsiLCJpbXBvcnQgeyBnc2FwLCBQb3dlcjAsIFBvd2VyMSwgUG93ZXIyLCBQb3dlcjMsIFBvd2VyNCwgTGluZWFyLCBRdWFkLCBDdWJpYywgUXVhcnQsIFF1aW50LCBTdHJvbmcsIEVsYXN0aWMsIEJhY2ssIFN0ZXBwZWRFYXNlLCBCb3VuY2UsIFNpbmUsIEV4cG8sIENpcmMsIFR3ZWVuTGl0ZSwgVGltZWxpbmVMaXRlLCBUaW1lbGluZU1heCB9IGZyb20gXCIuL2dzYXAtY29yZS5qc1wiO1xuaW1wb3J0IHsgQ1NTUGx1Z2luIH0gZnJvbSBcIi4vQ1NTUGx1Z2luLmpzXCI7XG52YXIgZ3NhcFdpdGhDU1MgPSBnc2FwLnJlZ2lzdGVyUGx1Z2luKENTU1BsdWdpbikgfHwgZ3NhcCxcbiAgICAvLyB0byBwcm90ZWN0IGZyb20gdHJlZSBzaGFraW5nXG5Ud2Vlbk1heFdpdGhDU1MgPSBnc2FwV2l0aENTUy5jb3JlLlR3ZWVuO1xuZXhwb3J0IHsgZ3NhcFdpdGhDU1MgYXMgZ3NhcCwgZ3NhcFdpdGhDU1MgYXMgZGVmYXVsdCwgQ1NTUGx1Z2luLCBUd2Vlbk1heFdpdGhDU1MgYXMgVHdlZW5NYXgsIFR3ZWVuTGl0ZSwgVGltZWxpbmVNYXgsIFRpbWVsaW5lTGl0ZSwgUG93ZXIwLCBQb3dlcjEsIFBvd2VyMiwgUG93ZXIzLCBQb3dlcjQsIExpbmVhciwgUXVhZCwgQ3ViaWMsIFF1YXJ0LCBRdWludCwgU3Ryb25nLCBFbGFzdGljLCBCYWNrLCBTdGVwcGVkRWFzZSwgQm91bmNlLCBTaW5lLCBFeHBvLCBDaXJjIH07IiwiLypcclxuRnVuY3Rpb24gdGhhdCBcInN0YXJ0XCIgYSB0aW1lbGluZSBvYmplY3QgYW5kIFwicmV2ZXJzZVwiIGl0XHJcbndoZW4gaXQgYW4gZXZlbnQgaW4gYSBzcGVjaWZpZWQgZWxlbWVudCBpcyB0cmlnZ2VyZWQuXHJcbiovXHJcbmV4cG9ydCBjb25zdCBzdGFydEFuZFJldmVyc2UgPSAoZWxlbSwgZXZlbnQsIHRsKSA9PiBlbGVtXHJcbiAgICAuYWRkRXZlbnRMaXN0ZW5lcihcclxuICAgICAgICBldmVudCxcclxuICAgICAgICAoKSA9PiB0bC5yZXZlcnNlZCgpID8gdGwucGxheSgpIDogdGwucmV2ZXJzZSgpXHJcbiAgICApO1xyXG4iLCJpbXBvcnQge2dzYXB9IGZyb20gJ2dzYXAnO1xyXG5pbXBvcnQge3N0YXJ0QW5kUmV2ZXJzZX0gZnJvbSAnLi9nc2FwLWhlbHBlcnMnO1xyXG5cclxuY29uc3QgbGluZTEgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjbGluZS0xJyksXHJcbiAgICBsaW5lMiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNsaW5lLTInKSxcclxuICAgIGxpbmUzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2xpbmUtMycpLFxyXG4gICAgaGFtYnVyZ3Vlck1lbnUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjbmF2X19oYW1idXJndWVyLW1lbnUnKSxcclxuICAgIG1lbnUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjbmF2X19tZW51Jyk7XHJcblxyXG5jb25zdCBvblJldmVyc2VDb21wbGV0ZSA9ICgpID0+IHt9XHJcbmNvbnN0IG9uQ29tcGxldGUgPSAoKSA9PiB7fVxyXG5cclxuY29uc3QgdGwgPSBnc2FwLnRpbWVsaW5lKHtwYXVzZWQ6IHRydWUsIHJldmVyc2VkOiB0cnVlfSlcclxuICAgIC5hZGRMYWJlbCgnaW5pdCcpXHJcbiAgICAudG8obGluZTEsIC41LCB7YXR0cjp7eTI6Mjh9fSlcclxuICAgIC50byhsaW5lMiwgLjUsIHtvcGFjaXR5OiAwfSwgJ2luaXQnKVxyXG4gICAgLnRvKGxpbmUzLCAuNSwge2F0dHI6e3kyOjJ9fSwgJ2luaXQnKVxyXG4gICAgLnRvKG1lbnUsIDAuNiwge2F1dG9BbHBoYToxfSwgJ2luaXQnKVxyXG4gICAgLnNldChtZW51LCB7ekluZGV4OiAxMH0pO1xyXG5cclxuc3RhcnRBbmRSZXZlcnNlKGhhbWJ1cmd1ZXJNZW51LCAnY2xpY2snLCB0bCk7XHJcbiIsIi8vIGltcG9ydCB7Z3NhcH0gZnJvbSAnZ3NhcCc7XHJcbi8vIGltcG9ydCB7U2Nyb2xsVHJpZ2dlcn0gZnJvbSBcImdzYXAvU2Nyb2xsVHJpZ2dlclwiO1xyXG5cclxuLy8gZ3NhcC5yZWdpc3RlclBsdWdpbihTY3JvbGxUcmlnZ2VyKTtcclxuXHJcbmltcG9ydCB7Z3NhcH0gZnJvbSAnZ3NhcCc7XHJcbmltcG9ydCB7c3RhcnRBbmRSZXZlcnNlfSBmcm9tICcuL2dzYXAtaGVscGVycyc7XHJcblxyXG5jb25zdCBvblJldmVyc2VDb21wbGV0ZSA9ICgpID0+IHt9XHJcbmNvbnN0IG9uQ29tcGxldGUgPSAoKSA9PiB7fVxyXG5cclxuY29uc3QgaW5mb0xpbmtPbkNsaWNrID0gZSA9PiB7XHJcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICBjb25zdCB7Y3VycmVudFRhcmdldH0gPSBlO1xyXG4gICAgY29uc3QgbGluZXMgPSBjdXJyZW50VGFyZ2V0LnF1ZXJ5U2VsZWN0b3JBbGwoJ2xpbmUnKTtcclxuICAgIGNvbnN0IHRsID0gZ3NhcC50aW1lbGluZSh7cGF1c2VkOiB0cnVlLCByZXZlcnNlZDogdHJ1ZX0pXHJcbiAgICAgICAgLmFkZExhYmVsKCdpbml0JylcclxuICAgICAgICAudG8obGluZXNbMF0sIC41LCB7YXR0cjoge3gyOiAwLCB5MjoyMH19LCAnaW5pdCcpXHJcbiAgICAgICAgLnRvKGxpbmVzWzFdLCAuNSwge2F0dHI6IHt4MToyMH19LCAnaW5pdCcpICAgICAgIFxyXG4gICAgc3RhcnRBbmRSZXZlcnNlKGN1cnJlbnRUYXJnZXQsICdjbGljaycsIHRsKTtcclxuICAgIC8vIGluZm8tbGlua19fbGluZS0xXHJcbn07XHJcblxyXG5kb2N1bWVudFxyXG4gICAgLnF1ZXJ5U2VsZWN0b3JBbGwoJy5hcnRpc3Qtc2VjdGlvbl9faW5mby1saW5rJylcclxuICAgIC5mb3JFYWNoKGVsZW0gPT4gZWxlbS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGluZm9MaW5rT25DbGljaykpO1xyXG5cclxuLypcclxuY29uc3QgYnVpbGRBcnRpc3RUaW1lbGluZSA9IGFydGlzdCA9PiB7XHJcbiAgICBjb25zdCBzZWN0aW9uID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgIyR7YXJ0aXN0fS5hcnRpc3Qtc2VjdGlvbmApLFxyXG4gICAgICAgIHdlbGNvbWVTZWN0aW9uID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgIyR7YXJ0aXN0fSAuYXJ0aXN0LXNlY3Rpb25fX3dlbGNvbWVgKSxcclxuICAgICAgICBzZWN0aW9uV3JhcHBlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYCMke2FydGlzdH0gLmFydGlzdC1zZWN0aW9uX193cmFwcGVyYCksXHJcbiAgICAgICAgc2VjdGlvbkluZm8gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGAjJHthcnRpc3R9IC5hcnRpc3Qtc2VjdGlvbl9faW5mb2ApLFxyXG4gICAgICAgIGluZm9BcnIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGAjJHthcnRpc3R9IC5hcnRpc3Qtc2VjdGlvbl9faW5mbyBwYCksXHJcbiAgICAgICAgcGVyc3BlY3RpdmUgPSAxMDAwOyAgICBcclxuICAgIFxyXG4gICAgY29uc3QgYVRsID0gZ3NhcC50aW1lbGluZSh7XHJcbiAgICAgICAgc2Nyb2xsVHJpZ2dlcjoge1xyXG4gICAgICAgICAgICB0cmlnZ2VyOiBzZWN0aW9uLFxyXG4gICAgICAgICAgICBzdGFydDogJ3RvcCB0b3AnLFxyXG4gICAgICAgICAgICBlbmQ6ICcrPTE1MDAwJyxcclxuICAgICAgICAgICAgcGluOiB0cnVlLFxyXG4gICAgICAgICAgICAvLyBhbnRpY2lwYXRlUGluOiAxLFxyXG4gICAgICAgICAgICAvLyBtYXJrZXJzOiB0cnVlLFxyXG4gICAgICAgICAgICBzY3J1YjogMSAgICAgICAgICAgIFxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICAvKlxyXG4gICAgY29uc3QgYnVpbGRJbmZvVGwgPSBzX3AgPT4ge1xyXG4gICAgICAgIHJldHVybiBnc2FwLnRpbWVsaW5lKClcclxuICAgICAgICAudG8oaW5mb0FycltzX3BdLCAxLCB7b3BhY2l0eTogMSwgZGlzcGxheTogJ2Jsb2NrJ30pXHJcbiAgICAgICAgLmFkZFBhdXNlKDIpXHJcbiAgICAgICAgLnRvKGluZm9BcnJbc19wXSwgMSwge29wYWNpdHk6IDAsIGRpc3BsYXk6ICdub25lJ30pXHJcbiAgICB9O1xyXG4gICAgKi9cclxuXHJcbiAgICAvL1RPRE86IEltcHJvdmUgdGhpcyBjb2RlXHJcbiAgICAvLyBFbCB2YWxvciBhcGFyZWNlIGJydXNjYW1lbnRlXHJcbiAgICAvKnJldHVybiBhVGxcclxuICAgICAgICAuc2V0KHNlY3Rpb25XcmFwcGVyLCB7Y3NzOnt0cmFuc2Zvcm1QZXJzcGVjdGl2ZTogcGVyc3BlY3RpdmUsIHRyYW5zZm9ybVN0eWxlOiAncHJlc2VydmUtM2QnfX0pXHJcbiAgICAgICAgLy8gSW1wcm92ZSBRdWFsaXR5XHJcbiAgICAgICAgLnRvKHdlbGNvbWVTZWN0aW9uLCAxLCB7Y3NzOiB7ejogcGVyc3BlY3RpdmV9fSlcclxuICAgICAgICAuZnJvbVRvKHNlY3Rpb25JbmZvLCAxLCB7b3BhY2l0eTogMH0sIHtvcGFjaXR5OiAxfSlcclxuICAgICAgICAuYWRkUGF1c2UoMylcclxuICAgICAgICAudG8oaW5mb0FyclswXSwgMSwge29wYWNpdHk6IDAsIGRpc3BsYXk6ICdub25lJ30pXHJcbiAgICAgICAgLmZyb21UbyhpbmZvQXJyWzFdLCAxLCB7b3BhY2l0eTogMH0sIHtvcGFjaXR5OiAxLCBkaXNwbGF5OiAnYmxvY2snfSlcclxuICAgICAgICAuYWRkUGF1c2UoMylcclxuICAgICAgICAudG8oaW5mb0FyclsxXSwgMSwge29wYWNpdHk6IDAsIGRpc3BsYXk6ICdub25lJ30pXHJcbiAgICAgICAgLmZyb21UbyhpbmZvQXJyWzJdLCAxLCB7b3BhY2l0eTogMH0sIHtvcGFjaXR5OiAxLCBkaXNwbGF5OiAnYmxvY2snfSlcclxuICAgICAgICAuYWRkUGF1c2UoMylcclxuICAgICAgICAudG8oaW5mb0FyclsyXSwgMSwge29wYWNpdHk6IDAsIGRpc3BsYXk6ICdub25lJ30pXHJcbiAgICAgICAgLmZyb21UbyhpbmZvQXJyWzNdLCAxLCB7b3BhY2l0eTogMH0sIHtvcGFjaXR5OiAxLCBkaXNwbGF5OiAnYmxvY2snfSlcclxuICAgICAgICAuYWRkUGF1c2UoMylcclxuICAgICAgICAudG8oaW5mb0FyclszXSwgMSwge29wYWNpdHk6IDAsIGRpc3BsYXk6ICdub25lJ30pXHJcbiAgICAgICAgLmZyb21UbyhpbmZvQXJyWzRdLCAxLCB7b3BhY2l0eTogMH0sIHtvcGFjaXR5OiAxLCBkaXNwbGF5OiAnYmxvY2snfSlcclxuICAgICAgICAuYWRkUGF1c2UoMylcclxuICAgICAgICAudG8oaW5mb0Fycls0XSwgMSwge29wYWNpdHk6IDAsIGRpc3BsYXk6ICdub25lJ30pXHJcbiAgICAgICAgLmZyb21UbyhpbmZvQXJyWzVdLCAxLCB7b3BhY2l0eTogMH0sIHtvcGFjaXR5OiAxLCBkaXNwbGF5OiAnYmxvY2snfSlcclxuICAgICAgICAuYWRkUGF1c2UoMylcclxuICAgICAgICAudG8oaW5mb0Fycls1XSwgMSwge29wYWNpdHk6IDAsIGRpc3BsYXk6ICdub25lJ30pXHJcbiAgICAgICAgLmZyb21UbyhpbmZvQXJyWzZdLCAxLCB7b3BhY2l0eTogMH0sIHtvcGFjaXR5OiAxLCBkaXNwbGF5OiAnYmxvY2snfSlcclxuICAgICAgICAuYWRkUGF1c2UoMyk7ICAgICAgICBcclxufTtcclxuXHJcbmdzYXAudGltZWxpbmUoKVxyXG4gICAgLmFkZChidWlsZEFydGlzdFRpbWVsaW5lKCd2ZWxhenF1ZXonKSlcclxuICAgIC5hZGQoYnVpbGRBcnRpc3RUaW1lbGluZSgnZ295YScpKVxyXG4gICAgLmFkZChidWlsZEFydGlzdFRpbWVsaW5lKCdwaWNhc3NvJykpXHJcbiAgICAuYWRkKGJ1aWxkQXJ0aXN0VGltZWxpbmUoJ2RhbGknKSk7XHJcbiovIiwiLyohXG4gKiBTY3JvbGxUcmlnZ2VyIDMuNC4yXG4gKiBodHRwczovL2dyZWVuc29jay5jb21cbiAqXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgMjAwOC0yMDIwLCBHcmVlblNvY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBTdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwczovL2dyZWVuc29jay5jb20vc3RhbmRhcmQtbGljZW5zZSBvciBmb3JcbiAqIENsdWIgR3JlZW5Tb2NrIG1lbWJlcnMsIHRoZSBhZ3JlZW1lbnQgaXNzdWVkIHdpdGggdGhhdCBtZW1iZXJzaGlwLlxuICogQGF1dGhvcjogSmFjayBEb3lsZSwgamFja0BncmVlbnNvY2suY29tXG4qL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xudmFyIGdzYXAsXG4gICAgX2NvcmVJbml0dGVkLFxuICAgIF93aW4sXG4gICAgX2RvYyxcbiAgICBfZG9jRWwsXG4gICAgX2JvZHksXG4gICAgX3Jvb3QsXG4gICAgX3Jlc2l6ZURlbGF5LFxuICAgIF9yYWYsXG4gICAgX3JlcXVlc3QsXG4gICAgX3RvQXJyYXksXG4gICAgX2NsYW1wLFxuICAgIF90aW1lMixcbiAgICBfc3luY0ludGVydmFsLFxuICAgIF9yZWZyZXNoaW5nLFxuICAgIF9wb2ludGVySXNEb3duLFxuICAgIF90cmFuc2Zvcm1Qcm9wLFxuICAgIF9pLFxuICAgIF9wcmV2V2lkdGgsXG4gICAgX3ByZXZIZWlnaHQsXG4gICAgX2F1dG9SZWZyZXNoLFxuICAgIF9zb3J0LFxuICAgIF9saW1pdENhbGxiYWNrcyxcbiAgICAvLyBpZiB0cnVlLCB3ZSdsbCBvbmx5IHRyaWdnZXIgY2FsbGJhY2tzIGlmIHRoZSBhY3RpdmUgc3RhdGUgdG9nZ2xlcywgc28gaWYgeW91IHNjcm9sbCBpbW1lZGlhdGVseSBwYXN0IGJvdGggdGhlIHN0YXJ0IGFuZCBlbmQgcG9zaXRpb25zIG9mIGEgU2Nyb2xsVHJpZ2dlciAodGh1cyBpbmFjdGl2ZSB0byBpbmFjdGl2ZSksIG5laXRoZXIgaXRzIG9uRW50ZXIgbm9yIG9uTGVhdmUgd2lsbCBiZSBjYWxsZWQuIFRoaXMgaXMgdXNlZnVsIGR1cmluZyBzdGFydHVwLlxuX3N0YXJ0dXAgPSAxLFxuICAgIF9wcm94aWVzID0gW10sXG4gICAgX3Njcm9sbGVycyA9IFtdLFxuICAgIF9nZXRUaW1lID0gRGF0ZS5ub3csXG4gICAgX3RpbWUxID0gX2dldFRpbWUoKSxcbiAgICBfbGFzdFNjcm9sbFRpbWUgPSAwLFxuICAgIF9lbmFibGVkID0gMSxcbiAgICBfcGFzc1Rocm91Z2ggPSBmdW5jdGlvbiBfcGFzc1Rocm91Z2godikge1xuICByZXR1cm4gdjtcbn0sXG4gICAgX3dpbmRvd0V4aXN0cyA9IGZ1bmN0aW9uIF93aW5kb3dFeGlzdHMoKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiO1xufSxcbiAgICBfZ2V0R1NBUCA9IGZ1bmN0aW9uIF9nZXRHU0FQKCkge1xuICByZXR1cm4gZ3NhcCB8fCBfd2luZG93RXhpc3RzKCkgJiYgKGdzYXAgPSB3aW5kb3cuZ3NhcCkgJiYgZ3NhcC5yZWdpc3RlclBsdWdpbiAmJiBnc2FwO1xufSxcbiAgICBfaXNWaWV3cG9ydCA9IGZ1bmN0aW9uIF9pc1ZpZXdwb3J0KGUpIHtcbiAgcmV0dXJuICEhfl9yb290LmluZGV4T2YoZSk7XG59LFxuICAgIF9nZXRQcm94eVByb3AgPSBmdW5jdGlvbiBfZ2V0UHJveHlQcm9wKGVsZW1lbnQsIHByb3BlcnR5KSB7XG4gIHJldHVybiB+X3Byb3hpZXMuaW5kZXhPZihlbGVtZW50KSAmJiBfcHJveGllc1tfcHJveGllcy5pbmRleE9mKGVsZW1lbnQpICsgMV1bcHJvcGVydHldO1xufSxcbiAgICBfZ2V0U2Nyb2xsRnVuYyA9IGZ1bmN0aW9uIF9nZXRTY3JvbGxGdW5jKGVsZW1lbnQsIF9yZWYpIHtcbiAgdmFyIHMgPSBfcmVmLnMsXG4gICAgICBzYyA9IF9yZWYuc2M7XG5cbiAgdmFyIGkgPSBfc2Nyb2xsZXJzLmluZGV4T2YoZWxlbWVudCksXG4gICAgICBmdW5jID0gfmkgPyBfc2Nyb2xsZXJzW2kgKyAxXSA6IF9nZXRQcm94eVByb3AoZWxlbWVudCwgcykgfHwgKF9pc1ZpZXdwb3J0KGVsZW1lbnQpID8gc2MgOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IGVsZW1lbnRbc10gPSB2YWx1ZSA6IGVsZW1lbnRbc107XG4gIH0pO1xuXG4gICF+aSAmJiBfc2Nyb2xsZXJzLnB1c2goZWxlbWVudCwgZnVuYyk7XG4gIHJldHVybiBmdW5jO1xufSxcbiAgICBfZ2V0Qm91bmRzRnVuYyA9IGZ1bmN0aW9uIF9nZXRCb3VuZHNGdW5jKGVsZW1lbnQpIHtcbiAgcmV0dXJuIF9nZXRQcm94eVByb3AoZWxlbWVudCwgXCJnZXRCb3VuZGluZ0NsaWVudFJlY3RcIikgfHwgKF9pc1ZpZXdwb3J0KGVsZW1lbnQpID8gZnVuY3Rpb24gKCkge1xuICAgIF93aW5PZmZzZXRzLndpZHRoID0gX3dpbi5pbm5lcldpZHRoO1xuICAgIF93aW5PZmZzZXRzLmhlaWdodCA9IF93aW4uaW5uZXJIZWlnaHQ7XG4gICAgcmV0dXJuIF93aW5PZmZzZXRzO1xuICB9IDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfZ2V0Qm91bmRzKGVsZW1lbnQpO1xuICB9KTtcbn0sXG4gICAgX2dldFNpemVGdW5jID0gZnVuY3Rpb24gX2dldFNpemVGdW5jKHNjcm9sbGVyLCBpc1ZpZXdwb3J0LCBfcmVmMikge1xuICB2YXIgZCA9IF9yZWYyLmQsXG4gICAgICBkMiA9IF9yZWYyLmQyLFxuICAgICAgYSA9IF9yZWYyLmE7XG4gIHJldHVybiAoYSA9IF9nZXRQcm94eVByb3Aoc2Nyb2xsZXIsIFwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0XCIpKSA/IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYSgpW2RdO1xuICB9IDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoaXNWaWV3cG9ydCA/IF93aW5bXCJpbm5lclwiICsgZDJdIDogc2Nyb2xsZXJbXCJjbGllbnRcIiArIGQyXSkgfHwgMDtcbiAgfTtcbn0sXG4gICAgX2dldE9mZnNldHNGdW5jID0gZnVuY3Rpb24gX2dldE9mZnNldHNGdW5jKGVsZW1lbnQsIGlzVmlld3BvcnQpIHtcbiAgcmV0dXJuICFpc1ZpZXdwb3J0IHx8IH5fcHJveGllcy5pbmRleE9mKGVsZW1lbnQpID8gX2dldEJvdW5kc0Z1bmMoZWxlbWVudCkgOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF93aW5PZmZzZXRzO1xuICB9O1xufSxcbiAgICBfbWF4U2Nyb2xsID0gZnVuY3Rpb24gX21heFNjcm9sbChlbGVtZW50LCBfcmVmMykge1xuICB2YXIgcyA9IF9yZWYzLnMsXG4gICAgICBkMiA9IF9yZWYzLmQyLFxuICAgICAgZCA9IF9yZWYzLmQsXG4gICAgICBhID0gX3JlZjMuYTtcbiAgcmV0dXJuIChzID0gXCJzY3JvbGxcIiArIGQyKSAmJiAoYSA9IF9nZXRQcm94eVByb3AoZWxlbWVudCwgcykpID8gYSgpIC0gX2dldEJvdW5kc0Z1bmMoZWxlbWVudCkoKVtkXSA6IF9pc1ZpZXdwb3J0KGVsZW1lbnQpID8gTWF0aC5tYXgoX2RvY0VsW3NdLCBfYm9keVtzXSkgLSAoX3dpbltcImlubmVyXCIgKyBkMl0gfHwgX2RvY0VsW1wiY2xpZW50XCIgKyBkMl0gfHwgX2JvZHlbXCJjbGllbnRcIiArIGQyXSkgOiBlbGVtZW50W3NdIC0gZWxlbWVudFtcIm9mZnNldFwiICsgZDJdO1xufSxcbiAgICBfaXRlcmF0ZUF1dG9SZWZyZXNoID0gZnVuY3Rpb24gX2l0ZXJhdGVBdXRvUmVmcmVzaChmdW5jLCBldmVudHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBfYXV0b1JlZnJlc2gubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAoIWV2ZW50cyB8fCB+ZXZlbnRzLmluZGV4T2YoX2F1dG9SZWZyZXNoW2kgKyAxXSkpICYmIGZ1bmMoX2F1dG9SZWZyZXNoW2ldLCBfYXV0b1JlZnJlc2hbaSArIDFdLCBfYXV0b1JlZnJlc2hbaSArIDJdKTtcbiAgfVxufSxcbiAgICBfaXNTdHJpbmcgPSBmdW5jdGlvbiBfaXNTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIjtcbn0sXG4gICAgX2lzRnVuY3Rpb24gPSBmdW5jdGlvbiBfaXNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCI7XG59LFxuICAgIF9pc051bWJlciA9IGZ1bmN0aW9uIF9pc051bWJlcih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiO1xufSxcbiAgICBfaXNPYmplY3QgPSBmdW5jdGlvbiBfaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIjtcbn0sXG4gICAgX2NhbGxJZkZ1bmMgPSBmdW5jdGlvbiBfY2FsbElmRnVuYyh2YWx1ZSkge1xuICByZXR1cm4gX2lzRnVuY3Rpb24odmFsdWUpICYmIHZhbHVlKCk7XG59LFxuICAgIF9jb21iaW5lRnVuYyA9IGZ1bmN0aW9uIF9jb21iaW5lRnVuYyhmMSwgZjIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzdWx0MSA9IF9jYWxsSWZGdW5jKGYxKSxcbiAgICAgICAgcmVzdWx0MiA9IF9jYWxsSWZGdW5jKGYyKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBfY2FsbElmRnVuYyhyZXN1bHQxKTtcblxuICAgICAgX2NhbGxJZkZ1bmMocmVzdWx0Mik7XG4gICAgfTtcbiAgfTtcbn0sXG4gICAgX2FicyA9IE1hdGguYWJzLFxuICAgIF9zY3JvbGxMZWZ0ID0gXCJzY3JvbGxMZWZ0XCIsXG4gICAgX3Njcm9sbFRvcCA9IFwic2Nyb2xsVG9wXCIsXG4gICAgX2xlZnQgPSBcImxlZnRcIixcbiAgICBfdG9wID0gXCJ0b3BcIixcbiAgICBfcmlnaHQgPSBcInJpZ2h0XCIsXG4gICAgX2JvdHRvbSA9IFwiYm90dG9tXCIsXG4gICAgX3dpZHRoID0gXCJ3aWR0aFwiLFxuICAgIF9oZWlnaHQgPSBcImhlaWdodFwiLFxuICAgIF9SaWdodCA9IFwiUmlnaHRcIixcbiAgICBfTGVmdCA9IFwiTGVmdFwiLFxuICAgIF9Ub3AgPSBcIlRvcFwiLFxuICAgIF9Cb3R0b20gPSBcIkJvdHRvbVwiLFxuICAgIF9wYWRkaW5nID0gXCJwYWRkaW5nXCIsXG4gICAgX21hcmdpbiA9IFwibWFyZ2luXCIsXG4gICAgX1dpZHRoID0gXCJXaWR0aFwiLFxuICAgIF9IZWlnaHQgPSBcIkhlaWdodFwiLFxuICAgIF9weCA9IFwicHhcIixcbiAgICBfaG9yaXpvbnRhbCA9IHtcbiAgczogX3Njcm9sbExlZnQsXG4gIHA6IF9sZWZ0LFxuICBwMjogX0xlZnQsXG4gIG9zOiBfcmlnaHQsXG4gIG9zMjogX1JpZ2h0LFxuICBkOiBfd2lkdGgsXG4gIGQyOiBfV2lkdGgsXG4gIGE6IFwieFwiLFxuICBzYzogZnVuY3Rpb24gc2ModmFsdWUpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IF93aW4uc2Nyb2xsVG8odmFsdWUsIF92ZXJ0aWNhbC5zYygpKSA6IF93aW4ucGFnZVhPZmZzZXQgfHwgX2RvY1tfc2Nyb2xsTGVmdF0gfHwgX2RvY0VsW19zY3JvbGxMZWZ0XSB8fCBfYm9keVtfc2Nyb2xsTGVmdF0gfHwgMDtcbiAgfVxufSxcbiAgICBfdmVydGljYWwgPSB7XG4gIHM6IF9zY3JvbGxUb3AsXG4gIHA6IF90b3AsXG4gIHAyOiBfVG9wLFxuICBvczogX2JvdHRvbSxcbiAgb3MyOiBfQm90dG9tLFxuICBkOiBfaGVpZ2h0LFxuICBkMjogX0hlaWdodCxcbiAgYTogXCJ5XCIsXG4gIG9wOiBfaG9yaXpvbnRhbCxcbiAgc2M6IGZ1bmN0aW9uIHNjKHZhbHVlKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBfd2luLnNjcm9sbFRvKF9ob3Jpem9udGFsLnNjKCksIHZhbHVlKSA6IF93aW4ucGFnZVlPZmZzZXQgfHwgX2RvY1tfc2Nyb2xsVG9wXSB8fCBfZG9jRWxbX3Njcm9sbFRvcF0gfHwgX2JvZHlbX3Njcm9sbFRvcF0gfHwgMDtcbiAgfVxufSxcbiAgICBfZ2V0Q29tcHV0ZWRTdHlsZSA9IGZ1bmN0aW9uIF9nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpIHtcbiAgcmV0dXJuIF93aW4uZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbn0sXG4gICAgX21ha2VQb3NpdGlvbmFibGUgPSBmdW5jdGlvbiBfbWFrZVBvc2l0aW9uYWJsZShlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gX2dldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiA/IFwiYWJzb2x1dGVcIiA6IFwicmVsYXRpdmVcIjtcbn0sXG4gICAgLy8gaWYgdGhlIGVsZW1lbnQgYWxyZWFkeSBoYXMgcG9zaXRpb246IGFic29sdXRlLCBsZWF2ZSB0aGF0LCBvdGhlcndpc2UgbWFrZSBpdCBwb3NpdGlvbjogcmVsYXRpdmVcbl9zZXREZWZhdWx0cyA9IGZ1bmN0aW9uIF9zZXREZWZhdWx0cyhvYmosIGRlZmF1bHRzKSB7XG4gIGZvciAodmFyIHAgaW4gZGVmYXVsdHMpIHtcbiAgICBwIGluIG9iaiB8fCAob2JqW3BdID0gZGVmYXVsdHNbcF0pO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn0sXG4gICAgLy9faXNJblZpZXdwb3J0ID0gZWxlbWVudCA9PiAoZWxlbWVudCA9IF9nZXRCb3VuZHMoZWxlbWVudCkpICYmICEoZWxlbWVudC50b3AgPiAoX3dpbi5pbm5lckhlaWdodCB8fCBfZG9jRWwuY2xpZW50SGVpZ2h0KSB8fCBlbGVtZW50LmJvdHRvbSA8IDAgfHwgZWxlbWVudC5sZWZ0ID4gKF93aW4uaW5uZXJXaWR0aCB8fCBfZG9jRWwuY2xpZW50V2lkdGgpIHx8IGVsZW1lbnQucmlnaHQgPCAwKSAmJiBlbGVtZW50LFxuX2dldEJvdW5kcyA9IGZ1bmN0aW9uIF9nZXRCb3VuZHMoZWxlbWVudCwgd2l0aG91dFRyYW5zZm9ybXMpIHtcbiAgdmFyIHR3ZWVuID0gd2l0aG91dFRyYW5zZm9ybXMgJiYgX2dldENvbXB1dGVkU3R5bGUoZWxlbWVudClbX3RyYW5zZm9ybVByb3BdICE9PSBcIm1hdHJpeCgxLCAwLCAwLCAxLCAwLCAwKVwiICYmIGdzYXAudG8oZWxlbWVudCwge1xuICAgIHg6IDAsXG4gICAgeTogMCxcbiAgICB4UGVyY2VudDogMCxcbiAgICB5UGVyY2VudDogMCxcbiAgICByb3RhdGlvbjogMCxcbiAgICByb3RhdGlvblg6IDAsXG4gICAgcm90YXRpb25ZOiAwLFxuICAgIHNjYWxlOiAxLFxuICAgIHNrZXdYOiAwLFxuICAgIHNrZXdZOiAwXG4gIH0pLnByb2dyZXNzKDEpLFxuICAgICAgYm91bmRzID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdHdlZW4gJiYgdHdlZW4ucHJvZ3Jlc3MoMCkua2lsbCgpO1xuICByZXR1cm4gYm91bmRzO1xufSxcbiAgICBfZ2V0U2l6ZSA9IGZ1bmN0aW9uIF9nZXRTaXplKGVsZW1lbnQsIF9yZWY0KSB7XG4gIHZhciBkMiA9IF9yZWY0LmQyO1xuICByZXR1cm4gZWxlbWVudFtcIm9mZnNldFwiICsgZDJdIHx8IGVsZW1lbnRbXCJjbGllbnRcIiArIGQyXSB8fCAwO1xufSxcbiAgICBfZ2V0TGFiZWxzID0gZnVuY3Rpb24gX2dldExhYmVscyhhbmltYXRpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciBhID0gW10sXG4gICAgICAgIGxhYmVscyA9IGFuaW1hdGlvbi5sYWJlbHMsXG4gICAgICAgIGR1cmF0aW9uID0gYW5pbWF0aW9uLmR1cmF0aW9uKCksXG4gICAgICAgIHA7XG5cbiAgICBmb3IgKHAgaW4gbGFiZWxzKSB7XG4gICAgICBhLnB1c2gobGFiZWxzW3BdIC8gZHVyYXRpb24pO1xuICAgIH1cblxuICAgIHJldHVybiBnc2FwLnV0aWxzLnNuYXAoYSwgdmFsdWUpO1xuICB9O1xufSxcbiAgICBfbXVsdGlMaXN0ZW5lciA9IGZ1bmN0aW9uIF9tdWx0aUxpc3RlbmVyKGZ1bmMsIGVsZW1lbnQsIHR5cGVzLCBjYWxsYmFjaykge1xuICByZXR1cm4gdHlwZXMuc3BsaXQoXCIsXCIpLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICByZXR1cm4gZnVuYyhlbGVtZW50LCB0eXBlLCBjYWxsYmFjayk7XG4gIH0pO1xufSxcbiAgICBfYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBfYWRkTGlzdGVuZXIoZWxlbWVudCwgdHlwZSwgZnVuYykge1xuICByZXR1cm4gZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGZ1bmMsIHtcbiAgICBwYXNzaXZlOiB0cnVlXG4gIH0pO1xufSxcbiAgICBfcmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiBfcmVtb3ZlTGlzdGVuZXIoZWxlbWVudCwgdHlwZSwgZnVuYykge1xuICByZXR1cm4gZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGZ1bmMpO1xufSxcbiAgICBfbWFya2VyRGVmYXVsdHMgPSB7XG4gIHN0YXJ0Q29sb3I6IFwiZ3JlZW5cIixcbiAgZW5kQ29sb3I6IFwicmVkXCIsXG4gIGluZGVudDogMCxcbiAgZm9udFNpemU6IFwiMTZweFwiLFxuICBmb250V2VpZ2h0OiBcIm5vcm1hbFwiXG59LFxuICAgIF9kZWZhdWx0cyA9IHtcbiAgdG9nZ2xlQWN0aW9uczogXCJwbGF5XCIsXG4gIGFudGljaXBhdGVQaW46IDBcbn0sXG4gICAgX2tleXdvcmRzID0ge1xuICB0b3A6IDAsXG4gIGxlZnQ6IDAsXG4gIGNlbnRlcjogMC41LFxuICBib3R0b206IDEsXG4gIHJpZ2h0OiAxXG59LFxuICAgIF9vZmZzZXRUb1B4ID0gZnVuY3Rpb24gX29mZnNldFRvUHgodmFsdWUsIHNpemUpIHtcbiAgaWYgKF9pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgZXFJbmRleCA9IHZhbHVlLmluZGV4T2YoXCI9XCIpLFxuICAgICAgICByZWxhdGl2ZSA9IH5lcUluZGV4ID8gKyh2YWx1ZS5jaGFyQXQoZXFJbmRleCAtIDEpICsgMSkgKiBwYXJzZUZsb2F0KHZhbHVlLnN1YnN0cihlcUluZGV4ICsgMSkpIDogMDtcblxuICAgIGlmIChyZWxhdGl2ZSkge1xuICAgICAgdmFsdWUuaW5kZXhPZihcIiVcIikgPiBlcUluZGV4ICYmIChyZWxhdGl2ZSAqPSBzaXplIC8gMTAwKTtcbiAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyKDAsIGVxSW5kZXggLSAxKTtcbiAgICB9XG5cbiAgICB2YWx1ZSA9IHJlbGF0aXZlICsgKHZhbHVlIGluIF9rZXl3b3JkcyA/IF9rZXl3b3Jkc1t2YWx1ZV0gKiBzaXplIDogfnZhbHVlLmluZGV4T2YoXCIlXCIpID8gcGFyc2VGbG9hdCh2YWx1ZSkgKiBzaXplIC8gMTAwIDogcGFyc2VGbG9hdCh2YWx1ZSkgfHwgMCk7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59LFxuICAgIF9jcmVhdGVNYXJrZXIgPSBmdW5jdGlvbiBfY3JlYXRlTWFya2VyKHR5cGUsIG5hbWUsIGNvbnRhaW5lciwgZGlyZWN0aW9uLCBfcmVmNSwgb2Zmc2V0LCBtYXRjaFdpZHRoRWwpIHtcbiAgdmFyIHN0YXJ0Q29sb3IgPSBfcmVmNS5zdGFydENvbG9yLFxuICAgICAgZW5kQ29sb3IgPSBfcmVmNS5lbmRDb2xvcixcbiAgICAgIGZvbnRTaXplID0gX3JlZjUuZm9udFNpemUsXG4gICAgICBpbmRlbnQgPSBfcmVmNS5pbmRlbnQsXG4gICAgICBmb250V2VpZ2h0ID0gX3JlZjUuZm9udFdlaWdodDtcblxuICB2YXIgZSA9IF9kb2MuY3JlYXRlRWxlbWVudChcImRpdlwiKSxcbiAgICAgIHVzZUZpeGVkUG9zaXRpb24gPSBfaXNWaWV3cG9ydChjb250YWluZXIpIHx8IF9nZXRQcm94eVByb3AoY29udGFpbmVyLCBcInBpblR5cGVcIikgPT09IFwiZml4ZWRcIixcbiAgICAgIGlzU2Nyb2xsZXIgPSB0eXBlLmluZGV4T2YoXCJzY3JvbGxlclwiKSAhPT0gLTEsXG4gICAgICBwYXJlbnQgPSB1c2VGaXhlZFBvc2l0aW9uID8gX2JvZHkgOiBjb250YWluZXIsXG4gICAgICBpc1N0YXJ0ID0gdHlwZS5pbmRleE9mKFwic3RhcnRcIikgIT09IC0xLFxuICAgICAgY29sb3IgPSBpc1N0YXJ0ID8gc3RhcnRDb2xvciA6IGVuZENvbG9yLFxuICAgICAgY3NzID0gXCJib3JkZXItY29sb3I6XCIgKyBjb2xvciArIFwiO2ZvbnQtc2l6ZTpcIiArIGZvbnRTaXplICsgXCI7Y29sb3I6XCIgKyBjb2xvciArIFwiO2ZvbnQtd2VpZ2h0OlwiICsgZm9udFdlaWdodCArIFwiO3BvaW50ZXItZXZlbnRzOm5vbmU7d2hpdGUtc3BhY2U6bm93cmFwO2ZvbnQtZmFtaWx5OnNhbnMtc2VyaWYsQXJpYWw7ei1pbmRleDoxMDAwO3BhZGRpbmc6NHB4IDhweDtib3JkZXItd2lkdGg6MDtib3JkZXItc3R5bGU6c29saWQ7XCI7XG5cbiAgY3NzICs9IFwicG9zaXRpb246XCIgKyAoaXNTY3JvbGxlciAmJiB1c2VGaXhlZFBvc2l0aW9uID8gXCJmaXhlZDtcIiA6IFwiYWJzb2x1dGU7XCIpO1xuICAoaXNTY3JvbGxlciB8fCAhdXNlRml4ZWRQb3NpdGlvbikgJiYgKGNzcyArPSAoZGlyZWN0aW9uID09PSBfdmVydGljYWwgPyBfcmlnaHQgOiBfYm90dG9tKSArIFwiOlwiICsgKG9mZnNldCArIHBhcnNlRmxvYXQoaW5kZW50KSkgKyBcInB4O1wiKTtcbiAgbWF0Y2hXaWR0aEVsICYmIChjc3MgKz0gXCJib3gtc2l6aW5nOmJvcmRlci1ib3g7dGV4dC1hbGlnbjpsZWZ0O3dpZHRoOlwiICsgbWF0Y2hXaWR0aEVsLm9mZnNldFdpZHRoICsgXCJweDtcIik7XG4gIGUuX2lzU3RhcnQgPSBpc1N0YXJ0O1xuICBlLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiZ3NhcC1tYXJrZXItXCIgKyB0eXBlKTtcbiAgZS5zdHlsZS5jc3NUZXh0ID0gY3NzO1xuICBlLmlubmVyVGV4dCA9IG5hbWUgfHwgbmFtZSA9PT0gMCA/IHR5cGUgKyBcIi1cIiArIG5hbWUgOiB0eXBlO1xuICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGUsIHBhcmVudC5jaGlsZHJlblswXSk7XG4gIGUuX29mZnNldCA9IGVbXCJvZmZzZXRcIiArIGRpcmVjdGlvbi5vcC5kMl07XG5cbiAgX3Bvc2l0aW9uTWFya2VyKGUsIDAsIGRpcmVjdGlvbiwgaXNTdGFydCk7XG5cbiAgcmV0dXJuIGU7XG59LFxuICAgIF9wb3NpdGlvbk1hcmtlciA9IGZ1bmN0aW9uIF9wb3NpdGlvbk1hcmtlcihtYXJrZXIsIHN0YXJ0LCBkaXJlY3Rpb24sIGZsaXBwZWQpIHtcbiAgdmFyIHZhcnMgPSB7XG4gICAgZGlzcGxheTogXCJibG9ja1wiXG4gIH0sXG4gICAgICBzaWRlID0gZGlyZWN0aW9uW2ZsaXBwZWQgPyBcIm9zMlwiIDogXCJwMlwiXSxcbiAgICAgIG9wcG9zaXRlU2lkZSA9IGRpcmVjdGlvbltmbGlwcGVkID8gXCJwMlwiIDogXCJvczJcIl07XG4gIG1hcmtlci5faXNGbGlwcGVkID0gZmxpcHBlZDtcbiAgdmFyc1tkaXJlY3Rpb24uYSArIFwiUGVyY2VudFwiXSA9IGZsaXBwZWQgPyAtMTAwIDogMDtcbiAgdmFyc1tkaXJlY3Rpb24uYV0gPSBmbGlwcGVkID8gMSA6IDA7XG4gIHZhcnNbXCJib3JkZXJcIiArIHNpZGUgKyBfV2lkdGhdID0gMTtcbiAgdmFyc1tcImJvcmRlclwiICsgb3Bwb3NpdGVTaWRlICsgX1dpZHRoXSA9IDA7XG4gIHZhcnNbZGlyZWN0aW9uLnBdID0gc3RhcnQ7XG4gIGdzYXAuc2V0KG1hcmtlciwgdmFycyk7XG59LFxuICAgIF90cmlnZ2VycyA9IFtdLFxuICAgIF9pZHMgPSB7fSxcbiAgICBfc3luYyA9IGZ1bmN0aW9uIF9zeW5jKCkge1xuICByZXR1cm4gX3JlcXVlc3QgfHwgKF9yZXF1ZXN0ID0gX3JhZihfdXBkYXRlQWxsKSk7XG59LFxuICAgIF9vblNjcm9sbCA9IGZ1bmN0aW9uIF9vblNjcm9sbCgpIHtcbiAgaWYgKCFfcmVxdWVzdCkge1xuICAgIF9yZXF1ZXN0ID0gX3JhZihfdXBkYXRlQWxsKTtcbiAgICBfbGFzdFNjcm9sbFRpbWUgfHwgX2Rpc3BhdGNoKFwic2Nyb2xsU3RhcnRcIik7XG4gICAgX2xhc3RTY3JvbGxUaW1lID0gX2dldFRpbWUoKTtcbiAgfVxufSxcbiAgICBfb25SZXNpemUgPSBmdW5jdGlvbiBfb25SZXNpemUoKSB7XG4gIHJldHVybiAhX3JlZnJlc2hpbmcgJiYgX3Jlc2l6ZURlbGF5LnJlc3RhcnQodHJ1ZSk7XG59LFxuICAgIC8vIGlnbm9yZSByZXNpemVzIHRyaWdnZXJlZCBieSByZWZyZXNoKClcbl9saXN0ZW5lcnMgPSB7fSxcbiAgICBfZW1wdHlBcnJheSA9IFtdLFxuICAgIF9tZWRpYSA9IFtdLFxuICAgIF9jcmVhdGluZ01lZGlhLFxuICAgIC8vIHdoZW4gU2Nyb2xsVHJpZ2dlci5tYXRjaE1lZGlhKCkgaXMgY2FsbGVkLCB3ZSByZWNvcmQgdGhlIGN1cnJlbnQgbWVkaWEga2V5IGhlcmUgKGxpa2UgXCIobWluLXdpZHRoOiA4MDBweClcIikgc28gdGhhdCB3ZSBjYW4gYXNzaWduIGl0IHRvIGV2ZXJ5dGhpbmcgdGhhdCdzIGNyZWF0ZWQgZHVyaW5nIHRoYXQgY2FsbC4gVGhlbiB3ZSBjYW4gcmV2ZXJ0IGp1c3QgdGhvc2Ugd2hlbiBuZWNlc3NhcnkuIEluIHRoZSBTY3JvbGxUcmlnZ2VyJ3MgaW5pdCgpIGNhbGwsIHRoZSBfY3JlYXRpbmdNZWRpYSBpcyByZWNvcmRlZCBhcyBhIFwibWVkaWFcIiBwcm9wZXJ0eSBvbiB0aGUgaW5zdGFuY2UuXG5fbGFzdE1lZGlhVGljayxcbiAgICBfb25NZWRpYUNoYW5nZSA9IGZ1bmN0aW9uIF9vbk1lZGlhQ2hhbmdlKGUpIHtcbiAgdmFyIHRpY2sgPSBnc2FwLnRpY2tlci5mcmFtZSxcbiAgICAgIG1hdGNoZXMgPSBbXSxcbiAgICAgIGkgPSAwO1xuXG4gIGlmIChfbGFzdE1lZGlhVGljayAhPT0gdGljayB8fCBfc3RhcnR1cCkge1xuICAgIF9yZXZlcnRBbGwoKTtcblxuICAgIGZvciAoOyBpIDwgX21lZGlhLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICBfd2luLm1hdGNoTWVkaWEoX21lZGlhW2ldKS5tYXRjaGVzID8gbWF0Y2hlcy5wdXNoKGkpIDogX3JldmVydEFsbCgxLCBfbWVkaWFbaV0pIHx8IF9pc0Z1bmN0aW9uKF9tZWRpYVtpICsgMl0pICYmIF9tZWRpYVtpICsgMl0oKTsgLy8gRmlyZWZveCBkb2Vzbid0IHVwZGF0ZSB0aGUgXCJtYXRjaGVzXCIgcHJvcGVydHkgb2YgdGhlIE1lZGlhUXVlcnlMaXN0IG9iamVjdCBjb3JyZWN0bHkgLSBpdCBvbmx5IGRvZXMgc28gYXMgaXQgY2FsbHMgaXRzIGNoYW5nZSBoYW5kbGVyIC0gc28gd2UgbXVzdCByZS1jcmVhdGUgYSBtZWRpYSBxdWVyeSBoZXJlIHRvIGVuc3VyZSBpdCdzIGFjY3VyYXRlLlxuICAgIH1cblxuICAgIF9yZXZlcnRSZWNvcmRlZCgpOyAvLyBpbiBjYXNlIGtpbGxpbmcvcmV2ZXJ0aW5nIGFueSBvZiB0aGUgYW5pbWF0aW9ucyBhY3R1YWxseSBhZGRlZCBpbmxpbmUgc3R5bGVzIGJhY2suXG5cblxuICAgIGZvciAoaSA9IDA7IGkgPCBtYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBfY3JlYXRpbmdNZWRpYSA9IF9tZWRpYVttYXRjaGVzW2ldXTtcbiAgICAgIF9tZWRpYVttYXRjaGVzW2ldICsgMl0gPSBfbWVkaWFbbWF0Y2hlc1tpXSArIDFdKGUpO1xuICAgIH1cblxuICAgIF9jcmVhdGluZ01lZGlhID0gMDtcblxuICAgIF9yZWZyZXNoQWxsKDAsIDEpO1xuXG4gICAgX2xhc3RNZWRpYVRpY2sgPSB0aWNrO1xuICB9XG59LFxuICAgIF9zb2Z0UmVmcmVzaCA9IGZ1bmN0aW9uIF9zb2Z0UmVmcmVzaCgpIHtcbiAgcmV0dXJuIF9yZW1vdmVMaXN0ZW5lcihTY3JvbGxUcmlnZ2VyLCBcInNjcm9sbEVuZFwiLCBfc29mdFJlZnJlc2gpIHx8IF9yZWZyZXNoQWxsKHRydWUpO1xufSxcbiAgICBfZGlzcGF0Y2ggPSBmdW5jdGlvbiBfZGlzcGF0Y2godHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVyc1t0eXBlXSAmJiBfbGlzdGVuZXJzW3R5cGVdLm1hcChmdW5jdGlvbiAoZikge1xuICAgIHJldHVybiBmKCk7XG4gIH0pIHx8IF9lbXB0eUFycmF5O1xufSxcbiAgICBfc2F2ZWRTdHlsZXMgPSBbXSxcbiAgICAvLyB3aGVuIFNjcm9sbFRyaWdnZXIuc2F2ZVN0eWxlcygpIGlzIGNhbGxlZCwgdGhlIGlubGluZSBzdHlsZXMgYXJlIHJlY29yZGVkIGluIHRoaXMgQXJyYXkgaW4gYSBzZXF1ZW50aWFsIGZvcm1hdCBsaWtlIFtlbGVtZW50LCBjc3NUZXh0LCBnc0NhY2hlLCBtZWRpYV0uIFRoaXMga2VlcHMgaXQgdmVyeSBtZW1vcnktZWZmaWNpZW50IGFuZCBmYXN0IHRvIGl0ZXJhdGUgdGhyb3VnaC5cbl9yZXZlcnRSZWNvcmRlZCA9IGZ1bmN0aW9uIF9yZXZlcnRSZWNvcmRlZChtZWRpYSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IF9zYXZlZFN0eWxlcy5sZW5ndGg7IGkgKz0gNCkge1xuICAgIGlmICghbWVkaWEgfHwgX3NhdmVkU3R5bGVzW2kgKyAzXSA9PT0gbWVkaWEpIHtcbiAgICAgIF9zYXZlZFN0eWxlc1tpXS5zdHlsZS5jc3NUZXh0ID0gX3NhdmVkU3R5bGVzW2kgKyAxXTtcbiAgICAgIF9zYXZlZFN0eWxlc1tpICsgMl0udW5jYWNoZSA9IDE7XG4gICAgfVxuICB9XG59LFxuICAgIF9yZXZlcnRBbGwgPSBmdW5jdGlvbiBfcmV2ZXJ0QWxsKGtpbGwsIG1lZGlhKSB7XG4gIHZhciB0cmlnZ2VyO1xuXG4gIGZvciAoX2kgPSAwOyBfaSA8IF90cmlnZ2Vycy5sZW5ndGg7IF9pKyspIHtcbiAgICB0cmlnZ2VyID0gX3RyaWdnZXJzW19pXTtcblxuICAgIGlmICghbWVkaWEgfHwgdHJpZ2dlci5tZWRpYSA9PT0gbWVkaWEpIHtcbiAgICAgIGlmIChraWxsKSB7XG4gICAgICAgIHRyaWdnZXIua2lsbCgxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyaWdnZXIuc2Nyb2xsLnJlYyB8fCAodHJpZ2dlci5zY3JvbGwucmVjID0gdHJpZ2dlci5zY3JvbGwoKSk7IC8vIHJlY29yZCB0aGUgc2Nyb2xsIHBvc2l0aW9ucyBzbyB0aGF0IGluIGVhY2ggcmVmcmVzaCgpIHdlIGNhbiBlbnN1cmUgdGhhdCBpdCBkb2Vzbid0IHNoaWZ0LiBSZW1lbWJlciwgcGlubmluZyBjYW4gbWFrZSB0aGluZ3MgY2hhbmdlIGFyb3VuZCwgZXNwZWNpYWxseSBpZiB0aGUgc2FtZSBlbGVtZW50IGlzIHBpbm5lZCBtdWx0aXBsZSB0aW1lcy4gSWYgb25lIHdhcyBhbHJlYWR5IHJlY29yZGVkLCBkb24ndCByZS1yZWNvcmQgYmVjYXVzZSB1bnBpbm5pbmcgbWF5IGhhdmUgb2NjdXJyZWQgYW5kIG1hZGUgaXQgc2hvcnRlci5cblxuICAgICAgICB0cmlnZ2VyLnJldmVydCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9yZXZlcnRSZWNvcmRlZChtZWRpYSk7XG5cbiAgbWVkaWEgfHwgX2Rpc3BhdGNoKFwicmV2ZXJ0XCIpO1xufSxcbiAgICBfcmVmcmVzaEFsbCA9IGZ1bmN0aW9uIF9yZWZyZXNoQWxsKGZvcmNlLCBza2lwUmV2ZXJ0KSB7XG4gIGlmIChfbGFzdFNjcm9sbFRpbWUgJiYgIWZvcmNlKSB7XG4gICAgX2FkZExpc3RlbmVyKFNjcm9sbFRyaWdnZXIsIFwic2Nyb2xsRW5kXCIsIF9zb2Z0UmVmcmVzaCk7XG5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcmVmcmVzaEluaXRzID0gX2Rpc3BhdGNoKFwicmVmcmVzaEluaXRcIik7XG5cbiAgX3NvcnQgJiYgU2Nyb2xsVHJpZ2dlci5zb3J0KCk7XG4gIHNraXBSZXZlcnQgfHwgX3JldmVydEFsbCgpO1xuXG4gIGZvciAoX2kgPSAwOyBfaSA8IF90cmlnZ2Vycy5sZW5ndGg7IF9pKyspIHtcbiAgICBfdHJpZ2dlcnNbX2ldLnJlZnJlc2goKTtcbiAgfVxuXG4gIHJlZnJlc2hJbml0cy5mb3JFYWNoKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICByZXR1cm4gcmVzdWx0ICYmIHJlc3VsdC5yZW5kZXIgJiYgcmVzdWx0LnJlbmRlcigtMSk7XG4gIH0pOyAvLyBpZiB0aGUgb25SZWZyZXNoSW5pdCgpIHJldHVybnMgYW4gYW5pbWF0aW9uICh0eXBpY2FsbHkgYSBnc2FwLnNldCgpKSwgcmV2ZXJ0IGl0LiBUaGlzIG1ha2VzIGl0IGVhc3kgdG8gcHV0IHRoaW5ncyBpbiBhIGNlcnRhaW4gc3BvdCBiZWZvcmUgcmVmcmVzaGluZyBmb3IgbWVhc3VyZW1lbnQgcHVycG9zZXMsIGFuZCB0aGVuIHB1dCB0aGluZ3MgYmFjay5cblxuICBfaSA9IF90cmlnZ2Vycy5sZW5ndGg7XG5cbiAgd2hpbGUgKF9pLS0pIHtcbiAgICBfdHJpZ2dlcnNbX2ldLnNjcm9sbC5yZWMgPSAwO1xuICB9XG5cbiAgX2Rpc3BhdGNoKFwicmVmcmVzaFwiKTtcbn0sXG4gICAgX2xhc3RTY3JvbGwgPSAwLFxuICAgIF9kaXJlY3Rpb24gPSAxLFxuICAgIF91cGRhdGVBbGwgPSBmdW5jdGlvbiBfdXBkYXRlQWxsKCkge1xuICB2YXIgbCA9IF90cmlnZ2Vycy5sZW5ndGgsXG4gICAgICB0aW1lID0gX2dldFRpbWUoKSxcbiAgICAgIHJlY29yZFZlbG9jaXR5ID0gdGltZSAtIF90aW1lMSA+PSA1MCxcbiAgICAgIHNjcm9sbCA9IGwgJiYgX3RyaWdnZXJzWzBdLnNjcm9sbCgpO1xuXG4gIF9kaXJlY3Rpb24gPSBfbGFzdFNjcm9sbCA+IHNjcm9sbCA/IC0xIDogMTtcbiAgX2xhc3RTY3JvbGwgPSBzY3JvbGw7XG5cbiAgaWYgKHJlY29yZFZlbG9jaXR5KSB7XG4gICAgaWYgKF9sYXN0U2Nyb2xsVGltZSAmJiAhX3BvaW50ZXJJc0Rvd24gJiYgdGltZSAtIF9sYXN0U2Nyb2xsVGltZSA+IDIwMCkge1xuICAgICAgX2xhc3RTY3JvbGxUaW1lID0gMDtcblxuICAgICAgX2Rpc3BhdGNoKFwic2Nyb2xsRW5kXCIpO1xuICAgIH1cblxuICAgIF90aW1lMiA9IF90aW1lMTtcbiAgICBfdGltZTEgPSB0aW1lO1xuICB9XG5cbiAgaWYgKF9kaXJlY3Rpb24gPCAwKSB7XG4gICAgX2kgPSBsO1xuXG4gICAgd2hpbGUgKF9pLS0pIHtcbiAgICAgIF90cmlnZ2Vyc1tfaV0udXBkYXRlKDAsIHJlY29yZFZlbG9jaXR5KTtcbiAgICB9XG5cbiAgICBfZGlyZWN0aW9uID0gMTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKF9pID0gMDsgX2kgPCBsOyBfaSsrKSB7XG4gICAgICBfdHJpZ2dlcnNbX2ldICYmIF90cmlnZ2Vyc1tfaV0udXBkYXRlKDAsIHJlY29yZFZlbG9jaXR5KTtcbiAgICB9XG4gIH1cblxuICBfcmVxdWVzdCA9IDA7XG59LFxuICAgIF9wcm9wTmFtZXNUb0NvcHkgPSBbX2xlZnQsIF90b3AsIF9ib3R0b20sIF9yaWdodCwgX21hcmdpbiArIF9Cb3R0b20sIF9tYXJnaW4gKyBfUmlnaHQsIF9tYXJnaW4gKyBfVG9wLCBfbWFyZ2luICsgX0xlZnQsIFwiZGlzcGxheVwiLCBcImZsZXhTaHJpbmtcIiwgXCJmbG9hdFwiXSxcbiAgICBfc3RhdGVQcm9wcyA9IF9wcm9wTmFtZXNUb0NvcHkuY29uY2F0KFtfd2lkdGgsIF9oZWlnaHQsIFwiYm94U2l6aW5nXCIsIFwibWF4XCIgKyBfV2lkdGgsIFwibWF4XCIgKyBfSGVpZ2h0LCBcInBvc2l0aW9uXCIsIF9tYXJnaW4sIF9wYWRkaW5nLCBfcGFkZGluZyArIF9Ub3AsIF9wYWRkaW5nICsgX1JpZ2h0LCBfcGFkZGluZyArIF9Cb3R0b20sIF9wYWRkaW5nICsgX0xlZnRdKSxcbiAgICBfc3dhcFBpbk91dCA9IGZ1bmN0aW9uIF9zd2FwUGluT3V0KHBpbiwgc3BhY2VyLCBzdGF0ZSkge1xuICBfc2V0U3RhdGUoc3RhdGUpO1xuXG4gIGlmIChwaW4ucGFyZW50Tm9kZSA9PT0gc3BhY2VyKSB7XG4gICAgdmFyIHBhcmVudCA9IHNwYWNlci5wYXJlbnROb2RlO1xuXG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShwaW4sIHNwYWNlcik7XG4gICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoc3BhY2VyKTtcbiAgICB9XG4gIH1cbn0sXG4gICAgX3N3YXBQaW5JbiA9IGZ1bmN0aW9uIF9zd2FwUGluSW4ocGluLCBzcGFjZXIsIGNzLCBzcGFjZXJTdGF0ZSkge1xuICBpZiAocGluLnBhcmVudE5vZGUgIT09IHNwYWNlcikge1xuICAgIHZhciBpID0gX3Byb3BOYW1lc1RvQ29weS5sZW5ndGgsXG4gICAgICAgIHNwYWNlclN0eWxlID0gc3BhY2VyLnN0eWxlLFxuICAgICAgICBwaW5TdHlsZSA9IHBpbi5zdHlsZSxcbiAgICAgICAgcDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHAgPSBfcHJvcE5hbWVzVG9Db3B5W2ldO1xuICAgICAgc3BhY2VyU3R5bGVbcF0gPSBjc1twXTtcbiAgICB9XG5cbiAgICBzcGFjZXJTdHlsZS5wb3NpdGlvbiA9IGNzLnBvc2l0aW9uID09PSBcImFic29sdXRlXCIgPyBcImFic29sdXRlXCIgOiBcInJlbGF0aXZlXCI7XG4gICAgY3MuZGlzcGxheSA9PT0gXCJpbmxpbmVcIiAmJiAoc3BhY2VyU3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCIpO1xuICAgIHBpblN0eWxlW19ib3R0b21dID0gcGluU3R5bGVbX3JpZ2h0XSA9IFwiYXV0b1wiO1xuICAgIHNwYWNlclN0eWxlLm92ZXJmbG93ID0gXCJ2aXNpYmxlXCI7XG4gICAgc3BhY2VyU3R5bGUuYm94U2l6aW5nID0gXCJib3JkZXItYm94XCI7XG4gICAgc3BhY2VyU3R5bGVbX3dpZHRoXSA9IF9nZXRTaXplKHBpbiwgX2hvcml6b250YWwpICsgX3B4O1xuICAgIHNwYWNlclN0eWxlW19oZWlnaHRdID0gX2dldFNpemUocGluLCBfdmVydGljYWwpICsgX3B4O1xuICAgIHNwYWNlclN0eWxlW19wYWRkaW5nXSA9IHBpblN0eWxlW19tYXJnaW5dID0gcGluU3R5bGVbX3RvcF0gPSBwaW5TdHlsZVtfbGVmdF0gPSBcIjBcIjtcblxuICAgIF9zZXRTdGF0ZShzcGFjZXJTdGF0ZSk7XG5cbiAgICBwaW5TdHlsZVtfd2lkdGhdID0gY3NbX3dpZHRoXTtcbiAgICBwaW5TdHlsZVtfaGVpZ2h0XSA9IGNzW19oZWlnaHRdO1xuICAgIHBpblN0eWxlW19wYWRkaW5nXSA9IGNzW19wYWRkaW5nXTtcbiAgICBwaW4ucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc3BhY2VyLCBwaW4pO1xuICAgIHNwYWNlci5hcHBlbmRDaGlsZChwaW4pO1xuICB9XG59LFxuICAgIF9jYXBzRXhwID0gLyhbQS1aXSkvZyxcbiAgICBfc2V0U3RhdGUgPSBmdW5jdGlvbiBfc2V0U3RhdGUoc3RhdGUpIHtcbiAgaWYgKHN0YXRlKSB7XG4gICAgdmFyIHN0eWxlID0gc3RhdGUudC5zdHlsZSxcbiAgICAgICAgbCA9IHN0YXRlLmxlbmd0aCxcbiAgICAgICAgaSA9IDAsXG4gICAgICAgIHAsXG4gICAgICAgIHZhbHVlO1xuXG4gICAgZm9yICg7IGkgPCBsOyBpICs9IDIpIHtcbiAgICAgIHZhbHVlID0gc3RhdGVbaSArIDFdO1xuICAgICAgcCA9IHN0YXRlW2ldO1xuXG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgc3R5bGVbcF0gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAoc3R5bGVbcF0pIHtcbiAgICAgICAgc3R5bGUucmVtb3ZlUHJvcGVydHkocC5yZXBsYWNlKF9jYXBzRXhwLCBcIi0kMVwiKS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0sXG4gICAgX2dldFN0YXRlID0gZnVuY3Rpb24gX2dldFN0YXRlKGVsZW1lbnQpIHtcbiAgLy8gcmV0dXJucyBhbiBhcnJheSB3aXRoIGFsdGVybmF0aW5nIHZhbHVlcyBsaWtlIFtwcm9wZXJ0eSwgdmFsdWUsIHByb3BlcnR5LCB2YWx1ZV0gYW5kIGEgXCJ0XCIgcHJvcGVydHkgcG9pbnRpbmcgdG8gdGhlIHRhcmdldCAoZWxlbWVudCkuIE1ha2VzIGl0IGZhc3QgYW5kIGNoZWFwLlxuICB2YXIgbCA9IF9zdGF0ZVByb3BzLmxlbmd0aCxcbiAgICAgIHN0eWxlID0gZWxlbWVudC5zdHlsZSxcbiAgICAgIHN0YXRlID0gW10sXG4gICAgICBpID0gMDtcblxuICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgIHN0YXRlLnB1c2goX3N0YXRlUHJvcHNbaV0sIHN0eWxlW19zdGF0ZVByb3BzW2ldXSk7XG4gIH1cblxuICBzdGF0ZS50ID0gZWxlbWVudDtcbiAgcmV0dXJuIHN0YXRlO1xufSxcbiAgICBfY29weVN0YXRlID0gZnVuY3Rpb24gX2NvcHlTdGF0ZShzdGF0ZSwgb3ZlcnJpZGUsIG9taXRPZmZzZXRzKSB7XG4gIHZhciByZXN1bHQgPSBbXSxcbiAgICAgIGwgPSBzdGF0ZS5sZW5ndGgsXG4gICAgICBpID0gb21pdE9mZnNldHMgPyA4IDogMCxcbiAgICAgIC8vIHNraXAgdG9wLCBsZWZ0LCByaWdodCwgYm90dG9tIGlmIG9taXRPZmZzZXRzIGlzIHRydWVcbiAgcDtcblxuICBmb3IgKDsgaSA8IGw7IGkgKz0gMikge1xuICAgIHAgPSBzdGF0ZVtpXTtcbiAgICByZXN1bHQucHVzaChwLCBwIGluIG92ZXJyaWRlID8gb3ZlcnJpZGVbcF0gOiBzdGF0ZVtpICsgMV0pO1xuICB9XG5cbiAgcmVzdWx0LnQgPSBzdGF0ZS50O1xuICByZXR1cm4gcmVzdWx0O1xufSxcbiAgICBfd2luT2Zmc2V0cyA9IHtcbiAgbGVmdDogMCxcbiAgdG9wOiAwXG59LFxuICAgIF9wYXJzZVBvc2l0aW9uID0gZnVuY3Rpb24gX3BhcnNlUG9zaXRpb24odmFsdWUsIHRyaWdnZXIsIHNjcm9sbGVyU2l6ZSwgZGlyZWN0aW9uLCBzY3JvbGwsIG1hcmtlciwgbWFya2VyU2Nyb2xsZXIsIHNlbGYsIHNjcm9sbGVyQm91bmRzLCBib3JkZXJXaWR0aCwgdXNlRml4ZWRQb3NpdGlvbiwgc2Nyb2xsZXJNYXgpIHtcbiAgX2lzRnVuY3Rpb24odmFsdWUpICYmICh2YWx1ZSA9IHZhbHVlKHNlbGYpKTtcblxuICBpZiAoX2lzU3RyaW5nKHZhbHVlKSAmJiB2YWx1ZS5zdWJzdHIoMCwgMykgPT09IFwibWF4XCIpIHtcbiAgICB2YWx1ZSA9IHNjcm9sbGVyTWF4ICsgKHZhbHVlLmNoYXJBdCg0KSA9PT0gXCI9XCIgPyBfb2Zmc2V0VG9QeChcIjBcIiArIHZhbHVlLnN1YnN0cigzKSwgc2Nyb2xsZXJTaXplKSA6IDApO1xuICB9XG5cbiAgaWYgKCFfaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgX2lzRnVuY3Rpb24odHJpZ2dlcikgJiYgKHRyaWdnZXIgPSB0cmlnZ2VyKHNlbGYpKTtcblxuICAgIHZhciBlbGVtZW50ID0gX3RvQXJyYXkodHJpZ2dlcilbMF0gfHwgX2JvZHksXG4gICAgICAgIGJvdW5kcyA9IF9nZXRCb3VuZHMoZWxlbWVudCkgfHwge30sXG4gICAgICAgIG9mZnNldHMgPSB2YWx1ZS5zcGxpdChcIiBcIiksXG4gICAgICAgIGxvY2FsT2Zmc2V0LFxuICAgICAgICBnbG9iYWxPZmZzZXQsXG4gICAgICAgIGRpc3BsYXk7XG5cbiAgICBpZiAoKCFib3VuZHMgfHwgIWJvdW5kcy5sZWZ0ICYmICFib3VuZHMudG9wKSAmJiBfZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5kaXNwbGF5ID09PSBcIm5vbmVcIikge1xuICAgICAgLy8gaWYgZGlzcGxheSBpcyBcIm5vbmVcIiwgaXQgd29uJ3QgcmVwb3J0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIHByb3Blcmx5XG4gICAgICBkaXNwbGF5ID0gZWxlbWVudC5zdHlsZS5kaXNwbGF5O1xuICAgICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgYm91bmRzID0gX2dldEJvdW5kcyhlbGVtZW50KTtcbiAgICAgIGRpc3BsYXkgPyBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBkaXNwbGF5IDogZWxlbWVudC5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcImRpc3BsYXlcIik7XG4gICAgfVxuXG4gICAgbG9jYWxPZmZzZXQgPSBfb2Zmc2V0VG9QeChvZmZzZXRzWzBdLCBib3VuZHNbZGlyZWN0aW9uLmRdKTtcbiAgICBnbG9iYWxPZmZzZXQgPSBfb2Zmc2V0VG9QeChvZmZzZXRzWzFdIHx8IFwiMFwiLCBzY3JvbGxlclNpemUpO1xuICAgIHZhbHVlID0gYm91bmRzW2RpcmVjdGlvbi5wXSAtIHNjcm9sbGVyQm91bmRzW2RpcmVjdGlvbi5wXSAtIGJvcmRlcldpZHRoICsgbG9jYWxPZmZzZXQgKyBzY3JvbGwgLSBnbG9iYWxPZmZzZXQ7XG4gICAgbWFya2VyU2Nyb2xsZXIgJiYgX3Bvc2l0aW9uTWFya2VyKG1hcmtlclNjcm9sbGVyLCBnbG9iYWxPZmZzZXQsIGRpcmVjdGlvbiwgc2Nyb2xsZXJTaXplIC0gZ2xvYmFsT2Zmc2V0IDwgMjAgfHwgbWFya2VyU2Nyb2xsZXIuX2lzU3RhcnQgJiYgZ2xvYmFsT2Zmc2V0ID4gMjApO1xuICAgIHNjcm9sbGVyU2l6ZSAtPSBzY3JvbGxlclNpemUgLSBnbG9iYWxPZmZzZXQ7IC8vIGFkanVzdCBmb3IgdGhlIG1hcmtlclxuICB9IGVsc2UgaWYgKG1hcmtlclNjcm9sbGVyKSB7XG4gICAgX3Bvc2l0aW9uTWFya2VyKG1hcmtlclNjcm9sbGVyLCBzY3JvbGxlclNpemUsIGRpcmVjdGlvbiwgdHJ1ZSk7XG4gIH1cblxuICBpZiAobWFya2VyKSB7XG4gICAgdmFyIHBvc2l0aW9uID0gdmFsdWUgKyBzY3JvbGxlclNpemUsXG4gICAgICAgIGlzU3RhcnQgPSBtYXJrZXIuX2lzU3RhcnQ7XG4gICAgc2Nyb2xsZXJNYXggPSBcInNjcm9sbFwiICsgZGlyZWN0aW9uLmQyO1xuXG4gICAgX3Bvc2l0aW9uTWFya2VyKG1hcmtlciwgcG9zaXRpb24sIGRpcmVjdGlvbiwgaXNTdGFydCAmJiBwb3NpdGlvbiA+IDIwIHx8ICFpc1N0YXJ0ICYmICh1c2VGaXhlZFBvc2l0aW9uID8gTWF0aC5tYXgoX2JvZHlbc2Nyb2xsZXJNYXhdLCBfZG9jRWxbc2Nyb2xsZXJNYXhdKSA6IG1hcmtlci5wYXJlbnROb2RlW3Njcm9sbGVyTWF4XSkgPD0gcG9zaXRpb24gKyAxKTtcblxuICAgIGlmICh1c2VGaXhlZFBvc2l0aW9uKSB7XG4gICAgICBzY3JvbGxlckJvdW5kcyA9IF9nZXRCb3VuZHMobWFya2VyU2Nyb2xsZXIpO1xuICAgICAgdXNlRml4ZWRQb3NpdGlvbiAmJiAobWFya2VyLnN0eWxlW2RpcmVjdGlvbi5vcC5wXSA9IHNjcm9sbGVyQm91bmRzW2RpcmVjdGlvbi5vcC5wXSAtIGRpcmVjdGlvbi5vcC5tIC0gbWFya2VyLl9vZmZzZXQgKyBfcHgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlKTtcbn0sXG4gICAgX3ByZWZpeEV4cCA9IC8oPzp3ZWJraXR8bW96fGxlbmd0aCkvaSxcbiAgICBfcmVwYXJlbnQgPSBmdW5jdGlvbiBfcmVwYXJlbnQoZWxlbWVudCwgcGFyZW50KSB7XG4gIGlmIChlbGVtZW50LnBhcmVudE5vZGUgIT09IHBhcmVudCkge1xuICAgIHZhciBzdHlsZSA9IGVsZW1lbnQuc3R5bGUsXG4gICAgICAgIHAsXG4gICAgICAgIGNzO1xuXG4gICAgaWYgKHBhcmVudCA9PT0gX2JvZHkpIHtcbiAgICAgIGVsZW1lbnQuX3N0T3JpZyA9IHN0eWxlLmNzc1RleHQ7IC8vIHJlY29yZCBvcmlnaW5hbCBpbmxpbmUgc3R5bGVzIHNvIHdlIGNhbiByZXZlcnQgdGhlbSBsYXRlclxuXG4gICAgICBjcyA9IF9nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuXG4gICAgICBmb3IgKHAgaW4gY3MpIHtcbiAgICAgICAgLy8gbXVzdCBjb3B5IGFsbCByZWxldmFudCBzdHlsZXMgdG8gZW5zdXJlIHRoYXQgbm90aGluZyBjaGFuZ2VzIHZpc3VhbGx5IHdoZW4gd2UgcmVwYXJlbnQgdG8gdGhlIDxib2R5Pi4gU2tpcCB0aGUgdmVuZG9yIHByZWZpeGVkIG9uZXMuXG4gICAgICAgIGlmICghK3AgJiYgIV9wcmVmaXhFeHAudGVzdChwKSAmJiBjc1twXSAmJiB0eXBlb2Ygc3R5bGVbcF0gPT09IFwic3RyaW5nXCIgJiYgcCAhPT0gXCIwXCIpIHtcbiAgICAgICAgICBzdHlsZVtwXSA9IGNzW3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlLmNzc1RleHQgPSBlbGVtZW50Ll9zdE9yaWc7XG4gICAgfVxuXG4gICAgcGFyZW50LmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICB9XG59LFxuICAgIC8vIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIHR3ZWVuIHRoZSBzY3JvbGwgcG9zaXRpb24gaW4gdGhlIGRpcmVjdGlvbiBwcm92aWRlZCwgYW5kIHdoZW4gZG9pbmcgc28gaXQnbGwgYWRkIGEgLnR3ZWVuIHByb3BlcnR5IHRvIHRoZSBGVU5DVElPTiBpdHNlbGYsIGFuZCByZW1vdmUgaXQgd2hlbiB0aGUgdHdlZW4gY29tcGxldGVzIG9yIGdldHMga2lsbGVkLiBUaGlzIGdpdmVzIHVzIGEgd2F5IHRvIGhhdmUgbXVsdGlwbGUgU2Nyb2xsVHJpZ2dlcnMgdXNlIGEgY2VudHJhbCBmdW5jdGlvbiBmb3IgYW55IGdpdmVuIHNjcm9sbGVyIGFuZCBzZWUgaWYgdGhlcmUncyBhIHNjcm9sbCB0d2VlbiBydW5uaW5nICh3aGljaCB3b3VsZCBhZmZlY3QgaWYvaG93IHRoaW5ncyBnZXQgdXBkYXRlZClcbl9nZXRUd2VlbkNyZWF0b3IgPSBmdW5jdGlvbiBfZ2V0VHdlZW5DcmVhdG9yKHNjcm9sbGVyLCBkaXJlY3Rpb24pIHtcbiAgdmFyIGdldFNjcm9sbCA9IF9nZXRTY3JvbGxGdW5jKHNjcm9sbGVyLCBkaXJlY3Rpb24pLFxuICAgICAgcHJvcCA9IFwiX3Njcm9sbFwiICsgZGlyZWN0aW9uLnAyLFxuICAgICAgLy8gYWRkIGEgdHdlZW5hYmxlIHByb3BlcnR5IHRvIHRoZSBzY3JvbGxlciB0aGF0J3MgYSBnZXR0ZXIvc2V0dGVyIGZ1bmN0aW9uLCBsaWtlIF9zY3JvbGxUb3Agb3IgX3Njcm9sbExlZnQuIFRoaXMgd2F5LCBpZiBzb21lb25lIGRvZXMgZ3NhcC5raWxsVHdlZW5zT2Yoc2Nyb2xsZXIpIGl0J2xsIGtpbGwgdGhlIHNjcm9sbCB0d2Vlbi5cbiAgbGFzdFNjcm9sbCxcbiAgICAgIGdldFR3ZWVuID0gZnVuY3Rpb24gZ2V0VHdlZW4oc2Nyb2xsVG8sIHZhcnMsIGluaXRpYWxWYWx1ZSwgY2hhbmdlMSwgY2hhbmdlMikge1xuICAgIHZhciB0d2VlbiA9IGdldFR3ZWVuLnR3ZWVuLFxuICAgICAgICBvbkNvbXBsZXRlID0gdmFycy5vbkNvbXBsZXRlLFxuICAgICAgICBtb2RpZmllcnMgPSB7fTtcbiAgICB0d2VlbiAmJiB0d2Vlbi5raWxsKCk7XG4gICAgbGFzdFNjcm9sbCA9IGdldFNjcm9sbCgpO1xuICAgIHZhcnNbcHJvcF0gPSBzY3JvbGxUbztcbiAgICB2YXJzLm1vZGlmaWVycyA9IG1vZGlmaWVycztcblxuICAgIG1vZGlmaWVyc1twcm9wXSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKE1hdGguYWJzKGdldFNjcm9sbCgpIC0gbGFzdFNjcm9sbCkgPiA3KSB7XG4gICAgICAgIC8vIGlmIHRoZSB1c2VyIHNjcm9sbHMsIGtpbGwgdGhlIHR3ZWVuLiBOZWVkIGEgbWFyZ2luIG9mIGVycm9yIGJlY2F1c2Ugc29tZSBicm93c2VycyBsaWtlIGlPUyBTYWZhcmkgbWlzcmVwb3J0IHRoZSBzY3JvbGwgcG9zaXRpb24hXG4gICAgICAgIHR3ZWVuLmtpbGwoKTtcbiAgICAgICAgZ2V0VHdlZW4udHdlZW4gPSAwO1xuICAgICAgICB2YWx1ZSA9IGdldFNjcm9sbCgpO1xuICAgICAgfSBlbHNlIGlmIChjaGFuZ2UxKSB7XG4gICAgICAgIHZhbHVlID0gaW5pdGlhbFZhbHVlICsgY2hhbmdlMSAqIHR3ZWVuLnJhdGlvICsgY2hhbmdlMiAqIHR3ZWVuLnJhdGlvICogdHdlZW4ucmF0aW87XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsYXN0U2Nyb2xsID0gTWF0aC5yb3VuZCh2YWx1ZSk7XG4gICAgfTtcblxuICAgIHZhcnMub25Db21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGdldFR3ZWVuLnR3ZWVuID0gMDtcbiAgICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZS5jYWxsKHR3ZWVuKTtcbiAgICB9O1xuXG4gICAgdHdlZW4gPSBnZXRUd2Vlbi50d2VlbiA9IGdzYXAudG8oc2Nyb2xsZXIsIHZhcnMpO1xuICAgIHJldHVybiB0d2VlbjtcbiAgfTtcblxuICBzY3JvbGxlcltwcm9wXSA9IGdldFNjcm9sbDtcbiAgcmV0dXJuIGdldFR3ZWVuO1xufTtcblxuX2hvcml6b250YWwub3AgPSBfdmVydGljYWw7XG5leHBvcnQgdmFyIFNjcm9sbFRyaWdnZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTY3JvbGxUcmlnZ2VyKHZhcnMsIGFuaW1hdGlvbikge1xuICAgIF9jb3JlSW5pdHRlZCB8fCBTY3JvbGxUcmlnZ2VyLnJlZ2lzdGVyKGdzYXApIHx8IGNvbnNvbGUud2FybihcIlBsZWFzZSBnc2FwLnJlZ2lzdGVyUGx1Z2luKFNjcm9sbFRyaWdnZXIpXCIpO1xuICAgIHRoaXMuaW5pdCh2YXJzLCBhbmltYXRpb24pO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFNjcm9sbFRyaWdnZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5pbml0ID0gZnVuY3Rpb24gaW5pdCh2YXJzLCBhbmltYXRpb24pIHtcbiAgICB0aGlzLnByb2dyZXNzID0gMDtcbiAgICB0aGlzLnZhcnMgJiYgdGhpcy5raWxsKDEpOyAvLyBpbiBjYXNlIGl0J3MgYmVpbmcgaW5pdHRlZCBhZ2FpblxuXG4gICAgaWYgKCFfZW5hYmxlZCkge1xuICAgICAgdGhpcy51cGRhdGUgPSB0aGlzLnJlZnJlc2ggPSB0aGlzLmtpbGwgPSBfcGFzc1Rocm91Z2g7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFycyA9IF9zZXREZWZhdWx0cyhfaXNTdHJpbmcodmFycykgfHwgX2lzTnVtYmVyKHZhcnMpIHx8IHZhcnMubm9kZVR5cGUgPyB7XG4gICAgICB0cmlnZ2VyOiB2YXJzXG4gICAgfSA6IHZhcnMsIF9kZWZhdWx0cyk7XG5cbiAgICB2YXIgZGlyZWN0aW9uID0gdmFycy5ob3Jpem9udGFsID8gX2hvcml6b250YWwgOiBfdmVydGljYWwsXG4gICAgICAgIF92YXJzID0gdmFycyxcbiAgICAgICAgb25VcGRhdGUgPSBfdmFycy5vblVwZGF0ZSxcbiAgICAgICAgdG9nZ2xlQ2xhc3MgPSBfdmFycy50b2dnbGVDbGFzcyxcbiAgICAgICAgaWQgPSBfdmFycy5pZCxcbiAgICAgICAgb25Ub2dnbGUgPSBfdmFycy5vblRvZ2dsZSxcbiAgICAgICAgb25SZWZyZXNoID0gX3ZhcnMub25SZWZyZXNoLFxuICAgICAgICBzY3J1YiA9IF92YXJzLnNjcnViLFxuICAgICAgICB0cmlnZ2VyID0gX3ZhcnMudHJpZ2dlcixcbiAgICAgICAgcGluID0gX3ZhcnMucGluLFxuICAgICAgICBwaW5TcGFjaW5nID0gX3ZhcnMucGluU3BhY2luZyxcbiAgICAgICAgaW52YWxpZGF0ZU9uUmVmcmVzaCA9IF92YXJzLmludmFsaWRhdGVPblJlZnJlc2gsXG4gICAgICAgIGFudGljaXBhdGVQaW4gPSBfdmFycy5hbnRpY2lwYXRlUGluLFxuICAgICAgICBvblNjcnViQ29tcGxldGUgPSBfdmFycy5vblNjcnViQ29tcGxldGUsXG4gICAgICAgIG9uU25hcENvbXBsZXRlID0gX3ZhcnMub25TbmFwQ29tcGxldGUsXG4gICAgICAgIG9uY2UgPSBfdmFycy5vbmNlLFxuICAgICAgICBzbmFwID0gX3ZhcnMuc25hcCxcbiAgICAgICAgcGluUmVwYXJlbnQgPSBfdmFycy5waW5SZXBhcmVudCxcbiAgICAgICAgaXNUb2dnbGUgPSAhc2NydWIgJiYgc2NydWIgIT09IDAsXG4gICAgICAgIHNjcm9sbGVyID0gX3RvQXJyYXkodmFycy5zY3JvbGxlciB8fCBfd2luKVswXSxcbiAgICAgICAgc2Nyb2xsZXJDYWNoZSA9IGdzYXAuY29yZS5nZXRDYWNoZShzY3JvbGxlciksXG4gICAgICAgIGlzVmlld3BvcnQgPSBfaXNWaWV3cG9ydChzY3JvbGxlciksXG4gICAgICAgIHVzZUZpeGVkUG9zaXRpb24gPSBpc1ZpZXdwb3J0IHx8IF9nZXRQcm94eVByb3Aoc2Nyb2xsZXIsIFwicGluVHlwZVwiKSA9PT0gXCJmaXhlZFwiLFxuICAgICAgICBjYWxsYmFja3MgPSBbdmFycy5vbkVudGVyLCB2YXJzLm9uTGVhdmUsIHZhcnMub25FbnRlckJhY2ssIHZhcnMub25MZWF2ZUJhY2tdLFxuICAgICAgICB0b2dnbGVBY3Rpb25zID0gaXNUb2dnbGUgJiYgKG9uY2UgPyBcInBsYXlcIiA6IHZhcnMudG9nZ2xlQWN0aW9ucykuc3BsaXQoXCIgXCIpLFxuICAgICAgICBtYXJrZXJzID0gXCJtYXJrZXJzXCIgaW4gdmFycyA/IHZhcnMubWFya2VycyA6IF9kZWZhdWx0cy5tYXJrZXJzLFxuICAgICAgICBib3JkZXJXaWR0aCA9IGlzVmlld3BvcnQgPyAwIDogcGFyc2VGbG9hdChfZ2V0Q29tcHV0ZWRTdHlsZShzY3JvbGxlcilbXCJib3JkZXJcIiArIGRpcmVjdGlvbi5wMiArIF9XaWR0aF0pIHx8IDAsXG4gICAgICAgIHNlbGYgPSB0aGlzLFxuICAgICAgICBvblJlZnJlc2hJbml0ID0gdmFycy5vblJlZnJlc2hJbml0ICYmIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB2YXJzLm9uUmVmcmVzaEluaXQoc2VsZik7XG4gICAgfSxcbiAgICAgICAgZ2V0U2Nyb2xsZXJTaXplID0gX2dldFNpemVGdW5jKHNjcm9sbGVyLCBpc1ZpZXdwb3J0LCBkaXJlY3Rpb24pLFxuICAgICAgICBnZXRTY3JvbGxlck9mZnNldHMgPSBfZ2V0T2Zmc2V0c0Z1bmMoc2Nyb2xsZXIsIGlzVmlld3BvcnQpLFxuICAgICAgICB0d2VlblRvLFxuICAgICAgICBwaW5DYWNoZSxcbiAgICAgICAgc25hcEZ1bmMsXG4gICAgICAgIGlzUmV2ZXJ0ZWQsXG4gICAgICAgIHNjcm9sbDEsXG4gICAgICAgIHNjcm9sbDIsXG4gICAgICAgIHN0YXJ0LFxuICAgICAgICBlbmQsXG4gICAgICAgIG1hcmtlclN0YXJ0LFxuICAgICAgICBtYXJrZXJFbmQsXG4gICAgICAgIG1hcmtlclN0YXJ0VHJpZ2dlcixcbiAgICAgICAgbWFya2VyRW5kVHJpZ2dlcixcbiAgICAgICAgbWFya2VyVmFycyxcbiAgICAgICAgY2hhbmdlLFxuICAgICAgICBwaW5PcmlnaW5hbFN0YXRlLFxuICAgICAgICBwaW5BY3RpdmVTdGF0ZSxcbiAgICAgICAgcGluU3RhdGUsXG4gICAgICAgIHNwYWNlcixcbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICBwaW5HZXR0ZXIsXG4gICAgICAgIHBpblNldHRlcixcbiAgICAgICAgcGluU3RhcnQsXG4gICAgICAgIHBpbkNoYW5nZSxcbiAgICAgICAgc3BhY2luZ1N0YXJ0LFxuICAgICAgICBzcGFjZXJTdGF0ZSxcbiAgICAgICAgbWFya2VyU3RhcnRTZXR0ZXIsXG4gICAgICAgIG1hcmtlckVuZFNldHRlcixcbiAgICAgICAgY3MsXG4gICAgICAgIHNuYXAxLFxuICAgICAgICBzbmFwMixcbiAgICAgICAgc2NydWJTY3JvbGxUaW1lLFxuICAgICAgICBzY3J1YlR3ZWVuLFxuICAgICAgICBzY3J1YlNtb290aCxcbiAgICAgICAgc25hcER1ckNsYW1wLFxuICAgICAgICBzbmFwRGVsYXllZENhbGwsXG4gICAgICAgIHByZXZQcm9ncmVzcyxcbiAgICAgICAgcHJldlNjcm9sbCxcbiAgICAgICAgcHJldkFuaW1Qcm9ncmVzcztcblxuICAgIHNlbGYubWVkaWEgPSBfY3JlYXRpbmdNZWRpYTtcbiAgICBhbnRpY2lwYXRlUGluICo9IDQ1O1xuXG4gICAgX3RyaWdnZXJzLnB1c2goc2VsZik7XG5cbiAgICBzZWxmLnNjcm9sbGVyID0gc2Nyb2xsZXI7XG4gICAgc2VsZi5zY3JvbGwgPSBfZ2V0U2Nyb2xsRnVuYyhzY3JvbGxlciwgZGlyZWN0aW9uKTtcbiAgICBzY3JvbGwxID0gc2VsZi5zY3JvbGwoKTtcbiAgICBzZWxmLnZhcnMgPSB2YXJzO1xuICAgIGFuaW1hdGlvbiA9IGFuaW1hdGlvbiB8fCB2YXJzLmFuaW1hdGlvbjtcbiAgICBcInJlZnJlc2hQcmlvcml0eVwiIGluIHZhcnMgJiYgKF9zb3J0ID0gMSk7XG4gICAgc2Nyb2xsZXJDYWNoZS50d2VlblNjcm9sbCA9IHNjcm9sbGVyQ2FjaGUudHdlZW5TY3JvbGwgfHwge1xuICAgICAgdG9wOiBfZ2V0VHdlZW5DcmVhdG9yKHNjcm9sbGVyLCBfdmVydGljYWwpLFxuICAgICAgbGVmdDogX2dldFR3ZWVuQ3JlYXRvcihzY3JvbGxlciwgX2hvcml6b250YWwpXG4gICAgfTtcbiAgICBzZWxmLnR3ZWVuVG8gPSB0d2VlblRvID0gc2Nyb2xsZXJDYWNoZS50d2VlblNjcm9sbFtkaXJlY3Rpb24ucF07XG5cbiAgICBpZiAoYW5pbWF0aW9uKSB7XG4gICAgICBhbmltYXRpb24udmFycy5sYXp5ID0gZmFsc2U7XG4gICAgICBhbmltYXRpb24uX2luaXR0ZWQgfHwgYW5pbWF0aW9uLnZhcnMuaW1tZWRpYXRlUmVuZGVyICE9PSBmYWxzZSAmJiB2YXJzLmltbWVkaWF0ZVJlbmRlciAhPT0gZmFsc2UgJiYgYW5pbWF0aW9uLnJlbmRlcigwLCB0cnVlLCB0cnVlKTtcbiAgICAgIHNlbGYuYW5pbWF0aW9uID0gYW5pbWF0aW9uLnBhdXNlKCk7XG4gICAgICBhbmltYXRpb24uc2Nyb2xsVHJpZ2dlciA9IHNlbGY7XG4gICAgICBzY3J1YlNtb290aCA9IF9pc051bWJlcihzY3J1YikgJiYgc2NydWI7XG4gICAgICBzY3J1YlNtb290aCAmJiAoc2NydWJUd2VlbiA9IGdzYXAudG8oYW5pbWF0aW9uLCB7XG4gICAgICAgIGVhc2U6IFwicG93ZXIzXCIsXG4gICAgICAgIGR1cmF0aW9uOiBzY3J1YlNtb290aCxcbiAgICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24gb25Db21wbGV0ZSgpIHtcbiAgICAgICAgICByZXR1cm4gb25TY3J1YkNvbXBsZXRlICYmIG9uU2NydWJDb21wbGV0ZShzZWxmKTtcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgICAgc25hcDEgPSAwO1xuICAgICAgaWQgfHwgKGlkID0gYW5pbWF0aW9uLnZhcnMuaWQpO1xuICAgIH1cblxuICAgIGlmIChzbmFwKSB7XG4gICAgICBfaXNPYmplY3Qoc25hcCkgfHwgKHNuYXAgPSB7XG4gICAgICAgIHNuYXBUbzogc25hcFxuICAgICAgfSk7XG4gICAgICBnc2FwLnNldChpc1ZpZXdwb3J0ID8gW19ib2R5LCBfZG9jRWxdIDogc2Nyb2xsZXIsIHtcbiAgICAgICAgc2Nyb2xsQmVoYXZpb3I6IFwiYXV0b1wiXG4gICAgICB9KTsgLy8gc21vb3RoIHNjcm9sbGluZyBkb2Vzbid0IHdvcmsgd2l0aCBzbmFwLlxuXG4gICAgICBzbmFwRnVuYyA9IF9pc0Z1bmN0aW9uKHNuYXAuc25hcFRvKSA/IHNuYXAuc25hcFRvIDogc25hcC5zbmFwVG8gPT09IFwibGFiZWxzXCIgPyBfZ2V0TGFiZWxzKGFuaW1hdGlvbikgOiBnc2FwLnV0aWxzLnNuYXAoc25hcC5zbmFwVG8pO1xuICAgICAgc25hcER1ckNsYW1wID0gc25hcC5kdXJhdGlvbiB8fCB7XG4gICAgICAgIG1pbjogMC4xLFxuICAgICAgICBtYXg6IDJcbiAgICAgIH07XG4gICAgICBzbmFwRHVyQ2xhbXAgPSBfaXNPYmplY3Qoc25hcER1ckNsYW1wKSA/IF9jbGFtcChzbmFwRHVyQ2xhbXAubWluLCBzbmFwRHVyQ2xhbXAubWF4KSA6IF9jbGFtcChzbmFwRHVyQ2xhbXAsIHNuYXBEdXJDbGFtcCk7XG4gICAgICBzbmFwRGVsYXllZENhbGwgPSBnc2FwLmRlbGF5ZWRDYWxsKHNuYXAuZGVsYXkgfHwgc2NydWJTbW9vdGggLyAyIHx8IDAuMSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIV9sYXN0U2Nyb2xsVGltZSB8fCBfbGFzdFNjcm9sbFRpbWUgPT09IHNjcnViU2Nyb2xsVGltZSAmJiAhX3BvaW50ZXJJc0Rvd24pIHtcbiAgICAgICAgICB2YXIgdG90YWxQcm9ncmVzcyA9IGFuaW1hdGlvbiAmJiAhaXNUb2dnbGUgPyBhbmltYXRpb24udG90YWxQcm9ncmVzcygpIDogc2VsZi5wcm9ncmVzcyxcbiAgICAgICAgICAgICAgdmVsb2NpdHkgPSAodG90YWxQcm9ncmVzcyAtIHNuYXAyKSAvIChfZ2V0VGltZSgpIC0gX3RpbWUyKSAqIDEwMDAgfHwgMCxcbiAgICAgICAgICAgICAgY2hhbmdlMSA9IF9hYnModmVsb2NpdHkgLyAyKSAqIHZlbG9jaXR5IC8gMC4xODUsXG4gICAgICAgICAgICAgIG5hdHVyYWxFbmQgPSB0b3RhbFByb2dyZXNzICsgY2hhbmdlMSxcbiAgICAgICAgICAgICAgZW5kVmFsdWUgPSBfY2xhbXAoMCwgMSwgc25hcEZ1bmMobmF0dXJhbEVuZCwgc2VsZikpLFxuICAgICAgICAgICAgICBjaGFuZ2UyID0gZW5kVmFsdWUgLSB0b3RhbFByb2dyZXNzIC0gY2hhbmdlMSxcbiAgICAgICAgICAgICAgc2Nyb2xsID0gc2VsZi5zY3JvbGwoKSxcbiAgICAgICAgICAgICAgZW5kU2Nyb2xsID0gTWF0aC5yb3VuZChzdGFydCArIGVuZFZhbHVlICogY2hhbmdlKSxcbiAgICAgICAgICAgICAgdHdlZW4gPSB0d2VlblRvLnR3ZWVuO1xuXG4gICAgICAgICAgaWYgKHNjcm9sbCA8PSBlbmQgJiYgc2Nyb2xsID49IHN0YXJ0KSB7XG4gICAgICAgICAgICBpZiAodHdlZW4gJiYgIXR3ZWVuLl9pbml0dGVkKSB7XG4gICAgICAgICAgICAgIC8vIHRoZXJlJ3MgYW4gb3ZlcmxhcHBpbmcgc25hcCEgU28gd2UgbXVzdCBmaWd1cmUgb3V0IHdoaWNoIG9uZSBpcyBjbG9zZXIgYW5kIGxldCB0aGF0IHR3ZWVuIGxpdmUuXG4gICAgICAgICAgICAgIGlmICh0d2Vlbi5kYXRhIDw9IE1hdGguYWJzKGVuZFNjcm9sbCAtIHNjcm9sbCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0d2Vlbi5raWxsKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHR3ZWVuVG8oZW5kU2Nyb2xsLCB7XG4gICAgICAgICAgICAgIGR1cmF0aW9uOiBzbmFwRHVyQ2xhbXAoX2FicyhNYXRoLm1heChfYWJzKG5hdHVyYWxFbmQgLSB0b3RhbFByb2dyZXNzKSwgX2FicyhlbmRWYWx1ZSAtIHRvdGFsUHJvZ3Jlc3MpKSAqIDAuMTg1IC8gdmVsb2NpdHkgLyAwLjA1IHx8IDApKSxcbiAgICAgICAgICAgICAgZWFzZTogc25hcC5lYXNlIHx8IFwicG93ZXIzXCIsXG4gICAgICAgICAgICAgIGRhdGE6IE1hdGguYWJzKGVuZFNjcm9sbCAtIHNjcm9sbCksXG4gICAgICAgICAgICAgIC8vIHJlY29yZCB0aGUgZGlzdGFuY2Ugc28gdGhhdCBpZiBhbm90aGVyIHNuYXAgdHdlZW4gb2NjdXJzIChjb25mbGljdCkgd2UgY2FuIHByaW9yaXRpemUgdGhlIGNsb3Nlc3Qgc25hcC5cbiAgICAgICAgICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24gb25Db21wbGV0ZSgpIHtcbiAgICAgICAgICAgICAgICBzbmFwMSA9IHNuYXAyID0gYW5pbWF0aW9uICYmICFpc1RvZ2dsZSA/IGFuaW1hdGlvbi50b3RhbFByb2dyZXNzKCkgOiBzZWxmLnByb2dyZXNzO1xuICAgICAgICAgICAgICAgIG9uU25hcENvbXBsZXRlICYmIG9uU25hcENvbXBsZXRlKHNlbGYpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBzdGFydCArIHRvdGFsUHJvZ3Jlc3MgKiBjaGFuZ2UsIGNoYW5nZTEgKiBjaGFuZ2UsIGNoYW5nZTIgKiBjaGFuZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzbmFwRGVsYXllZENhbGwucmVzdGFydCh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSkucGF1c2UoKTtcbiAgICB9XG5cbiAgICBpZCAmJiAoX2lkc1tpZF0gPSBzZWxmKTtcbiAgICB0cmlnZ2VyID0gc2VsZi50cmlnZ2VyID0gX3RvQXJyYXkodHJpZ2dlciB8fCBwaW4pWzBdO1xuICAgIHBpbiA9IHBpbiA9PT0gdHJ1ZSA/IHRyaWdnZXIgOiBfdG9BcnJheShwaW4pWzBdO1xuICAgIF9pc1N0cmluZyh0b2dnbGVDbGFzcykgJiYgKHRvZ2dsZUNsYXNzID0ge1xuICAgICAgdGFyZ2V0czogdHJpZ2dlcixcbiAgICAgIGNsYXNzTmFtZTogdG9nZ2xlQ2xhc3NcbiAgICB9KTtcblxuICAgIGlmIChwaW4pIHtcbiAgICAgIHBpblNwYWNpbmcgPT09IGZhbHNlIHx8IHBpblNwYWNpbmcgPT09IF9tYXJnaW4gfHwgKHBpblNwYWNpbmcgPSBfZ2V0Q29tcHV0ZWRTdHlsZShwaW4ucGFyZW50Tm9kZSkuZGlzcGxheSA9PT0gXCJmbGV4XCIgPyBmYWxzZSA6IF9wYWRkaW5nKTsgLy8gaWYgdGhlIHBhcmVudCBpcyBkaXNwbGF5OiBmbGV4LCBkb24ndCBhcHBseSBwaW5TcGFjaW5nIGJ5IGRlZmF1bHQuXG5cbiAgICAgIHNlbGYucGluID0gcGluO1xuICAgICAgdmFycy5mb3JjZTNEICE9PSBmYWxzZSAmJiBnc2FwLnNldChwaW4sIHtcbiAgICAgICAgZm9yY2UzRDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBwaW5DYWNoZSA9IGdzYXAuY29yZS5nZXRDYWNoZShwaW4pO1xuXG4gICAgICBpZiAoIXBpbkNhY2hlLnNwYWNlcikge1xuICAgICAgICAvLyByZWNvcmQgdGhlIHNwYWNlciBhbmQgcGluT3JpZ2luYWxTdGF0ZSBvbiB0aGUgY2FjaGUgaW4gY2FzZSBzb21lb25lIHRyaWVzIHBpbm5pbmcgdGhlIHNhbWUgZWxlbWVudCB3aXRoIE1VTFRJUExFIFNjcm9sbFRyaWdnZXJzIC0gd2UgZG9uJ3Qgd2FudCB0byBoYXZlIG11bHRpcGxlIHNwYWNlcnMgb3IgcmVjb3JkIHRoZSBcIm9yaWdpbmFsXCIgcGluIHN0YXRlIGFmdGVyIGl0IGhhcyBhbHJlYWR5IGJlZW4gYWZmZWN0ZWQgYnkgYW5vdGhlciBTY3JvbGxUcmlnZ2VyLlxuICAgICAgICBwaW5DYWNoZS5zcGFjZXIgPSBzcGFjZXIgPSBfZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHNwYWNlci5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcInBpbi1zcGFjZXJcIiArIChpZCA/IFwiIHBpbi1zcGFjZXItXCIgKyBpZCA6IFwiXCIpKTtcbiAgICAgICAgcGluQ2FjaGUucGluU3RhdGUgPSBwaW5PcmlnaW5hbFN0YXRlID0gX2dldFN0YXRlKHBpbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwaW5PcmlnaW5hbFN0YXRlID0gcGluQ2FjaGUucGluU3RhdGU7XG4gICAgICB9XG5cbiAgICAgIHNlbGYuc3BhY2VyID0gc3BhY2VyID0gcGluQ2FjaGUuc3BhY2VyO1xuICAgICAgY3MgPSBfZ2V0Q29tcHV0ZWRTdHlsZShwaW4pO1xuICAgICAgc3BhY2luZ1N0YXJ0ID0gY3NbcGluU3BhY2luZyArIGRpcmVjdGlvbi5vczJdO1xuICAgICAgcGluR2V0dGVyID0gZ3NhcC5nZXRQcm9wZXJ0eShwaW4pO1xuICAgICAgcGluU2V0dGVyID0gZ3NhcC5xdWlja1NldHRlcihwaW4sIGRpcmVjdGlvbi5hLCBfcHgpO1xuICAgICAgcGluLmZpcnN0Q2hpbGQgJiYgIV9tYXhTY3JvbGwocGluLCBkaXJlY3Rpb24pICYmIChwaW4uc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiKTsgLy8gcHJvdGVjdHMgZnJvbSBjb2xsYXBzaW5nIG1hcmdpbnMhXG5cbiAgICAgIF9zd2FwUGluSW4ocGluLCBzcGFjZXIsIGNzKTtcblxuICAgICAgcGluU3RhdGUgPSBfZ2V0U3RhdGUocGluKTtcbiAgICB9XG5cbiAgICBpZiAobWFya2Vycykge1xuICAgICAgbWFya2VyVmFycyA9IF9pc09iamVjdChtYXJrZXJzKSA/IF9zZXREZWZhdWx0cyhtYXJrZXJzLCBfbWFya2VyRGVmYXVsdHMpIDogX21hcmtlckRlZmF1bHRzO1xuICAgICAgbWFya2VyU3RhcnRUcmlnZ2VyID0gX2NyZWF0ZU1hcmtlcihcInNjcm9sbGVyLXN0YXJ0XCIsIGlkLCBzY3JvbGxlciwgZGlyZWN0aW9uLCBtYXJrZXJWYXJzLCAwKTtcbiAgICAgIG1hcmtlckVuZFRyaWdnZXIgPSBfY3JlYXRlTWFya2VyKFwic2Nyb2xsZXItZW5kXCIsIGlkLCBzY3JvbGxlciwgZGlyZWN0aW9uLCBtYXJrZXJWYXJzLCAwLCBtYXJrZXJTdGFydFRyaWdnZXIpO1xuICAgICAgb2Zmc2V0ID0gbWFya2VyU3RhcnRUcmlnZ2VyW1wib2Zmc2V0XCIgKyBkaXJlY3Rpb24ub3AuZDJdO1xuICAgICAgbWFya2VyU3RhcnQgPSBfY3JlYXRlTWFya2VyKFwic3RhcnRcIiwgaWQsIHNjcm9sbGVyLCBkaXJlY3Rpb24sIG1hcmtlclZhcnMsIG9mZnNldCk7XG4gICAgICBtYXJrZXJFbmQgPSBfY3JlYXRlTWFya2VyKFwiZW5kXCIsIGlkLCBzY3JvbGxlciwgZGlyZWN0aW9uLCBtYXJrZXJWYXJzLCBvZmZzZXQpO1xuXG4gICAgICBpZiAoIXVzZUZpeGVkUG9zaXRpb24pIHtcbiAgICAgICAgX21ha2VQb3NpdGlvbmFibGUoc2Nyb2xsZXIpO1xuXG4gICAgICAgIGdzYXAuc2V0KFttYXJrZXJTdGFydFRyaWdnZXIsIG1hcmtlckVuZFRyaWdnZXJdLCB7XG4gICAgICAgICAgZm9yY2UzRDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgbWFya2VyU3RhcnRTZXR0ZXIgPSBnc2FwLnF1aWNrU2V0dGVyKG1hcmtlclN0YXJ0VHJpZ2dlciwgZGlyZWN0aW9uLmEsIF9weCk7XG4gICAgICAgIG1hcmtlckVuZFNldHRlciA9IGdzYXAucXVpY2tTZXR0ZXIobWFya2VyRW5kVHJpZ2dlciwgZGlyZWN0aW9uLmEsIF9weCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZi5yZXZlcnQgPSBmdW5jdGlvbiAocmV2ZXJ0KSB7XG4gICAgICB2YXIgciA9IHJldmVydCAhPT0gZmFsc2UgfHwgIXNlbGYuZW5hYmxlZCxcbiAgICAgICAgICBwcmV2UmVmcmVzaGluZyA9IF9yZWZyZXNoaW5nO1xuXG4gICAgICBpZiAociAhPT0gaXNSZXZlcnRlZCkge1xuICAgICAgICBpZiAocikge1xuICAgICAgICAgIHByZXZTY3JvbGwgPSBNYXRoLm1heChzZWxmLnNjcm9sbCgpLCBzZWxmLnNjcm9sbC5yZWMgfHwgMCk7IC8vIHJlY29yZCB0aGUgc2Nyb2xsIHNvIHdlIGNhbiByZXZlcnQgbGF0ZXIgKHJlcG9zaXRpb25pbmcvcGlubmluZyB0aGluZ3MgY2FuIGFmZmVjdCBzY3JvbGwgcG9zaXRpb24pLiBJbiB0aGUgc3RhdGljIHJlZnJlc2goKSBtZXRob2QsIHdlIGZpcnN0IHJlY29yZCBhbGwgdGhlIHNjcm9sbCBwb3NpdGlvbnMgYXMgYSByZWZlcmVuY2UuXG5cbiAgICAgICAgICBwcmV2UHJvZ3Jlc3MgPSBzZWxmLnByb2dyZXNzO1xuICAgICAgICAgIHByZXZBbmltUHJvZ3Jlc3MgPSBhbmltYXRpb24gJiYgYW5pbWF0aW9uLnByb2dyZXNzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBtYXJrZXJTdGFydCAmJiBbbWFya2VyU3RhcnQsIG1hcmtlckVuZCwgbWFya2VyU3RhcnRUcmlnZ2VyLCBtYXJrZXJFbmRUcmlnZ2VyXS5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgcmV0dXJuIG0uc3R5bGUuZGlzcGxheSA9IHIgPyBcIm5vbmVcIiA6IFwiYmxvY2tcIjtcbiAgICAgICAgfSk7XG4gICAgICAgIF9yZWZyZXNoaW5nID0gMTtcbiAgICAgICAgc2VsZi51cGRhdGUocik7IC8vIG1ha2Ugc3VyZSB0aGUgcGluIGlzIGJhY2sgaW4gaXRzIG9yaWdpbmFsIHBvc2l0aW9uIHNvIHRoYXQgYWxsIHRoZSBtZWFzdXJlbWVudHMgYXJlIGNvcnJlY3QuXG5cbiAgICAgICAgX3JlZnJlc2hpbmcgPSBwcmV2UmVmcmVzaGluZztcbiAgICAgICAgcGluICYmIChyID8gX3N3YXBQaW5PdXQocGluLCBzcGFjZXIsIHBpbk9yaWdpbmFsU3RhdGUpIDogX3N3YXBQaW5JbihwaW4sIHNwYWNlciwgX2dldENvbXB1dGVkU3R5bGUocGluKSwgc3BhY2VyU3RhdGUpKTtcbiAgICAgICAgaXNSZXZlcnRlZCA9IHI7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHNlbGYucmVmcmVzaCA9IGZ1bmN0aW9uIChzb2Z0KSB7XG4gICAgICBpZiAoX3JlZnJlc2hpbmcgfHwgIXNlbGYuZW5hYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChwaW4gJiYgc29mdCAmJiBfbGFzdFNjcm9sbFRpbWUpIHtcbiAgICAgICAgX2FkZExpc3RlbmVyKFNjcm9sbFRyaWdnZXIsIFwic2Nyb2xsRW5kXCIsIF9zb2Z0UmVmcmVzaCk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBfcmVmcmVzaGluZyA9IDE7XG4gICAgICBzY3J1YlR3ZWVuICYmIHNjcnViVHdlZW4ua2lsbCgpO1xuICAgICAgaW52YWxpZGF0ZU9uUmVmcmVzaCAmJiBhbmltYXRpb24gJiYgYW5pbWF0aW9uLnByb2dyZXNzKDApLmludmFsaWRhdGUoKTtcbiAgICAgIGlzUmV2ZXJ0ZWQgfHwgc2VsZi5yZXZlcnQoKTtcblxuICAgICAgdmFyIHNpemUgPSBnZXRTY3JvbGxlclNpemUoKSxcbiAgICAgICAgICBzY3JvbGxlckJvdW5kcyA9IGdldFNjcm9sbGVyT2Zmc2V0cygpLFxuICAgICAgICAgIG1heCA9IF9tYXhTY3JvbGwoc2Nyb2xsZXIsIGRpcmVjdGlvbiksXG4gICAgICAgICAgb2Zmc2V0ID0gMCxcbiAgICAgICAgICBvdGhlclBpbk9mZnNldCA9IDAsXG4gICAgICAgICAgcGFyc2VkRW5kID0gdmFycy5lbmQsXG4gICAgICAgICAgcGFyc2VkRW5kVHJpZ2dlciA9IHZhcnMuZW5kVHJpZ2dlciB8fCB0cmlnZ2VyLFxuICAgICAgICAgIHBhcnNlZFN0YXJ0ID0gdmFycy5zdGFydCB8fCAocGluIHx8ICF0cmlnZ2VyID8gXCIwIDBcIiA6IFwiMCAxMDAlXCIpLFxuICAgICAgICAgIHRyaWdnZXJJbmRleCA9IHRyaWdnZXIgJiYgTWF0aC5tYXgoMCwgX3RyaWdnZXJzLmluZGV4T2Yoc2VsZikpIHx8IDAsXG4gICAgICAgICAgaSA9IHRyaWdnZXJJbmRleCxcbiAgICAgICAgICBjcyxcbiAgICAgICAgICBib3VuZHMsXG4gICAgICAgICAgc2Nyb2xsLFxuICAgICAgICAgIGlzVmVydGljYWwsXG4gICAgICAgICAgb3ZlcnJpZGUsXG4gICAgICAgICAgY3VyVHJpZ2dlcixcbiAgICAgICAgICBjdXJQaW47XG5cbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgLy8gdXNlciBtaWdodCB0cnkgdG8gcGluIHRoZSBzYW1lIGVsZW1lbnQgbW9yZSB0aGFuIG9uY2UsIHNvIHdlIG11c3QgZmluZCBhbnkgcHJpb3IgdHJpZ2dlcnMgd2l0aCB0aGUgc2FtZSBwaW4sIHJldmVydCB0aGVtLCBhbmQgZGV0ZXJtaW5lIGhvdyBsb25nIHRoZXkncmUgcGlubmluZyBzbyB0aGF0IHdlIGNhbiBvZmZzZXQgdGhpbmdzIGFwcHJvcHJpYXRlbHkuIE1ha2Ugc3VyZSB3ZSByZXZlcnQgZnJvbSBsYXN0IHRvIGZpcnN0IHNvIHRoYXQgdGhpbmdzIFwicmV3aW5kXCIgcHJvcGVybHkuXG4gICAgICAgIGN1clBpbiA9IF90cmlnZ2Vyc1tpXS5waW47XG4gICAgICAgIGN1clBpbiAmJiAoY3VyUGluID09PSB0cmlnZ2VyIHx8IGN1clBpbiA9PT0gcGluKSAmJiBfdHJpZ2dlcnNbaV0ucmV2ZXJ0KCk7XG4gICAgICB9XG5cbiAgICAgIHN0YXJ0ID0gX3BhcnNlUG9zaXRpb24ocGFyc2VkU3RhcnQsIHRyaWdnZXIsIHNpemUsIGRpcmVjdGlvbiwgc2VsZi5zY3JvbGwoKSwgbWFya2VyU3RhcnQsIG1hcmtlclN0YXJ0VHJpZ2dlciwgc2VsZiwgc2Nyb2xsZXJCb3VuZHMsIGJvcmRlcldpZHRoLCB1c2VGaXhlZFBvc2l0aW9uLCBtYXgpIHx8IChwaW4gPyAtMC4wMDEgOiAwKTtcbiAgICAgIF9pc0Z1bmN0aW9uKHBhcnNlZEVuZCkgJiYgKHBhcnNlZEVuZCA9IHBhcnNlZEVuZChzZWxmKSk7XG5cbiAgICAgIGlmIChfaXNTdHJpbmcocGFyc2VkRW5kKSAmJiAhcGFyc2VkRW5kLmluZGV4T2YoXCIrPVwiKSkge1xuICAgICAgICBpZiAofnBhcnNlZEVuZC5pbmRleE9mKFwiIFwiKSkge1xuICAgICAgICAgIHBhcnNlZEVuZCA9IChfaXNTdHJpbmcocGFyc2VkU3RhcnQpID8gcGFyc2VkU3RhcnQuc3BsaXQoXCIgXCIpWzBdIDogXCJcIikgKyBwYXJzZWRFbmQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2Zmc2V0ID0gX29mZnNldFRvUHgocGFyc2VkRW5kLnN1YnN0cigyKSwgc2l6ZSk7XG4gICAgICAgICAgcGFyc2VkRW5kID0gX2lzU3RyaW5nKHBhcnNlZFN0YXJ0KSA/IHBhcnNlZFN0YXJ0IDogc3RhcnQgKyBvZmZzZXQ7IC8vIF9wYXJzZVBvc2l0aW9uIHdvbid0IGZhY3RvciBpbiB0aGUgb2Zmc2V0IGlmIHRoZSBzdGFydCBpcyBhIG51bWJlciwgc28gZG8gaXQgaGVyZS5cblxuICAgICAgICAgIHBhcnNlZEVuZFRyaWdnZXIgPSB0cmlnZ2VyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGVuZCA9IE1hdGgubWF4KHN0YXJ0LCBfcGFyc2VQb3NpdGlvbihwYXJzZWRFbmQgfHwgKHBhcnNlZEVuZFRyaWdnZXIgPyBcIjEwMCUgMFwiIDogbWF4KSwgcGFyc2VkRW5kVHJpZ2dlciwgc2l6ZSwgZGlyZWN0aW9uLCBzZWxmLnNjcm9sbCgpICsgb2Zmc2V0LCBtYXJrZXJFbmQsIG1hcmtlckVuZFRyaWdnZXIsIHNlbGYsIHNjcm9sbGVyQm91bmRzLCBib3JkZXJXaWR0aCwgdXNlRml4ZWRQb3NpdGlvbiwgbWF4KSkgfHwgLTAuMDAxO1xuICAgICAgY2hhbmdlID0gZW5kIC0gc3RhcnQgfHwgKHN0YXJ0IC09IDAuMDEpICYmIDAuMDAxO1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgIGkgPSB0cmlnZ2VySW5kZXg7XG5cbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgY3VyVHJpZ2dlciA9IF90cmlnZ2Vyc1tpXTtcbiAgICAgICAgY3VyUGluID0gY3VyVHJpZ2dlci5waW47XG5cbiAgICAgICAgaWYgKGN1clBpbiAmJiBjdXJUcmlnZ2VyLnN0YXJ0IC0gY3VyVHJpZ2dlci5fcGluUHVzaCA8IHN0YXJ0KSB7XG4gICAgICAgICAgY3MgPSBjdXJUcmlnZ2VyLmVuZCAtIGN1clRyaWdnZXIuc3RhcnQ7XG4gICAgICAgICAgY3VyUGluID09PSB0cmlnZ2VyICYmIChvZmZzZXQgKz0gY3MpO1xuICAgICAgICAgIGN1clBpbiA9PT0gcGluICYmIChvdGhlclBpbk9mZnNldCArPSBjcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3RhcnQgKz0gb2Zmc2V0O1xuICAgICAgZW5kICs9IG9mZnNldDtcbiAgICAgIHNlbGYuX3BpblB1c2ggPSBvdGhlclBpbk9mZnNldDtcblxuICAgICAgaWYgKG1hcmtlclN0YXJ0ICYmIG9mZnNldCkge1xuICAgICAgICAvLyBvZmZzZXQgdGhlIG1hcmtlcnMgaWYgbmVjZXNzYXJ5XG4gICAgICAgIGNzID0ge307XG4gICAgICAgIGNzW2RpcmVjdGlvbi5hXSA9IFwiKz1cIiArIG9mZnNldDtcbiAgICAgICAgZ3NhcC5zZXQoW21hcmtlclN0YXJ0LCBtYXJrZXJFbmRdLCBjcyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwaW4pIHtcbiAgICAgICAgY3MgPSBfZ2V0Q29tcHV0ZWRTdHlsZShwaW4pO1xuICAgICAgICBpc1ZlcnRpY2FsID0gZGlyZWN0aW9uID09PSBfdmVydGljYWw7XG4gICAgICAgIHNjcm9sbCA9IHNlbGYuc2Nyb2xsKCk7IC8vIHJlY2FsY3VsYXRlIGJlY2F1c2UgdGhlIHRyaWdnZXJzIGNhbiBhZmZlY3QgdGhlIHNjcm9sbFxuXG4gICAgICAgIHBpblN0YXJ0ID0gcGFyc2VGbG9hdChwaW5HZXR0ZXIoZGlyZWN0aW9uLmEpKSArIG90aGVyUGluT2Zmc2V0O1xuXG4gICAgICAgIF9zd2FwUGluSW4ocGluLCBzcGFjZXIsIGNzKTtcblxuICAgICAgICBwaW5TdGF0ZSA9IF9nZXRTdGF0ZShwaW4pOyAvLyB0cmFuc2Zvcm1zIHdpbGwgaW50ZXJmZXJlIHdpdGggdGhlIHRvcC9sZWZ0L3JpZ2h0L2JvdHRvbSBwbGFjZW1lbnQsIHNvIHJlbW92ZSB0aGVtIHRlbXBvcmFyaWx5LiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKSBmYWN0b3JzIGluIHRyYW5zZm9ybXMuXG5cbiAgICAgICAgYm91bmRzID0gX2dldEJvdW5kcyhwaW4sIHRydWUpO1xuXG4gICAgICAgIGlmIChwaW5TcGFjaW5nKSB7XG4gICAgICAgICAgc3BhY2VyU3RhdGUgPSBbcGluU3BhY2luZyArIGRpcmVjdGlvbi5vczIsIGNoYW5nZSArIG90aGVyUGluT2Zmc2V0ICsgX3B4XTtcbiAgICAgICAgICBzcGFjZXJTdGF0ZS50ID0gc3BhY2VyO1xuICAgICAgICAgIGkgPSBwaW5TcGFjaW5nID09PSBfcGFkZGluZyA/IF9nZXRTaXplKHBpbiwgZGlyZWN0aW9uKSArIGNoYW5nZSArIG90aGVyUGluT2Zmc2V0IDogMDtcbiAgICAgICAgICBpICYmIHNwYWNlclN0YXRlLnB1c2goZGlyZWN0aW9uLmQsIGkgKyBfcHgpOyAvLyBmb3IgYm94LXNpemluZzogYm9yZGVyLWJveCAobXVzdCBpbmNsdWRlIHBhZGRpbmcpLlxuXG4gICAgICAgICAgX3NldFN0YXRlKHNwYWNlclN0YXRlKTtcblxuICAgICAgICAgIHVzZUZpeGVkUG9zaXRpb24gJiYgc2VsZi5zY3JvbGwocHJldlNjcm9sbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXNlRml4ZWRQb3NpdGlvbikge1xuICAgICAgICAgIG92ZXJyaWRlID0ge1xuICAgICAgICAgICAgdG9wOiBib3VuZHMudG9wICsgKGlzVmVydGljYWwgPyBzY3JvbGwgLSBzdGFydCA6IDApICsgX3B4LFxuICAgICAgICAgICAgbGVmdDogYm91bmRzLmxlZnQgKyAoaXNWZXJ0aWNhbCA/IDAgOiBzY3JvbGwgLSBzdGFydCkgKyBfcHgsXG4gICAgICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgICAgICAgICAgcG9zaXRpb246IFwiZml4ZWRcIlxuICAgICAgICAgIH07XG4gICAgICAgICAgb3ZlcnJpZGVbX3dpZHRoXSA9IG92ZXJyaWRlW1wibWF4XCIgKyBfV2lkdGhdID0gTWF0aC5jZWlsKGJvdW5kcy53aWR0aCkgKyBfcHg7XG4gICAgICAgICAgb3ZlcnJpZGVbX2hlaWdodF0gPSBvdmVycmlkZVtcIm1heFwiICsgX0hlaWdodF0gPSBNYXRoLmNlaWwoYm91bmRzLmhlaWdodCkgKyBfcHg7XG4gICAgICAgICAgb3ZlcnJpZGVbX21hcmdpbl0gPSBvdmVycmlkZVtfbWFyZ2luICsgX1RvcF0gPSBvdmVycmlkZVtfbWFyZ2luICsgX1JpZ2h0XSA9IG92ZXJyaWRlW19tYXJnaW4gKyBfQm90dG9tXSA9IG92ZXJyaWRlW19tYXJnaW4gKyBfTGVmdF0gPSBcIjBcIjtcbiAgICAgICAgICBvdmVycmlkZVtfcGFkZGluZ10gPSBjc1tfcGFkZGluZ107XG4gICAgICAgICAgb3ZlcnJpZGVbX3BhZGRpbmcgKyBfVG9wXSA9IGNzW19wYWRkaW5nICsgX1RvcF07XG4gICAgICAgICAgb3ZlcnJpZGVbX3BhZGRpbmcgKyBfUmlnaHRdID0gY3NbX3BhZGRpbmcgKyBfUmlnaHRdO1xuICAgICAgICAgIG92ZXJyaWRlW19wYWRkaW5nICsgX0JvdHRvbV0gPSBjc1tfcGFkZGluZyArIF9Cb3R0b21dO1xuICAgICAgICAgIG92ZXJyaWRlW19wYWRkaW5nICsgX0xlZnRdID0gY3NbX3BhZGRpbmcgKyBfTGVmdF07XG4gICAgICAgICAgcGluQWN0aXZlU3RhdGUgPSBfY29weVN0YXRlKHBpbk9yaWdpbmFsU3RhdGUsIG92ZXJyaWRlLCBwaW5SZXBhcmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYW5pbWF0aW9uKSB7XG4gICAgICAgICAgLy8gdGhlIGFuaW1hdGlvbiBtaWdodCBiZSBhZmZlY3RpbmcgdGhlIHRyYW5zZm9ybSwgc28gd2UgbXVzdCBqdW1wIHRvIHRoZSBlbmQsIGNoZWNrIHRoZSB2YWx1ZSwgYW5kIGNvbXBlbnNhdGUgYWNjb3JkaW5nbHkuIE90aGVyd2lzZSwgd2hlbiBpdCBiZWNvbWVzIHVucGlubmVkLCB0aGUgcGluU2V0dGVyKCkgd2lsbCBnZXQgc2V0IHRvIGEgdmFsdWUgdGhhdCBkb2Vzbid0IGluY2x1ZGUgd2hhdGV2ZXIgdGhlIGFuaW1hdGlvbiBkaWQuXG4gICAgICAgICAgYW5pbWF0aW9uLnByb2dyZXNzKDEsIHRydWUpO1xuICAgICAgICAgIHBpbkNoYW5nZSA9IHBpbkdldHRlcihkaXJlY3Rpb24uYSkgLSBwaW5TdGFydCArIGNoYW5nZSArIG90aGVyUGluT2Zmc2V0O1xuICAgICAgICAgIGNoYW5nZSAhPT0gcGluQ2hhbmdlICYmIHBpbkFjdGl2ZVN0YXRlLnNwbGljZShwaW5BY3RpdmVTdGF0ZS5sZW5ndGggLSAyLCAyKTsgLy8gdHJhbnNmb3JtIGlzIHRoZSBsYXN0IHByb3BlcnR5L3ZhbHVlIHNldCBpbiB0aGUgc3RhdGUgQXJyYXkuIFNpbmNlIHRoZSBhbmltYXRpb24gaXMgY29udHJvbGxpbmcgdGhhdCwgd2Ugc2hvdWxkIG9taXQgaXQuXG5cbiAgICAgICAgICBhbmltYXRpb24ucHJvZ3Jlc3MoMCwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGluQ2hhbmdlID0gY2hhbmdlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRyaWdnZXIgJiYgc2VsZi5zY3JvbGwoKSkge1xuICAgICAgICAvLyBpdCBtYXkgYmUgSU5TSURFIGEgcGlubmVkIGVsZW1lbnQsIHNvIHdhbGsgdXAgdGhlIHRyZWUgYW5kIGxvb2sgZm9yIGFueSBlbGVtZW50cyB3aXRoIF9waW5PZmZzZXQgdG8gY29tcGVuc2F0ZSBiZWNhdXNlIGFueXRoaW5nIHdpdGggcGluU3BhY2luZyB0aGF0J3MgYWxyZWFkeSBzY3JvbGxlZCB3b3VsZCB0aHJvdyBvZmYgdGhlIG1lYXN1cmVtZW50cyBpbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgICBib3VuZHMgPSB0cmlnZ2VyLnBhcmVudE5vZGU7XG5cbiAgICAgICAgd2hpbGUgKGJvdW5kcyAmJiBib3VuZHMgIT09IF9ib2R5KSB7XG4gICAgICAgICAgaWYgKGJvdW5kcy5fcGluT2Zmc2V0KSB7XG4gICAgICAgICAgICBzdGFydCAtPSBib3VuZHMuX3Bpbk9mZnNldDtcbiAgICAgICAgICAgIGVuZCAtPSBib3VuZHMuX3Bpbk9mZnNldDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBib3VuZHMgPSBib3VuZHMucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdHJpZ2dlckluZGV4OyBpKyspIHtcbiAgICAgICAgLy8gbWFrZSBzdXJlIHdlIHJldmVydCBmcm9tIGZpcnN0IHRvIGxhc3QgdG8gbWFrZSBzdXJlIHRoaW5ncyByZWFjaCB0aGVpciBlbmQgc3RhdGUgcHJvcGVybHlcbiAgICAgICAgY3VyVHJpZ2dlciA9IF90cmlnZ2Vyc1tpXS5waW47XG4gICAgICAgIGN1clRyaWdnZXIgJiYgKGN1clRyaWdnZXIgPT09IHRyaWdnZXIgfHwgY3VyVHJpZ2dlciA9PT0gcGluKSAmJiBfdHJpZ2dlcnNbaV0ucmV2ZXJ0KGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgc2VsZi5zdGFydCA9IHN0YXJ0O1xuICAgICAgc2VsZi5lbmQgPSBlbmQ7XG4gICAgICBzY3JvbGwxID0gc2Nyb2xsMiA9IHNlbGYuc2Nyb2xsKCk7IC8vIHJlc2V0IHZlbG9jaXR5XG5cbiAgICAgIHNjcm9sbDEgPCBwcmV2U2Nyb2xsICYmIHNlbGYuc2Nyb2xsKHByZXZTY3JvbGwpO1xuICAgICAgc2VsZi5yZXZlcnQoZmFsc2UpO1xuICAgICAgX3JlZnJlc2hpbmcgPSAwO1xuICAgICAgcHJldkFuaW1Qcm9ncmVzcyAmJiBpc1RvZ2dsZSAmJiBhbmltYXRpb24ucHJvZ3Jlc3MocHJldkFuaW1Qcm9ncmVzcywgdHJ1ZSk7XG5cbiAgICAgIGlmIChwcmV2UHJvZ3Jlc3MgIT09IHNlbGYucHJvZ3Jlc3MpIHtcbiAgICAgICAgLy8gZW5zdXJlcyB0aGF0IHRoZSBkaXJlY3Rpb24gaXMgc2V0IHByb3Blcmx5ICh3aGVuIHJlZnJlc2hpbmcsIHByb2dyZXNzIGlzIHNldCBiYWNrIHRvIDAgaW5pdGlhbGx5LCB0aGVuIGJhY2sgYWdhaW4gdG8gd2hlcmV2ZXIgaXQgbmVlZHMgdG8gYmUpIGFuZCB0aGF0IGNhbGxiYWNrcyBhcmUgdHJpZ2dlcmVkLlxuICAgICAgICBzY3J1YlR3ZWVuICYmIGFuaW1hdGlvbi50b3RhbFByb2dyZXNzKHByZXZQcm9ncmVzcywgdHJ1ZSk7IC8vIHRvIGF2b2lkIGlzc3VlcyB3aGVyZSBhbmltYXRpb24gY2FsbGJhY2tzIGxpa2Ugb25TdGFydCBhcmVuJ3QgdHJpZ2dlcmVkLlxuXG4gICAgICAgIHNlbGYucHJvZ3Jlc3MgPSBwcmV2UHJvZ3Jlc3M7XG4gICAgICAgIHNlbGYudXBkYXRlKCk7XG4gICAgICB9XG5cbiAgICAgIHBpbiAmJiBwaW5TcGFjaW5nICYmIChzcGFjZXIuX3Bpbk9mZnNldCA9IE1hdGgucm91bmQoc2VsZi5wcm9ncmVzcyAqIHBpbkNoYW5nZSkpO1xuICAgICAgb25SZWZyZXNoICYmIG9uUmVmcmVzaChzZWxmKTtcbiAgICB9O1xuXG4gICAgc2VsZi5nZXRWZWxvY2l0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoc2VsZi5zY3JvbGwoKSAtIHNjcm9sbDIpIC8gKF9nZXRUaW1lKCkgLSBfdGltZTIpICogMTAwMCB8fCAwO1xuICAgIH07XG5cbiAgICBzZWxmLnVwZGF0ZSA9IGZ1bmN0aW9uIChyZXNldCwgcmVjb3JkVmVsb2NpdHkpIHtcbiAgICAgIHZhciBzY3JvbGwgPSBzZWxmLnNjcm9sbCgpLFxuICAgICAgICAgIHAgPSByZXNldCA/IDAgOiAoc2Nyb2xsIC0gc3RhcnQpIC8gY2hhbmdlLFxuICAgICAgICAgIGNsaXBwZWQgPSBwIDwgMCA/IDAgOiBwID4gMSA/IDEgOiBwIHx8IDAsXG4gICAgICAgICAgcHJldlByb2dyZXNzID0gc2VsZi5wcm9ncmVzcyxcbiAgICAgICAgICBpc0FjdGl2ZSxcbiAgICAgICAgICB3YXNBY3RpdmUsXG4gICAgICAgICAgdG9nZ2xlU3RhdGUsXG4gICAgICAgICAgYWN0aW9uLFxuICAgICAgICAgIHN0YXRlQ2hhbmdlZCxcbiAgICAgICAgICB0b2dnbGVkO1xuXG4gICAgICBpZiAocmVjb3JkVmVsb2NpdHkpIHtcbiAgICAgICAgc2Nyb2xsMiA9IHNjcm9sbDE7XG4gICAgICAgIHNjcm9sbDEgPSBzY3JvbGw7XG5cbiAgICAgICAgaWYgKHNuYXApIHtcbiAgICAgICAgICBzbmFwMiA9IHNuYXAxO1xuICAgICAgICAgIHNuYXAxID0gYW5pbWF0aW9uICYmICFpc1RvZ2dsZSA/IGFuaW1hdGlvbi50b3RhbFByb2dyZXNzKCkgOiBjbGlwcGVkO1xuICAgICAgICB9XG4gICAgICB9IC8vIGFudGljaXBhdGUgdGhlIHBpbm5pbmcgYSBmZXcgdGlja3MgYWhlYWQgb2YgdGltZSBiYXNlZCBvbiB2ZWxvY2l0eSB0byBhdm9pZCBhIHZpc3VhbCBnbGl0Y2ggZHVlIHRvIHRoZSBmYWN0IHRoYXQgbW9zdCBicm93c2VycyBkbyBzY3JvbGxpbmcgb24gYSBzZXBhcmF0ZSB0aHJlYWQgKG5vdCBzeW5jZWQgd2l0aCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUpLlxuXG5cbiAgICAgIGFudGljaXBhdGVQaW4gJiYgIWNsaXBwZWQgJiYgcGluICYmICFfcmVmcmVzaGluZyAmJiAhX3N0YXJ0dXAgJiYgX2xhc3RTY3JvbGxUaW1lICYmIHN0YXJ0IDwgc2Nyb2xsICsgKHNjcm9sbCAtIHNjcm9sbDIpIC8gKF9nZXRUaW1lKCkgLSBfdGltZTIpICogYW50aWNpcGF0ZVBpbiAmJiAoY2xpcHBlZCA9IDAuMDAwMSk7XG5cbiAgICAgIGlmIChjbGlwcGVkICE9PSBwcmV2UHJvZ3Jlc3MgJiYgc2VsZi5lbmFibGVkKSB7XG4gICAgICAgIGlzQWN0aXZlID0gc2VsZi5pc0FjdGl2ZSA9ICEhY2xpcHBlZCAmJiBjbGlwcGVkIDwgMTtcbiAgICAgICAgd2FzQWN0aXZlID0gISFwcmV2UHJvZ3Jlc3MgJiYgcHJldlByb2dyZXNzIDwgMTtcbiAgICAgICAgdG9nZ2xlZCA9IGlzQWN0aXZlICE9PSB3YXNBY3RpdmU7XG4gICAgICAgIHN0YXRlQ2hhbmdlZCA9IHRvZ2dsZWQgfHwgISFjbGlwcGVkICE9PSAhIXByZXZQcm9ncmVzczsgLy8gY291bGQgZ28gZnJvbSBzdGFydCBhbGwgdGhlIHdheSB0byBlbmQsIHRodXMgaXQgZGlkbid0IHRvZ2dsZSBidXQgaXQgZGlkIGNoYW5nZSBzdGF0ZSBpbiBhIHNlbnNlIChtYXkgbmVlZCB0byBmaXJlIGEgY2FsbGJhY2spXG5cbiAgICAgICAgc2VsZi5kaXJlY3Rpb24gPSBjbGlwcGVkID4gcHJldlByb2dyZXNzID8gMSA6IC0xO1xuICAgICAgICBzZWxmLnByb2dyZXNzID0gY2xpcHBlZDtcblxuICAgICAgICBpZiAoIWlzVG9nZ2xlKSB7XG4gICAgICAgICAgaWYgKHNjcnViVHdlZW4gJiYgIV9yZWZyZXNoaW5nICYmICFfc3RhcnR1cCkge1xuICAgICAgICAgICAgc2NydWJUd2Vlbi52YXJzLnRvdGFsUHJvZ3Jlc3MgPSBjbGlwcGVkO1xuICAgICAgICAgICAgc2NydWJUd2Vlbi5pbnZhbGlkYXRlKCkucmVzdGFydCgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYW5pbWF0aW9uKSB7XG4gICAgICAgICAgICBhbmltYXRpb24udG90YWxQcm9ncmVzcyhjbGlwcGVkLCAhIV9yZWZyZXNoaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGluKSB7XG4gICAgICAgICAgcmVzZXQgJiYgcGluU3BhY2luZyAmJiAoc3BhY2VyLnN0eWxlW3BpblNwYWNpbmcgKyBkaXJlY3Rpb24ub3MyXSA9IHNwYWNpbmdTdGFydCk7XG5cbiAgICAgICAgICBpZiAoIXVzZUZpeGVkUG9zaXRpb24pIHtcbiAgICAgICAgICAgIHBpblNldHRlcihwaW5TdGFydCArIHBpbkNoYW5nZSAqIGNsaXBwZWQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGVDaGFuZ2VkKSB7XG4gICAgICAgICAgICBhY3Rpb24gPSAhcmVzZXQgJiYgY2xpcHBlZCA+IHByZXZQcm9ncmVzcyAmJiBlbmQgKyAxID4gc2Nyb2xsICYmIHNjcm9sbCArIDEgPj0gX21heFNjcm9sbChzY3JvbGxlciwgZGlyZWN0aW9uKTsgLy8gaWYgaXQncyBhdCB0aGUgVkVSWSBlbmQgb2YgdGhlIHBhZ2UsIGRvbid0IHN3aXRjaCBhd2F5IGZyb20gcG9zaXRpb246IGZpeGVkIGJlY2F1c2UgaXQncyBwb2ludGxlc3MgYW5kIGl0IGNvdWxkIGNhdXNlIGEgYnJpZWYgZmxhc2ggd2hlbiB0aGUgdXNlciBzY3JvbGxzIGJhY2sgdXAgKHdoZW4gaXQgZ2V0cyBwaW5uZWQgYWdhaW4pXG5cbiAgICAgICAgICAgIGlmIChwaW5SZXBhcmVudCkge1xuICAgICAgICAgICAgICBpZiAoIV9yZWZyZXNoaW5nICYmIChpc0FjdGl2ZSB8fCBhY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJvdW5kcyA9IF9nZXRCb3VuZHMocGluLCB0cnVlKSxcbiAgICAgICAgICAgICAgICAgICAgX29mZnNldCA9IHNjcm9sbCAtIHN0YXJ0O1xuXG4gICAgICAgICAgICAgICAgcGluLnN0eWxlLnRvcCA9IGJvdW5kcy50b3AgKyAoZGlyZWN0aW9uID09PSBfdmVydGljYWwgPyBfb2Zmc2V0IDogMCkgKyBfcHg7XG4gICAgICAgICAgICAgICAgcGluLnN0eWxlLmxlZnQgPSBib3VuZHMubGVmdCArIChkaXJlY3Rpb24gPT09IF92ZXJ0aWNhbCA/IDAgOiBfb2Zmc2V0KSArIF9weDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIF9yZXBhcmVudChwaW4sICFfcmVmcmVzaGluZyAmJiAoaXNBY3RpdmUgfHwgYWN0aW9uKSA/IF9ib2R5IDogc3BhY2VyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX3NldFN0YXRlKGlzQWN0aXZlIHx8IGFjdGlvbiA/IHBpbkFjdGl2ZVN0YXRlIDogcGluU3RhdGUpO1xuXG4gICAgICAgICAgICBwaW5DaGFuZ2UgIT09IGNoYW5nZSAmJiBjbGlwcGVkIDwgMSAmJiBpc0FjdGl2ZSB8fCBwaW5TZXR0ZXIocGluU3RhcnQgKyAoY2xpcHBlZCA9PT0gMSAmJiAhYWN0aW9uID8gcGluQ2hhbmdlIDogMCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzbmFwICYmICF0d2VlblRvLnR3ZWVuICYmICFfcmVmcmVzaGluZyAmJiAhX3N0YXJ0dXApIHtcbiAgICAgICAgICBzY3J1YlNjcm9sbFRpbWUgPSBfbGFzdFNjcm9sbFRpbWU7XG4gICAgICAgICAgc25hcERlbGF5ZWRDYWxsLnJlc3RhcnQodHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0b2dnbGVDbGFzcyAmJiB0b2dnbGVkICYmICghb25jZSB8fCBpc0FjdGl2ZSkgJiYgX3RvQXJyYXkodG9nZ2xlQ2xhc3MudGFyZ2V0cykuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICByZXR1cm4gZWwuY2xhc3NMaXN0W2lzQWN0aXZlID8gXCJhZGRcIiA6IFwicmVtb3ZlXCJdKHRvZ2dsZUNsYXNzLmNsYXNzTmFtZSk7XG4gICAgICAgIH0pOyAvLyBjbGFzc2VzIGNvdWxkIGFmZmVjdCBwb3NpdGlvbmluZywgc28gZG8gaXQgZXZlbiBpZiByZXNldCBvciByZWZyZXNoaW5nIGlzIHRydWUuXG5cbiAgICAgICAgb25VcGRhdGUgJiYgIWlzVG9nZ2xlICYmICFyZXNldCAmJiBvblVwZGF0ZShzZWxmKTtcblxuICAgICAgICBpZiAoc3RhdGVDaGFuZ2VkICYmICFfcmVmcmVzaGluZykge1xuICAgICAgICAgIHRvZ2dsZVN0YXRlID0gY2xpcHBlZCAmJiAhcHJldlByb2dyZXNzID8gMCA6IGNsaXBwZWQgPT09IDEgPyAxIDogcHJldlByb2dyZXNzID09PSAxID8gMiA6IDM7IC8vIDAgPSBlbnRlciwgMSA9IGxlYXZlLCAyID0gZW50ZXJCYWNrLCAzID0gbGVhdmVCYWNrICh3ZSBwcmlvcml0aXplIHRoZSBGSVJTVCBlbmNvdW50ZXIsIHRodXMgaWYgeW91IHNjcm9sbCByZWFsbHkgZmFzdCBwYXN0IHRoZSBvbkVudGVyIGFuZCBvbkxlYXZlIGluIG9uZSB0aWNrLCBpdCdkIHByaW9yaXRpemUgb25FbnRlci5cblxuICAgICAgICAgIGlmIChpc1RvZ2dsZSkge1xuICAgICAgICAgICAgYWN0aW9uID0gIXRvZ2dsZWQgJiYgdG9nZ2xlQWN0aW9uc1t0b2dnbGVTdGF0ZSArIDFdICE9PSBcIm5vbmVcIiAmJiB0b2dnbGVBY3Rpb25zW3RvZ2dsZVN0YXRlICsgMV0gfHwgdG9nZ2xlQWN0aW9uc1t0b2dnbGVTdGF0ZV07IC8vIGlmIGl0IGRpZG4ndCB0b2dnbGUsIHRoYXQgbWVhbnMgaXQgc2hvdCByaWdodCBwYXN0IGFuZCBzaW5jZSB3ZSBwcmlvcml0aXplIHRoZSBcImVudGVyXCIgYWN0aW9uLCB3ZSBzaG91bGQgc3dpdGNoIHRvIHRoZSBcImxlYXZlXCIgaW4gdGhpcyBjYXNlIChidXQgb25seSBpZiBvbmUgaXMgZGVmaW5lZClcblxuICAgICAgICAgICAgaWYgKGFuaW1hdGlvbiAmJiAoYWN0aW9uID09PSBcImNvbXBsZXRlXCIgfHwgYWN0aW9uID09PSBcInJlc2V0XCIgfHwgYWN0aW9uIGluIGFuaW1hdGlvbikpIHtcbiAgICAgICAgICAgICAgaWYgKGFjdGlvbiA9PT0gXCJjb21wbGV0ZVwiKSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uLnBhdXNlKCkudG90YWxQcm9ncmVzcygxKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChhY3Rpb24gPT09IFwicmVzZXRcIikge1xuICAgICAgICAgICAgICAgIGFuaW1hdGlvbi5yZXN0YXJ0KHRydWUpLnBhdXNlKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uW2FjdGlvbl0oKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvblVwZGF0ZSAmJiBvblVwZGF0ZShzZWxmKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodG9nZ2xlZCB8fCAhX2xpbWl0Q2FsbGJhY2tzKSB7XG4gICAgICAgICAgICAvLyBvbiBzdGFydHVwLCB0aGUgcGFnZSBjb3VsZCBiZSBzY3JvbGxlZCBhbmQgd2UgZG9uJ3Qgd2FudCB0byBmaXJlIGNhbGxiYWNrcyB0aGF0IGRpZG4ndCB0b2dnbGUuIEZvciBleGFtcGxlIG9uRW50ZXIgc2hvdWxkbid0IGZpcmUgaWYgdGhlIFNjcm9sbFRyaWdnZXIgaXNuJ3QgYWN0dWFsbHkgZW50ZXJlZC5cbiAgICAgICAgICAgIG9uVG9nZ2xlICYmIHRvZ2dsZWQgJiYgb25Ub2dnbGUoc2VsZik7XG4gICAgICAgICAgICBjYWxsYmFja3NbdG9nZ2xlU3RhdGVdICYmIGNhbGxiYWNrc1t0b2dnbGVTdGF0ZV0oc2VsZik7XG4gICAgICAgICAgICBvbmNlICYmIChjbGlwcGVkID09PSAxID8gc2VsZi5raWxsKGZhbHNlLCAxKSA6IGNhbGxiYWNrc1t0b2dnbGVTdGF0ZV0gPSAwKTsgLy8gYSBjYWxsYmFjayBzaG91bGRuJ3QgYmUgY2FsbGVkIGFnYWluIGlmIG9uY2UgaXMgdHJ1ZS5cblxuICAgICAgICAgICAgaWYgKCF0b2dnbGVkKSB7XG4gICAgICAgICAgICAgIC8vIGl0J3MgcG9zc2libGUgdG8gZ28gY29tcGxldGVseSBwYXN0LCBsaWtlIGZyb20gYmVmb3JlIHRoZSBzdGFydCB0byBhZnRlciB0aGUgZW5kIChvciB2aWNlLXZlcnNhKSBpbiB3aGljaCBjYXNlIEJPVEggY2FsbGJhY2tzIHNob3VsZCBiZSBmaXJlZCBpbiB0aGF0IG9yZGVyXG4gICAgICAgICAgICAgIHRvZ2dsZVN0YXRlID0gY2xpcHBlZCA9PT0gMSA/IDEgOiAzO1xuICAgICAgICAgICAgICBjYWxsYmFja3NbdG9nZ2xlU3RhdGVdICYmIGNhbGxiYWNrc1t0b2dnbGVTdGF0ZV0oc2VsZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGlzVG9nZ2xlICYmIG9uVXBkYXRlICYmICFfcmVmcmVzaGluZykge1xuICAgICAgICAgIG9uVXBkYXRlKHNlbGYpO1xuICAgICAgICB9XG4gICAgICB9IC8vIHVwZGF0ZSBhYnNvbHV0ZWx5LXBvc2l0aW9uZWQgbWFya2VycyAob25seSBpZiB0aGUgc2Nyb2xsZXIgaXNuJ3QgdGhlIHZpZXdwb3J0KVxuXG5cbiAgICAgIGlmIChtYXJrZXJFbmRTZXR0ZXIpIHtcbiAgICAgICAgbWFya2VyU3RhcnRTZXR0ZXIoc2Nyb2xsICsgKG1hcmtlclN0YXJ0VHJpZ2dlci5faXNGbGlwcGVkID8gMSA6IDApKTtcbiAgICAgICAgbWFya2VyRW5kU2V0dGVyKHNjcm9sbCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHNlbGYuZW5hYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzZWxmLmVuYWJsZWQpIHtcbiAgICAgICAgc2VsZi5lbmFibGVkID0gdHJ1ZTtcblxuICAgICAgICBfYWRkTGlzdGVuZXIoc2Nyb2xsZXIsIFwicmVzaXplXCIsIF9vblJlc2l6ZSk7XG5cbiAgICAgICAgX2FkZExpc3RlbmVyKHNjcm9sbGVyLCBcInNjcm9sbFwiLCBfb25TY3JvbGwpO1xuXG4gICAgICAgIG9uUmVmcmVzaEluaXQgJiYgX2FkZExpc3RlbmVyKFNjcm9sbFRyaWdnZXIsIFwicmVmcmVzaEluaXRcIiwgb25SZWZyZXNoSW5pdCk7XG4gICAgICAgICFhbmltYXRpb24gfHwgIWFuaW1hdGlvbi5hZGQgPyBzZWxmLnJlZnJlc2goKSA6IGdzYXAuZGVsYXllZENhbGwoMC4wMSwgc2VsZi5yZWZyZXNoKSAmJiAoY2hhbmdlID0gMC4wMSkgJiYgKHN0YXJ0ID0gZW5kID0gMCk7IC8vIGlmIHRoZSBhbmltYXRpb24gaXMgYSB0aW1lbGluZSwgaXQgbWF5IG5vdCBoYXZlIGJlZW4gcG9wdWxhdGVkIHlldCwgc28gaXQgd291bGRuJ3QgcmVuZGVyIGF0IHRoZSBwcm9wZXIgcGxhY2Ugb24gdGhlIGZpcnN0IHJlZnJlc2goKSwgdGh1cyB3ZSBzaG91bGQgc2NoZWR1bGUgb25lIGZvciB0aGUgbmV4dCB0aWNrLlxuICAgICAgfVxuICAgIH07XG5cbiAgICBzZWxmLmRpc2FibGUgPSBmdW5jdGlvbiAocmVzZXQsIGFsbG93U2NydWIpIHtcbiAgICAgIGlmIChzZWxmLmVuYWJsZWQpIHtcbiAgICAgICAgcmVzZXQgIT09IGZhbHNlICYmIHNlbGYucmV2ZXJ0KCk7XG4gICAgICAgIHNlbGYuZW5hYmxlZCA9IHNlbGYuaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgYWxsb3dTY3J1YiB8fCBzY3J1YlR3ZWVuICYmIHNjcnViVHdlZW4ucGF1c2UoKTtcbiAgICAgICAgcHJldlNjcm9sbCA9IDA7XG4gICAgICAgIHBpbkNhY2hlICYmIChwaW5DYWNoZS51bmNhY2hlID0gMSk7XG4gICAgICAgIG9uUmVmcmVzaEluaXQgJiYgX3JlbW92ZUxpc3RlbmVyKFNjcm9sbFRyaWdnZXIsIFwicmVmcmVzaEluaXRcIiwgb25SZWZyZXNoSW5pdCk7XG5cbiAgICAgICAgaWYgKHNuYXBEZWxheWVkQ2FsbCkge1xuICAgICAgICAgIHNuYXBEZWxheWVkQ2FsbC5wYXVzZSgpO1xuICAgICAgICAgIHR3ZWVuVG8udHdlZW4gJiYgdHdlZW5Uby50d2Vlbi5raWxsKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzVmlld3BvcnQpIHtcbiAgICAgICAgICB2YXIgaSA9IF90cmlnZ2Vycy5sZW5ndGg7XG5cbiAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICBpZiAoX3RyaWdnZXJzW2ldLnNjcm9sbGVyID09PSBzY3JvbGxlciAmJiBfdHJpZ2dlcnNbaV0gIT09IHNlbGYpIHtcbiAgICAgICAgICAgICAgcmV0dXJuOyAvL2Rvbid0IHJlbW92ZSB0aGUgbGlzdGVuZXJzIGlmIHRoZXJlIGFyZSBzdGlsbCBvdGhlciB0cmlnZ2VycyByZWZlcmVuY2luZyBpdC5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfcmVtb3ZlTGlzdGVuZXIoc2Nyb2xsZXIsIFwicmVzaXplXCIsIF9vblJlc2l6ZSk7XG5cbiAgICAgICAgICBfcmVtb3ZlTGlzdGVuZXIoc2Nyb2xsZXIsIFwic2Nyb2xsXCIsIF9vblNjcm9sbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgc2VsZi5raWxsID0gZnVuY3Rpb24gKHJldmVydCwgYWxsb3dTY3J1Yikge1xuICAgICAgc2VsZi5kaXNhYmxlKHJldmVydCwgYWxsb3dTY3J1Yik7XG4gICAgICBpZCAmJiBkZWxldGUgX2lkc1tpZF07XG5cbiAgICAgIHZhciBpID0gX3RyaWdnZXJzLmluZGV4T2Yoc2VsZik7XG5cbiAgICAgIF90cmlnZ2Vycy5zcGxpY2UoaSwgMSk7XG5cbiAgICAgIGkgPT09IF9pICYmIF9kaXJlY3Rpb24gPiAwICYmIF9pLS07IC8vIGlmIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSByZWZyZXNoKCkgb3IgdXBkYXRlKCksIHNwbGljaW5nIHdvdWxkIGNhdXNlIHNraXBzIGluIHRoZSBpbmRleCwgc28gYWRqdXN0Li4uXG5cbiAgICAgIGlmIChhbmltYXRpb24pIHtcbiAgICAgICAgYW5pbWF0aW9uLnNjcm9sbFRyaWdnZXIgPSBudWxsO1xuICAgICAgICByZXZlcnQgJiYgYW5pbWF0aW9uLnJlbmRlcigtMSk7XG4gICAgICAgIGFsbG93U2NydWIgJiYgc2NydWJUd2VlbiB8fCBhbmltYXRpb24ua2lsbCgpO1xuICAgICAgfVxuXG4gICAgICBtYXJrZXJTdGFydCAmJiBbbWFya2VyU3RhcnQsIG1hcmtlckVuZCwgbWFya2VyU3RhcnRUcmlnZ2VyLCBtYXJrZXJFbmRUcmlnZ2VyXS5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgIHJldHVybiBtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobSk7XG4gICAgICB9KTtcbiAgICAgIHBpbkNhY2hlICYmIChwaW5DYWNoZS51bmNhY2hlID0gMSk7XG4gICAgfTtcblxuICAgIHNlbGYuZW5hYmxlKCk7XG4gIH07XG5cbiAgU2Nyb2xsVHJpZ2dlci5yZWdpc3RlciA9IGZ1bmN0aW9uIHJlZ2lzdGVyKGNvcmUpIHtcbiAgICBpZiAoIV9jb3JlSW5pdHRlZCkge1xuICAgICAgZ3NhcCA9IGNvcmUgfHwgX2dldEdTQVAoKTtcblxuICAgICAgaWYgKF93aW5kb3dFeGlzdHMoKSAmJiB3aW5kb3cuZG9jdW1lbnQpIHtcbiAgICAgICAgX3dpbiA9IHdpbmRvdztcbiAgICAgICAgX2RvYyA9IGRvY3VtZW50O1xuICAgICAgICBfZG9jRWwgPSBfZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgX2JvZHkgPSBfZG9jLmJvZHk7XG4gICAgICB9XG5cbiAgICAgIGlmIChnc2FwKSB7XG4gICAgICAgIF90b0FycmF5ID0gZ3NhcC51dGlscy50b0FycmF5O1xuICAgICAgICBfY2xhbXAgPSBnc2FwLnV0aWxzLmNsYW1wO1xuICAgICAgICBnc2FwLmNvcmUuZ2xvYmFscyhcIlNjcm9sbFRyaWdnZXJcIiwgU2Nyb2xsVHJpZ2dlcik7IC8vIG11c3QgcmVnaXN0ZXIgdGhlIGdsb2JhbCBtYW51YWxseSBiZWNhdXNlIGluIEludGVybmV0IEV4cGxvcmVyLCBmdW5jdGlvbnMgKGNsYXNzZXMpIGRvbid0IGhhdmUgYSBcIm5hbWVcIiBwcm9wZXJ0eS5cblxuICAgICAgICBpZiAoX2JvZHkpIHtcbiAgICAgICAgICBfcmFmID0gX3dpbi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGYsIDE2KTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgX2FkZExpc3RlbmVyKF93aW4sIFwibW91c2V3aGVlbFwiLCBfb25TY3JvbGwpO1xuXG4gICAgICAgICAgX3Jvb3QgPSBbX3dpbiwgX2RvYywgX2RvY0VsLCBfYm9keV07XG5cbiAgICAgICAgICBfYWRkTGlzdGVuZXIoX2RvYywgXCJzY3JvbGxcIiwgX29uU2Nyb2xsKTsgLy8gc29tZSBicm93c2VycyAobGlrZSBDaHJvbWUpLCB0aGUgd2luZG93IHN0b3BzIGRpc3BhdGNoaW5nIHNjcm9sbCBldmVudHMgb24gdGhlIHdpbmRvdyBpZiB5b3Ugc2Nyb2xsIHJlYWxseSBmYXN0LCBidXQgaXQncyBjb25zaXN0ZW50IG9uIHRoZSBkb2N1bWVudCFcblxuXG4gICAgICAgICAgdmFyIGJvZHlTdHlsZSA9IF9ib2R5LnN0eWxlLFxuICAgICAgICAgICAgICBib3JkZXIgPSBib2R5U3R5bGUuYm9yZGVyVG9wLFxuICAgICAgICAgICAgICBib3VuZHM7XG4gICAgICAgICAgYm9keVN0eWxlLmJvcmRlclRvcCA9IFwiMXB4IHNvbGlkICMwMDBcIjsgLy8gd29ya3MgYXJvdW5kIGFuIGlzc3VlIHdoZXJlIGEgbWFyZ2luIG9mIGEgY2hpbGQgZWxlbWVudCBjb3VsZCB0aHJvdyBvZmYgdGhlIGJvdW5kcyBvZiB0aGUgX2JvZHksIG1ha2luZyBpdCBzZWVtIGxpa2UgdGhlcmUncyBhIG1hcmdpbiB3aGVuIHRoZXJlIGFjdHVhbGx5IGlzbid0LiBUaGUgYm9yZGVyIGVuc3VyZXMgdGhhdCB0aGUgYm91bmRzIGFyZSBhY2N1cmF0ZS5cblxuICAgICAgICAgIGJvdW5kcyA9IF9nZXRCb3VuZHMoX2JvZHkpO1xuICAgICAgICAgIF92ZXJ0aWNhbC5tID0gTWF0aC5yb3VuZChib3VuZHMudG9wICsgX3ZlcnRpY2FsLnNjKCkpIHx8IDA7IC8vIGFjY29tbW9kYXRlIHRoZSBvZmZzZXQgb2YgdGhlIDxib2R5PiBjYXVzZWQgYnkgbWFyZ2lucyBhbmQvb3IgcGFkZGluZ1xuXG4gICAgICAgICAgX2hvcml6b250YWwubSA9IE1hdGgucm91bmQoYm91bmRzLmxlZnQgKyBfaG9yaXpvbnRhbC5zYygpKSB8fCAwO1xuICAgICAgICAgIGJvcmRlciA/IGJvZHlTdHlsZS5ib3JkZXJUb3AgPSBib3JkZXIgOiBib2R5U3R5bGUucmVtb3ZlUHJvcGVydHkoXCJib3JkZXItdG9wXCIpO1xuICAgICAgICAgIF9zeW5jSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChfc3luYywgMjAwKTtcbiAgICAgICAgICBnc2FwLmRlbGF5ZWRDYWxsKDAuNSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9zdGFydHVwID0gMDtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIF9hZGRMaXN0ZW5lcihfZG9jLCBcInRvdWNoY2FuY2VsXCIsIF9wYXNzVGhyb3VnaCk7IC8vIHNvbWUgb2xkZXIgQW5kcm9pZCBkZXZpY2VzIGludGVybWl0dGVudGx5IHN0b3AgZGlzcGF0Y2hpbmcgXCJ0b3VjaG1vdmVcIiBldmVudHMgaWYgd2UgZG9uJ3QgbGlzdGVuIGZvciBcInRvdWNoY2FuY2VsXCIgb24gdGhlIGRvY3VtZW50LlxuXG5cbiAgICAgICAgICBfYWRkTGlzdGVuZXIoX2JvZHksIFwidG91Y2hzdGFydFwiLCBfcGFzc1Rocm91Z2gpOyAvL3dvcmtzIGFyb3VuZCBTYWZhcmkgYnVnOiBodHRwczovL2dyZWVuc29jay5jb20vZm9ydW1zL3RvcGljLzIxNDUwLWRyYWdnYWJsZS1pbi1pZnJhbWUtb24tbW9iaWxlLWlzLWJ1Z2d5L1xuXG5cbiAgICAgICAgICBfbXVsdGlMaXN0ZW5lcihfYWRkTGlzdGVuZXIsIF9kb2MsIFwicG9pbnRlcmRvd24sdG91Y2hzdGFydCxtb3VzZWRvd25cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9wb2ludGVySXNEb3duID0gMTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIF9tdWx0aUxpc3RlbmVyKF9hZGRMaXN0ZW5lciwgX2RvYywgXCJwb2ludGVydXAsdG91Y2hlbmQsbW91c2V1cFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3BvaW50ZXJJc0Rvd24gPSAwO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgX3RyYW5zZm9ybVByb3AgPSBnc2FwLnV0aWxzLmNoZWNrUHJlZml4KFwidHJhbnNmb3JtXCIpO1xuXG4gICAgICAgICAgX3N0YXRlUHJvcHMucHVzaChfdHJhbnNmb3JtUHJvcCk7XG5cbiAgICAgICAgICBfY29yZUluaXR0ZWQgPSBfZ2V0VGltZSgpO1xuICAgICAgICAgIF9yZXNpemVEZWxheSA9IGdzYXAuZGVsYXllZENhbGwoMC4yLCBfcmVmcmVzaEFsbCkucGF1c2UoKTtcbiAgICAgICAgICBfYXV0b1JlZnJlc2ggPSBbX2RvYywgXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB3ID0gX3dpbi5pbm5lcldpZHRoLFxuICAgICAgICAgICAgICAgIGggPSBfd2luLmlubmVySGVpZ2h0O1xuXG4gICAgICAgICAgICBpZiAoX2RvYy5oaWRkZW4pIHtcbiAgICAgICAgICAgICAgX3ByZXZXaWR0aCA9IHc7XG4gICAgICAgICAgICAgIF9wcmV2SGVpZ2h0ID0gaDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoX3ByZXZXaWR0aCAhPT0gdyB8fCBfcHJldkhlaWdodCAhPT0gaCkge1xuICAgICAgICAgICAgICBfb25SZXNpemUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBfZG9jLCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgX3JlZnJlc2hBbGwsIF93aW4sIFwibG9hZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX2xhc3RTY3JvbGxUaW1lIHx8IF9yZWZyZXNoQWxsKCk7XG4gICAgICAgICAgfSwgX3dpbiwgXCJyZXNpemVcIiwgX29uUmVzaXplXTtcblxuICAgICAgICAgIF9pdGVyYXRlQXV0b1JlZnJlc2goX2FkZExpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBfY29yZUluaXR0ZWQ7XG4gIH07XG5cbiAgU2Nyb2xsVHJpZ2dlci5kZWZhdWx0cyA9IGZ1bmN0aW9uIGRlZmF1bHRzKGNvbmZpZykge1xuICAgIGZvciAodmFyIHAgaW4gY29uZmlnKSB7XG4gICAgICBfZGVmYXVsdHNbcF0gPSBjb25maWdbcF07XG4gICAgfVxuICB9O1xuXG4gIFNjcm9sbFRyaWdnZXIua2lsbCA9IGZ1bmN0aW9uIGtpbGwoKSB7XG4gICAgX2VuYWJsZWQgPSAwO1xuXG4gICAgX3RyaWdnZXJzLnNsaWNlKDApLmZvckVhY2goZnVuY3Rpb24gKHRyaWdnZXIpIHtcbiAgICAgIHJldHVybiB0cmlnZ2VyLmtpbGwoMSk7XG4gICAgfSk7XG4gIH07XG5cbiAgU2Nyb2xsVHJpZ2dlci5jb25maWcgPSBmdW5jdGlvbiBjb25maWcodmFycykge1xuICAgIFwibGltaXRDYWxsYmFja3NcIiBpbiB2YXJzICYmIChfbGltaXRDYWxsYmFja3MgPSAhIXZhcnMubGltaXRDYWxsYmFja3MpO1xuICAgIHZhciBtcyA9IHZhcnMuc3luY0ludGVydmFsO1xuICAgIG1zICYmIGNsZWFySW50ZXJ2YWwoX3N5bmNJbnRlcnZhbCkgfHwgKF9zeW5jSW50ZXJ2YWwgPSBtcykgJiYgc2V0SW50ZXJ2YWwoX3N5bmMsIG1zKTtcbiAgICBcImF1dG9SZWZyZXNoRXZlbnRzXCIgaW4gdmFycyAmJiAoX2l0ZXJhdGVBdXRvUmVmcmVzaChfcmVtb3ZlTGlzdGVuZXIpIHx8IF9pdGVyYXRlQXV0b1JlZnJlc2goX2FkZExpc3RlbmVyLCB2YXJzLmF1dG9SZWZyZXNoRXZlbnRzIHx8IFwibm9uZVwiKSk7XG4gIH07XG5cbiAgU2Nyb2xsVHJpZ2dlci5zY3JvbGxlclByb3h5ID0gZnVuY3Rpb24gc2Nyb2xsZXJQcm94eSh0YXJnZXQsIHZhcnMpIHtcbiAgICB2YXIgdCA9IF90b0FycmF5KHRhcmdldClbMF07XG5cbiAgICBfaXNWaWV3cG9ydCh0KSA/IF9wcm94aWVzLnVuc2hpZnQoX3dpbiwgdmFycywgX2JvZHksIHZhcnMsIF9kb2NFbCwgdmFycykgOiBfcHJveGllcy51bnNoaWZ0KHQsIHZhcnMpO1xuICB9O1xuXG4gIFNjcm9sbFRyaWdnZXIubWF0Y2hNZWRpYSA9IGZ1bmN0aW9uIG1hdGNoTWVkaWEodmFycykge1xuICAgIHZhciBtcSwgcCwgaSwgZnVuYywgcmVzdWx0O1xuXG4gICAgZm9yIChwIGluIHZhcnMpIHtcbiAgICAgIGkgPSBfbWVkaWEuaW5kZXhPZihwKTtcbiAgICAgIGZ1bmMgPSB2YXJzW3BdO1xuICAgICAgX2NyZWF0aW5nTWVkaWEgPSBwO1xuXG4gICAgICBpZiAocCA9PT0gXCJhbGxcIikge1xuICAgICAgICBmdW5jKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtcSA9IF93aW4ubWF0Y2hNZWRpYShwKTtcblxuICAgICAgICBpZiAobXEpIHtcbiAgICAgICAgICBtcS5tYXRjaGVzICYmIChyZXN1bHQgPSBmdW5jKCkpO1xuXG4gICAgICAgICAgaWYgKH5pKSB7XG4gICAgICAgICAgICBfbWVkaWFbaSArIDFdID0gX2NvbWJpbmVGdW5jKF9tZWRpYVtpICsgMV0sIGZ1bmMpO1xuICAgICAgICAgICAgX21lZGlhW2kgKyAyXSA9IF9jb21iaW5lRnVuYyhfbWVkaWFbaSArIDJdLCByZXN1bHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpID0gX21lZGlhLmxlbmd0aDtcblxuICAgICAgICAgICAgX21lZGlhLnB1c2gocCwgZnVuYywgcmVzdWx0KTtcblxuICAgICAgICAgICAgbXEuYWRkTGlzdGVuZXIgPyBtcS5hZGRMaXN0ZW5lcihfb25NZWRpYUNoYW5nZSkgOiBtcS5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIF9vbk1lZGlhQ2hhbmdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX2NyZWF0aW5nTWVkaWEgPSAwO1xuICAgIH1cblxuICAgIHJldHVybiBfbWVkaWE7XG4gIH07XG5cbiAgcmV0dXJuIFNjcm9sbFRyaWdnZXI7XG59KCk7XG5TY3JvbGxUcmlnZ2VyLnZlcnNpb24gPSBcIjMuNC4yXCI7XG5cblNjcm9sbFRyaWdnZXIuc2F2ZVN0eWxlcyA9IGZ1bmN0aW9uICh0YXJnZXRzKSB7XG4gIHJldHVybiB0YXJnZXRzID8gX3RvQXJyYXkodGFyZ2V0cykuZm9yRWFjaChmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgdmFyIGkgPSBfc2F2ZWRTdHlsZXMuaW5kZXhPZih0YXJnZXQpO1xuXG4gICAgaSA+PSAwICYmIF9zYXZlZFN0eWxlcy5zcGxpY2UoaSwgNCk7XG5cbiAgICBfc2F2ZWRTdHlsZXMucHVzaCh0YXJnZXQsIHRhcmdldC5zdHlsZS5jc3NUZXh0LCBnc2FwLmNvcmUuZ2V0Q2FjaGUodGFyZ2V0KSwgX2NyZWF0aW5nTWVkaWEpO1xuICB9KSA6IF9zYXZlZFN0eWxlcztcbn07XG5cblNjcm9sbFRyaWdnZXIucmV2ZXJ0ID0gZnVuY3Rpb24gKHNvZnQsIG1lZGlhKSB7XG4gIHJldHVybiBfcmV2ZXJ0QWxsKCFzb2Z0LCBtZWRpYSk7XG59O1xuXG5TY3JvbGxUcmlnZ2VyLmNyZWF0ZSA9IGZ1bmN0aW9uICh2YXJzLCBhbmltYXRpb24pIHtcbiAgcmV0dXJuIG5ldyBTY3JvbGxUcmlnZ2VyKHZhcnMsIGFuaW1hdGlvbik7XG59O1xuXG5TY3JvbGxUcmlnZ2VyLnJlZnJlc2ggPSBmdW5jdGlvbiAoc2FmZSkge1xuICByZXR1cm4gc2FmZSA/IF9vblJlc2l6ZSgpIDogX3JlZnJlc2hBbGwodHJ1ZSk7XG59O1xuXG5TY3JvbGxUcmlnZ2VyLnVwZGF0ZSA9IF91cGRhdGVBbGw7XG5cblNjcm9sbFRyaWdnZXIubWF4U2Nyb2xsID0gZnVuY3Rpb24gKGVsZW1lbnQsIGhvcml6b250YWwpIHtcbiAgcmV0dXJuIF9tYXhTY3JvbGwoZWxlbWVudCwgaG9yaXpvbnRhbCA/IF9ob3Jpem9udGFsIDogX3ZlcnRpY2FsKTtcbn07XG5cblNjcm9sbFRyaWdnZXIuZ2V0U2Nyb2xsRnVuYyA9IGZ1bmN0aW9uIChlbGVtZW50LCBob3Jpem9udGFsKSB7XG4gIHJldHVybiBfZ2V0U2Nyb2xsRnVuYyhfdG9BcnJheShlbGVtZW50KVswXSwgaG9yaXpvbnRhbCA/IF9ob3Jpem9udGFsIDogX3ZlcnRpY2FsKTtcbn07XG5cblNjcm9sbFRyaWdnZXIuZ2V0QnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICByZXR1cm4gX2lkc1tpZF07XG59O1xuXG5TY3JvbGxUcmlnZ2VyLmdldEFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIF90cmlnZ2Vycy5zbGljZSgwKTtcbn07XG5cblNjcm9sbFRyaWdnZXIuaXNTY3JvbGxpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhIV9sYXN0U2Nyb2xsVGltZTtcbn07XG5cblNjcm9sbFRyaWdnZXIuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uICh0eXBlLCBjYWxsYmFjaykge1xuICB2YXIgYSA9IF9saXN0ZW5lcnNbdHlwZV0gfHwgKF9saXN0ZW5lcnNbdHlwZV0gPSBbXSk7XG4gIH5hLmluZGV4T2YoY2FsbGJhY2spIHx8IGEucHVzaChjYWxsYmFjayk7XG59O1xuXG5TY3JvbGxUcmlnZ2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAodHlwZSwgY2FsbGJhY2spIHtcbiAgdmFyIGEgPSBfbGlzdGVuZXJzW3R5cGVdLFxuICAgICAgaSA9IGEgJiYgYS5pbmRleE9mKGNhbGxiYWNrKTtcbiAgaSA+PSAwICYmIGEuc3BsaWNlKGksIDEpO1xufTtcblxuU2Nyb2xsVHJpZ2dlci5iYXRjaCA9IGZ1bmN0aW9uICh0YXJnZXRzLCB2YXJzKSB7XG4gIHZhciByZXN1bHQgPSBbXSxcbiAgICAgIHZhcnNDb3B5ID0ge30sXG4gICAgICBpbnRlcnZhbCA9IHZhcnMuaW50ZXJ2YWwgfHwgMC4wMTYsXG4gICAgICBiYXRjaE1heCA9IHZhcnMuYmF0Y2hNYXggfHwgMWU5LFxuICAgICAgcHJveHlDYWxsYmFjayA9IGZ1bmN0aW9uIHByb3h5Q2FsbGJhY2sodHlwZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgZWxlbWVudHMgPSBbXSxcbiAgICAgICAgdHJpZ2dlcnMgPSBbXSxcbiAgICAgICAgZGVsYXkgPSBnc2FwLmRlbGF5ZWRDYWxsKGludGVydmFsLCBmdW5jdGlvbiAoKSB7XG4gICAgICBjYWxsYmFjayhlbGVtZW50cywgdHJpZ2dlcnMpO1xuICAgICAgZWxlbWVudHMgPSBbXTtcbiAgICAgIHRyaWdnZXJzID0gW107XG4gICAgfSkucGF1c2UoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNlbGYpIHtcbiAgICAgIGVsZW1lbnRzLmxlbmd0aCB8fCBkZWxheS5yZXN0YXJ0KHRydWUpO1xuICAgICAgZWxlbWVudHMucHVzaChzZWxmLnRyaWdnZXIpO1xuICAgICAgdHJpZ2dlcnMucHVzaChzZWxmKTtcbiAgICAgIGJhdGNoTWF4IDw9IGVsZW1lbnRzLmxlbmd0aCAmJiBkZWxheS5wcm9ncmVzcygxKTtcbiAgICB9O1xuICB9LFxuICAgICAgcDtcblxuICBmb3IgKHAgaW4gdmFycykge1xuICAgIHZhcnNDb3B5W3BdID0gcC5zdWJzdHIoMCwgMikgPT09IFwib25cIiAmJiBfaXNGdW5jdGlvbih2YXJzW3BdKSAmJiBwICE9PSBcIm9uUmVmcmVzaEluaXRcIiA/IHByb3h5Q2FsbGJhY2socCwgdmFyc1twXSkgOiB2YXJzW3BdO1xuICB9XG5cbiAgaWYgKF9pc0Z1bmN0aW9uKGJhdGNoTWF4KSkge1xuICAgIGJhdGNoTWF4ID0gYmF0Y2hNYXgoKTtcblxuICAgIF9hZGRMaXN0ZW5lcihTY3JvbGxUcmlnZ2VyLCBcInJlZnJlc2hcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGJhdGNoTWF4ID0gdmFycy5iYXRjaE1heCgpO1xuICAgIH0pO1xuICB9XG5cbiAgX3RvQXJyYXkodGFyZ2V0cykuZm9yRWFjaChmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgdmFyIGNvbmZpZyA9IHt9O1xuXG4gICAgZm9yIChwIGluIHZhcnNDb3B5KSB7XG4gICAgICBjb25maWdbcF0gPSB2YXJzQ29weVtwXTtcbiAgICB9XG5cbiAgICBjb25maWcudHJpZ2dlciA9IHRhcmdldDtcbiAgICByZXN1bHQucHVzaChTY3JvbGxUcmlnZ2VyLmNyZWF0ZShjb25maWcpKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblNjcm9sbFRyaWdnZXIuc29ydCA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gIHJldHVybiBfdHJpZ2dlcnMuc29ydChmdW5jIHx8IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIChhLnZhcnMucmVmcmVzaFByaW9yaXR5IHx8IDApICogLTFlNiArIGEuc3RhcnQgLSAoYi5zdGFydCArIChiLnZhcnMucmVmcmVzaFByaW9yaXR5IHx8IDApICogLTFlNik7XG4gIH0pO1xufTtcblxuX2dldEdTQVAoKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luKFNjcm9sbFRyaWdnZXIpO1xuZXhwb3J0IHsgU2Nyb2xsVHJpZ2dlciBhcyBkZWZhdWx0IH07IiwiaW1wb3J0IHtnc2FwfSBmcm9tICdnc2FwJztcclxuaW1wb3J0IHtTY3JvbGxUcmlnZ2VyfSBmcm9tIFwiZ3NhcC9TY3JvbGxUcmlnZ2VyXCI7XHJcblxyXG5nc2FwLnJlZ2lzdGVyUGx1Z2luKFNjcm9sbFRyaWdnZXIpO1xyXG5cclxuY29uc3Qgc2VjdGlvbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN2ZWxhenF1ZXouYXJ0aXN0LXNlY3Rpb24nKSxcclxuICAgIHdlbGNvbWVTZWN0aW9uID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3ZlbGF6cXVleiAuYXJ0aXN0LXNlY3Rpb25fX3dlbGNvbWUnKSxcclxuICAgIHNlY3Rpb25XcmFwcGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3ZlbGF6cXVleiAuYXJ0aXN0LXNlY3Rpb25fX3dyYXBwZXInKSxcclxuICAgIHNlY3Rpb25JbmZvID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3ZlbGF6cXVleiAuYXJ0aXN0LXNlY3Rpb25fX2luZm8nKSxcclxuICAgIHZlbGF6cXVlekluZm9fMSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJyN2ZWxhenF1ZXotaW5mby0xJyksXHJcbiAgICB2ZWxhenF1ZXpJbmZvXzIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcjdmVsYXpxdWV6LWluZm8tMicpLFxyXG4gICAgdmVsYXpxdWV6SW5mb18zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnI3ZlbGF6cXVlei1pbmZvLTMnKSxcclxuICAgIHZlbGF6cXVlekluZm9fNCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJyN2ZWxhenF1ZXotaW5mby00JyksXHJcbiAgICB2ZWxhenF1ZXpJbmZvXzUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcjdmVsYXpxdWV6LWluZm8tNScpLFxyXG4gICAgdmVsYXpxdWV6SW5mb182ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnI3ZlbGF6cXVlei1pbmZvLTYnKSxcclxuICAgIHZlbGF6cXVlekluZm9fNyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJyN2ZWxhenF1ZXotaW5mby03JyksXHJcbiAgICB2ZWxhenF1ZXpJbWFnZV8yID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnI3ZlbGF6cXVlei1pbWFnZS0yJyksXHJcbiAgICB2ZWxhenF1ZXpJbWFnZV8zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnI3ZlbGF6cXVlei1pbWFnZS0zJyksXHJcbiAgICB2ZWxhenF1ZXpJbWFnZV80ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnI3ZlbGF6cXVlei1pbWFnZS00JyksXHJcbiAgICB2ZWxhenF1ZXpJbWFnZV81ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnI3ZlbGF6cXVlei1pbWFnZS01JyksXHJcbiAgICB2ZWxhenF1ZXpJbWFnZV82ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnI3ZlbGF6cXVlei1pbWFnZS02JyksXHJcbiAgICBwZXJzcGVjdGl2ZSA9IDEwMDA7IFxyXG5cclxuZ3NhcC50aW1lbGluZSh7XHJcbiAgICBzY3JvbGxUcmlnZ2VyOiB7XHJcbiAgICAgICAgdHJpZ2dlcjogc2VjdGlvbixcclxuICAgICAgICBzdGFydDogJ3RvcCB0b3AnLFxyXG4gICAgICAgIGVuZDogJys9MTUwMDAnLFxyXG4gICAgICAgIHBpbjogdHJ1ZSxcclxuICAgICAgICBhbnRpY2lwYXRlUGluOiAxLFxyXG4gICAgICAgIC8vIG1hcmtlcnM6IHRydWUsXHJcbiAgICAgICAgc2NydWI6IDEgICAgICAgICAgICBcclxuICAgIH1cclxufSlcclxuLnNldChzZWN0aW9uV3JhcHBlciwge2Nzczp7dHJhbnNmb3JtUGVyc3BlY3RpdmU6IHBlcnNwZWN0aXZlLCB0cmFuc2Zvcm1TdHlsZTogJ3ByZXNlcnZlLTNkJ319KVxyXG4vLyBJbXByb3ZlIFF1YWxpdHlcclxuLnRvKHdlbGNvbWVTZWN0aW9uLCAxLCB7Y3NzOiB7ejogcGVyc3BlY3RpdmV9fSlcclxuLmZyb21UbyhzZWN0aW9uSW5mbywgMSwge29wYWNpdHk6IDB9LCB7b3BhY2l0eTogMX0pXHJcbi5hZGRMYWJlbCgnc2hvd19pbmZvXzEnKVxyXG4uYWRkUGF1c2UoMylcclxuLnRvKHZlbGF6cXVlekluZm9fMSwgMSwge29wYWNpdHk6IDAsIGRpc3BsYXk6ICdub25lJ30pXHJcbi5mcm9tVG8odmVsYXpxdWV6SW5mb18yLCAxLCB7b3BhY2l0eTogMH0sIHtvcGFjaXR5OiAxLCBkaXNwbGF5OiAnYmxvY2snfSlcclxuLmFkZFBhdXNlKDMpXHJcbi50byh2ZWxhenF1ZXpJbmZvXzIsIDEsIHtvcGFjaXR5OiAwLCBkaXNwbGF5OiAnbm9uZSd9KVxyXG4uZnJvbVRvKHZlbGF6cXVlekluZm9fMywgMSwge29wYWNpdHk6IDB9LCB7b3BhY2l0eTogMSwgZGlzcGxheTogJ2Jsb2NrJ30pXHJcbi5hZGRQYXVzZSgzKVxyXG4udG8odmVsYXpxdWV6SW5mb18zLCAxLCB7b3BhY2l0eTogMCwgZGlzcGxheTogJ25vbmUnfSlcclxuLmZyb21Ubyh2ZWxhenF1ZXpJbmZvXzQsIDEsIHtvcGFjaXR5OiAwfSwge29wYWNpdHk6IDEsIGRpc3BsYXk6ICdibG9jayd9KVxyXG4uYWRkTGFiZWwoJ3Nob3dfaW5mb180JylcclxuLmFkZFBhdXNlKDMpXHJcbi50byh2ZWxhenF1ZXpJbmZvXzQsIDEsIHtvcGFjaXR5OiAwLCBkaXNwbGF5OiAnbm9uZSd9KVxyXG4uZnJvbVRvKHZlbGF6cXVlekluZm9fNSwgMSwge29wYWNpdHk6IDB9LCB7b3BhY2l0eTogMSwgZGlzcGxheTogJ2Jsb2NrJ30pXHJcbi5hZGRQYXVzZSgzKVxyXG4udG8odmVsYXpxdWV6SW5mb181LCAxLCB7b3BhY2l0eTogMCwgZGlzcGxheTogJ25vbmUnfSlcclxuLmZyb21Ubyh2ZWxhenF1ZXpJbmZvXzYsIDEsIHtvcGFjaXR5OiAwfSwge29wYWNpdHk6IDEsIGRpc3BsYXk6ICdibG9jayd9KVxyXG4uYWRkUGF1c2UoMylcclxuLnRvKHZlbGF6cXVlekluZm9fNiwgMSwge29wYWNpdHk6IDAsIGRpc3BsYXk6ICdub25lJ30pXHJcbi5mcm9tVG8odmVsYXpxdWV6SW5mb183LCAxLCB7b3BhY2l0eTogMH0sIHtvcGFjaXR5OiAxLCBkaXNwbGF5OiAnYmxvY2snfSlcclxuLmFkZFBhdXNlKDMpXHJcbi50byh2ZWxhenF1ZXpJbWFnZV8zLCAxMCwge3k6IC04fSwgJ3Nob3dfaW5mb18xJylcclxuLnRvKHZlbGF6cXVlekltYWdlXzQsIDEwLCB7eTogLTV9LCAnc2hvd19pbmZvXzEnKVxyXG4udG8odmVsYXpxdWV6SW1hZ2VfNSwgMTAsIHt5OiAtOH0sICdzaG93X2luZm9fMScpXHJcbi50byh2ZWxhenF1ZXpJbWFnZV82LCAxMCwge3k6IC0xMH0sICdzaG93X2luZm9fMScpO1xyXG4iLCJpbXBvcnQge2dzYXB9IGZyb20gJ2dzYXAnO1xyXG5pbXBvcnQge1Njcm9sbFRyaWdnZXJ9IGZyb20gXCJnc2FwL1Njcm9sbFRyaWdnZXJcIjtcclxuXHJcbmdzYXAucmVnaXN0ZXJQbHVnaW4oU2Nyb2xsVHJpZ2dlcik7XHJcblxyXG5jb25zdCBzZWN0aW9uID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2dveWEuYXJ0aXN0LXNlY3Rpb24nKSxcclxuICAgIHdlbGNvbWVTZWN0aW9uID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2dveWEgLmFydGlzdC1zZWN0aW9uX193ZWxjb21lJyksXHJcbiAgICBzZWN0aW9uV3JhcHBlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNnb3lhIC5hcnRpc3Qtc2VjdGlvbl9fd3JhcHBlcicpLFxyXG4gICAgc2VjdGlvbkluZm8gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjZ295YSAuYXJ0aXN0LXNlY3Rpb25fX2luZm8nKSxcclxuICAgIGdveWFJbmZvXzEgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcjZ295YS1pbmZvLTEnKSxcclxuICAgIGdveWFJbmZvXzIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcjZ295YS1pbmZvLTInKSxcclxuICAgIGdveWFJbmZvXzMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcjZ295YS1pbmZvLTMnKSxcclxuICAgIGdveWFJbmZvXzQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcjZ295YS1pbmZvLTQnKSxcclxuICAgIGdveWFJbmZvXzUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcjZ295YS1pbmZvLTUnKSxcclxuICAgIGdveWFJbmZvXzYgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcjZ295YS1pbmZvLTYnKSxcclxuICAgIGdveWFJbmZvXzcgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcjZ295YS1pbmZvLTcnKSxcclxuICAgIGdveWFJbWFnZV8xID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnI2dveWEtaW1hZ2UtMScpLFxyXG4gICAgZ295YUltYWdlXzIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcjZ295YS1pbWFnZS0yJyksXHJcbiAgICBnb3lhSW1hZ2VfMyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJyNnb3lhLWltYWdlLTMnKSxcclxuICAgIGdveWFJbWFnZV80ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnI2dveWEtaW1hZ2UtNCcpLFxyXG4gICAgZ295YUltYWdlXzUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcjZ295YS1pbWFnZS01JyksICAgIFxyXG4gICAgcGVyc3BlY3RpdmUgPSAxMDAwOyBcclxuXHJcbmdzYXAudGltZWxpbmUoe1xyXG4gICAgc2Nyb2xsVHJpZ2dlcjoge1xyXG4gICAgICAgIHRyaWdnZXI6IHNlY3Rpb24sXHJcbiAgICAgICAgc3RhcnQ6ICd0b3AgdG9wJyxcclxuICAgICAgICBlbmQ6ICcrPTE1MDAwJyxcclxuICAgICAgICBwaW46IHRydWUsXHJcbiAgICAgICAgYW50aWNpcGF0ZVBpbjogMSxcclxuICAgICAgICAvLyBtYXJrZXJzOiB0cnVlLFxyXG4gICAgICAgIHNjcnViOiAxICAgICAgICAgICAgXHJcbiAgICB9XHJcbn0pXHJcbi5zZXQoc2VjdGlvbldyYXBwZXIsIHtjc3M6e3RyYW5zZm9ybVBlcnNwZWN0aXZlOiBwZXJzcGVjdGl2ZSwgdHJhbnNmb3JtU3R5bGU6ICdwcmVzZXJ2ZS0zZCd9fSlcclxuLy8gSW1wcm92ZSBRdWFsaXR5XHJcbi50byh3ZWxjb21lU2VjdGlvbiwgMSwge3o6IHBlcnNwZWN0aXZlfSlcclxuLmZyb21UbyhzZWN0aW9uSW5mbywgMSwge29wYWNpdHk6IDB9LCB7b3BhY2l0eTogMX0pXHJcbi5hZGRMYWJlbCgnc2hvd19pbmZvXzEnKVxyXG4uYWRkUGF1c2UoMylcclxuLnRvKGdveWFJbmZvXzEsIDEsIHtvcGFjaXR5OiAwLCBkaXNwbGF5OiAnbm9uZSd9KVxyXG4uZnJvbVRvKGdveWFJbmZvXzIsIDEsIHtvcGFjaXR5OiAwfSwge29wYWNpdHk6IDEsIGRpc3BsYXk6ICdibG9jayd9KVxyXG4uYWRkUGF1c2UoMylcclxuLnRvKGdveWFJbmZvXzIsIDEsIHtvcGFjaXR5OiAwLCBkaXNwbGF5OiAnbm9uZSd9KVxyXG4uZnJvbVRvKGdveWFJbmZvXzMsIDEsIHtvcGFjaXR5OiAwfSwge29wYWNpdHk6IDEsIGRpc3BsYXk6ICdibG9jayd9KVxyXG4uYWRkUGF1c2UoMylcclxuLnRvKGdveWFJbmZvXzMsIDEsIHtvcGFjaXR5OiAwLCBkaXNwbGF5OiAnbm9uZSd9KVxyXG4uZnJvbVRvKGdveWFJbmZvXzQsIDEsIHtvcGFjaXR5OiAwfSwge29wYWNpdHk6IDEsIGRpc3BsYXk6ICdibG9jayd9KVxyXG4uYWRkTGFiZWwoJ3Nob3dfaW5mb180JylcclxuLmFkZFBhdXNlKDMpXHJcbi50byhnb3lhSW5mb180LCAxLCB7b3BhY2l0eTogMCwgZGlzcGxheTogJ25vbmUnfSlcclxuLmZyb21Ubyhnb3lhSW5mb181LCAxLCB7b3BhY2l0eTogMH0sIHtvcGFjaXR5OiAxLCBkaXNwbGF5OiAnYmxvY2snfSlcclxuLmFkZFBhdXNlKDMpXHJcbi50byhnb3lhSW5mb181LCAxLCB7b3BhY2l0eTogMCwgZGlzcGxheTogJ25vbmUnfSlcclxuLmZyb21Ubyhnb3lhSW5mb182LCAxLCB7b3BhY2l0eTogMH0sIHtvcGFjaXR5OiAxLCBkaXNwbGF5OiAnYmxvY2snfSlcclxuLmFkZFBhdXNlKDMpXHJcbi50byhnb3lhSW5mb182LCAxLCB7b3BhY2l0eTogMCwgZGlzcGxheTogJ25vbmUnfSlcclxuLmZyb21Ubyhnb3lhSW5mb183LCAxLCB7b3BhY2l0eTogMH0sIHtvcGFjaXR5OiAxLCBkaXNwbGF5OiAnYmxvY2snfSlcclxuLmFkZFBhdXNlKDMpXHJcbi50byhnb3lhSW1hZ2VfMSwgOCwge3k6IDMwfSwgJ3Nob3dfaW5mb18xJylcclxuLnRvKGdveWFJbWFnZV8yLCA4LCB7eTogMTV9LCAnc2hvd19pbmZvXzEnKVxyXG4udG8oZ295YUltYWdlXzMsIDgsIHt5OiAxMH0sICdzaG93X2luZm9fMScpXHJcbi50byhnb3lhSW1hZ2VfNCwgOCwge3NjYWxlOiAxLjAwNSwgejogMTB9LCAnc2hvd19pbmZvXzEnKVxyXG4udG8oZ295YUltYWdlXzUsIDgsIHtzY2FsZTogMS4wMDV9LCAnc2hvd19pbmZvXzEnKTtcclxuIiwiaW1wb3J0IHtnc2FwfSBmcm9tICdnc2FwJztcclxuaW1wb3J0IHtTY3JvbGxUcmlnZ2VyfSBmcm9tIFwiZ3NhcC9TY3JvbGxUcmlnZ2VyXCI7XHJcblxyXG5nc2FwLnJlZ2lzdGVyUGx1Z2luKFNjcm9sbFRyaWdnZXIpO1xyXG5cclxuY29uc3Qgc2VjdGlvbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNwaWNhc3NvLmFydGlzdC1zZWN0aW9uJyksXHJcbiAgICB3ZWxjb21lU2VjdGlvbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNwaWNhc3NvIC5hcnRpc3Qtc2VjdGlvbl9fd2VsY29tZScpLFxyXG4gICAgc2VjdGlvbldyYXBwZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjcGljYXNzbyAuYXJ0aXN0LXNlY3Rpb25fX3dyYXBwZXInKSxcclxuICAgIHNlY3Rpb25JbmZvID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3BpY2Fzc28gLmFydGlzdC1zZWN0aW9uX19pbmZvJyksXHJcbiAgICBwaWNhc3NvSW5mb18xID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnI3BpY2Fzc28taW5mby0xJyksXHJcbiAgICBwaWNhc3NvSW5mb18yID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnI3BpY2Fzc28taW5mby0yJyksXHJcbiAgICBwaWNhc3NvSW5mb18zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnI3BpY2Fzc28taW5mby0zJyksXHJcbiAgICBwaWNhc3NvSW5mb180ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnI3BpY2Fzc28taW5mby00JyksXHJcbiAgICBwaWNhc3NvSW5mb181ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnI3BpY2Fzc28taW5mby01JyksXHJcbiAgICBwaWNhc3NvSW5mb182ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnI3BpY2Fzc28taW5mby02JyksXHJcbiAgICBwaWNhc3NvSW5mb183ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnI3BpY2Fzc28taW5mby03JyksXHJcbiAgICBwaWNhc3NvSW1hZ2VfMSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJyNwaWNhc3NvLWltYWdlLTEnKSxcclxuICAgIHBpY2Fzc29JbWFnZV8yID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnI3BpY2Fzc28taW1hZ2UtMicpLFxyXG4gICAgcGljYXNzb0ltYWdlXzMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcjcGljYXNzby1pbWFnZS0zJyksXHJcbiAgICBwaWNhc3NvSW1hZ2VfNCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJyNwaWNhc3NvLWltYWdlLTQnKSxcclxuICAgIHBpY2Fzc29JbWFnZV81ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnI3BpY2Fzc28taW1hZ2UtNScpLFxyXG4gICAgcGljYXNzb0ltYWdlXzYgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcjcGljYXNzby1pbWFnZS02JyksXHJcbiAgICBwaWNhc3NvSW1hZ2VfNyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJyNwaWNhc3NvLWltYWdlLTcnKSxcclxuICAgIHBpY2Fzc29JbWFnZV84ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnI3BpY2Fzc28taW1hZ2UtOCcpLFxyXG4gICAgcGljYXNzb0ltYWdlXzkgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcjcGljYXNzby1pbWFnZS05JyksXHJcbiAgICBwaWNhc3NvSW1hZ2VfMTAgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcjcGljYXNzby1pbWFnZS0xMCcpLFxyXG4gICAgcGljYXNzb0ltYWdlXzExID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnI3BpY2Fzc28taW1hZ2UtMTEnKSxcclxuICAgIHBlcnNwZWN0aXZlID0gMTAwMDsgXHJcblxyXG5nc2FwLnRpbWVsaW5lKHtcclxuICAgIHNjcm9sbFRyaWdnZXI6IHtcclxuICAgICAgICB0cmlnZ2VyOiBzZWN0aW9uLFxyXG4gICAgICAgIHN0YXJ0OiAndG9wIHRvcCcsXHJcbiAgICAgICAgZW5kOiAnKz0xNTAwMCcsXHJcbiAgICAgICAgcGluOiB0cnVlLFxyXG4gICAgICAgIGFudGljaXBhdGVQaW46IDEsXHJcbiAgICAgICAgLy8gbWFya2VyczogdHJ1ZSxcclxuICAgICAgICBzY3J1YjogMSAgICAgICAgICAgIFxyXG4gICAgfVxyXG59KVxyXG4uc2V0KHNlY3Rpb25XcmFwcGVyLCB7Y3NzOnt0cmFuc2Zvcm1QZXJzcGVjdGl2ZTogcGVyc3BlY3RpdmUsIHRyYW5zZm9ybVN0eWxlOiAncHJlc2VydmUtM2QnfX0pXHJcbi8vIEltcHJvdmUgUXVhbGl0eVxyXG4udG8od2VsY29tZVNlY3Rpb24sIDEsIHtjc3M6IHt6OiBwZXJzcGVjdGl2ZX19KVxyXG4uZnJvbVRvKHNlY3Rpb25JbmZvLCAxLCB7b3BhY2l0eTogMH0sIHtvcGFjaXR5OiAxfSlcclxuLmFkZExhYmVsKCdzaG93X2luZm9fMScpXHJcbi5hZGRQYXVzZSgzKVxyXG4udG8ocGljYXNzb0luZm9fMSwgMSwge29wYWNpdHk6IDAsIGRpc3BsYXk6ICdub25lJ30pXHJcbi5mcm9tVG8ocGljYXNzb0luZm9fMiwgMSwge29wYWNpdHk6IDB9LCB7b3BhY2l0eTogMSwgZGlzcGxheTogJ2Jsb2NrJ30pXHJcbi5hZGRQYXVzZSgzKVxyXG4udG8ocGljYXNzb0luZm9fMiwgMSwge29wYWNpdHk6IDAsIGRpc3BsYXk6ICdub25lJ30pXHJcbi5mcm9tVG8ocGljYXNzb0luZm9fMywgMSwge29wYWNpdHk6IDB9LCB7b3BhY2l0eTogMSwgZGlzcGxheTogJ2Jsb2NrJ30pXHJcbi5hZGRQYXVzZSgzKVxyXG4udG8ocGljYXNzb0luZm9fMywgMSwge29wYWNpdHk6IDAsIGRpc3BsYXk6ICdub25lJ30pXHJcbi5mcm9tVG8ocGljYXNzb0luZm9fNCwgMSwge29wYWNpdHk6IDB9LCB7b3BhY2l0eTogMSwgZGlzcGxheTogJ2Jsb2NrJ30pXHJcbi5hZGRMYWJlbCgnc2hvd19pbmZvXzQnKVxyXG4uYWRkUGF1c2UoMylcclxuLnRvKHBpY2Fzc29JbmZvXzQsIDEsIHtvcGFjaXR5OiAwLCBkaXNwbGF5OiAnbm9uZSd9KVxyXG4uZnJvbVRvKHBpY2Fzc29JbmZvXzUsIDEsIHtvcGFjaXR5OiAwfSwge29wYWNpdHk6IDEsIGRpc3BsYXk6ICdibG9jayd9KVxyXG4uYWRkUGF1c2UoMylcclxuLnRvKHBpY2Fzc29JbmZvXzUsIDEsIHtvcGFjaXR5OiAwLCBkaXNwbGF5OiAnbm9uZSd9KVxyXG4uZnJvbVRvKHBpY2Fzc29JbmZvXzYsIDEsIHtvcGFjaXR5OiAwfSwge29wYWNpdHk6IDEsIGRpc3BsYXk6ICdibG9jayd9KVxyXG4uYWRkUGF1c2UoMylcclxuLnRvKHBpY2Fzc29JbmZvXzYsIDEsIHtvcGFjaXR5OiAwLCBkaXNwbGF5OiAnbm9uZSd9KVxyXG4uZnJvbVRvKHBpY2Fzc29JbmZvXzcsIDEsIHtvcGFjaXR5OiAwfSwge29wYWNpdHk6IDEsIGRpc3BsYXk6ICdibG9jayd9KVxyXG4uYWRkUGF1c2UoMylcclxuLnRvKHBpY2Fzc29JbWFnZV8xLCAxMCwge3k6IC0xNX0sICdzaG93X2luZm9fMScpXHJcbi50byhwaWNhc3NvSW1hZ2VfMiwgMTAsIHt5OiAtMTB9LCAnc2hvd19pbmZvXzEnKVxyXG4udG8ocGljYXNzb0ltYWdlXzMsIDEwLCB7eTogLTh9LCAnc2hvd19pbmZvXzEnKVxyXG4udG8ocGljYXNzb0ltYWdlXzQsIDEwLCB7eTogLTZ9LCAnc2hvd19pbmZvXzEnKVxyXG4udG8ocGljYXNzb0ltYWdlXzUsIDEwLCB7eTogLTIwfSwgJ3Nob3dfaW5mb18xJylcclxuLnRvKHBpY2Fzc29JbWFnZV82LCAxMCwge3k6IC0xMSwgc2NhbGU6IDEuMDE1fSwgJ3Nob3dfaW5mb18xJylcclxuLnRvKHBpY2Fzc29JbWFnZV83LCAxMCwge3k6IC0yfSwgJ3Nob3dfaW5mb18xJylcclxuLnRvKHBpY2Fzc29JbWFnZV84LCAxMCwge3k6IC0yMCwgc2NhbGU6IDEuMDE1fSwgJ3Nob3dfaW5mb18xJylcclxuLnRvKHBpY2Fzc29JbWFnZV85LCAxMCwge3k6IC0yMCwgc2NhbGU6IDEuMDE1fSwgJ3Nob3dfaW5mb18xJylcclxuLnRvKHBpY2Fzc29JbWFnZV8xMCwgMTAsIHt5OiAtMTAsIHNjYWxlOiAxLjAxNX0sICdzaG93X2luZm9fMScpXHJcbi50byhwaWNhc3NvSW1hZ2VfMTEsIDEwLCB7eDogLTMwLCB5OiAtMTgsIHNjYWxlOiAxLjA1fSwgJ3Nob3dfaW5mb18xJyk7XHJcbiIsImltcG9ydCB7Z3NhcH0gZnJvbSAnZ3NhcCc7XHJcbmltcG9ydCB7U2Nyb2xsVHJpZ2dlcn0gZnJvbSBcImdzYXAvU2Nyb2xsVHJpZ2dlclwiO1xyXG5cclxuZ3NhcC5yZWdpc3RlclBsdWdpbihTY3JvbGxUcmlnZ2VyKTtcclxuXHJcbmNvbnN0IHNlY3Rpb24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjZGFsaS5hcnRpc3Qtc2VjdGlvbicpLFxyXG4gICAgd2VsY29tZVNlY3Rpb24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjZGFsaSAuYXJ0aXN0LXNlY3Rpb25fX3dlbGNvbWUnKSxcclxuICAgIHNlY3Rpb25XcmFwcGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2RhbGkgLmFydGlzdC1zZWN0aW9uX193cmFwcGVyJyksXHJcbiAgICBzZWN0aW9uSW5mbyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNkYWxpIC5hcnRpc3Qtc2VjdGlvbl9faW5mbycpLFxyXG4gICAgZGFsaUluZm9fMSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJyNkYWxpLWluZm8tMScpLFxyXG4gICAgZGFsaUluZm9fMiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJyNkYWxpLWluZm8tMicpLFxyXG4gICAgZGFsaUluZm9fMyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJyNkYWxpLWluZm8tMycpLFxyXG4gICAgZGFsaUluZm9fNCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJyNkYWxpLWluZm8tNCcpLFxyXG4gICAgZGFsaUluZm9fNSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJyNkYWxpLWluZm8tNScpLFxyXG4gICAgZGFsaUluZm9fNiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJyNkYWxpLWluZm8tNicpLFxyXG4gICAgZGFsaUluZm9fNyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJyNkYWxpLWluZm8tNycpLFxyXG4gICAgZGFsaUltYWdlXzEgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcjZGFsaS1pbWFnZS0xJyksXHJcbiAgICBkYWxpSW1hZ2VfMiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJyNkYWxpLWltYWdlLTInKSxcclxuICAgIGRhbGlJbWFnZV8zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnI2RhbGktaW1hZ2UtMycpLFxyXG4gICAgZGFsaUltYWdlXzQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcjZGFsaS1pbWFnZS00JyksXHJcbiAgICBwZXJzcGVjdGl2ZSA9IDEwMDA7IFxyXG5cclxuZ3NhcC50aW1lbGluZSh7XHJcbiAgICBzY3JvbGxUcmlnZ2VyOiB7XHJcbiAgICAgICAgdHJpZ2dlcjogc2VjdGlvbixcclxuICAgICAgICBzdGFydDogJ3RvcCB0b3AnLFxyXG4gICAgICAgIGVuZDogJys9MTUwMDAnLFxyXG4gICAgICAgIHBpbjogdHJ1ZSxcclxuICAgICAgICBhbnRpY2lwYXRlUGluOiAxLFxyXG4gICAgICAgIC8vIG1hcmtlcnM6IHRydWUsXHJcbiAgICAgICAgc2NydWI6IDEgICAgICAgICAgICBcclxuICAgIH1cclxufSlcclxuLnNldChzZWN0aW9uV3JhcHBlciwge2Nzczp7dHJhbnNmb3JtUGVyc3BlY3RpdmU6IHBlcnNwZWN0aXZlLCB0cmFuc2Zvcm1TdHlsZTogJ3ByZXNlcnZlLTNkJ319KVxyXG4vLyBJbXByb3ZlIFF1YWxpdHlcclxuLnRvKHdlbGNvbWVTZWN0aW9uLCAxLCB7Y3NzOiB7ejogcGVyc3BlY3RpdmV9fSlcclxuLmZyb21UbyhzZWN0aW9uSW5mbywgMSwge29wYWNpdHk6IDB9LCB7b3BhY2l0eTogMX0pXHJcbi5hZGRMYWJlbCgnc2hvd19pbmZvXzEnKVxyXG4uYWRkUGF1c2UoMylcclxuLnRvKGRhbGlJbmZvXzEsIDEsIHtvcGFjaXR5OiAwLCBkaXNwbGF5OiAnbm9uZSd9KVxyXG4uZnJvbVRvKGRhbGlJbmZvXzIsIDEsIHtvcGFjaXR5OiAwfSwge29wYWNpdHk6IDEsIGRpc3BsYXk6ICdibG9jayd9KVxyXG4uYWRkUGF1c2UoMylcclxuLnRvKGRhbGlJbmZvXzIsIDEsIHtvcGFjaXR5OiAwLCBkaXNwbGF5OiAnbm9uZSd9KVxyXG4uZnJvbVRvKGRhbGlJbmZvXzMsIDEsIHtvcGFjaXR5OiAwfSwge29wYWNpdHk6IDEsIGRpc3BsYXk6ICdibG9jayd9KVxyXG4uYWRkUGF1c2UoMylcclxuLnRvKGRhbGlJbmZvXzMsIDEsIHtvcGFjaXR5OiAwLCBkaXNwbGF5OiAnbm9uZSd9KVxyXG4uZnJvbVRvKGRhbGlJbmZvXzQsIDEsIHtvcGFjaXR5OiAwfSwge29wYWNpdHk6IDEsIGRpc3BsYXk6ICdibG9jayd9KVxyXG4uYWRkTGFiZWwoJ3Nob3dfaW5mb180JylcclxuLmFkZFBhdXNlKDMpXHJcbi50byhkYWxpSW5mb180LCAxLCB7b3BhY2l0eTogMCwgZGlzcGxheTogJ25vbmUnfSlcclxuLmZyb21UbyhkYWxpSW5mb181LCAxLCB7b3BhY2l0eTogMH0sIHtvcGFjaXR5OiAxLCBkaXNwbGF5OiAnYmxvY2snfSlcclxuLmFkZFBhdXNlKDMpXHJcbi50byhkYWxpSW5mb181LCAxLCB7b3BhY2l0eTogMCwgZGlzcGxheTogJ25vbmUnfSlcclxuLmZyb21UbyhkYWxpSW5mb182LCAxLCB7b3BhY2l0eTogMH0sIHtvcGFjaXR5OiAxLCBkaXNwbGF5OiAnYmxvY2snfSlcclxuLmFkZFBhdXNlKDMpXHJcbi50byhkYWxpSW5mb182LCAxLCB7b3BhY2l0eTogMCwgZGlzcGxheTogJ25vbmUnfSlcclxuLmZyb21UbyhkYWxpSW5mb183LCAxLCB7b3BhY2l0eTogMH0sIHtvcGFjaXR5OiAxLCBkaXNwbGF5OiAnYmxvY2snfSlcclxuLmFkZFBhdXNlKDMpXHJcbi50byhkYWxpSW1hZ2VfMiwgMTAsIHt5OiAtMzB9LCAnc2hvd19pbmZvXzEnKVxyXG4udG8oZGFsaUltYWdlXzMsIDEwLCB7eTogLTEwfSwgJ3Nob3dfaW5mb18xJylcclxuLnRvKGRhbGlJbWFnZV80LCAxMCwge3k6IC01fSwgJ3Nob3dfaW5mb18xJyk7XHJcbiIsIi8vIGltcG9ydCAnLi9sb2FkaW5nJztcclxuaW1wb3J0ICcuL25hdmlnYXRpb24nO1xyXG4vLyBpbXBvcnQgJy4vcHJvZ3Jlc3MtYmFyJztcclxuaW1wb3J0ICcuL3NjZW5lcydcclxuaW1wb3J0ICcuL3ZlbGF6cXVlel9zY2VuZSc7XHJcbmltcG9ydCAnLi9nb3lhX3NjZW5lJztcclxuaW1wb3J0ICcuL3BpY2Fzc29fc2NlbmUnO1xyXG5pbXBvcnQgJy4vZGFsaV9zY2VuZSc7IiwiLy8gQ1NTXHJcbmltcG9ydCAnLi4vY3NzL21haW4uc2Nzcyc7XHJcblxyXG4vLyBKU1xyXG5pbXBvcnQgJy4vY29tcG9uZW50cy9pbmRleC5qcyc7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7\n')}]);